/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/tinymce/icons/default/icons.js":
/*!*****************************************************!*\
  !*** ./node_modules/tinymce/icons/default/icons.js ***!
  \*****************************************************/
/***/ (() => {

eval("tinymce.IconManager.add('default', {\n  icons: {\n    'accessibility-check': '<svg width=\"24\" height=\"24\"><path d=\"M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2Zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1Z\" fill-rule=\"nonzero\"/></svg>',\n    'accordion-toggle': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z\"/><path opacity=\".2\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z\"/><path opacity=\".2\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12.3 7.3a1 1 0 0 1 1.4 0L16 9.6l2.3-2.3a1 1 0 1 1 1.4 1.4L16 12.4l-3.7-3.7a1 1 0 0 1 0-1.4ZM4.3 11.7a1 1 0 0 1 0-1.4L6.6 8 4.3 5.7a1 1 0 0 1 1.4-1.4L9.4 8l-3.7 3.7a1 1 0 0 1-1.4 0Z\"/></svg>',\n    'accordion': '<svg width=\"24\" height=\"24\"><rect x=\"12\" y=\"7\" width=\"10\" height=\"2\" rx=\"1\"/><rect x=\"12\" y=\"11\" width=\"10\" height=\"2\" rx=\"1\"/><rect x=\"12\" y=\"15\" width=\"6\" height=\"2\" rx=\"1\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M2.3 7.3a1 1 0 0 1 1.4 0L6 9.6l2.3-2.3a1 1 0 0 1 1.4 1.4L6 12.4 2.3 8.7a1 1 0 0 1 0-1.4Z\"/></svg>',\n    'action-next': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M5.7 7.3a1 1 0 0 0-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 1 0-1.4-1.4L12 13.6 5.7 7.3Z\"/></svg>',\n    'action-prev': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M18.3 15.7a1 1 0 0 0 1.4-1.4L12 6.6l-7.7 7.7a1 1 0 0 0 1.4 1.4L12 9.4l6.3 6.3Z\"/></svg>',\n    'addtag': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M15 5a2 2 0 0 1 1.6.8L21 12l-4.4 6.2a2 2 0 0 1-1.6.8h-3v-2h3l3.5-5L15 7H5v3H3V7c0-1.1.9-2 2-2h10Z\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M6 12a1 1 0 0 0-1 1v2H3a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2H7v-2c0-.6-.4-1-1-1Z\"/></svg>',\n    'ai-prompt': '<svg width=\"24\" height=\"24\"><g clip-path=\"url(#a)\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M15 6.7a1 1 0 0 0-1.4 0l-9.9 10a1 1 0 0 0 0 1.3l2.1 2.1c.4.4 1 .4 1.4 0l10-9.9c.3-.3.3-1 0-1.4l-2.2-2Zm1.4 2.8-2-2-3 2.7 2.2 2.2 2.8-2.9Z\"/><path d=\"m18.5 7.3-.7-1.5-1.5-.8 1.5-.7.7-1.5.7 1.5 1.5.7-1.5.8-.7 1.5ZM18.5 16.5l-.7-1.6-1.5-.7 1.5-.7.7-1.6.7 1.6 1.5.7-1.5.7-.7 1.6ZM9.7 7.3 9 5.8 7.5 5 9 4.3l.7-1.5.7 1.5L12 5l-1.5.8-.7 1.5Z\"/></g><defs><clipPath id=\"a\"><path d=\"M0 0h24v24H0z\"/></clipPath></defs></svg>',\n    'ai': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M5 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3H5Zm6.8 11.5.5 1.2a68.3 68.3 0 0 0 .7 1.1l.4.1c.3 0 .5 0 .7-.3.2-.1.3-.3.3-.6l-.3-1-2.6-6.2a20.4 20.4 0 0 0-.5-1.3l-.5-.4-.7-.2c-.2 0-.5 0-.6.2-.2 0-.4.2-.5.4l-.3.6-.3.7L5.7 15l-.2.6-.1.4c0 .3 0 .5.3.7l.6.2c.3 0 .5 0 .7-.2l.4-1 .5-1.2h3.9ZM9.8 9l1.5 4h-3l1.5-4Zm5.6-.9v7.6c0 .4 0 .7.2 1l.7.2c.3 0 .6 0 .8-.3l.2-.9V8.1c0-.4 0-.7-.2-.9a1 1 0 0 0-.8-.3c-.2 0-.5.1-.7.3l-.2 1Z\"/></svg>',\n    'align-center': '<svg width=\"24\" height=\"24\"><path d=\"M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z\" fill-rule=\"evenodd\"/></svg>',\n    'align-justify': '<svg width=\"24\" height=\"24\"><path d=\"M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z\" fill-rule=\"evenodd\"/></svg>',\n    'align-left': '<svg width=\"24\" height=\"24\"><path d=\"M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z\" fill-rule=\"evenodd\"/></svg>',\n    'align-none': '<svg width=\"24\" height=\"24\"><path d=\"M14.2 5 13 7H5a1 1 0 1 1 0-2h9.2Zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h6.8Zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h4.4Zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2ZM7 17l-1.2 2H5a1 1 0 0 1 0-2h2Zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2Zm5.2-13.5 1.3.7-9.7 16.3-1.3-.7 9.7-16.3Z\" fill-rule=\"evenodd\"/></svg>',\n    'align-right': '<svg width=\"24\" height=\"24\"><path d=\"M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z\" fill-rule=\"evenodd\"/></svg>',\n    'arrow-left': '<svg width=\"24\" height=\"24\"><path d=\"m5.6 13 12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8Z\" fill-rule=\"evenodd\"/></svg>',\n    'arrow-right': '<svg width=\"24\" height=\"24\"><path d=\"m18.5 13-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8Z\" fill-rule=\"evenodd\"/></svg>',\n    'bold': '<svg width=\"24\" height=\"24\"><path d=\"M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8Zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4Zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4Z\" fill-rule=\"evenodd\"/></svg>',\n    'bookmark': '<svg width=\"24\" height=\"24\"><path d=\"M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1Z\" fill-rule=\"nonzero\"/></svg>',\n    'border-style': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><rect width=\"18\" height=\"2\" x=\"3\" y=\"6\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"3\" y=\"16\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"6.8\" y=\"16\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"10.6\" y=\"16\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"14.4\" y=\"16\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"18.2\" y=\"16\" rx=\"1\"/><rect width=\"8\" height=\"2\" x=\"3\" y=\"11\" rx=\"1\"/><rect width=\"8\" height=\"2\" x=\"13\" y=\"11\" rx=\"1\"/></g></svg>',\n    'border-width': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><rect width=\"18\" height=\"5\" x=\"3\" y=\"5\" rx=\"1\"/><rect width=\"18\" height=\"3.5\" x=\"3\" y=\"11.5\" rx=\"1\"/><rect width=\"18\" height=\"2\" x=\"3\" y=\"17\" rx=\"1\"/></g></svg>',\n    'brightness': '<svg width=\"24\" height=\"24\"><path d=\"M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3Zm0-10a1 1 0 0 1-.7-.3A1 1 0 0 1 11 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3Zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-1a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1ZM7 12c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H5a1 1 0 0 1-.7-.3A1 1 0 0 1 4 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7Zm10 3.5.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 0 1-.8.3 1 1 0 0 1-.6-.3l-.8-.7a1 1 0 0 1-.3-.8c0-.2.1-.5.3-.7a1 1 0 0 1 1.4 0Zm-10-7-.7-.8a1 1 0 0 1-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.8-.3Zm10 0a1 1 0 0 1-.8.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7Zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 0 1 0 1.4l-.8.8a1 1 0 0 1-.6.3 1 1 0 0 1-.8-.3 1 1 0 0 1-.3-.8c0-.2.1-.5.3-.6l.7-.8ZM12 8a4 4 0 0 1 3.7 2.4 4 4 0 0 1 0 3.2A4 4 0 0 1 12 16a4 4 0 0 1-3.7-2.4 4 4 0 0 1 0-3.2A4 4 0 0 1 12 8Zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7Z\" fill-rule=\"evenodd\"/></svg>',\n    'browse': '<svg width=\"24\" height=\"24\"><path d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9.4-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6Z\" fill-rule=\"nonzero\"/></svg>',\n    'cancel': '<svg width=\"24\" height=\"24\"><path d=\"M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8ZM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7Z\" fill-rule=\"nonzero\"/></svg>',\n    'cell-background-color': '<svg width=\"24\" height=\"24\"><path d=\"m15.7 2 1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 0 1-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2ZM18 12l-4.5-4L9 12h9ZM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16Z\"/></svg>',\n    'cell-border-color': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M5 13v5h2v2H5a2 2 0 0 1-2-2v-5h2zm8-7V4h6a2 2 0 0 1 2 2h-8z\" opacity=\".2\"/><path fill-rule=\"nonzero\" d=\"M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z\"/><path d=\"m13 11-2 2H5v-2h6V6h2z\"/><path fill-rule=\"nonzero\" d=\"m18.4 8 1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 0 1-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8Zm1.6 7-3-3-3 3h6Z\"/></g></svg>',\n    'change-case': '<svg width=\"24\" height=\"24\"><path d=\"M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 0 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5-2-6.5-1.9 6.5h3.9z\" fill-rule=\"evenodd\"/></svg>',\n    'character-count': '<svg width=\"24\" height=\"24\"><path d=\"M4 11.5h16v1H4v-1Zm4.8-6.8V10H7.7V5.8h-1v-1h2ZM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1Zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1ZM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2V18.7l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1Zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6Zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4Zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8Zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1Z\" fill-rule=\"evenodd\"/></svg>',\n    'checklist-rtl': '<svg width=\"24\" height=\"24\"><path d=\"M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z\" fill-rule=\"evenodd\"/></svg>',\n    'checklist': '<svg width=\"24\" height=\"24\"><path d=\"M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2ZM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Z\" fill-rule=\"evenodd\"/></svg>',\n    'checkmark': '<svg width=\"24\" height=\"24\"><path d=\"M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11Z\" fill-rule=\"nonzero\"/></svg>',\n    'chevron-down': '<svg width=\"10\" height=\"10\"><path d=\"M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8Z\" fill-rule=\"nonzero\"/></svg>',\n    'chevron-left': '<svg width=\"10\" height=\"10\"><path d=\"M7.8 1.3 4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1Z\" fill-rule=\"nonzero\"/></svg>',\n    'chevron-right': '<svg width=\"10\" height=\"10\"><path d=\"M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3Z\" fill-rule=\"nonzero\"/></svg>',\n    'chevron-up': '<svg width=\"10\" height=\"10\"><path d=\"M8.7 7.8 5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0Z\" fill-rule=\"nonzero\"/></svg>',\n    'close': '<svg width=\"24\" height=\"24\"><path d=\"M17.3 8.2 13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5Z\" fill-rule=\"evenodd\"/></svg>',\n    'code-sample': '<svg width=\"24\" height=\"26\"><path d=\"M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11Zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2Zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2ZM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5Z\" fill-rule=\"evenodd\"/></svg>',\n    'color-levels': '<svg width=\"24\" height=\"24\"><path d=\"M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4Zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5Z\" fill-rule=\"evenodd\"/></svg>',\n    'color-picker': '<svg width=\"24\" height=\"24\"><path d=\"M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8Zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Z\" fill-rule=\"nonzero\"/></svg>',\n    'color-swatch-remove-color': '<svg width=\"24\" height=\"24\"><path stroke=\"#000\" stroke-width=\"2\" d=\"M21 3 3 21\" fill-rule=\"evenodd\"/></svg>',\n    'color-swatch': '<svg width=\"24\" height=\"24\"><rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"1\" fill-rule=\"evenodd\"/></svg>',\n    'comment-add': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z\"/><path d=\"M13 10h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V8a1 1 0 0 1 2 0v2Z\"/></g></svg>',\n    'comment': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z\"/></svg>',\n    'contrast': '<svg width=\"24\" height=\"24\"><path d=\"M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-6 8a6 6 0 0 0 6 6V6a6 6 0 0 0-6 6Z\" fill-rule=\"evenodd\"/></svg>',\n    'copy': '<svg width=\"24\" height=\"24\"><path d=\"M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3Zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7Zm0 12V9h-7v10h7Z\" fill-rule=\"nonzero\"/></svg>',\n    'crop': '<svg width=\"24\" height=\"24\"><path d=\"M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3ZM9 9v5l5-5H9Zm1 6h5v-5l-5 5Z\" fill-rule=\"evenodd\"/></svg>',\n    'cut-column': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0 1 10.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 0 1 2 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 0 1 7 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7Zm12.3 5h-3v10h3v-10ZM8 13.8h-.3l-.4.2a2.8 2.8 0 0 0-.7.4v.1a2.8 2.8 0 0 0-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 0 0 .8-.3 2.4 2.4 0 0 0 .7-.7 2.5 2.5 0 0 0 .3-.8 1.5 1.5 0 0 0 0-.8 1 1 0 0 0-.2-.4 1 1 0 0 0-.5-.2H8Zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4ZM7 5.8h-.4a1 1 0 0 0-.5.3 1 1 0 0 0-.2.5v.7a2.5 2.5 0 0 0 .3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 0 0 0-.8 2.6 2.6 0 0 0-.3-.8A2.5 2.5 0 0 0 7.7 6l-.4-.1H7Z\"/></svg>',\n    'cut-row': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l2 2V3h14ZM8.5 15.3h-.3a2.6 2.6 0 0 0-.8.4 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3L9 18V18l.4-.4.2-.4.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2h-.5Zm7 0H15a1 1 0 0 0-.4.3 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4a2.8 2.8 0 0 0 .5.7h.1a2.8 2.8 0 0 0 .8.6l.4.1h.7l.5-.2.2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3h-.3ZM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4Zm8.5-7.1h-11v2h11v-2Z\"/></svg>',\n    'cut': '<svg width=\"24\" height=\"24\"><path d=\"M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8Zm-8.5 2.2.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1Zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4Zm5.4 4 .2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2Z\" fill-rule=\"evenodd\"/></svg>',\n    'document-properties': '<svg width=\"24\" height=\"24\"><path d=\"M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z\" fill-rule=\"nonzero\"/></svg>',\n    'drag': '<svg width=\"24\" height=\"24\"><path d=\"M13 5h2v2h-2V5Zm0 4h2v2h-2V9ZM9 9h2v2H9V9Zm4 4h2v2h-2v-2Zm-4 0h2v2H9v-2Zm0 4h2v2H9v-2Zm4 0h2v2h-2v-2ZM9 5h2v2H9V5Z\" fill-rule=\"evenodd\"/></svg>',\n    'duplicate-column': '<svg width=\"24\" height=\"24\"><path d=\"M17 6v16h-7V6h7Zm-2 2h-3v12h3V8Zm-2-6v2H8v15H6V2h7Z\"/></svg>',\n    'duplicate-row': '<svg width=\"24\" height=\"24\"><path d=\"M22 11v7H6v-7h16Zm-2 2H8v3h12v-3Zm-1-6v2H4v5H2V7h17Z\"/></svg>',\n    'duplicate': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10Zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2Z\"/><path d=\"M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1Z\"/></g></svg>',\n    'edit-block': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"m19.8 8.8-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5Zm-2-.2 1-.9v-.3l-2.2-2.2a.3.3 0 0 0-.3 0l-1 1L18 8.5Zm-1 1-2.5-2.4-6 6 2.5 2.5 6-6Zm-7 7.1-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5Z\"/></svg>',\n    'edit-image': '<svg width=\"24\" height=\"24\"><path d=\"M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9ZM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13Zm3-5.3 1.3 2 3-4.7 3.7 6H7l2-3.3Z\" fill-rule=\"nonzero\"/></svg>',\n    'embed-page': '<svg width=\"24\" height=\"24\"><path d=\"M19 6V5H5v14h2A13 13 0 0 1 19 6Zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4Zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6Zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3Zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2Zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2Z\" fill-rule=\"nonzero\"/></svg>',\n    'embed': '<svg width=\"24\" height=\"24\"><path d=\"M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm4.8 2.6 5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4Z\" fill-rule=\"nonzero\"/></svg>',\n    'emoji': '<svg width=\"24\" height=\"24\"><path d=\"M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5ZM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13Z\" fill-rule=\"nonzero\"/></svg>',\n    'export': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M14.4 3 18 7v1h-5V5H7v14h9a1 1 0 0 1 2 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5Z\"/><path d=\"M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3Z\"/><path d=\"M16.4 9.2a1 1 0 0 1 1.4.2l2.4 3.6-2.4 3.6a1 1 0 0 1-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 0 1 .2-1.4Z\"/></g></svg>',\n    'fill': '<svg width=\"24\" height=\"26\"><path d=\"m16.6 12-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2ZM5.2 13 10 8.2l4.8 4.8H5.2ZM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5Z\" fill-rule=\"nonzero\"/></svg>',\n    'flip-horizontally': '<svg width=\"24\" height=\"24\"><path d=\"M14 19h2v-2h-2v2Zm4-8h2V9h-2v2ZM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2Zm14-2v2h2a2 2 0 0 0-2-2Zm-7 16h2V3h-2v18Zm7-6h2v-2h-2v2Zm-4-8h2V5h-2v2Zm4 12a2 2 0 0 0 2-2h-2v2Z\" fill-rule=\"nonzero\"/></svg>',\n    'flip-vertically': '<svg width=\"24\" height=\"24\"><path d=\"M5 14v2h2v-2H5Zm8 4v2h2v-2h-2Zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2Zm2 14h-2v2a2 2 0 0 0 2-2ZM3 11v2h18v-2H3Zm6 7v2h2v-2H9Zm8-4v2h2v-2h-2ZM5 18c0 1.1.9 2 2 2v-2H5Z\" fill-rule=\"nonzero\"/></svg>',\n    'footnote': '<svg width=\"24\" height=\"24\"><path d=\"M19 13c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h14Z\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M19 4v6h-1V5h-1.5V4h2.6Z\"/><path d=\"M12 18c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h7ZM14 8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2h9Z\"/></svg>',\n    'format-painter': '<svg width=\"24\" height=\"24\"><path d=\"M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3Z\" fill-rule=\"nonzero\"/></svg>',\n    'format': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M17 5a1 1 0 0 1 0 2h-4v11a1 1 0 0 1-2 0V7H7a1 1 0 1 1 0-2h10Z\"/></svg>',\n    'fullscreen': '<svg width=\"24\" height=\"24\"><path d=\"m15.3 10-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3Zm0 4 3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2ZM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3ZM8.7 10 5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2Z\" fill-rule=\"nonzero\"/></svg>',\n    'gallery': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"m5 15.7 2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7ZM5 18V19h3l1.8-1.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V7c0-.6.4-1 1-1Zm6 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4ZM4.5 4h15a.5.5 0 1 1 0 1h-15a.5.5 0 0 1 0-1Zm2-2h11a.5.5 0 1 1 0 1h-11a.5.5 0 0 1 0-1Z\"/></svg>',\n    'gamma': '<svg width=\"24\" height=\"24\"><path d=\"M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 0 0-.4-.8l-.1-.2H8v-1l.3-.1.3-.1h.7a1 1 0 0 1 .6.5l.1.3a8.5 8.5 0 0 1 .3.6l1.9 4.6 2-5.2a1 1 0 0 1 1-.6.5.5 0 0 1 .5.6L13 14v2.8a.7.7 0 0 1-1.4 0Z\" fill-rule=\"nonzero\"/></svg>',\n    'help': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1ZM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Z\"/><path d=\"M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8Z\" fill-rule=\"nonzero\"/><circle cx=\"12\" cy=\"16\" r=\"1\"/></g></svg>',\n    'highlight-bg-color': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path class=\"tox-icon-highlight-bg-color__color\" d=\"M3 18h18v3H3z\"/><path fill-rule=\"nonzero\" d=\"M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6\"/></g></svg>',\n    'home': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z\"/></svg>',\n    'horizontal-rule': '<svg width=\"24\" height=\"24\"><path d=\"M4 11h16v2H4z\" fill-rule=\"evenodd\"/></svg>',\n    'image-options': '<svg width=\"24\" height=\"24\"><path d=\"M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z\" fill-rule=\"nonzero\"/></svg>',\n    'image': '<svg width=\"24\" height=\"24\"><path d=\"m5 15.7 3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7ZM5 18V19h3l2.8-2.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z\" fill-rule=\"nonzero\"/></svg>',\n    'indent': '<svg width=\"24\" height=\"24\"><path d=\"M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z\" fill-rule=\"evenodd\"/></svg>',\n    'info': '<svg width=\"24\" height=\"24\"><path d=\"M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-1 3v2h2V7h-2Zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4Z\" fill-rule=\"evenodd\"/></svg>',\n    'insert-character': '<svg width=\"24\" height=\"24\"><path d=\"M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5Z\" fill-rule=\"evenodd\"/></svg>',\n    'insert-time': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M12 19a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z\"/><path d=\"M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 0 0-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1Z\"/></g></svg>',\n    'invert': '<svg width=\"24\" height=\"24\"><path d=\"M18 19.3 16.5 18a5.8 5.8 0 0 1-3.1 1.9 6.1 6.1 0 0 1-5.5-1.6A5.8 5.8 0 0 1 6 14v-.3l.1-1.2A13.9 13.9 0 0 1 7.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6Zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 0 0 .2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 0 0-3-4.2L12 6a26.1 26.1 0 0 0-2.2 2.5l-1-1a20.9 20.9 0 0 1 2.9-3.3L12 4l1 .8a22.2 22.2 0 0 1 4 5.4c.6 1.2 1 2.4 1 3.6Z\" fill-rule=\"evenodd\"/></svg>',\n    'italic': '<svg width=\"24\" height=\"24\"><path d=\"m16.7 4.7-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8Z\" fill-rule=\"evenodd\"/></svg>',\n    'language': '<svg width=\"24\" height=\"24\"><path d=\"M12 3a9 9 0 1 1 0 18 9 9 0 0 1 0-18Zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 0 0 3.2-2.1l-.2-.2a6 6 0 0 0-1-.6Zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 0 1-2-2.8Zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7Zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3Zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 0 1-.3-2Zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1Zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6Zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3Zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1Zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3Zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1Zm3-1.4-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 0 0-1.3-3.5Zm-9 0 2 .2V5.5a9 9 0 0 0-2 2.2Zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 0 0-2-2.3Zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 0 1 1.9-2.5Zm4.4 0 .1.1a10 10 0 0 1 1.8 2.4l1.1-.7a7.5 7.5 0 0 0-3-1.8Z\"/></svg>',\n    'line-height': '<svg width=\"24\" height=\"24\"><path d=\"M21 5a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zM7 3.6l3.7 3.7a1 1 0 0 1-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 0 1 1.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 0 1 1.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 0 1-1.3 0h-.1a1 1 0 0 1 0-1.3v-.1L7 3.6z\"/></svg>',\n    'line': '<svg width=\"24\" height=\"24\"><path d=\"m15 9-8 8H4v-3l8-8 3 3Zm1-1-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1ZM4 18h16v2H4v-2Z\" fill-rule=\"evenodd\"/></svg>',\n    'link': '<svg width=\"24\" height=\"24\"><path d=\"M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2Z\" fill-rule=\"nonzero\"/></svg>',\n    'list-bull-circle': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path d=\"M11 16a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 26a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 36a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6Z\" fill-rule=\"nonzero\"/><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/></g></svg>',\n    'list-bull-default': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><circle cx=\"11\" cy=\"14\" r=\"3\"/><circle cx=\"11\" cy=\"24\" r=\"3\"/><circle cx=\"11\" cy=\"34\" r=\"3\"/><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/></g></svg>',\n    'list-bull-square': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path d=\"M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z\"/><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/></g></svg>',\n    'list-num-default-rtl': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M37.4 17v-4.8h-.1l-1.5 1v-1.1l1.6-1.1h1.2v6zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z\"/></g></svg>',\n    'list-num-default': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2Zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5Zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7Zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Z\"/></g></svg>',\n    'list-num-lower-alpha-rtl': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7Zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6ZM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7ZM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4Zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3ZM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z\"/></g></svg>',\n    'list-num-lower-alpha': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6Zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7Zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4Zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3Zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7Zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z\"/></g></svg>',\n    'list-num-lower-greek-rtl': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8Zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4ZM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22Zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3ZM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM37.1 34.6 34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1ZM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z\"/></g></svg>',\n    'list-num-lower-greek': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4Zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8Zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3ZM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22Zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1Zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z\"/></g></svg>',\n    'list-num-lower-roman-rtl': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M32.9 16v-1.2h-1.3V16H33Zm0 10v-1.2h-1.3V26H33Zm0 10v-1.2h-1.3V36H33Z\"/><path fill-rule=\"nonzero\" d=\"M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z\"/></g></svg>',\n    'list-num-lower-roman': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M15.1 16v-1.2h1.3V16H15Zm0 10v-1.2h1.3V26H15Zm0 10v-1.2h1.3V36H15Z\"/><path fill-rule=\"nonzero\" d=\"M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z\"/></g></svg>',\n    'list-num-upper-alpha-rtl': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"m39.3 17-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3Zm-1.6-4.7-.7 2.3h1.6l-.8-2.3ZM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7Zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26ZM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z\"/></g></svg>',\n    'list-num-upper-alpha': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"m12.6 17-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3ZM11 12.3l-.7 2.3h1.6l-.8-2.3Zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7ZM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7ZM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26Zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z\"/></g></svg>',\n    'list-num-upper-roman-rtl': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M31.6 17v-1.2H33V17h-1.3Zm0 10v-1.2H33V27h-1.3Zm0 10v-1.2H33V37h-1.3Z\"/><path fill-rule=\"nonzero\" d=\"M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z\"/></g></svg>',\n    'list-num-upper-roman': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M15.1 17v-1.2h1.3V17H15Zm0 10v-1.2h1.3V27H15Zm0 10v-1.2h1.3V37H15Z\"/><path fill-rule=\"nonzero\" d=\"M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z\"/></g></svg>',\n    'lock': '<svg width=\"24\" height=\"24\"><path d=\"M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3ZM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7Z\" fill-rule=\"evenodd\"/></svg>',\n    'ltr': '<svg width=\"24\" height=\"24\"><path d=\"M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5ZM4.4 16.2 6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z\" fill-rule=\"evenodd\"/></svg>',\n    'math-equation': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M9 4.8c.1-.5.5-.8 1-.8h10a1 1 0 1 1 0 2h-9.2L8.3 19.2a1 1 0 0 1-1.7.4l-3.4-4.2a1 1 0 0 1 1.6-1.2l2 2.5L9 4.8Zm9.7 5.5c.4.4.4 1 0 1.4L17 13.5l1.8 1.8a1 1 0 1 1-1.4 1.4L15.5 15l-1.8 1.8a1 1 0 0 1-1.4-1.4l1.8-1.8-1.8-1.8a1 1 0 0 1 1.4-1.4l1.8 1.8 1.8-1.8a1 1 0 0 1 1.4 0Z\"/></svg>',\n    'minus': '<svg width=\"24\" height=\"24\"><path d=\"M19 11a1 1 0 0 1 .1 2H5a1 1 0 0 1-.1-2H19Z\"/></svg>',\n    'more-drawer': '<svg width=\"24\" height=\"24\"><path d=\"M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z\" fill-rule=\"nonzero\"/></svg>',\n    'new-document': '<svg width=\"24\" height=\"24\"><path d=\"M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z\" fill-rule=\"nonzero\"/></svg>',\n    'new-tab': '<svg width=\"24\" height=\"24\"><path d=\"m15 13 2-2v8H5V7h8l-2 2H7v8h8v-4Zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19Z\" fill-rule=\"evenodd\"/></svg>',\n    'non-breaking': '<svg width=\"24\" height=\"24\"><path d=\"M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3Zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1Z\" fill-rule=\"evenodd\"/></svg>',\n    'notice': '<svg width=\"24\" height=\"24\"><path d=\"M15.5 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7ZM13 17v-2h-2v2h2Zm0-4V7h-2v6h2Z\" fill-rule=\"evenodd\" clip-rule=\"evenodd\"/></svg>',\n    'ordered-list-rtl': '<svg width=\"24\" height=\"24\"><path d=\"M6 17h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2Zm13-1v3.5a.5.5 0 1 1-1 0V5h-.5a.5.5 0 1 1 0-1H19Zm-1 8.8.2.2h1.3a.5.5 0 1 1 0 1h-1.6a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2h-1.3a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3Zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 0 1 0-1h1.2a.3.3 0 1 0 0-.6h-1.3a.4.4 0 1 1 0-.8h1.3a.3.3 0 0 0 0-.6h-1.2a.5.5 0 1 1 0-1H19c.6 0 1 .4 1 1Z\" fill-rule=\"evenodd\"/></svg>',\n    'ordered-list': '<svg width=\"24\" height=\"24\"><path d=\"M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2ZM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6Zm-1 8.8.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3ZM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1Z\" fill-rule=\"evenodd\"/></svg>',\n    'orientation': '<svg width=\"24\" height=\"24\"><path d=\"M7.3 6.4 1 13l6.4 6.5 6.5-6.5-6.5-6.5ZM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7ZM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1Z\" fill-rule=\"nonzero\"/></svg>',\n    'outdent': '<svg width=\"24\" height=\"24\"><path d=\"M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2Z\" fill-rule=\"evenodd\"/></svg>',\n    'page-break': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2ZM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1ZM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1Z\"/></g></svg>',\n    'paragraph': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z\"/></svg>',\n    'paste-column-after': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm8 7v12h-6V8h6Zm-1.5 1.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z\"/></svg>',\n    'paste-column-before': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm-2 7v12H4V8h6ZM8.5 9.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z\"/></svg>',\n    'paste-row-after': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 11v5H8v-5h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z\"/></svg>',\n    'paste-row-before': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 7v5H8V8h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z\"/></svg>',\n    'paste-text': '<svg width=\"24\" height=\"24\"><path d=\"M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2Z\" fill-rule=\"nonzero\"/></svg>',\n    'paste': '<svg width=\"24\" height=\"24\"><path d=\"M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Z\" fill-rule=\"nonzero\"/></svg>',\n    'permanent-pen': '<svg width=\"24\" height=\"24\"><path d=\"M10.5 17.5 8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1Z\" fill-rule=\"nonzero\"/></svg>',\n    'plus': '<svg width=\"24\" height=\"24\"><path d=\"M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 0 1 .1 2H13v6a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H11V5c0-.6.4-1 1-1Z\"/></svg>',\n    'preferences': '<svg width=\"24\" height=\"24\"><path d=\"m20.1 13.5-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1ZM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z\" fill-rule=\"evenodd\"/></svg>',\n    'preview': '<svg width=\"24\" height=\"24\"><path d=\"M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5Zm-2.4-1 .7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1Zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6Z\" fill-rule=\"nonzero\"/></svg>',\n    'print': '<svg width=\"24\" height=\"24\"><path d=\"M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3Zm-1 10H7v-4h10v4Zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5Zm.5-8H6v2h12V5Z\" fill-rule=\"nonzero\"/></svg>',\n    'quote': '<svg width=\"24\" height=\"24\"><path d=\"M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Z\" fill-rule=\"nonzero\"/></svg>',\n    'redo': '<svg width=\"24\" height=\"24\"><path d=\"M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3Z\" fill-rule=\"nonzero\"/></svg>',\n    'reload': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"m5 22.1-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5ZM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1Z\"/></g></svg>',\n    'remove-formatting': '<svg width=\"24\" height=\"24\"><path d=\"M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8ZM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1Z\" fill-rule=\"evenodd\"/></svg>',\n    'remove': '<svg width=\"24\" height=\"24\"><path d=\"M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1Zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4Zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9Zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Z\" fill-rule=\"nonzero\"/></svg>',\n    'resize-handle': '<svg width=\"10\" height=\"10\"><g fill-rule=\"nonzero\"><path d=\"M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7ZM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3Z\"/></g></svg>',\n    'resize': '<svg width=\"24\" height=\"24\"><path d=\"M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5Z\" fill-rule=\"evenodd\"/></svg>',\n    'restore-draft': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z\"/><path d=\"M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z\" fill-rule=\"nonzero\"/></g></svg>',\n    'revision-history': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z\"/><path d=\"M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z\" fill-rule=\"nonzero\"/></g></svg>',\n    'rotate-left': '<svg width=\"24\" height=\"24\"><path d=\"M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z\" fill-rule=\"nonzero\"/></svg>',\n    'rotate-right': '<svg width=\"24\" height=\"24\"><path d=\"M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8Z\" fill-rule=\"nonzero\"/></svg>',\n    'rtl': '<svg width=\"24\" height=\"24\"><path d=\"M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5Zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2Z\" fill-rule=\"evenodd\"/></svg>',\n    'save': '<svg width=\"24\" height=\"24\"><path d=\"M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2Zm0 2v2h14v-2H5Zm10 0h2v2h-2v-2Zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6Z\" fill-rule=\"nonzero\"/></svg>',\n    'search': '<svg width=\"24\" height=\"24\"><path d=\"M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z\" fill-rule=\"nonzero\"/></svg>',\n    'select-all': '<svg width=\"24\" height=\"24\"><path d=\"M3 5h2V3a2 2 0 0 0-2 2Zm0 8h2v-2H3v2Zm4 8h2v-2H7v2ZM3 9h2V7H3v2Zm10-6h-2v2h2V3Zm6 0v2h2a2 2 0 0 0-2-2ZM5 21v-2H3c0 1.1.9 2 2 2Zm-2-4h2v-2H3v2ZM9 3H7v2h2V3Zm2 18h2v-2h-2v2Zm8-8h2v-2h-2v2Zm0 8a2 2 0 0 0 2-2h-2v2Zm0-12h2V7h-2v2Zm0 8h2v-2h-2v2Zm-4 4h2v-2h-2v2Zm0-16h2V3h-2v2ZM7 17h10V7H7v10Zm2-8h6v6H9V9Z\" fill-rule=\"nonzero\"/></svg>',\n    'selected': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm3.6 10.9L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3Z\"/></svg>',\n    'send': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"m13.3 22 7-18.3-18.3 7L9 15l4.3 7ZM18 6.8l-.7-.7L9.4 14l.7.7L18 6.8Z\"/></svg>',\n    'settings': '<svg width=\"24\" height=\"24\"><path d=\"M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6ZM8 8h2V6H8v2Zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6ZM14 13h2v-2h-2v2Zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6ZM8 18h2v-2H8v2Z\" fill-rule=\"evenodd\"/></svg>',\n    'sharpen': '<svg width=\"24\" height=\"24\"><path d=\"m16 6 4 4-8 9-8-9 4-4h8Zm-4 10.2 5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2Z\" fill-rule=\"evenodd\"/></svg>',\n    'sourcecode': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7ZM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7Z\"/></g></svg>',\n    'spell-check': '<svg width=\"24\" height=\"24\"><path d=\"M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6Zm0-3v2h2V5H6Zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1Zm-5 1.5-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5ZM13 10V8h-2v2h2Zm0-3V5h-2v2h2Zm3 5 1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12Z\" fill-rule=\"evenodd\"/></svg>',\n    'strike-through': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1Z\"/><path d=\"M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Z\" fill-rule=\"nonzero\"/></g></svg>',\n    'subscript': '<svg width=\"24\" height=\"24\"><path d=\"m10.4 10 4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10ZM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19Z\" fill-rule=\"nonzero\"/></svg>',\n    'superscript': '<svg width=\"24\" height=\"24\"><path d=\"M15 9.4 10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4Zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11Z\" fill-rule=\"nonzero\"/></svg>',\n    'table-caption': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><rect width=\"12\" height=\"2\" x=\"3\" y=\"4\" rx=\"1\"/><path d=\"M19 8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-8c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z\"/></g></svg>',\n    'table-cell-classes': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M13 4v9H3V6c0-1.1.9-2 2-2h8Zm-2 2H5v5h6V6Z\"/><path fill-rule=\"nonzero\" d=\"M13 4h6a2 2 0 0 1 2 2v7h-8v-2h6V6h-6V4Z\" opacity=\".2\"/><path d=\"m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z\"/><path fill-rule=\"nonzero\" d=\"M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3Z\" opacity=\".2\"/></g></svg>',\n    'table-cell-properties': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8 0h-6v5h6v-5Zm-8-7H5v5h6V6Z\"/></svg>',\n    'table-cell-select-all': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z\"/><path d=\"M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z\" opacity=\".2\"/></g></svg>',\n    'table-cell-select-inner': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z\" opacity=\".2\"/><path d=\"M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z\"/></g></svg>',\n    'table-classes': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v7h-8v7H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8-7h-6v5h6V6Zm-8 0H5v5h6V6Z\"/><path d=\"m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z\"/></g></svg>',\n    'table-delete-column': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2Zm.3.5 1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5Z\"/></svg>',\n    'table-delete-row': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6Zm-4.7 1.8 1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3Z\"/></svg>',\n    'table-delete-table': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 6v12h14V6H5Z\"/><path d=\"m14.4 8.6 1.1 1-2.4 2.4 2.4 2.4-1.1 1.1-2.4-2.4-2.4 2.4-1-1.1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z\"/></g></svg>',\n    'table-insert-column-after': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M20 4c.6 0 1 .4 1 1v2a1 1 0 0 1-2 0V6h-8v12h8v-1a1 1 0 0 1 2 0v2c0 .5-.4 1-.9 1H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h15ZM9 13H5v5h4v-5Zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H17v2a1 1 0 0 1-2 .1V13h-2a1 1 0 0 1-.1-2H15V9c0-.6.4-1 1-1ZM9 6H5v5h4V6Z\"/></svg>',\n    'table-insert-column-before': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 2 0v1h8V6H5v1a1 1 0 1 1-2 0V5c0-.6.4-1 1-1h15Zm0 9h-4v5h4v-5ZM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H9v2a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H7V9c0-.6.4-1 1-1Zm11-2h-4v5h4V6Z\"/></svg>',\n    'table-insert-row-above': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M6 4a1 1 0 1 1 0 2H5v6h14V6h-1a1 1 0 0 1 0-2h2c.6 0 1 .4 1 1v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-.6.4-1 1-1h2Zm5 10H5v4h6v-4Zm8 0h-6v4h6v-4ZM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 .1V8H9a1 1 0 0 1 0-2h2V4c0-.6.4-1 1-1Z\"/></svg>',\n    'table-insert-row-after': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 0 1 .1 2H13v2a1 1 0 0 1-2 .1V18H9a1 1 0 0 1-.1-2H11v-2c0-.6.4-1 1-1Zm6 7a1 1 0 0 1 0-2h1v-6H5v6h1a1 1 0 0 1 0 2H4a1 1 0 0 1-1-1V6c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v13c0 .5-.4 1-.9 1H18ZM11 6H5v4h6V6Zm8 0h-6v4h6V6Z\"/></svg>',\n    'table-left-header': '<svg width=\"24\" height=\"24\"><path d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 9h-4v5h4v-5Zm-6 0H9v5h4v-5Zm0-7H9v5h4V6Zm6 0h-4v5h4V6Z\"/></svg>',\n    'table-merge-cells': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15.5V18h3v-2.5H5Zm14-5h-9V18h9v-7.5ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Zm-8 7.5h3v-3H5v3Z\"/></svg>',\n    'table-row-numbering-rtl': '<svg width=\"24\" height=\"24\"><path d=\"M6 4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H6Zm0 12h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 11h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 6h8v3H6V6Zm11 0c.6 0 1 .4 1 1v1a1 1 0 1 1-2 0V7c0-.6.4-1 1-1Z\"/></svg>',\n    'table-row-numbering': '<svg width=\"24\" height=\"24\"><path d=\"M18 4a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h12Zm0 12h-8v3h8v-3ZM7 16a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8v-3ZM7 11a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8V6ZM7 6a1 1 0 0 0-1 1v1a1 1 0 1 0 2 0V7c0-.6-.4-1-1-1Z\"/></svg>',\n    'table-row-properties': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-9h-6v3h6V6ZM5 9h6V6H5v3Z\"/></svg>',\n    'table-split-cells': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM8 15.5H5V18h3v-2.5Zm11-5h-9V18h9v-7.5Zm-2.5 1 1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2Zm-8.5-1H5v3h3v-3ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Z\"/></svg>',\n    'table-top-header': '<svg width=\"24\" height=\"24\"><path d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 11H5v3h6v-3Zm8 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z\"/></svg>',\n    'table': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 14v4h6v-4H5Zm14 0h-6v4h6v-4Zm0-6h-6v4h6V8ZM5 12h6V8H5v4Z\"/></svg>',\n    'template-add': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M9 12v4H5a2 2 0 0 0-2 2v3h9.3a6 6 0 0 1-.3-2H5v-1h7a6 6 0 0 1 .8-2H11v-5l-.8-.6a3 3 0 1 1 3.6 0l-.8.6v4.7a6 6 0 0 1 2-1.9V12a5 5 0 1 0-6 0Z\"/><path d=\"M18 15c.5 0 1 .4 1 .9V18h2a1 1 0 0 1 .1 2H19v2a1 1 0 0 1-2 .1V20h-2a1 1 0 0 1-.1-2H17v-2c0-.6.4-1 1-1Z\"/></svg>',\n    'template': '<svg width=\"24\" height=\"24\"><path d=\"M19 19v-1H5v1h14ZM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4Zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2Z\" fill-rule=\"nonzero\"/></svg>',\n    'temporary-placeholder': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M9 7.6V6h2.5V4.5a.5.5 0 1 1 1 0V6H15v1.6a8 8 0 1 1-6 0Zm-2.6 5.3a.5.5 0 0 0 .3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 0 1 3.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 0 0-4.1 3.7Z\"/><circle cx=\"14\" cy=\"4\" r=\"1\"/><circle cx=\"12\" cy=\"2\" r=\"1\"/><circle cx=\"10\" cy=\"4\" r=\"1\"/></g></svg>',\n    'text-color': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path class=\"tox-icon-text-color__color\" d=\"M3 18h18v3H3z\"/><path d=\"M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4Zm2.6-7.6-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4Z\"/></g></svg>',\n    'text-size-decrease': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM14 12a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Z\"/></svg>',\n    'text-size-increase': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM17 9a1 1 0 0 0-1 1v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2v-2c0-.6-.4-1-1-1Z\"/></svg>',\n    'toc': '<svg width=\"24\" height=\"24\"><path d=\"M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Z\" fill-rule=\"evenodd\"/></svg>',\n    'translate': '<svg width=\"24\" height=\"24\"><path d=\"m12.7 14.3-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8Zm4.3-3 2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 0 1 2 0Zm-2.2 4.4h2.4L16 12.5l-1.2 3.2Z\" fill-rule=\"evenodd\"/></svg>',\n    'typography': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M17 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H7a1 1 0 0 1 0-2h10Z\"/><path d=\"m17.5 14 .8-1.7 1.7-.8-1.7-.8-.8-1.7-.8 1.7-1.7.8 1.7.8.8 1.7ZM7 14l1 2 2 1-2 1-1 2-1-2-2-1 2-1 1-2Z\"/></svg>',\n    'underline': '<svg width=\"24\" height=\"24\"><path d=\"M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1ZM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Z\" fill-rule=\"evenodd\"/></svg>',\n    'undo': '<svg width=\"24\" height=\"24\"><path d=\"M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8Z\" fill-rule=\"nonzero\"/></svg>',\n    'unlink': '<svg width=\"24\" height=\"24\"><path d=\"M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2ZM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1ZM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5Zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5Zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17Zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19Zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19Z\" fill-rule=\"nonzero\"/></svg>',\n    'unlock': '<svg width=\"24\" height=\"24\"><path d=\"M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2Z\" fill-rule=\"evenodd\"/></svg>',\n    'unordered-list': '<svg width=\"24\" height=\"24\"><path d=\"M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2ZM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Z\" fill-rule=\"evenodd\"/></svg>',\n    'unselected': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm0 1a1 1 0 0 0-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6Z\"/></svg>',\n    'upload': '<svg width=\"24\" height=\"24\"><path d=\"M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12ZM11 6.4 8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4Z\" fill-rule=\"nonzero\"/></svg>',\n    'user': '<svg width=\"24\" height=\"24\"><path d=\"M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24Zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7ZM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13Z\" fill-rule=\"nonzero\"/></svg>',\n    'vertical-align': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><rect width=\"18\" height=\"2\" x=\"3\" y=\"11\" rx=\"1\"/><path d=\"M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 0 1 1.2 1.5l-.1.1-4.1 3-4-3a1 1 0 0 1 1-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8 4 2.9a1 1 0 0 1-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 0 1-1-1v-4l-2 1.3a1 1 0 0 1-1.2-.1l-.1-.1a1 1 0 0 1 .1-1.3l.1-.1 4.1-3z\"/></g></svg>',\n    'visualblocks': '<svg width=\"24\" height=\"24\"><path d=\"M9 19v2H7v-2h2Zm-4 0v2a2 2 0 0 1-2-2h2Zm8 0v2h-2v-2h2Zm8 0a2 2 0 0 1-2 2v-2h2Zm-4 0v2h-2v-2h2ZM15 7a1 1 0 0 1 0 2v7a1 1 0 0 1-2 0V9h-1v7a1 1 0 0 1-2 0v-4a2.5 2.5 0 0 1-.2-5H15ZM5 15v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 11v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 7v2H3V7h2Zm16 0v2h-2V7h2ZM5 3v2H3c0-1.1.9-2 2-2Zm8 0v2h-2V3h2Zm6 0a2 2 0 0 1 2 2h-2V3ZM9 3v2H7V3h2Zm8 0v2h-2V3h2Z\" fill-rule=\"evenodd\"/></svg>',\n    'visualchars': '<svg width=\"24\" height=\"24\"><path d=\"M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z\" fill-rule=\"evenodd\"/></svg>',\n    'warning': '<svg width=\"24\" height=\"24\"><path d=\"M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6ZM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3Zm.7-3 .3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4Z\" fill-rule=\"evenodd\"/></svg>',\n    'zoom-in': '<svg width=\"24\" height=\"24\"><path d=\"M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8Zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z\" fill-rule=\"nonzero\"/></svg>',\n    'zoom-out': '<svg width=\"24\" height=\"24\"><path d=\"M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z\" fill-rule=\"nonzero\"/></svg>',\n    'export-pdf': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7 3h7.4L19 7.6V17h-2V9h-4V5H7v3H5V5c0-1.1.9-2 2-2Z\"/><path d=\"M2.6 15.2v-1.9h1c.6 0 1-.2 1.4-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2a2 2 0 0 0-1.3-.4H1v5.2h1.6Zm.4-3h-.4v-1.1h.5l.6.1.2.5c0 .1 0 .3-.2.4l-.7.1Zm5.7 3 1-.1c.3 0 .5-.2.7-.4l.5-.8c.2-.3.2-.7.2-1.3v-1l-.5-.8c-.2-.3-.4-.5-.7-.6L8.7 10H6.3v5.2h2.4Zm-.4-1.1H8v-3h.4c.5 0 .8.2 1 .4l.2 1.1-.1 1-.3.3-.8.2Zm5.3 1.2V13h2v-1h-2v-1H16V10h-4v5.2h1.6Z\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M15 17a1 1 0 1 0-2 0v3.1l-1.4-1a1 1 0 1 0-1.2 1.7l3.6 2.4 3.6-2.4a1 1 0 0 0-1.2-1.6l-1.4 1V17Z\"/></svg>',\n    'export-word': '<svg width=\"24\" height=\"24\"><path d=\"M9.5 7A1.5 1.5 0 0 1 11 8.4v7.1A1.5 1.5 0 0 1 9.6 17H2.5A1.5 1.5 0 0 1 1 15.6V8.5A1.5 1.5 0 0 1 2.4 7h7.1Zm-1 2.8-1 2.6-1-2.5v-.1a.6.6 0 0 0-1 0l-.1.1-.9 2.5-1-2.5v-.1a.6.6 0 0 0-1 .4v.1l1.5 4v.1a.6.6 0 0 0 1 0v-.1l1-2.5.9 2.5v.1a.6.6 0 0 0 1 0H8l1.6-4v-.2a.6.6 0 0 0-1.1-.4Z\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7 3h7.4L19 7.6V17h-2V9h-4V5H5c0-1.1.9-2 2-2ZM15 17a1 1 0 1 0-2 0v3.1l-1.4-1a1 1 0 1 0-1.2 1.7l3.6 2.4 3.6-2.4a1 1 0 0 0-1.2-1.6l-1.4 1V17Z\"/></svg>',\n    'import-word': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7 3h7.4L19 7.6V15h-2V9h-4V5H5c0-1.1.9-2 2-2Z\"/><path d=\"M9.5 7A1.5 1.5 0 0 1 11 8.4v7.1A1.5 1.5 0 0 1 9.6 17H2.5A1.5 1.5 0 0 1 1 15.6V8.5A1.5 1.5 0 0 1 2.4 7h7.1Zm-1 2.8-1 2.6-1-2.5v-.1a.6.6 0 0 0-1 0l-.1.1-.9 2.5-1-2.5v-.1a.6.6 0 0 0-1 .4v.1l1.5 4v.1a.6.6 0 0 0 1 0v-.1l1-2.5.9 2.5v.1a.6.6 0 0 0 1 0H8l1.6-4v-.2a.6.6 0 0 0-1.1-.4Z\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M11.4 18.2a1 1 0 0 0 1.2 1.6l1.4-1V22a1 1 0 1 0 2 0v-3.1l1.4 1a1 1 0 0 0 1.2-1.7L15 15.8l-3.6 2.4Z\"/></svg>',\n  }\n});\n\n//# sourceURL=webpack://keenthemes/./node_modules/tinymce/icons/default/icons.js?");

/***/ }),

/***/ "./node_modules/tinymce/themes/silver/theme.js":
/*!*****************************************************!*\
  !*** ./node_modules/tinymce/themes/silver/theme.js ***!
  \*****************************************************/
/***/ (() => {

eval("/**\n * TinyMCE version 7.2.1 (2024-07-03)\n */\n\n(function () {\n    'use strict';\n\n    const getPrototypeOf$2 = Object.getPrototypeOf;\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const eq$1 = t => a => t === a;\n    const is$2 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isPlainObject = value => is$2(value, Object);\n    const isArray = isType$1('array');\n    const isNull = eq$1(null);\n    const isBoolean = isSimpleType('boolean');\n    const isUndefined = eq$1(undefined);\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n    const isArrayOf = (value, pred) => {\n      if (isArray(value)) {\n        for (let i = 0, len = value.length; i < len; ++i) {\n          if (!pred(value[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    };\n\n    const noop = () => {\n    };\n    const noarg = f => () => f();\n    const compose = (fa, fb) => {\n      return (...args) => {\n        return fa(fb.apply(null, args));\n      };\n    };\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\n    const constant$1 = value => {\n      return () => {\n        return value;\n      };\n    };\n    const identity = x => {\n      return x;\n    };\n    const tripleEquals = (a, b) => {\n      return a === b;\n    };\n    function curry(fn, ...initialArgs) {\n      return (...restArgs) => {\n        const all = initialArgs.concat(restArgs);\n        return fn.apply(null, all);\n      };\n    }\n    const not = f => t => !f(t);\n    const die = msg => {\n      return () => {\n        throw new Error(msg);\n      };\n    };\n    const apply$1 = f => {\n      return f();\n    };\n    const never = constant$1(false);\n    const always = constant$1(true);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const indexOf = (xs, x) => {\n      const r = rawIndexOf(xs, x);\n      return r === -1 ? Optional.none() : Optional.some(r);\n    };\n    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const range$2 = (num, f) => {\n      const r = [];\n      for (let i = 0; i < num; i++) {\n        r.push(f(i));\n      }\n      return r;\n    };\n    const chunk$1 = (array, size) => {\n      const r = [];\n      for (let i = 0; i < array.length; i += size) {\n        const s = nativeSlice.call(array, i, i + size);\n        r.push(s);\n      }\n      return r;\n    };\n    const map$2 = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each$1 = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const eachr = (xs, f) => {\n      for (let i = xs.length - 1; i >= 0; i--) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const partition$3 = (xs, pred) => {\n      const pass = [];\n      const fail = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        const arr = pred(x, i) ? pass : fail;\n        arr.push(x);\n      }\n      return {\n        pass,\n        fail\n      };\n    };\n    const filter$2 = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    const foldr = (xs, f, acc) => {\n      eachr(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const foldl = (xs, f, acc) => {\n      each$1(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const findUntil = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const find$5 = (xs, pred) => {\n      return findUntil(xs, pred, never);\n    };\n    const findIndex$1 = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(i);\n        }\n      }\n      return Optional.none();\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind$3 = (xs, f) => flatten(map$2(xs, f));\n    const forall = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        const x = xs[i];\n        if (pred(x, i) !== true) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const reverse = xs => {\n      const r = nativeSlice.call(xs, 0);\n      r.reverse();\n      return r;\n    };\n    const difference = (a1, a2) => filter$2(a1, x => !contains$2(a2, x));\n    const mapToObject = (xs, f) => {\n      const r = {};\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        r[String(x)] = f(x, i);\n      }\n      return r;\n    };\n    const pure$2 = x => [x];\n    const sort = (xs, comparator) => {\n      const copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n    const get$i = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = xs => get$i(xs, 0);\n    const last$1 = xs => get$i(xs, xs.length - 1);\n    const from = isFunction(Array.from) ? Array.from : x => nativeSlice.call(x);\n    const findMap = (arr, f) => {\n      for (let i = 0; i < arr.length; i++) {\n        const r = f(arr[i], i);\n        if (r.isSome()) {\n          return r;\n        }\n      }\n      return Optional.none();\n    };\n\n    const keys = Object.keys;\n    const hasOwnProperty = Object.hasOwnProperty;\n    const each = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const map$1 = (obj, f) => {\n      return tupleMap(obj, (x, i) => ({\n        k: i,\n        v: f(x, i)\n      }));\n    };\n    const tupleMap = (obj, f) => {\n      const r = {};\n      each(obj, (x, i) => {\n        const tuple = f(x, i);\n        r[tuple.k] = tuple.v;\n      });\n      return r;\n    };\n    const objAcc = r => (x, i) => {\n      r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n      each(obj, (x, i) => {\n        (pred(x, i) ? onTrue : onFalse)(x, i);\n      });\n    };\n    const bifilter = (obj, pred) => {\n      const t = {};\n      const f = {};\n      internalFilter(obj, pred, objAcc(t), objAcc(f));\n      return {\n        t,\n        f\n      };\n    };\n    const filter$1 = (obj, pred) => {\n      const t = {};\n      internalFilter(obj, pred, objAcc(t), noop);\n      return t;\n    };\n    const mapToArray = (obj, f) => {\n      const r = [];\n      each(obj, (value, name) => {\n        r.push(f(value, name));\n      });\n      return r;\n    };\n    const find$4 = (obj, pred) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        if (pred(x, i, obj)) {\n          return Optional.some(x);\n        }\n      }\n      return Optional.none();\n    };\n    const values = obj => {\n      return mapToArray(obj, identity);\n    };\n    const get$h = (obj, key) => {\n      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\n    };\n    const has$2 = (obj, key) => hasOwnProperty.call(obj, key);\n    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\n\n    const is$1 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\n    const cat = arr => {\n      const r = [];\n      const push = x => {\n        r.push(x);\n      };\n      for (let i = 0; i < arr.length; i++) {\n        arr[i].each(push);\n      }\n      return r;\n    };\n    const sequence = arr => {\n      const r = [];\n      for (let i = 0; i < arr.length; i++) {\n        const x = arr[i];\n        if (x.isSome()) {\n          r.push(x.getOrDie());\n        } else {\n          return Optional.none();\n        }\n      }\n      return Optional.some(r);\n    };\n    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\n    const mapFrom = (a, f) => a !== undefined && a !== null ? Optional.some(f(a)) : Optional.none();\n    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n\n    const addToEnd = (str, suffix) => {\n      return str + suffix;\n    };\n    const removeFromStart = (str, numChars) => {\n      return str.substring(numChars);\n    };\n\n    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n    const removeLeading = (str, prefix) => {\n      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\n    };\n    const ensureTrailing = (str, suffix) => {\n      return endsWith(str, suffix) ? str : addToEnd(str, suffix);\n    };\n    const contains$1 = (str, substr, start = 0, end) => {\n      const idx = str.indexOf(substr, start);\n      if (idx !== -1) {\n        return isUndefined(end) ? true : idx + substr.length <= end;\n      } else {\n        return false;\n      }\n    };\n    const startsWith = (str, prefix) => {\n      return checkRange(str, prefix, 0);\n    };\n    const endsWith = (str, suffix) => {\n      return checkRange(str, suffix, str.length - suffix.length);\n    };\n    const blank = r => s => s.replace(r, '');\n    const trim$1 = blank(/^\\s+|\\s+$/g);\n    const isNotEmpty = s => s.length > 0;\n    const isEmpty = s => !isNotEmpty(s);\n\n    const isSupported$1 = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const fromHtml$2 = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom(node);\n    };\n    const fromDom = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);\n    const SugarElement = {\n      fromHtml: fromHtml$2,\n      fromTag,\n      fromText,\n      fromDom,\n      fromPoint\n    };\n\n    const Global = typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const path$1 = (parts, scope) => {\n      let o = scope !== undefined && scope !== null ? scope : Global;\n      for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n        o = o[parts[i]];\n      }\n      return o;\n    };\n    const resolve = (p, scope) => {\n      const parts = p.split('.');\n      return path$1(parts, scope);\n    };\n\n    const unsafe = (name, scope) => {\n      return resolve(name, scope);\n    };\n    const getOrDie$1 = (name, scope) => {\n      const actual = unsafe(name, scope);\n      if (actual === undefined || actual === null) {\n        throw new Error(name + ' not available on this browser');\n      }\n      return actual;\n    };\n\n    const getPrototypeOf$1 = Object.getPrototypeOf;\n    const sandHTMLElement = scope => {\n      return getOrDie$1('HTMLElement', scope);\n    };\n    const isPrototypeOf = x => {\n      const scope = resolve('ownerDocument.defaultView', x);\n      return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf$1(x).constructor.name));\n    };\n\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const name$3 = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type$1 = element => element.dom.nodeType;\n    const isType = t => element => type$1(element) === t;\n    const isHTMLElement = element => isElement$1(element) && isPrototypeOf(element.dom);\n    const isElement$1 = isType(ELEMENT);\n    const isText = isType(TEXT);\n    const isDocument = isType(DOCUMENT);\n    const isDocumentFragment = isType(DOCUMENT_FRAGMENT);\n    const isTag = tag => e => isElement$1(e) && name$3(e) === tag;\n\n    const is = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n    const all$3 = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? [] : map$2(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n    const one = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n    };\n\n    const eq = (e1, e2) => e1.dom === e2.dom;\n    const contains = (e1, e2) => {\n      const d1 = e1.dom;\n      const d2 = e2.dom;\n      return d1 === d2 ? false : d1.contains(d2);\n    };\n\n    const owner$4 = element => SugarElement.fromDom(element.dom.ownerDocument);\n    const documentOrOwner = dos => isDocument(dos) ? dos : owner$4(dos);\n    const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n    const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentNode = element => parent(element);\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const parents = (element, isRoot) => {\n      const stop = isFunction(isRoot) ? isRoot : never;\n      let dom = element.dom;\n      const ret = [];\n      while (dom.parentNode !== null && dom.parentNode !== undefined) {\n        const rawParent = dom.parentNode;\n        const p = SugarElement.fromDom(rawParent);\n        ret.push(p);\n        if (stop(p) === true) {\n          break;\n        } else {\n          dom = rawParent;\n        }\n      }\n      return ret;\n    };\n    const offsetParent = element => Optional.from(element.dom.offsetParent).map(SugarElement.fromDom);\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const children = element => map$2(element.dom.childNodes, SugarElement.fromDom);\n    const child$2 = (element, index) => {\n      const cs = element.dom.childNodes;\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = element => child$2(element, 0);\n    const spot = (element, offset) => ({\n      element,\n      offset\n    });\n    const leaf = (element, offset) => {\n      const cs = children(element);\n      return cs.length > 0 && offset < cs.length ? spot(cs[offset], 0) : spot(element, offset);\n    };\n\n    const isShadowRoot = dos => isDocumentFragment(dos) && isNonNullable(dos.dom.host);\n    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n    const isSupported = constant$1(supported);\n    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n    const getContentContainer = dos => isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);\n    const isInShadowRoot = e => getShadowRoot(e).isSome();\n    const getShadowRoot = e => {\n      const r = getRootNode(e);\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n    const getOriginalEventTarget = event => {\n      if (isSupported() && isNonNullable(event.target)) {\n        const el = SugarElement.fromDom(event.target);\n        if (isElement$1(el) && isOpenShadowHost(el)) {\n          if (event.composed && event.composedPath) {\n            const composedPath = event.composedPath();\n            if (composedPath) {\n              return head(composedPath);\n            }\n          }\n        }\n      }\n      return Optional.from(event.target);\n    };\n    const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\n\n    const inBody = element => {\n      const dom = isText(element) ? element.dom.parentNode : element.dom;\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\n        return false;\n      }\n      const doc = dom.ownerDocument;\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n    const body = () => getBody(SugarElement.fromDom(document));\n    const getBody = doc => {\n      const b = doc.dom.body;\n      if (b === null || b === undefined) {\n        throw new Error('Body is not available yet');\n      }\n      return SugarElement.fromDom(b);\n    };\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const set$9 = (element, key, value) => {\n      rawSet(element.dom, key, value);\n    };\n    const setAll$1 = (element, attrs) => {\n      const dom = element.dom;\n      each(attrs, (v, k) => {\n        rawSet(dom, k, v);\n      });\n    };\n    const get$g = (element, key) => {\n      const v = element.dom.getAttribute(key);\n      return v === null ? undefined : v;\n    };\n    const getOpt = (element, key) => Optional.from(get$g(element, key));\n    const has$1 = (element, key) => {\n      const dom = element.dom;\n      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\n    };\n    const remove$8 = (element, key) => {\n      element.dom.removeAttribute(key);\n    };\n    const clone$2 = element => foldl(element.dom.attributes, (acc, attr) => {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n\n    const internalSet = (dom, property, value) => {\n      if (!isString(value)) {\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n        throw new Error('CSS value must be a string: ' + value);\n      }\n      if (isSupported$1(dom)) {\n        dom.style.setProperty(property, value);\n      }\n    };\n    const internalRemove = (dom, property) => {\n      if (isSupported$1(dom)) {\n        dom.style.removeProperty(property);\n      }\n    };\n    const set$8 = (element, property, value) => {\n      const dom = element.dom;\n      internalSet(dom, property, value);\n    };\n    const setAll = (element, css) => {\n      const dom = element.dom;\n      each(css, (v, k) => {\n        internalSet(dom, k, v);\n      });\n    };\n    const setOptions = (element, css) => {\n      const dom = element.dom;\n      each(css, (v, k) => {\n        v.fold(() => {\n          internalRemove(dom, k);\n        }, value => {\n          internalSet(dom, k, value);\n        });\n      });\n    };\n    const get$f = (element, property) => {\n      const dom = element.dom;\n      const styles = window.getComputedStyle(dom);\n      const r = styles.getPropertyValue(property);\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n    };\n    const getUnsafeProperty = (dom, property) => isSupported$1(dom) ? dom.style.getPropertyValue(property) : '';\n    const getRaw = (element, property) => {\n      const dom = element.dom;\n      const raw = getUnsafeProperty(dom, property);\n      return Optional.from(raw).filter(r => r.length > 0);\n    };\n    const getAllRaw = element => {\n      const css = {};\n      const dom = element.dom;\n      if (isSupported$1(dom)) {\n        for (let i = 0; i < dom.style.length; i++) {\n          const ruleName = dom.style.item(i);\n          css[ruleName] = dom.style[ruleName];\n        }\n      }\n      return css;\n    };\n    const isValidValue$1 = (tag, property, value) => {\n      const element = SugarElement.fromTag(tag);\n      set$8(element, property, value);\n      const style = getRaw(element, property);\n      return style.isSome();\n    };\n    const remove$7 = (element, property) => {\n      const dom = element.dom;\n      internalRemove(dom, property);\n      if (is$1(getOpt(element, 'style').map(trim$1), '')) {\n        remove$8(element, 'style');\n      }\n    };\n    const reflow = e => e.dom.offsetWidth;\n\n    const Dimension = (name, getOffset) => {\n      const set = (element, h) => {\n        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n        }\n        const dom = element.dom;\n        if (isSupported$1(dom)) {\n          dom.style[name] = h + 'px';\n        }\n      };\n      const get = element => {\n        const r = getOffset(element);\n        if (r <= 0 || r === null) {\n          const css = get$f(element, name);\n          return parseFloat(css) || 0;\n        }\n        return r;\n      };\n      const getOuter = get;\n      const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n        const val = get$f(element, property);\n        const value = val === undefined ? 0 : parseInt(val, 10);\n        return isNaN(value) ? acc : acc + value;\n      }, 0);\n      const max = (element, value, properties) => {\n        const cumulativeInclusions = aggregate(element, properties);\n        const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n        return absoluteMax;\n      };\n      return {\n        set,\n        get,\n        getOuter,\n        aggregate,\n        max\n      };\n    };\n\n    const api$2 = Dimension('height', element => {\n      const dom = element.dom;\n      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n    });\n    const get$e = element => api$2.get(element);\n    const getOuter$2 = element => api$2.getOuter(element);\n    const setMax$1 = (element, value) => {\n      const inclusions = [\n        'margin-top',\n        'border-top-width',\n        'padding-top',\n        'padding-bottom',\n        'border-bottom-width',\n        'margin-bottom'\n      ];\n      const absMax = api$2.max(element, value, inclusions);\n      set$8(element, 'max-height', absMax + 'px');\n    };\n\n    const r$1 = (left, top) => {\n      const translate = (x, y) => r$1(left + x, top + y);\n      return {\n        left,\n        top,\n        translate\n      };\n    };\n    const SugarPosition = r$1;\n\n    const boxPosition = dom => {\n      const box = dom.getBoundingClientRect();\n      return SugarPosition(box.left, box.top);\n    };\n    const firstDefinedOrZero = (a, b) => {\n      if (a !== undefined) {\n        return a;\n      } else {\n        return b !== undefined ? b : 0;\n      }\n    };\n    const absolute$3 = element => {\n      const doc = element.dom.ownerDocument;\n      const body = doc.body;\n      const win = doc.defaultView;\n      const html = doc.documentElement;\n      if (body === element.dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n      const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n      const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n      const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n      return viewport$1(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n    };\n    const viewport$1 = element => {\n      const dom = element.dom;\n      const doc = dom.ownerDocument;\n      const body = doc.body;\n      if (body === dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      if (!inBody(element)) {\n        return SugarPosition(0, 0);\n      }\n      return boxPosition(dom);\n    };\n\n    const api$1 = Dimension('width', element => element.dom.offsetWidth);\n    const set$7 = (element, h) => api$1.set(element, h);\n    const get$d = element => api$1.get(element);\n    const getOuter$1 = element => api$1.getOuter(element);\n    const setMax = (element, value) => {\n      const inclusions = [\n        'margin-left',\n        'border-left-width',\n        'padding-left',\n        'padding-right',\n        'border-right-width',\n        'margin-right'\n      ];\n      const absMax = api$1.max(element, value, inclusions);\n      set$8(element, 'max-width', absMax + 'px');\n    };\n\n    const cached = f => {\n      let called = false;\n      let r;\n      return (...args) => {\n        if (!called) {\n          called = true;\n          r = f.apply(null, args);\n        }\n        return r;\n      };\n    };\n\n    const DeviceType = (os, browser, userAgent, mediaMatch) => {\n      const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n      const isiPhone = os.isiOS() && !isiPad;\n      const isMobile = os.isiOS() || os.isAndroid();\n      const isTouch = isMobile || mediaMatch('(pointer:coarse)');\n      const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n      const isPhone = isiPhone || isMobile && !isTablet;\n      const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n      const isDesktop = !isPhone && !isTablet && !iOSwebview;\n      return {\n        isiPad: constant$1(isiPad),\n        isiPhone: constant$1(isiPhone),\n        isTablet: constant$1(isTablet),\n        isPhone: constant$1(isPhone),\n        isTouch: constant$1(isTouch),\n        isAndroid: os.isAndroid,\n        isiOS: os.isiOS,\n        isWebView: constant$1(iOSwebview),\n        isDesktop: constant$1(isDesktop)\n      };\n    };\n\n    const firstMatch = (regexes, s) => {\n      for (let i = 0; i < regexes.length; i++) {\n        const x = regexes[i];\n        if (x.test(s)) {\n          return x;\n        }\n      }\n      return undefined;\n    };\n    const find$3 = (regexes, agent) => {\n      const r = firstMatch(regexes, agent);\n      if (!r) {\n        return {\n          major: 0,\n          minor: 0\n        };\n      }\n      const group = i => {\n        return Number(agent.replace(r, '$' + i));\n      };\n      return nu$d(group(1), group(2));\n    };\n    const detect$4 = (versionRegexes, agent) => {\n      const cleanedAgent = String(agent).toLowerCase();\n      if (versionRegexes.length === 0) {\n        return unknown$3();\n      }\n      return find$3(versionRegexes, cleanedAgent);\n    };\n    const unknown$3 = () => {\n      return nu$d(0, 0);\n    };\n    const nu$d = (major, minor) => {\n      return {\n        major,\n        minor\n      };\n    };\n    const Version = {\n      nu: nu$d,\n      detect: detect$4,\n      unknown: unknown$3\n    };\n\n    const detectBrowser$1 = (browsers, userAgentData) => {\n      return findMap(userAgentData.brands, uaBrand => {\n        const lcBrand = uaBrand.brand.toLowerCase();\n        return find$5(browsers, browser => {\n          var _a;\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n        }).map(info => ({\n          current: info.name,\n          version: Version.nu(parseInt(uaBrand.version, 10), 0)\n        }));\n      });\n    };\n\n    const detect$3 = (candidates, userAgent) => {\n      const agent = String(userAgent).toLowerCase();\n      return find$5(candidates, candidate => {\n        return candidate.search(agent);\n      });\n    };\n    const detectBrowser = (browsers, userAgent) => {\n      return detect$3(browsers, userAgent).map(browser => {\n        const version = Version.detect(browser.versionRegexes, userAgent);\n        return {\n          current: browser.name,\n          version\n        };\n      });\n    };\n    const detectOs = (oses, userAgent) => {\n      return detect$3(oses, userAgent).map(os => {\n        const version = Version.detect(os.versionRegexes, userAgent);\n        return {\n          current: os.name,\n          version\n        };\n      });\n    };\n\n    const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n    const checkContains = target => {\n      return uastring => {\n        return contains$1(uastring, target);\n      };\n    };\n    const browsers = [\n      {\n        name: 'Edge',\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n        search: uastring => {\n          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\n        }\n      },\n      {\n        name: 'Chromium',\n        brand: 'Chromium',\n        versionRegexes: [\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\n          normalVersionRegex\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\n        }\n      },\n      {\n        name: 'IE',\n        versionRegexes: [\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\n        }\n      },\n      {\n        name: 'Opera',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\n        ],\n        search: checkContains('opera')\n      },\n      {\n        name: 'Firefox',\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n        search: checkContains('firefox')\n      },\n      {\n        name: 'Safari',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\n        ],\n        search: uastring => {\n          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\n        }\n      }\n    ];\n    const oses = [\n      {\n        name: 'Windows',\n        search: checkContains('win'),\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'iOS',\n        search: uastring => {\n          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\n        },\n        versionRegexes: [\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\n        ]\n      },\n      {\n        name: 'Android',\n        search: checkContains('android'),\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'macOS',\n        search: checkContains('mac os x'),\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n      },\n      {\n        name: 'Linux',\n        search: checkContains('linux'),\n        versionRegexes: []\n      },\n      {\n        name: 'Solaris',\n        search: checkContains('sunos'),\n        versionRegexes: []\n      },\n      {\n        name: 'FreeBSD',\n        search: checkContains('freebsd'),\n        versionRegexes: []\n      },\n      {\n        name: 'ChromeOS',\n        search: checkContains('cros'),\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n      }\n    ];\n    const PlatformInfo = {\n      browsers: constant$1(browsers),\n      oses: constant$1(oses)\n    };\n\n    const edge = 'Edge';\n    const chromium = 'Chromium';\n    const ie = 'IE';\n    const opera = 'Opera';\n    const firefox = 'Firefox';\n    const safari = 'Safari';\n    const unknown$2 = () => {\n      return nu$c({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$c = info => {\n      const current = info.current;\n      const version = info.version;\n      const isBrowser = name => () => current === name;\n      return {\n        current,\n        version,\n        isEdge: isBrowser(edge),\n        isChromium: isBrowser(chromium),\n        isIE: isBrowser(ie),\n        isOpera: isBrowser(opera),\n        isFirefox: isBrowser(firefox),\n        isSafari: isBrowser(safari)\n      };\n    };\n    const Browser = {\n      unknown: unknown$2,\n      nu: nu$c,\n      edge: constant$1(edge),\n      chromium: constant$1(chromium),\n      ie: constant$1(ie),\n      opera: constant$1(opera),\n      firefox: constant$1(firefox),\n      safari: constant$1(safari)\n    };\n\n    const windows = 'Windows';\n    const ios = 'iOS';\n    const android = 'Android';\n    const linux = 'Linux';\n    const macos = 'macOS';\n    const solaris = 'Solaris';\n    const freebsd = 'FreeBSD';\n    const chromeos = 'ChromeOS';\n    const unknown$1 = () => {\n      return nu$b({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$b = info => {\n      const current = info.current;\n      const version = info.version;\n      const isOS = name => () => current === name;\n      return {\n        current,\n        version,\n        isWindows: isOS(windows),\n        isiOS: isOS(ios),\n        isAndroid: isOS(android),\n        isMacOS: isOS(macos),\n        isLinux: isOS(linux),\n        isSolaris: isOS(solaris),\n        isFreeBSD: isOS(freebsd),\n        isChromeOS: isOS(chromeos)\n      };\n    };\n    const OperatingSystem = {\n      unknown: unknown$1,\n      nu: nu$b,\n      windows: constant$1(windows),\n      ios: constant$1(ios),\n      android: constant$1(android),\n      linux: constant$1(linux),\n      macos: constant$1(macos),\n      solaris: constant$1(solaris),\n      freebsd: constant$1(freebsd),\n      chromeos: constant$1(chromeos)\n    };\n\n    const detect$2 = (userAgent, userAgentDataOpt, mediaMatch) => {\n      const browsers = PlatformInfo.browsers();\n      const oses = PlatformInfo.oses();\n      const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\n      const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n      const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n      return {\n        browser,\n        os,\n        deviceType\n      };\n    };\n    const PlatformDetection = { detect: detect$2 };\n\n    const mediaMatch = query => window.matchMedia(query).matches;\n    let platform = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));\n    const detect$1 = () => platform();\n\n    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\n      target,\n      x,\n      y,\n      stop,\n      prevent,\n      kill,\n      raw\n    });\n    const fromRawEvent$1 = rawEvent => {\n      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n      const stop = () => rawEvent.stopPropagation();\n      const prevent = () => rawEvent.preventDefault();\n      const kill = compose(prevent, stop);\n      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n    };\n    const handle = (filter, handler) => rawEvent => {\n      if (filter(rawEvent)) {\n        handler(fromRawEvent$1(rawEvent));\n      }\n    };\n    const binder = (element, event, filter, handler, useCapture) => {\n      const wrapped = handle(filter, handler);\n      element.dom.addEventListener(event, wrapped, useCapture);\n      return { unbind: curry(unbind, element, event, wrapped, useCapture) };\n    };\n    const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\n    const capture$1 = (element, event, filter, handler) => binder(element, event, filter, handler, true);\n    const unbind = (element, event, handler, useCapture) => {\n      element.dom.removeEventListener(event, handler, useCapture);\n    };\n\n    const before$1 = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const after$2 = (marker, element) => {\n      const sibling = nextSibling(marker);\n      sibling.fold(() => {\n        const parent$1 = parent(marker);\n        parent$1.each(v => {\n          append$2(v, element);\n        });\n      }, v => {\n        before$1(v, element);\n      });\n    };\n    const prepend$1 = (parent, element) => {\n      const firstChild$1 = firstChild(parent);\n      firstChild$1.fold(() => {\n        append$2(parent, element);\n      }, v => {\n        parent.dom.insertBefore(element.dom, v.dom);\n      });\n    };\n    const append$2 = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n    const appendAt = (parent, element, index) => {\n      child$2(parent, index).fold(() => {\n        append$2(parent, element);\n      }, v => {\n        before$1(v, element);\n      });\n    };\n\n    const append$1 = (parent, elements) => {\n      each$1(elements, x => {\n        append$2(parent, x);\n      });\n    };\n\n    const empty = element => {\n      element.dom.textContent = '';\n      each$1(children(element), rogue => {\n        remove$6(rogue);\n      });\n    };\n    const remove$6 = element => {\n      const dom = element.dom;\n      if (dom.parentNode !== null) {\n        dom.parentNode.removeChild(dom);\n      }\n    };\n\n    const get$c = _DOC => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n      const y = doc.body.scrollTop || doc.documentElement.scrollTop;\n      return SugarPosition(x, y);\n    };\n    const to = (x, y, _DOC) => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const win = doc.defaultView;\n      if (win) {\n        win.scrollTo(x, y);\n      }\n    };\n\n    const get$b = _win => {\n      const win = _win === undefined ? window : _win;\n      if (detect$1().browser.isFirefox()) {\n        return Optional.none();\n      } else {\n        return Optional.from(win.visualViewport);\n      }\n    };\n    const bounds$1 = (x, y, width, height) => ({\n      x,\n      y,\n      width,\n      height,\n      right: x + width,\n      bottom: y + height\n    });\n    const getBounds$3 = _win => {\n      const win = _win === undefined ? window : _win;\n      const doc = win.document;\n      const scroll = get$c(SugarElement.fromDom(doc));\n      return get$b(win).fold(() => {\n        const html = win.document.documentElement;\n        const width = html.clientWidth;\n        const height = html.clientHeight;\n        return bounds$1(scroll.left, scroll.top, width, height);\n      }, visualViewport => bounds$1(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));\n    };\n\n    const getDocument = () => SugarElement.fromDom(document);\n\n    const walkUp = (navigation, doc) => {\n      const frame = navigation.view(doc);\n      return frame.fold(constant$1([]), f => {\n        const parent = navigation.owner(f);\n        const rest = walkUp(navigation, parent);\n        return [f].concat(rest);\n      });\n    };\n    const pathTo = (element, navigation) => {\n      const d = navigation.owner(element);\n      const paths = walkUp(navigation, d);\n      return Optional.some(paths);\n    };\n\n    const view = doc => {\n      var _a;\n      const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\n      return element.map(SugarElement.fromDom);\n    };\n    const owner$3 = element => owner$4(element);\n\n    var Navigation = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        view: view,\n        owner: owner$3\n    });\n\n    const find$2 = element => {\n      const doc = getDocument();\n      const scroll = get$c(doc);\n      const path = pathTo(element, Navigation);\n      return path.fold(curry(absolute$3, element), frames => {\n        const offset = viewport$1(element);\n        const r = foldr(frames, (b, a) => {\n          const loc = viewport$1(a);\n          return {\n            left: b.left + loc.left,\n            top: b.top + loc.top\n          };\n        }, {\n          left: 0,\n          top: 0\n        });\n        return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\n      });\n    };\n\n    const pointed = (point, width, height) => ({\n      point,\n      width,\n      height\n    });\n    const rect = (x, y, width, height) => ({\n      x,\n      y,\n      width,\n      height\n    });\n    const bounds = (x, y, width, height) => ({\n      x,\n      y,\n      width,\n      height,\n      right: x + width,\n      bottom: y + height\n    });\n    const box$1 = element => {\n      const xy = absolute$3(element);\n      const w = getOuter$1(element);\n      const h = getOuter$2(element);\n      return bounds(xy.left, xy.top, w, h);\n    };\n    const absolute$2 = element => {\n      const position = find$2(element);\n      const width = getOuter$1(element);\n      const height = getOuter$2(element);\n      return bounds(position.left, position.top, width, height);\n    };\n    const constrain = (original, constraint) => {\n      const left = Math.max(original.x, constraint.x);\n      const top = Math.max(original.y, constraint.y);\n      const right = Math.min(original.right, constraint.right);\n      const bottom = Math.min(original.bottom, constraint.bottom);\n      const width = right - left;\n      const height = bottom - top;\n      return bounds(left, top, width, height);\n    };\n    const constrainByMany = (original, constraints) => {\n      return foldl(constraints, (acc, c) => constrain(acc, c), original);\n    };\n    const win = () => getBounds$3(window);\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    const singleton$1 = doRevoke => {\n      const subject = Cell(Optional.none());\n      const revoke = () => subject.get().each(doRevoke);\n      const clear = () => {\n        revoke();\n        subject.set(Optional.none());\n      };\n      const isSet = () => subject.get().isSome();\n      const get = () => subject.get();\n      const set = s => {\n        revoke();\n        subject.set(Optional.some(s));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const destroyable = () => singleton$1(s => s.destroy());\n    const unbindable = () => singleton$1(s => s.unbind());\n    const value$4 = () => {\n      const subject = singleton$1(noop);\n      const on = f => subject.get().each(f);\n      return {\n        ...subject,\n        on\n      };\n    };\n\n    var global$a = tinymce.util.Tools.resolve('tinymce.ThemeManager');\n\n    const value$3 = value => {\n      const applyHelper = fn => fn(value);\n      const constHelper = constant$1(value);\n      const outputHelper = () => output;\n      const output = {\n        tag: true,\n        inner: value,\n        fold: (_onError, onValue) => onValue(value),\n        isValue: always,\n        isError: never,\n        map: mapper => Result.value(mapper(value)),\n        mapError: outputHelper,\n        bind: applyHelper,\n        exists: applyHelper,\n        forall: applyHelper,\n        getOr: constHelper,\n        or: outputHelper,\n        getOrThunk: constHelper,\n        orThunk: outputHelper,\n        getOrDie: constHelper,\n        each: fn => {\n          fn(value);\n        },\n        toOptional: () => Optional.some(value)\n      };\n      return output;\n    };\n    const error$1 = error => {\n      const outputHelper = () => output;\n      const output = {\n        tag: false,\n        inner: error,\n        fold: (onError, _onValue) => onError(error),\n        isValue: never,\n        isError: always,\n        map: outputHelper,\n        mapError: mapper => Result.error(mapper(error)),\n        bind: outputHelper,\n        exists: never,\n        forall: always,\n        getOr: identity,\n        or: identity,\n        getOrThunk: apply$1,\n        orThunk: apply$1,\n        getOrDie: die(String(error)),\n        each: noop,\n        toOptional: Optional.none\n      };\n      return output;\n    };\n    const fromOption = (optional, err) => optional.fold(() => error$1(err), value$3);\n    const Result = {\n      value: value$3,\n      error: error$1,\n      fromOption\n    };\n\n    var SimpleResultType;\n    (function (SimpleResultType) {\n      SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';\n      SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';\n    }(SimpleResultType || (SimpleResultType = {})));\n    const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);\n    const partition$2 = results => {\n      const values = [];\n      const errors = [];\n      each$1(results, obj => {\n        fold$1(obj, err => errors.push(err), val => values.push(val));\n      });\n      return {\n        values,\n        errors\n      };\n    };\n    const mapError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return {\n          stype: SimpleResultType.Error,\n          serror: f(res.serror)\n        };\n      } else {\n        return res;\n      }\n    };\n    const map = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return {\n          stype: SimpleResultType.Value,\n          svalue: f(res.svalue)\n        };\n      } else {\n        return res;\n      }\n    };\n    const bind$1 = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return f(res.svalue);\n      } else {\n        return res;\n      }\n    };\n    const bindError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return f(res.serror);\n      } else {\n        return res;\n      }\n    };\n    const svalue = v => ({\n      stype: SimpleResultType.Value,\n      svalue: v\n    });\n    const serror = e => ({\n      stype: SimpleResultType.Error,\n      serror: e\n    });\n    const toResult$1 = res => fold$1(res, Result.error, Result.value);\n    const fromResult$1 = res => res.fold(serror, svalue);\n    const SimpleResult = {\n      fromResult: fromResult$1,\n      toResult: toResult$1,\n      svalue,\n      partition: partition$2,\n      serror,\n      bind: bind$1,\n      bindError,\n      map,\n      mapError,\n      fold: fold$1\n    };\n\n    const field$2 = (key, newKey, presence, prop) => ({\n      tag: 'field',\n      key,\n      newKey,\n      presence,\n      prop\n    });\n    const customField$1 = (newKey, instantiator) => ({\n      tag: 'custom',\n      newKey,\n      instantiator\n    });\n    const fold = (value, ifField, ifCustom) => {\n      switch (value.tag) {\n      case 'field':\n        return ifField(value.key, value.newKey, value.presence, value.prop);\n      case 'custom':\n        return ifCustom(value.newKey, value.instantiator);\n      }\n    };\n\n    const shallow$1 = (old, nu) => {\n      return nu;\n    };\n    const deep$1 = (old, nu) => {\n      const bothObjects = isPlainObject(old) && isPlainObject(nu);\n      return bothObjects ? deepMerge(old, nu) : nu;\n    };\n    const baseMerge = merger => {\n      return (...objects) => {\n        if (objects.length === 0) {\n          throw new Error(`Can't merge zero objects`);\n        }\n        const ret = {};\n        for (let j = 0; j < objects.length; j++) {\n          const curObject = objects[j];\n          for (const key in curObject) {\n            if (has$2(curObject, key)) {\n              ret[key] = merger(ret[key], curObject[key]);\n            }\n          }\n        }\n        return ret;\n      };\n    };\n    const deepMerge = baseMerge(deep$1);\n    const merge$1 = baseMerge(shallow$1);\n\n    const required$2 = () => ({\n      tag: 'required',\n      process: {}\n    });\n    const defaultedThunk = fallbackThunk => ({\n      tag: 'defaultedThunk',\n      process: fallbackThunk\n    });\n    const defaulted$1 = fallback => defaultedThunk(constant$1(fallback));\n    const asOption = () => ({\n      tag: 'option',\n      process: {}\n    });\n    const mergeWithThunk = baseThunk => ({\n      tag: 'mergeWithThunk',\n      process: baseThunk\n    });\n    const mergeWith = base => mergeWithThunk(constant$1(base));\n\n    const mergeValues$1 = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge$1.apply(undefined, values))) : SimpleResult.svalue(base);\n    const mergeErrors$1 = errors => compose(SimpleResult.serror, flatten)(errors);\n    const consolidateObj = (objects, base) => {\n      const partition = SimpleResult.partition(objects);\n      return partition.errors.length > 0 ? mergeErrors$1(partition.errors) : mergeValues$1(partition.values, base);\n    };\n    const consolidateArr = objects => {\n      const partitions = SimpleResult.partition(objects);\n      return partitions.errors.length > 0 ? mergeErrors$1(partitions.errors) : SimpleResult.svalue(partitions.values);\n    };\n    const ResultCombine = {\n      consolidateObj,\n      consolidateArr\n    };\n\n    const formatObj = input => {\n      return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);\n    };\n    const formatErrors = errors => {\n      const es = errors.length > 10 ? errors.slice(0, 10).concat([{\n          path: [],\n          getErrorInfo: constant$1('... (only showing first ten failures)')\n        }]) : errors;\n      return map$2(es, e => {\n        return 'Failed path: (' + e.path.join(' > ') + ')\\n' + e.getErrorInfo();\n      });\n    };\n\n    const nu$a = (path, getErrorInfo) => {\n      return SimpleResult.serror([{\n          path,\n          getErrorInfo\n        }]);\n    };\n    const missingRequired = (path, key, obj) => nu$a(path, () => 'Could not find valid *required* value for \"' + key + '\" in ' + formatObj(obj));\n    const missingKey = (path, key) => nu$a(path, () => 'Choice schema did not contain choice key: \"' + key + '\"');\n    const missingBranch = (path, branches, branch) => nu$a(path, () => 'The chosen schema: \"' + branch + '\" did not exist in branches: ' + formatObj(branches));\n    const unsupportedFields = (path, unsupported) => nu$a(path, () => 'There are unsupported fields: [' + unsupported.join(', ') + '] specified');\n    const custom = (path, err) => nu$a(path, constant$1(err));\n\n    const value$2 = validator => {\n      const extract = (path, val) => {\n        return SimpleResult.bindError(validator(val), err => custom(path, err));\n      };\n      const toString = constant$1('val');\n      return {\n        extract,\n        toString\n      };\n    };\n    const anyValue$1 = value$2(SimpleResult.svalue);\n\n    const requiredAccess = (path, obj, key, bundle) => get$h(obj, key).fold(() => missingRequired(path, key, obj), bundle);\n    const fallbackAccess = (obj, key, fallback, bundle) => {\n      const v = get$h(obj, key).getOrThunk(() => fallback(obj));\n      return bundle(v);\n    };\n    const optionAccess = (obj, key, bundle) => bundle(get$h(obj, key));\n    const optionDefaultedAccess = (obj, key, fallback, bundle) => {\n      const opt = get$h(obj, key).map(val => val === true ? fallback(obj) : val);\n      return bundle(opt);\n    };\n    const extractField = (field, path, obj, key, prop) => {\n      const bundle = av => prop.extract(path.concat([key]), av);\n      const bundleAsOption = optValue => optValue.fold(() => SimpleResult.svalue(Optional.none()), ov => {\n        const result = prop.extract(path.concat([key]), ov);\n        return SimpleResult.map(result, Optional.some);\n      });\n      switch (field.tag) {\n      case 'required':\n        return requiredAccess(path, obj, key, bundle);\n      case 'defaultedThunk':\n        return fallbackAccess(obj, key, field.process, bundle);\n      case 'option':\n        return optionAccess(obj, key, bundleAsOption);\n      case 'defaultedOptionThunk':\n        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);\n      case 'mergeWithThunk': {\n          return fallbackAccess(obj, key, constant$1({}), v => {\n            const result = deepMerge(field.process(obj), v);\n            return bundle(result);\n          });\n        }\n      }\n    };\n    const extractFields = (path, obj, fields) => {\n      const success = {};\n      const errors = [];\n      for (const field of fields) {\n        fold(field, (key, newKey, presence, prop) => {\n          const result = extractField(presence, path, obj, key, prop);\n          SimpleResult.fold(result, err => {\n            errors.push(...err);\n          }, res => {\n            success[newKey] = res;\n          });\n        }, (newKey, instantiator) => {\n          success[newKey] = instantiator(obj);\n        });\n      }\n      return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);\n    };\n    const valueThunk = getDelegate => {\n      const extract = (path, val) => getDelegate().extract(path, val);\n      const toString = () => getDelegate().toString();\n      return {\n        extract,\n        toString\n      };\n    };\n    const getSetKeys = obj => keys(filter$1(obj, isNonNullable));\n    const objOfOnly = fields => {\n      const delegate = objOf(fields);\n      const fieldNames = foldr(fields, (acc, value) => {\n        return fold(value, key => deepMerge(acc, { [key]: true }), constant$1(acc));\n      }, {});\n      const extract = (path, o) => {\n        const keys = isBoolean(o) ? [] : getSetKeys(o);\n        const extra = filter$2(keys, k => !hasNonNullableKey(fieldNames, k));\n        return extra.length === 0 ? delegate.extract(path, o) : unsupportedFields(path, extra);\n      };\n      return {\n        extract,\n        toString: delegate.toString\n      };\n    };\n    const objOf = values => {\n      const extract = (path, o) => extractFields(path, o, values);\n      const toString = () => {\n        const fieldStrings = map$2(values, value => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));\n        return 'obj{\\n' + fieldStrings.join('\\n') + '}';\n      };\n      return {\n        extract,\n        toString\n      };\n    };\n    const arrOf = prop => {\n      const extract = (path, array) => {\n        const results = map$2(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));\n        return ResultCombine.consolidateArr(results);\n      };\n      const toString = () => 'array(' + prop.toString() + ')';\n      return {\n        extract,\n        toString\n      };\n    };\n    const oneOf = (props, rawF) => {\n      const f = rawF !== undefined ? rawF : identity;\n      const extract = (path, val) => {\n        const errors = [];\n        for (const prop of props) {\n          const res = prop.extract(path, val);\n          if (res.stype === SimpleResultType.Value) {\n            return {\n              stype: SimpleResultType.Value,\n              svalue: f(res.svalue)\n            };\n          }\n          errors.push(res);\n        }\n        return ResultCombine.consolidateArr(errors);\n      };\n      const toString = () => 'oneOf(' + map$2(props, prop => prop.toString()).join(', ') + ')';\n      return {\n        extract,\n        toString\n      };\n    };\n    const setOf$1 = (validator, prop) => {\n      const validateKeys = (path, keys) => arrOf(value$2(validator)).extract(path, keys);\n      const extract = (path, o) => {\n        const keys$1 = keys(o);\n        const validatedKeys = validateKeys(path, keys$1);\n        return SimpleResult.bind(validatedKeys, validKeys => {\n          const schema = map$2(validKeys, vk => {\n            return field$2(vk, vk, required$2(), prop);\n          });\n          return objOf(schema).extract(path, o);\n        });\n      };\n      const toString = () => 'setOf(' + prop.toString() + ')';\n      return {\n        extract,\n        toString\n      };\n    };\n    const thunk = (_desc, processor) => {\n      const getP = cached(processor);\n      const extract = (path, val) => getP().extract(path, val);\n      const toString = () => getP().toString();\n      return {\n        extract,\n        toString\n      };\n    };\n    const arrOfObj = compose(arrOf, objOf);\n\n    const anyValue = constant$1(anyValue$1);\n    const typedValue = (validator, expectedType) => value$2(a => {\n      const actualType = typeof a;\n      return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${ expectedType } but got: ${ actualType }`);\n    });\n    const number = typedValue(isNumber, 'number');\n    const string = typedValue(isString, 'string');\n    const boolean = typedValue(isBoolean, 'boolean');\n    const functionProcessor = typedValue(isFunction, 'function');\n    const isPostMessageable = val => {\n      if (Object(val) !== val) {\n        return true;\n      }\n      switch ({}.toString.call(val).slice(8, -1)) {\n      case 'Boolean':\n      case 'Number':\n      case 'String':\n      case 'Date':\n      case 'RegExp':\n      case 'Blob':\n      case 'FileList':\n      case 'ImageData':\n      case 'ImageBitmap':\n      case 'ArrayBuffer':\n        return true;\n      case 'Array':\n      case 'Object':\n        return Object.keys(val).every(prop => isPostMessageable(val[prop]));\n      default:\n        return false;\n      }\n    };\n    const postMessageable = value$2(a => {\n      if (isPostMessageable(a)) {\n        return SimpleResult.svalue(a);\n      } else {\n        return SimpleResult.serror('Expected value to be acceptable for sending via postMessage');\n      }\n    });\n\n    const chooseFrom = (path, input, branches, ch) => {\n      const fields = get$h(branches, ch);\n      return fields.fold(() => missingBranch(path, branches, ch), vp => vp.extract(path.concat(['branch: ' + ch]), input));\n    };\n    const choose$2 = (key, branches) => {\n      const extract = (path, input) => {\n        const choice = get$h(input, key);\n        return choice.fold(() => missingKey(path, key), chosen => chooseFrom(path, input, branches, chosen));\n      };\n      const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const arrOfVal = () => arrOf(anyValue$1);\n    const valueOf = validator => value$2(v => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));\n    const setOf = (validator, prop) => setOf$1(v => SimpleResult.fromResult(validator(v)), prop);\n    const extractValue = (label, prop, obj) => {\n      const res = prop.extract([label], obj);\n      return SimpleResult.mapError(res, errs => ({\n        input: obj,\n        errors: errs\n      }));\n    };\n    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));\n    const getOrDie = extraction => {\n      return extraction.fold(errInfo => {\n        throw new Error(formatError(errInfo));\n      }, identity);\n    };\n    const asRawOrDie$1 = (label, prop, obj) => getOrDie(asRaw(label, prop, obj));\n    const formatError = errInfo => {\n      return 'Errors: \\n' + formatErrors(errInfo.errors).join('\\n') + '\\n\\nInput object: ' + formatObj(errInfo.input);\n    };\n    const choose$1 = (key, branches) => choose$2(key, map$1(branches, objOf));\n    const thunkOf = (desc, schema) => thunk(desc, schema);\n\n    const field$1 = field$2;\n    const customField = customField$1;\n    const validateEnum = values => valueOf(value => contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: \"${ value }\", choose one of \"${ values.join(', ') }\".`));\n    const required$1 = key => field$1(key, key, required$2(), anyValue());\n    const requiredOf = (key, schema) => field$1(key, key, required$2(), schema);\n    const requiredNumber = key => requiredOf(key, number);\n    const requiredString = key => requiredOf(key, string);\n    const requiredStringEnum = (key, values) => field$1(key, key, required$2(), validateEnum(values));\n    const requiredBoolean = key => requiredOf(key, boolean);\n    const requiredFunction = key => requiredOf(key, functionProcessor);\n    const forbid = (key, message) => field$1(key, key, asOption(), value$2(_v => SimpleResult.serror('The field: ' + key + ' is forbidden. ' + message)));\n    const requiredObjOf = (key, objSchema) => field$1(key, key, required$2(), objOf(objSchema));\n    const requiredArrayOfObj = (key, objFields) => field$1(key, key, required$2(), arrOfObj(objFields));\n    const requiredArrayOf = (key, schema) => field$1(key, key, required$2(), arrOf(schema));\n    const option$3 = key => field$1(key, key, asOption(), anyValue());\n    const optionOf = (key, schema) => field$1(key, key, asOption(), schema);\n    const optionNumber = key => optionOf(key, number);\n    const optionString = key => optionOf(key, string);\n    const optionStringEnum = (key, values) => optionOf(key, validateEnum(values));\n    const optionFunction = key => optionOf(key, functionProcessor);\n    const optionArrayOf = (key, schema) => optionOf(key, arrOf(schema));\n    const optionObjOf = (key, objSchema) => optionOf(key, objOf(objSchema));\n    const optionObjOfOnly = (key, objSchema) => optionOf(key, objOfOnly(objSchema));\n    const defaulted = (key, fallback) => field$1(key, key, defaulted$1(fallback), anyValue());\n    const defaultedOf = (key, fallback, schema) => field$1(key, key, defaulted$1(fallback), schema);\n    const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);\n    const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);\n    const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));\n    const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);\n    const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);\n    const defaultedPostMsg = (key, fallback) => defaultedOf(key, fallback, postMessageable);\n    const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));\n    const defaultedObjOf = (key, fallback, objSchema) => defaultedOf(key, fallback, objOf(objSchema));\n\n    const generate$7 = cases => {\n      if (!isArray(cases)) {\n        throw new Error('cases must be an array');\n      }\n      if (cases.length === 0) {\n        throw new Error('there must be at least one case');\n      }\n      const constructors = [];\n      const adt = {};\n      each$1(cases, (acase, count) => {\n        const keys$1 = keys(acase);\n        if (keys$1.length !== 1) {\n          throw new Error('one and only one name per case');\n        }\n        const key = keys$1[0];\n        const value = acase[key];\n        if (adt[key] !== undefined) {\n          throw new Error('duplicate key detected:' + key);\n        } else if (key === 'cata') {\n          throw new Error('cannot have a case named cata (sorry)');\n        } else if (!isArray(value)) {\n          throw new Error('case arguments must be an array');\n        }\n        constructors.push(key);\n        adt[key] = (...args) => {\n          const argLength = args.length;\n          if (argLength !== value.length) {\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n          }\n          const match = branches => {\n            const branchKeys = keys(branches);\n            if (constructors.length !== branchKeys.length) {\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n            }\n            const allReqd = forall(constructors, reqKey => {\n              return contains$2(branchKeys, reqKey);\n            });\n            if (!allReqd) {\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n            }\n            return branches[key].apply(null, args);\n          };\n          return {\n            fold: (...foldArgs) => {\n              if (foldArgs.length !== cases.length) {\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n              }\n              const target = foldArgs[count];\n              return target.apply(null, args);\n            },\n            match,\n            log: label => {\n              console.log(label, {\n                constructors,\n                constructor: key,\n                params: args\n              });\n            }\n          };\n        };\n      });\n      return adt;\n    };\n    const Adt = { generate: generate$7 };\n\n    Adt.generate([\n      {\n        bothErrors: [\n          'error1',\n          'error2'\n        ]\n      },\n      {\n        firstError: [\n          'error1',\n          'value2'\n        ]\n      },\n      {\n        secondError: [\n          'value1',\n          'error2'\n        ]\n      },\n      {\n        bothValues: [\n          'value1',\n          'value2'\n        ]\n      }\n    ]);\n    const partition$1 = results => {\n      const errors = [];\n      const values = [];\n      each$1(results, result => {\n        result.fold(err => {\n          errors.push(err);\n        }, value => {\n          values.push(value);\n        });\n      });\n      return {\n        errors,\n        values\n      };\n    };\n\n    const exclude$1 = (obj, fields) => {\n      const r = {};\n      each(obj, (v, k) => {\n        if (!contains$2(fields, k)) {\n          r[k] = v;\n        }\n      });\n      return r;\n    };\n\n    const wrap$2 = (key, value) => ({ [key]: value });\n    const wrapAll$1 = keyvalues => {\n      const r = {};\n      each$1(keyvalues, kv => {\n        r[kv.key] = kv.value;\n      });\n      return r;\n    };\n\n    const exclude = (obj, fields) => exclude$1(obj, fields);\n    const wrap$1 = (key, value) => wrap$2(key, value);\n    const wrapAll = keyvalues => wrapAll$1(keyvalues);\n    const mergeValues = (values, base) => {\n      return values.length === 0 ? Result.value(base) : Result.value(deepMerge(base, merge$1.apply(undefined, values)));\n    };\n    const mergeErrors = errors => Result.error(flatten(errors));\n    const consolidate = (objs, base) => {\n      const partitions = partition$1(objs);\n      return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : mergeValues(partitions.values, base);\n    };\n\n    const ensureIsRoot = isRoot => isFunction(isRoot) ? isRoot : never;\n    const ancestor$2 = (scope, transform, isRoot) => {\n      let element = scope.dom;\n      const stop = ensureIsRoot(isRoot);\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        const transformed = transform(el);\n        if (transformed.isSome()) {\n          return transformed;\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$4 = (scope, transform, isRoot) => {\n      const current = transform(scope);\n      const stop = ensureIsRoot(isRoot);\n      return current.orThunk(() => stop(scope) ? Optional.none() : ancestor$2(scope, transform, stop));\n    };\n\n    const isSource = (component, simulatedEvent) => eq(component.element, simulatedEvent.event.target);\n\n    const defaultEventHandler = {\n      can: always,\n      abort: never,\n      run: noop\n    };\n    const nu$9 = parts => {\n      if (!hasNonNullableKey(parts, 'can') && !hasNonNullableKey(parts, 'abort') && !hasNonNullableKey(parts, 'run')) {\n        throw new Error('EventHandler defined by: ' + JSON.stringify(parts, null, 2) + ' does not have can, abort, or run!');\n      }\n      return {\n        ...defaultEventHandler,\n        ...parts\n      };\n    };\n    const all$2 = (handlers, f) => (...args) => foldl(handlers, (acc, handler) => acc && f(handler).apply(undefined, args), true);\n    const any = (handlers, f) => (...args) => foldl(handlers, (acc, handler) => acc || f(handler).apply(undefined, args), false);\n    const read$2 = handler => isFunction(handler) ? {\n      can: always,\n      abort: never,\n      run: handler\n    } : handler;\n    const fuse$1 = handlers => {\n      const can = all$2(handlers, handler => handler.can);\n      const abort = any(handlers, handler => handler.abort);\n      const run = (...args) => {\n        each$1(handlers, handler => {\n          handler.run.apply(undefined, args);\n        });\n      };\n      return {\n        can,\n        abort,\n        run\n      };\n    };\n\n    const constant = constant$1;\n    const touchstart = constant('touchstart');\n    const touchmove = constant('touchmove');\n    const touchend = constant('touchend');\n    const touchcancel = constant('touchcancel');\n    const mousedown = constant('mousedown');\n    const mousemove = constant('mousemove');\n    const mouseout = constant('mouseout');\n    const mouseup = constant('mouseup');\n    const mouseover = constant('mouseover');\n    const focusin = constant('focusin');\n    const focusout = constant('focusout');\n    const keydown = constant('keydown');\n    const keyup = constant('keyup');\n    const input = constant('input');\n    const change = constant('change');\n    const click = constant('click');\n    const transitioncancel = constant('transitioncancel');\n    const transitionend = constant('transitionend');\n    const transitionstart = constant('transitionstart');\n    const selectstart = constant('selectstart');\n\n    const prefixName = name => constant$1('alloy.' + name);\n    const alloy = { tap: prefixName('tap') };\n    const focus$4 = prefixName('focus');\n    const postBlur = prefixName('blur.post');\n    const postPaste = prefixName('paste.post');\n    const receive = prefixName('receive');\n    const execute$5 = prefixName('execute');\n    const focusItem = prefixName('focus.item');\n    const tap = alloy.tap;\n    const longpress = prefixName('longpress');\n    const sandboxClose = prefixName('sandbox.close');\n    const typeaheadCancel = prefixName('typeahead.cancel');\n    const systemInit = prefixName('system.init');\n    const documentTouchmove = prefixName('system.touchmove');\n    const documentTouchend = prefixName('system.touchend');\n    const windowScroll = prefixName('system.scroll');\n    const windowResize = prefixName('system.resize');\n    const attachedToDom = prefixName('system.attached');\n    const detachedFromDom = prefixName('system.detached');\n    const dismissRequested = prefixName('system.dismissRequested');\n    const repositionRequested = prefixName('system.repositionRequested');\n    const focusShifted = prefixName('focusmanager.shifted');\n    const slotVisibility = prefixName('slotcontainer.visibility');\n    const externalElementScroll = prefixName('system.external.element.scroll');\n    const changeTab = prefixName('change.tab');\n    const dismissTab = prefixName('dismiss.tab');\n    const highlight$1 = prefixName('highlight');\n    const dehighlight$1 = prefixName('dehighlight');\n\n    const emit = (component, event) => {\n      dispatchWith(component, component.element, event, {});\n    };\n    const emitWith = (component, event, properties) => {\n      dispatchWith(component, component.element, event, properties);\n    };\n    const emitExecute = component => {\n      emit(component, execute$5());\n    };\n    const dispatch = (component, target, event) => {\n      dispatchWith(component, target, event, {});\n    };\n    const dispatchWith = (component, target, event, properties) => {\n      const data = {\n        target,\n        ...properties\n      };\n      component.getSystem().triggerEvent(event, target, data);\n    };\n    const retargetAndDispatchWith = (component, target, eventName, properties) => {\n      const data = {\n        ...properties,\n        target\n      };\n      component.getSystem().triggerEvent(eventName, target, data);\n    };\n    const dispatchEvent = (component, target, event, simulatedEvent) => {\n      component.getSystem().triggerEvent(event, target, simulatedEvent.event);\n    };\n\n    const derive$2 = configs => wrapAll(configs);\n    const abort = (name, predicate) => {\n      return {\n        key: name,\n        value: nu$9({ abort: predicate })\n      };\n    };\n    const can = (name, predicate) => {\n      return {\n        key: name,\n        value: nu$9({ can: predicate })\n      };\n    };\n    const preventDefault = name => {\n      return {\n        key: name,\n        value: nu$9({\n          run: (component, simulatedEvent) => {\n            simulatedEvent.event.prevent();\n          }\n        })\n      };\n    };\n    const run$1 = (name, handler) => {\n      return {\n        key: name,\n        value: nu$9({ run: handler })\n      };\n    };\n    const runActionExtra = (name, action, extra) => {\n      return {\n        key: name,\n        value: nu$9({\n          run: (component, simulatedEvent) => {\n            action.apply(undefined, [\n              component,\n              simulatedEvent\n            ].concat(extra));\n          }\n        })\n      };\n    };\n    const runOnName = name => {\n      return handler => run$1(name, handler);\n    };\n    const runOnSourceName = name => {\n      return handler => ({\n        key: name,\n        value: nu$9({\n          run: (component, simulatedEvent) => {\n            if (isSource(component, simulatedEvent)) {\n              handler(component, simulatedEvent);\n            }\n          }\n        })\n      });\n    };\n    const redirectToUid = (name, uid) => {\n      return run$1(name, (component, simulatedEvent) => {\n        component.getSystem().getByUid(uid).each(redirectee => {\n          dispatchEvent(redirectee, redirectee.element, name, simulatedEvent);\n        });\n      });\n    };\n    const redirectToPart = (name, detail, partName) => {\n      const uid = detail.partUids[partName];\n      return redirectToUid(name, uid);\n    };\n    const runWithTarget = (name, f) => {\n      return run$1(name, (component, simulatedEvent) => {\n        const ev = simulatedEvent.event;\n        const target = component.getSystem().getByDom(ev.target).getOrThunk(() => {\n          const closest = closest$4(ev.target, el => component.getSystem().getByDom(el).toOptional(), never);\n          return closest.getOr(component);\n        });\n        f(component, target, simulatedEvent);\n      });\n    };\n    const cutter = name => {\n      return run$1(name, (component, simulatedEvent) => {\n        simulatedEvent.cut();\n      });\n    };\n    const stopper = name => {\n      return run$1(name, (component, simulatedEvent) => {\n        simulatedEvent.stop();\n      });\n    };\n    const runOnSource = (name, f) => {\n      return runOnSourceName(name)(f);\n    };\n    const runOnAttached = runOnSourceName(attachedToDom());\n    const runOnDetached = runOnSourceName(detachedFromDom());\n    const runOnInit = runOnSourceName(systemInit());\n    const runOnExecute$1 = runOnName(execute$5());\n\n    const markAsBehaviourApi = (f, apiName, apiFunction) => {\n      const delegate = apiFunction.toString();\n      const endIndex = delegate.indexOf(')') + 1;\n      const openBracketIndex = delegate.indexOf('(');\n      const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\\s*/);\n      f.toFunctionAnnotation = () => ({\n        name: apiName,\n        parameters: cleanParameters(parameters.slice(0, 1).concat(parameters.slice(3)))\n      });\n      return f;\n    };\n    const cleanParameters = parameters => map$2(parameters, p => endsWith(p, '/*') ? p.substring(0, p.length - '/*'.length) : p);\n    const markAsExtraApi = (f, extraName) => {\n      const delegate = f.toString();\n      const endIndex = delegate.indexOf(')') + 1;\n      const openBracketIndex = delegate.indexOf('(');\n      const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\\s*/);\n      f.toFunctionAnnotation = () => ({\n        name: extraName,\n        parameters: cleanParameters(parameters)\n      });\n      return f;\n    };\n    const markAsSketchApi = (f, apiFunction) => {\n      const delegate = apiFunction.toString();\n      const endIndex = delegate.indexOf(')') + 1;\n      const openBracketIndex = delegate.indexOf('(');\n      const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\\s*/);\n      f.toFunctionAnnotation = () => ({\n        name: 'OVERRIDE',\n        parameters: cleanParameters(parameters.slice(1))\n      });\n      return f;\n    };\n\n    const nu$8 = s => ({\n      classes: isUndefined(s.classes) ? [] : s.classes,\n      attributes: isUndefined(s.attributes) ? {} : s.attributes,\n      styles: isUndefined(s.styles) ? {} : s.styles\n    });\n    const merge = (defnA, mod) => ({\n      ...defnA,\n      attributes: {\n        ...defnA.attributes,\n        ...mod.attributes\n      },\n      styles: {\n        ...defnA.styles,\n        ...mod.styles\n      },\n      classes: defnA.classes.concat(mod.classes)\n    });\n\n    const executeEvent = (bConfig, bState, executor) => runOnExecute$1(component => {\n      executor(component, bConfig, bState);\n    });\n    const loadEvent = (bConfig, bState, f) => runOnInit((component, _simulatedEvent) => {\n      f(component, bConfig, bState);\n    });\n    const create$5 = (schema, name, active, apis, extra, state) => {\n      const configSchema = objOfOnly(schema);\n      const schemaSchema = optionObjOf(name, [optionObjOfOnly('config', schema)]);\n      return doCreate(configSchema, schemaSchema, name, active, apis, extra, state);\n    };\n    const createModes$1 = (modes, name, active, apis, extra, state) => {\n      const configSchema = modes;\n      const schemaSchema = optionObjOf(name, [optionOf('config', modes)]);\n      return doCreate(configSchema, schemaSchema, name, active, apis, extra, state);\n    };\n    const wrapApi = (bName, apiFunction, apiName) => {\n      const f = (component, ...rest) => {\n        const args = [component].concat(rest);\n        return component.config({ name: constant$1(bName) }).fold(() => {\n          throw new Error('We could not find any behaviour configuration for: ' + bName + '. Using API: ' + apiName);\n        }, info => {\n          const rest = Array.prototype.slice.call(args, 1);\n          return apiFunction.apply(undefined, [\n            component,\n            info.config,\n            info.state\n          ].concat(rest));\n        });\n      };\n      return markAsBehaviourApi(f, apiName, apiFunction);\n    };\n    const revokeBehaviour = name => ({\n      key: name,\n      value: undefined\n    });\n    const doCreate = (configSchema, schemaSchema, name, active, apis, extra, state) => {\n      const getConfig = info => hasNonNullableKey(info, name) ? info[name]() : Optional.none();\n      const wrappedApis = map$1(apis, (apiF, apiName) => wrapApi(name, apiF, apiName));\n      const wrappedExtra = map$1(extra, (extraF, extraName) => markAsExtraApi(extraF, extraName));\n      const me = {\n        ...wrappedExtra,\n        ...wrappedApis,\n        revoke: curry(revokeBehaviour, name),\n        config: spec => {\n          const prepared = asRawOrDie$1(name + '-config', configSchema, spec);\n          return {\n            key: name,\n            value: {\n              config: prepared,\n              me,\n              configAsRaw: cached(() => asRawOrDie$1(name + '-config', configSchema, spec)),\n              initialConfig: spec,\n              state\n            }\n          };\n        },\n        schema: constant$1(schemaSchema),\n        exhibit: (info, base) => {\n          return lift2(getConfig(info), get$h(active, 'exhibit'), (behaviourInfo, exhibitor) => {\n            return exhibitor(base, behaviourInfo.config, behaviourInfo.state);\n          }).getOrThunk(() => nu$8({}));\n        },\n        name: constant$1(name),\n        handlers: info => {\n          return getConfig(info).map(behaviourInfo => {\n            const getEvents = get$h(active, 'events').getOr(() => ({}));\n            return getEvents(behaviourInfo.config, behaviourInfo.state);\n          }).getOr({});\n        }\n      };\n      return me;\n    };\n\n    const NoState = { init: () => nu$7({ readState: constant$1('No State required') }) };\n    const nu$7 = spec => spec;\n\n    const derive$1 = capabilities => wrapAll(capabilities);\n    const simpleSchema = objOfOnly([\n      required$1('fields'),\n      required$1('name'),\n      defaulted('active', {}),\n      defaulted('apis', {}),\n      defaulted('state', NoState),\n      defaulted('extra', {})\n    ]);\n    const create$4 = data => {\n      const value = asRawOrDie$1('Creating behaviour: ' + data.name, simpleSchema, data);\n      return create$5(value.fields, value.name, value.active, value.apis, value.extra, value.state);\n    };\n    const modeSchema = objOfOnly([\n      required$1('branchKey'),\n      required$1('branches'),\n      required$1('name'),\n      defaulted('active', {}),\n      defaulted('apis', {}),\n      defaulted('state', NoState),\n      defaulted('extra', {})\n    ]);\n    const createModes = data => {\n      const value = asRawOrDie$1('Creating behaviour: ' + data.name, modeSchema, data);\n      return createModes$1(choose$1(value.branchKey, value.branches), value.name, value.active, value.apis, value.extra, value.state);\n    };\n    const revoke = constant$1(undefined);\n\n    const read$1 = (element, attr) => {\n      const value = get$g(element, attr);\n      return value === undefined || value === '' ? [] : value.split(' ');\n    };\n    const add$4 = (element, attr, id) => {\n      const old = read$1(element, attr);\n      const nu = old.concat([id]);\n      set$9(element, attr, nu.join(' '));\n      return true;\n    };\n    const remove$5 = (element, attr, id) => {\n      const nu = filter$2(read$1(element, attr), v => v !== id);\n      if (nu.length > 0) {\n        set$9(element, attr, nu.join(' '));\n      } else {\n        remove$8(element, attr);\n      }\n      return false;\n    };\n\n    const supports = element => element.dom.classList !== undefined;\n    const get$a = element => read$1(element, 'class');\n    const add$3 = (element, clazz) => add$4(element, 'class', clazz);\n    const remove$4 = (element, clazz) => remove$5(element, 'class', clazz);\n    const toggle$5 = (element, clazz) => {\n      if (contains$2(get$a(element), clazz)) {\n        return remove$4(element, clazz);\n      } else {\n        return add$3(element, clazz);\n      }\n    };\n\n    const add$2 = (element, clazz) => {\n      if (supports(element)) {\n        element.dom.classList.add(clazz);\n      } else {\n        add$3(element, clazz);\n      }\n    };\n    const cleanClass = element => {\n      const classList = supports(element) ? element.dom.classList : get$a(element);\n      if (classList.length === 0) {\n        remove$8(element, 'class');\n      }\n    };\n    const remove$3 = (element, clazz) => {\n      if (supports(element)) {\n        const classList = element.dom.classList;\n        classList.remove(clazz);\n      } else {\n        remove$4(element, clazz);\n      }\n      cleanClass(element);\n    };\n    const toggle$4 = (element, clazz) => {\n      const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$5(element, clazz);\n      cleanClass(element);\n      return result;\n    };\n    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n\n    const add$1 = (element, classes) => {\n      each$1(classes, x => {\n        add$2(element, x);\n      });\n    };\n    const remove$2 = (element, classes) => {\n      each$1(classes, x => {\n        remove$3(element, x);\n      });\n    };\n    const toggle$3 = (element, classes) => {\n      each$1(classes, x => {\n        toggle$4(element, x);\n      });\n    };\n    const hasAll = (element, classes) => forall(classes, clazz => has(element, clazz));\n    const getNative = element => {\n      const classList = element.dom.classList;\n      const r = new Array(classList.length);\n      for (let i = 0; i < classList.length; i++) {\n        const item = classList.item(i);\n        if (item !== null) {\n          r[i] = item;\n        }\n      }\n      return r;\n    };\n    const get$9 = element => supports(element) ? getNative(element) : get$a(element);\n\n    const NuPositionCss = (position, left, top, right, bottom) => {\n      const toPx = num => num + 'px';\n      return {\n        position,\n        left: left.map(toPx),\n        top: top.map(toPx),\n        right: right.map(toPx),\n        bottom: bottom.map(toPx)\n      };\n    };\n    const toOptions = position => ({\n      ...position,\n      position: Optional.some(position.position)\n    });\n    const applyPositionCss = (element, position) => {\n      setOptions(element, toOptions(position));\n    };\n\n    const getOffsetParent = element => {\n      const isFixed = is$1(getRaw(element, 'position'), 'fixed');\n      const offsetParent$1 = isFixed ? Optional.none() : offsetParent(element);\n      return offsetParent$1.orThunk(() => {\n        const marker = SugarElement.fromTag('span');\n        return parent(element).bind(parent => {\n          append$2(parent, marker);\n          const offsetParent$1 = offsetParent(marker);\n          remove$6(marker);\n          return offsetParent$1;\n        });\n      });\n    };\n    const getOrigin = element => getOffsetParent(element).map(absolute$3).getOrThunk(() => SugarPosition(0, 0));\n\n    const appear = (component, contextualInfo) => {\n      const elem = component.element;\n      add$2(elem, contextualInfo.transitionClass);\n      remove$3(elem, contextualInfo.fadeOutClass);\n      add$2(elem, contextualInfo.fadeInClass);\n      contextualInfo.onShow(component);\n    };\n    const disappear = (component, contextualInfo) => {\n      const elem = component.element;\n      add$2(elem, contextualInfo.transitionClass);\n      remove$3(elem, contextualInfo.fadeInClass);\n      add$2(elem, contextualInfo.fadeOutClass);\n      contextualInfo.onHide(component);\n    };\n    const isPartiallyVisible = (box, bounds) => box.y < bounds.bottom && box.bottom > bounds.y;\n    const isTopCompletelyVisible = (box, bounds) => box.y >= bounds.y;\n    const isBottomCompletelyVisible = (box, bounds) => box.bottom <= bounds.bottom;\n    const forceTopPosition = (winBox, leftX, viewport) => ({\n      location: 'top',\n      leftX,\n      topY: viewport.bounds.y - winBox.y\n    });\n    const forceBottomPosition = (winBox, leftX, viewport) => ({\n      location: 'bottom',\n      leftX,\n      bottomY: winBox.bottom - viewport.bounds.bottom\n    });\n    const getDockedLeftPosition = bounds => {\n      return bounds.box.x - bounds.win.x;\n    };\n    const tryDockingPosition = (modes, bounds, viewport) => {\n      const winBox = bounds.win;\n      const box = bounds.box;\n      const leftX = getDockedLeftPosition(bounds);\n      return findMap(modes, mode => {\n        switch (mode) {\n        case 'bottom':\n          return !isBottomCompletelyVisible(box, viewport.bounds) ? Optional.some(forceBottomPosition(winBox, leftX, viewport)) : Optional.none();\n        case 'top':\n          return !isTopCompletelyVisible(box, viewport.bounds) ? Optional.some(forceTopPosition(winBox, leftX, viewport)) : Optional.none();\n        default:\n          return Optional.none();\n        }\n      }).getOr({ location: 'no-dock' });\n    };\n    const isVisibleForModes = (modes, box, viewport) => forall(modes, mode => {\n      switch (mode) {\n      case 'bottom':\n        return isBottomCompletelyVisible(box, viewport.bounds);\n      case 'top':\n        return isTopCompletelyVisible(box, viewport.bounds);\n      }\n    });\n    const getXYForRestoring = (pos, viewport) => {\n      const priorY = viewport.optScrollEnv.fold(constant$1(pos.bounds.y), scrollEnv => scrollEnv.scrollElmTop + (pos.bounds.y - scrollEnv.currentScrollTop));\n      return SugarPosition(pos.bounds.x, priorY);\n    };\n    const getXYForSaving = (box, viewport) => {\n      const priorY = viewport.optScrollEnv.fold(constant$1(box.y), scrollEnv => box.y + scrollEnv.currentScrollTop - scrollEnv.scrollElmTop);\n      return SugarPosition(box.x, priorY);\n    };\n    const getPrior = (elem, viewport, state) => state.getInitialPos().map(pos => {\n      const xy = getXYForRestoring(pos, viewport);\n      return {\n        box: bounds(xy.left, xy.top, get$d(elem), get$e(elem)),\n        location: pos.location\n      };\n    });\n    const storePrior = (elem, box, viewport, state, decision) => {\n      const xy = getXYForSaving(box, viewport);\n      const bounds$1 = bounds(xy.left, xy.top, box.width, box.height);\n      state.setInitialPos({\n        style: getAllRaw(elem),\n        position: get$f(elem, 'position') || 'static',\n        bounds: bounds$1,\n        location: decision.location\n      });\n    };\n    const storePriorIfNone = (elem, box, viewport, state, decision) => {\n      state.getInitialPos().fold(() => storePrior(elem, box, viewport, state, decision), () => noop);\n    };\n    const revertToOriginal = (elem, box, state) => state.getInitialPos().bind(position => {\n      var _a;\n      state.clearInitialPos();\n      switch (position.position) {\n      case 'static':\n        return Optional.some({ morph: 'static' });\n      case 'absolute':\n        const offsetParent = getOffsetParent(elem).getOr(body());\n        const offsetBox = box$1(offsetParent);\n        const scrollDelta = (_a = offsetParent.dom.scrollTop) !== null && _a !== void 0 ? _a : 0;\n        return Optional.some({\n          morph: 'absolute',\n          positionCss: NuPositionCss('absolute', get$h(position.style, 'left').map(_left => box.x - offsetBox.x), get$h(position.style, 'top').map(_top => box.y - offsetBox.y + scrollDelta), get$h(position.style, 'right').map(_right => offsetBox.right - box.right), get$h(position.style, 'bottom').map(_bottom => offsetBox.bottom - box.bottom))\n        });\n      default:\n        return Optional.none();\n      }\n    });\n    const tryMorphToOriginal = (elem, viewport, state) => getPrior(elem, viewport, state).filter(({box}) => isVisibleForModes(state.getModes(), box, viewport)).bind(({box}) => revertToOriginal(elem, box, state));\n    const tryDecisionToFixedMorph = decision => {\n      switch (decision.location) {\n      case 'top': {\n          return Optional.some({\n            morph: 'fixed',\n            positionCss: NuPositionCss('fixed', Optional.some(decision.leftX), Optional.some(decision.topY), Optional.none(), Optional.none())\n          });\n        }\n      case 'bottom': {\n          return Optional.some({\n            morph: 'fixed',\n            positionCss: NuPositionCss('fixed', Optional.some(decision.leftX), Optional.none(), Optional.none(), Optional.some(decision.bottomY))\n          });\n        }\n      default:\n        return Optional.none();\n      }\n    };\n    const tryMorphToFixed = (elem, viewport, state) => {\n      const box = box$1(elem);\n      const winBox = win();\n      const decision = tryDockingPosition(state.getModes(), {\n        win: winBox,\n        box\n      }, viewport);\n      if (decision.location === 'top' || decision.location === 'bottom') {\n        storePrior(elem, box, viewport, state, decision);\n        return tryDecisionToFixedMorph(decision);\n      } else {\n        return Optional.none();\n      }\n    };\n    const tryMorphToOriginalOrUpdateFixed = (elem, viewport, state) => {\n      return tryMorphToOriginal(elem, viewport, state).orThunk(() => {\n        return viewport.optScrollEnv.bind(_ => getPrior(elem, viewport, state)).bind(({box, location}) => {\n          const winBox = win();\n          const leftX = getDockedLeftPosition({\n            win: winBox,\n            box\n          });\n          const decision = location === 'top' ? forceTopPosition(winBox, leftX, viewport) : forceBottomPosition(winBox, leftX, viewport);\n          return tryDecisionToFixedMorph(decision);\n        });\n      });\n    };\n    const tryMorph = (component, viewport, state) => {\n      const elem = component.element;\n      const isDocked = is$1(getRaw(elem, 'position'), 'fixed');\n      return isDocked ? tryMorphToOriginalOrUpdateFixed(elem, viewport, state) : tryMorphToFixed(elem, viewport, state);\n    };\n    const calculateMorphToOriginal = (component, viewport, state) => {\n      const elem = component.element;\n      return getPrior(elem, viewport, state).bind(({box}) => revertToOriginal(elem, box, state));\n    };\n    const forceDockWith = (elem, viewport, state, getDecision) => {\n      const box = box$1(elem);\n      const winBox = win();\n      const leftX = getDockedLeftPosition({\n        win: winBox,\n        box\n      });\n      const decision = getDecision(winBox, leftX, viewport);\n      if (decision.location === 'bottom' || decision.location === 'top') {\n        storePriorIfNone(elem, box, viewport, state, decision);\n        return tryDecisionToFixedMorph(decision);\n      } else {\n        return Optional.none();\n      }\n    };\n\n    const morphToStatic = (component, config, state) => {\n      state.setDocked(false);\n      each$1([\n        'left',\n        'right',\n        'top',\n        'bottom',\n        'position'\n      ], prop => remove$7(component.element, prop));\n      config.onUndocked(component);\n    };\n    const morphToCoord = (component, config, state, position) => {\n      const isDocked = position.position === 'fixed';\n      state.setDocked(isDocked);\n      applyPositionCss(component.element, position);\n      const method = isDocked ? config.onDocked : config.onUndocked;\n      method(component);\n    };\n    const updateVisibility = (component, config, state, viewport, morphToDocked = false) => {\n      config.contextual.each(contextInfo => {\n        contextInfo.lazyContext(component).each(box => {\n          const isVisible = isPartiallyVisible(box, viewport.bounds);\n          if (isVisible !== state.isVisible()) {\n            state.setVisible(isVisible);\n            if (morphToDocked && !isVisible) {\n              add$1(component.element, [contextInfo.fadeOutClass]);\n              contextInfo.onHide(component);\n            } else {\n              const method = isVisible ? appear : disappear;\n              method(component, contextInfo);\n            }\n          }\n        });\n      });\n    };\n    const applyFixedMorph = (component, config, state, viewport, morph) => {\n      updateVisibility(component, config, state, viewport, true);\n      morphToCoord(component, config, state, morph.positionCss);\n    };\n    const applyMorph = (component, config, state, viewport, morph) => {\n      switch (morph.morph) {\n      case 'static': {\n          return morphToStatic(component, config, state);\n        }\n      case 'absolute': {\n          return morphToCoord(component, config, state, morph.positionCss);\n        }\n      case 'fixed': {\n          return applyFixedMorph(component, config, state, viewport, morph);\n        }\n      }\n    };\n    const refreshInternal = (component, config, state) => {\n      const viewport = config.lazyViewport(component);\n      updateVisibility(component, config, state, viewport);\n      tryMorph(component, viewport, state).each(morph => {\n        applyMorph(component, config, state, viewport, morph);\n      });\n    };\n    const resetInternal = (component, config, state) => {\n      const elem = component.element;\n      state.setDocked(false);\n      const viewport = config.lazyViewport(component);\n      calculateMorphToOriginal(component, viewport, state).each(staticOrAbsoluteMorph => {\n        switch (staticOrAbsoluteMorph.morph) {\n        case 'static': {\n            morphToStatic(component, config, state);\n            break;\n          }\n        case 'absolute': {\n            morphToCoord(component, config, state, staticOrAbsoluteMorph.positionCss);\n            break;\n          }\n        }\n      });\n      state.setVisible(true);\n      config.contextual.each(contextInfo => {\n        remove$2(elem, [\n          contextInfo.fadeInClass,\n          contextInfo.fadeOutClass,\n          contextInfo.transitionClass\n        ]);\n        contextInfo.onShow(component);\n      });\n      refresh$4(component, config, state);\n    };\n    const refresh$4 = (component, config, state) => {\n      if (component.getSystem().isConnected()) {\n        refreshInternal(component, config, state);\n      }\n    };\n    const reset$2 = (component, config, state) => {\n      if (state.isDocked()) {\n        resetInternal(component, config, state);\n      }\n    };\n    const forceDockWithDecision = getDecision => (component, config, state) => {\n      const viewport = config.lazyViewport(component);\n      const optMorph = forceDockWith(component.element, viewport, state, getDecision);\n      optMorph.each(morph => {\n        applyFixedMorph(component, config, state, viewport, morph);\n      });\n    };\n    const forceDockToTop = forceDockWithDecision(forceTopPosition);\n    const forceDockToBottom = forceDockWithDecision(forceBottomPosition);\n    const isDocked$2 = (component, config, state) => state.isDocked();\n    const setModes = (component, config, state, modes) => state.setModes(modes);\n    const getModes = (component, config, state) => state.getModes();\n\n    var DockingApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        refresh: refresh$4,\n        reset: reset$2,\n        isDocked: isDocked$2,\n        getModes: getModes,\n        setModes: setModes,\n        forceDockToTop: forceDockToTop,\n        forceDockToBottom: forceDockToBottom\n    });\n\n    const events$i = (dockInfo, dockState) => derive$2([\n      runOnSource(transitionend(), (component, simulatedEvent) => {\n        dockInfo.contextual.each(contextInfo => {\n          if (has(component.element, contextInfo.transitionClass)) {\n            remove$2(component.element, [\n              contextInfo.transitionClass,\n              contextInfo.fadeInClass\n            ]);\n            const notify = dockState.isVisible() ? contextInfo.onShown : contextInfo.onHidden;\n            notify(component);\n          }\n          simulatedEvent.stop();\n        });\n      }),\n      run$1(windowScroll(), (component, _) => {\n        refresh$4(component, dockInfo, dockState);\n      }),\n      run$1(externalElementScroll(), (component, _) => {\n        refresh$4(component, dockInfo, dockState);\n      }),\n      run$1(windowResize(), (component, _) => {\n        reset$2(component, dockInfo, dockState);\n      })\n    ]);\n\n    var ActiveDocking = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        events: events$i\n    });\n\n    const fromHtml$1 = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      return children(SugarElement.fromDom(div));\n    };\n\n    const get$8 = element => element.dom.innerHTML;\n    const set$6 = (element, content) => {\n      const owner = owner$4(element);\n      const docDom = owner.dom;\n      const fragment = SugarElement.fromDom(docDom.createDocumentFragment());\n      const contentElements = fromHtml$1(content, docDom);\n      append$1(fragment, contentElements);\n      empty(element);\n      append$2(element, fragment);\n    };\n    const getOuter = element => {\n      const container = SugarElement.fromTag('div');\n      const clone = SugarElement.fromDom(element.dom.cloneNode(true));\n      append$2(container, clone);\n      return get$8(container);\n    };\n\n    const clone$1 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    const shallow = original => clone$1(original, false);\n    const deep = original => clone$1(original, true);\n\n    const getHtml = element => {\n      if (isShadowRoot(element)) {\n        return '#shadow-root';\n      } else {\n        const clone = shallow(element);\n        return getOuter(clone);\n      }\n    };\n\n    const element = elem => getHtml(elem);\n\n    const unknown = 'unknown';\n    var EventConfiguration;\n    (function (EventConfiguration) {\n      EventConfiguration[EventConfiguration['STOP'] = 0] = 'STOP';\n      EventConfiguration[EventConfiguration['NORMAL'] = 1] = 'NORMAL';\n      EventConfiguration[EventConfiguration['LOGGING'] = 2] = 'LOGGING';\n    }(EventConfiguration || (EventConfiguration = {})));\n    const eventConfig = Cell({});\n    const makeEventLogger = (eventName, initialTarget) => {\n      const sequence = [];\n      const startTime = new Date().getTime();\n      return {\n        logEventCut: (_name, target, purpose) => {\n          sequence.push({\n            outcome: 'cut',\n            target,\n            purpose\n          });\n        },\n        logEventStopped: (_name, target, purpose) => {\n          sequence.push({\n            outcome: 'stopped',\n            target,\n            purpose\n          });\n        },\n        logNoParent: (_name, target, purpose) => {\n          sequence.push({\n            outcome: 'no-parent',\n            target,\n            purpose\n          });\n        },\n        logEventNoHandlers: (_name, target) => {\n          sequence.push({\n            outcome: 'no-handlers-left',\n            target\n          });\n        },\n        logEventResponse: (_name, target, purpose) => {\n          sequence.push({\n            outcome: 'response',\n            purpose,\n            target\n          });\n        },\n        write: () => {\n          const finishTime = new Date().getTime();\n          if (contains$2([\n              'mousemove',\n              'mouseover',\n              'mouseout',\n              systemInit()\n            ], eventName)) {\n            return;\n          }\n          console.log(eventName, {\n            event: eventName,\n            time: finishTime - startTime,\n            target: initialTarget.dom,\n            sequence: map$2(sequence, s => {\n              if (!contains$2([\n                  'cut',\n                  'stopped',\n                  'response'\n                ], s.outcome)) {\n                return s.outcome;\n              } else {\n                return '{' + s.purpose + '} ' + s.outcome + ' at (' + element(s.target) + ')';\n              }\n            })\n          });\n        }\n      };\n    };\n    const processEvent = (eventName, initialTarget, f) => {\n      const status = get$h(eventConfig.get(), eventName).orThunk(() => {\n        const patterns = keys(eventConfig.get());\n        return findMap(patterns, p => eventName.indexOf(p) > -1 ? Optional.some(eventConfig.get()[p]) : Optional.none());\n      }).getOr(EventConfiguration.NORMAL);\n      switch (status) {\n      case EventConfiguration.NORMAL:\n        return f(noLogger());\n      case EventConfiguration.LOGGING: {\n          const logger = makeEventLogger(eventName, initialTarget);\n          const output = f(logger);\n          logger.write();\n          return output;\n        }\n      case EventConfiguration.STOP:\n        return true;\n      }\n    };\n    const path = [\n      'alloy/data/Fields',\n      'alloy/debugging/Debugging'\n    ];\n    const getTrace = () => {\n      const err = new Error();\n      if (err.stack !== undefined) {\n        const lines = err.stack.split('\\n');\n        return find$5(lines, line => line.indexOf('alloy') > 0 && !exists(path, p => line.indexOf(p) > -1)).getOr(unknown);\n      } else {\n        return unknown;\n      }\n    };\n    const ignoreEvent = {\n      logEventCut: noop,\n      logEventStopped: noop,\n      logNoParent: noop,\n      logEventNoHandlers: noop,\n      logEventResponse: noop,\n      write: noop\n    };\n    const monitorEvent = (eventName, initialTarget, f) => processEvent(eventName, initialTarget, f);\n    const noLogger = constant$1(ignoreEvent);\n\n    const menuFields = constant$1([\n      required$1('menu'),\n      required$1('selectedMenu')\n    ]);\n    const itemFields = constant$1([\n      required$1('item'),\n      required$1('selectedItem')\n    ]);\n    constant$1(objOf(itemFields().concat(menuFields())));\n    const itemSchema$3 = constant$1(objOf(itemFields()));\n\n    const _initSize = requiredObjOf('initSize', [\n      required$1('numColumns'),\n      required$1('numRows')\n    ]);\n    const itemMarkers = () => requiredOf('markers', itemSchema$3());\n    const tieredMenuMarkers = () => requiredObjOf('markers', [required$1('backgroundMenu')].concat(menuFields()).concat(itemFields()));\n    const markers$1 = required => requiredObjOf('markers', map$2(required, required$1));\n    const onPresenceHandler = (label, fieldName, presence) => {\n      getTrace();\n      return field$1(fieldName, fieldName, presence, valueOf(f => Result.value((...args) => {\n        return f.apply(undefined, args);\n      })));\n    };\n    const onHandler = fieldName => onPresenceHandler('onHandler', fieldName, defaulted$1(noop));\n    const onKeyboardHandler = fieldName => onPresenceHandler('onKeyboardHandler', fieldName, defaulted$1(Optional.none));\n    const onStrictHandler = fieldName => onPresenceHandler('onHandler', fieldName, required$2());\n    const onStrictKeyboardHandler = fieldName => onPresenceHandler('onKeyboardHandler', fieldName, required$2());\n    const output$1 = (name, value) => customField(name, constant$1(value));\n    const snapshot = name => customField(name, identity);\n    const initSize = constant$1(_initSize);\n\n    var DockingSchema = [\n      optionObjOf('contextual', [\n        requiredString('fadeInClass'),\n        requiredString('fadeOutClass'),\n        requiredString('transitionClass'),\n        requiredFunction('lazyContext'),\n        onHandler('onShow'),\n        onHandler('onShown'),\n        onHandler('onHide'),\n        onHandler('onHidden')\n      ]),\n      defaultedFunction('lazyViewport', () => ({\n        bounds: win(),\n        optScrollEnv: Optional.none()\n      })),\n      defaultedArrayOf('modes', [\n        'top',\n        'bottom'\n      ], string),\n      onHandler('onDocked'),\n      onHandler('onUndocked')\n    ];\n\n    const init$g = spec => {\n      const docked = Cell(false);\n      const visible = Cell(true);\n      const initialBounds = value$4();\n      const modes = Cell(spec.modes);\n      const readState = () => `docked:  ${ docked.get() }, visible: ${ visible.get() }, modes: ${ modes.get().join(',') }`;\n      return nu$7({\n        isDocked: docked.get,\n        setDocked: docked.set,\n        getInitialPos: initialBounds.get,\n        setInitialPos: initialBounds.set,\n        clearInitialPos: initialBounds.clear,\n        isVisible: visible.get,\n        setVisible: visible.set,\n        getModes: modes.get,\n        setModes: modes.set,\n        readState\n      });\n    };\n\n    var DockingState = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        init: init$g\n    });\n\n    const Docking = create$4({\n      fields: DockingSchema,\n      name: 'docking',\n      active: ActiveDocking,\n      apis: DockingApis,\n      state: DockingState\n    });\n\n    const isRecursive = (component, originator, target) => eq(originator, component.element) && !eq(originator, target);\n    const events$h = derive$2([can(focus$4(), (component, simulatedEvent) => {\n        const event = simulatedEvent.event;\n        const originator = event.originator;\n        const target = event.target;\n        if (isRecursive(component, originator, target)) {\n          console.warn(focus$4() + ' did not get interpreted by the desired target. ' + '\\nOriginator: ' + element(originator) + '\\nTarget: ' + element(target) + '\\nCheck the ' + focus$4() + ' event handlers');\n          return false;\n        } else {\n          return true;\n        }\n      })]);\n\n    var DefaultEvents = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        events: events$h\n    });\n\n    let unique = 0;\n    const generate$6 = prefix => {\n      const date = new Date();\n      const time = date.getTime();\n      const random = Math.floor(Math.random() * 1000000000);\n      unique++;\n      return prefix + '_' + random + unique + String(time);\n    };\n\n    const prefix$1 = constant$1('alloy-id-');\n    const idAttr$1 = constant$1('data-alloy-id');\n\n    const prefix = prefix$1();\n    const idAttr = idAttr$1();\n    const write = (label, elem) => {\n      const id = generate$6(prefix + label);\n      writeOnly(elem, id);\n      return id;\n    };\n    const writeOnly = (elem, uid) => {\n      Object.defineProperty(elem.dom, idAttr, {\n        value: uid,\n        writable: true\n      });\n    };\n    const read = elem => {\n      const id = isElement$1(elem) ? elem.dom[idAttr] : null;\n      return Optional.from(id);\n    };\n    const generate$5 = prefix => generate$6(prefix);\n\n    const make$8 = identity;\n\n    const NoContextApi = getComp => {\n      const getMessage = event => `The component must be in a context to execute: ${ event }` + (getComp ? '\\n' + element(getComp().element) + ' is not in context.' : '');\n      const fail = event => () => {\n        throw new Error(getMessage(event));\n      };\n      const warn = event => () => {\n        console.warn(getMessage(event));\n      };\n      return {\n        debugInfo: constant$1('fake'),\n        triggerEvent: warn('triggerEvent'),\n        triggerFocus: warn('triggerFocus'),\n        triggerEscape: warn('triggerEscape'),\n        broadcast: warn('broadcast'),\n        broadcastOn: warn('broadcastOn'),\n        broadcastEvent: warn('broadcastEvent'),\n        build: fail('build'),\n        buildOrPatch: fail('buildOrPatch'),\n        addToWorld: fail('addToWorld'),\n        removeFromWorld: fail('removeFromWorld'),\n        addToGui: fail('addToGui'),\n        removeFromGui: fail('removeFromGui'),\n        getByUid: fail('getByUid'),\n        getByDom: fail('getByDom'),\n        isConnected: never\n      };\n    };\n    const singleton = NoContextApi();\n\n    const premadeTag = generate$6('alloy-premade');\n    const premade$1 = comp => {\n      Object.defineProperty(comp.element.dom, premadeTag, {\n        value: comp.uid,\n        writable: true\n      });\n      return wrap$1(premadeTag, comp);\n    };\n    const isPremade = element => has$2(element.dom, premadeTag);\n    const getPremade = spec => get$h(spec, premadeTag);\n    const makeApi = f => markAsSketchApi((component, ...rest) => f(component.getApis(), component, ...rest), f);\n\n    const generateFrom$1 = (spec, all) => {\n      const schema = map$2(all, a => optionObjOf(a.name(), [\n        required$1('config'),\n        defaulted('state', NoState)\n      ]));\n      const validated = asRaw('component.behaviours', objOf(schema), spec.behaviours).fold(errInfo => {\n        throw new Error(formatError(errInfo) + '\\nComplete spec:\\n' + JSON.stringify(spec, null, 2));\n      }, identity);\n      return {\n        list: all,\n        data: map$1(validated, optBlobThunk => {\n          const output = optBlobThunk.map(blob => ({\n            config: blob.config,\n            state: blob.state.init(blob.config)\n          }));\n          return constant$1(output);\n        })\n      };\n    };\n    const getBehaviours$3 = bData => bData.list;\n    const getData$2 = bData => bData.data;\n\n    const byInnerKey = (data, tuple) => {\n      const r = {};\n      each(data, (detail, key) => {\n        each(detail, (value, indexKey) => {\n          const chain = get$h(r, indexKey).getOr([]);\n          r[indexKey] = chain.concat([tuple(key, value)]);\n        });\n      });\n      return r;\n    };\n\n    const combine$2 = (info, baseMod, behaviours, base) => {\n      const modsByBehaviour = { ...baseMod };\n      each$1(behaviours, behaviour => {\n        modsByBehaviour[behaviour.name()] = behaviour.exhibit(info, base);\n      });\n      const byAspect = byInnerKey(modsByBehaviour, (name, modification) => ({\n        name,\n        modification\n      }));\n      const combineObjects = objects => foldr(objects, (b, a) => ({\n        ...a.modification,\n        ...b\n      }), {});\n      const combinedClasses = foldr(byAspect.classes, (b, a) => a.modification.concat(b), []);\n      const combinedAttributes = combineObjects(byAspect.attributes);\n      const combinedStyles = combineObjects(byAspect.styles);\n      return nu$8({\n        classes: combinedClasses,\n        attributes: combinedAttributes,\n        styles: combinedStyles\n      });\n    };\n\n    const sortKeys = (label, keyName, array, order) => {\n      try {\n        const sorted = sort(array, (a, b) => {\n          const aKey = a[keyName];\n          const bKey = b[keyName];\n          const aIndex = order.indexOf(aKey);\n          const bIndex = order.indexOf(bKey);\n          if (aIndex === -1) {\n            throw new Error('The ordering for ' + label + ' does not have an entry for ' + aKey + '.\\nOrder specified: ' + JSON.stringify(order, null, 2));\n          }\n          if (bIndex === -1) {\n            throw new Error('The ordering for ' + label + ' does not have an entry for ' + bKey + '.\\nOrder specified: ' + JSON.stringify(order, null, 2));\n          }\n          if (aIndex < bIndex) {\n            return -1;\n          } else if (bIndex < aIndex) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n        return Result.value(sorted);\n      } catch (err) {\n        return Result.error([err]);\n      }\n    };\n\n    const uncurried = (handler, purpose) => ({\n      handler,\n      purpose\n    });\n    const curried = (handler, purpose) => ({\n      cHandler: handler,\n      purpose\n    });\n    const curryArgs = (descHandler, extraArgs) => curried(curry.apply(undefined, [descHandler.handler].concat(extraArgs)), descHandler.purpose);\n    const getCurried = descHandler => descHandler.cHandler;\n\n    const behaviourTuple = (name, handler) => ({\n      name,\n      handler\n    });\n    const nameToHandlers = (behaviours, info) => {\n      const r = {};\n      each$1(behaviours, behaviour => {\n        r[behaviour.name()] = behaviour.handlers(info);\n      });\n      return r;\n    };\n    const groupByEvents = (info, behaviours, base) => {\n      const behaviourEvents = {\n        ...base,\n        ...nameToHandlers(behaviours, info)\n      };\n      return byInnerKey(behaviourEvents, behaviourTuple);\n    };\n    const combine$1 = (info, eventOrder, behaviours, base) => {\n      const byEventName = groupByEvents(info, behaviours, base);\n      return combineGroups(byEventName, eventOrder);\n    };\n    const assemble = rawHandler => {\n      const handler = read$2(rawHandler);\n      return (component, simulatedEvent, ...rest) => {\n        const args = [\n          component,\n          simulatedEvent\n        ].concat(rest);\n        if (handler.abort.apply(undefined, args)) {\n          simulatedEvent.stop();\n        } else if (handler.can.apply(undefined, args)) {\n          handler.run.apply(undefined, args);\n        }\n      };\n    };\n    const missingOrderError = (eventName, tuples) => Result.error(['The event (' + eventName + ') has more than one behaviour that listens to it.\\nWhen this occurs, you must ' + 'specify an event ordering for the behaviours in your spec (e.g. [ \"listing\", \"toggling\" ]).\\nThe behaviours that ' + 'can trigger it are: ' + JSON.stringify(map$2(tuples, c => c.name), null, 2)]);\n    const fuse = (tuples, eventOrder, eventName) => {\n      const order = eventOrder[eventName];\n      if (!order) {\n        return missingOrderError(eventName, tuples);\n      } else {\n        return sortKeys('Event: ' + eventName, 'name', tuples, order).map(sortedTuples => {\n          const handlers = map$2(sortedTuples, tuple => tuple.handler);\n          return fuse$1(handlers);\n        });\n      }\n    };\n    const combineGroups = (byEventName, eventOrder) => {\n      const r = mapToArray(byEventName, (tuples, eventName) => {\n        const combined = tuples.length === 1 ? Result.value(tuples[0].handler) : fuse(tuples, eventOrder, eventName);\n        return combined.map(handler => {\n          const assembled = assemble(handler);\n          const purpose = tuples.length > 1 ? filter$2(eventOrder[eventName], o => exists(tuples, t => t.name === o)).join(' > ') : tuples[0].name;\n          return wrap$1(eventName, uncurried(assembled, purpose));\n        });\n      });\n      return consolidate(r, {});\n    };\n\n    const baseBehaviour = 'alloy.base.behaviour';\n    const schema$z = objOf([\n      field$1('dom', 'dom', required$2(), objOf([\n        required$1('tag'),\n        defaulted('styles', {}),\n        defaulted('classes', []),\n        defaulted('attributes', {}),\n        option$3('value'),\n        option$3('innerHtml')\n      ])),\n      required$1('components'),\n      required$1('uid'),\n      defaulted('events', {}),\n      defaulted('apis', {}),\n      field$1('eventOrder', 'eventOrder', mergeWith({\n        [execute$5()]: [\n          'disabling',\n          baseBehaviour,\n          'toggling',\n          'typeaheadevents'\n        ],\n        [focus$4()]: [\n          baseBehaviour,\n          'focusing',\n          'keying'\n        ],\n        [systemInit()]: [\n          baseBehaviour,\n          'disabling',\n          'toggling',\n          'representing'\n        ],\n        [input()]: [\n          baseBehaviour,\n          'representing',\n          'streaming',\n          'invalidating'\n        ],\n        [detachedFromDom()]: [\n          baseBehaviour,\n          'representing',\n          'item-events',\n          'toolbar-button-events',\n          'tooltipping'\n        ],\n        [mousedown()]: [\n          'focusing',\n          baseBehaviour,\n          'item-type-events'\n        ],\n        [touchstart()]: [\n          'focusing',\n          baseBehaviour,\n          'item-type-events'\n        ],\n        [mouseover()]: [\n          'item-type-events',\n          'tooltipping'\n        ],\n        [receive()]: [\n          'receiving',\n          'reflecting',\n          'tooltipping'\n        ]\n      }), anyValue()),\n      option$3('domModification')\n    ]);\n    const toInfo = spec => asRaw('custom.definition', schema$z, spec);\n    const toDefinition = detail => ({\n      ...detail.dom,\n      uid: detail.uid,\n      domChildren: map$2(detail.components, comp => comp.element)\n    });\n    const toModification = detail => detail.domModification.fold(() => nu$8({}), nu$8);\n    const toEvents = info => info.events;\n\n    const get$7 = element => element.dom.value;\n    const set$5 = (element, value) => {\n      if (value === undefined) {\n        throw new Error('Value.set was undefined');\n      }\n      element.dom.value = value;\n    };\n\n    const determineObsoleted = (parent, index, oldObsoleted) => {\n      const newObsoleted = child$2(parent, index);\n      return newObsoleted.map(newObs => {\n        const elemChanged = oldObsoleted.exists(o => !eq(o, newObs));\n        if (elemChanged) {\n          const oldTag = oldObsoleted.map(name$3).getOr('span');\n          const marker = SugarElement.fromTag(oldTag);\n          before$1(newObs, marker);\n          return marker;\n        } else {\n          return newObs;\n        }\n      });\n    };\n    const ensureInDom = (parent, child, obsoleted) => {\n      obsoleted.fold(() => append$2(parent, child), obs => {\n        if (!eq(obs, child)) {\n          before$1(obs, child);\n          remove$6(obs);\n        }\n      });\n    };\n    const patchChildrenWith = (parent, nu, f) => {\n      const builtChildren = map$2(nu, f);\n      const currentChildren = children(parent);\n      each$1(currentChildren.slice(builtChildren.length), remove$6);\n      return builtChildren;\n    };\n    const patchSpecChild = (parent, index, spec, build) => {\n      const oldObsoleted = child$2(parent, index);\n      const childComp = build(spec, oldObsoleted);\n      const obsoleted = determineObsoleted(parent, index, oldObsoleted);\n      ensureInDom(parent, childComp.element, obsoleted);\n      return childComp;\n    };\n    const patchSpecChildren = (parent, specs, build) => patchChildrenWith(parent, specs, (spec, index) => patchSpecChild(parent, index, spec, build));\n    const patchDomChildren = (parent, nodes) => patchChildrenWith(parent, nodes, (node, index) => {\n      const optObsoleted = child$2(parent, index);\n      ensureInDom(parent, node, optObsoleted);\n      return node;\n    });\n\n    const diffKeyValueSet = (newObj, oldObj) => {\n      const newKeys = keys(newObj);\n      const oldKeys = keys(oldObj);\n      const toRemove = difference(oldKeys, newKeys);\n      const toSet = bifilter(newObj, (v, k) => {\n        return !has$2(oldObj, k) || v !== oldObj[k];\n      }).t;\n      return {\n        toRemove,\n        toSet\n      };\n    };\n    const reconcileToDom = (definition, obsoleted) => {\n      const {\n        class: clazz,\n        style,\n        ...existingAttributes\n      } = clone$2(obsoleted);\n      const {\n        toSet: attrsToSet,\n        toRemove: attrsToRemove\n      } = diffKeyValueSet(definition.attributes, existingAttributes);\n      const updateAttrs = () => {\n        each$1(attrsToRemove, a => remove$8(obsoleted, a));\n        setAll$1(obsoleted, attrsToSet);\n      };\n      const existingStyles = getAllRaw(obsoleted);\n      const {\n        toSet: stylesToSet,\n        toRemove: stylesToRemove\n      } = diffKeyValueSet(definition.styles, existingStyles);\n      const updateStyles = () => {\n        each$1(stylesToRemove, s => remove$7(obsoleted, s));\n        setAll(obsoleted, stylesToSet);\n      };\n      const existingClasses = get$9(obsoleted);\n      const classesToRemove = difference(existingClasses, definition.classes);\n      const classesToAdd = difference(definition.classes, existingClasses);\n      const updateClasses = () => {\n        add$1(obsoleted, classesToAdd);\n        remove$2(obsoleted, classesToRemove);\n      };\n      const updateHtml = html => {\n        set$6(obsoleted, html);\n      };\n      const updateChildren = () => {\n        const children = definition.domChildren;\n        patchDomChildren(obsoleted, children);\n      };\n      const updateValue = () => {\n        const valueElement = obsoleted;\n        const value = definition.value.getOrUndefined();\n        if (value !== get$7(valueElement)) {\n          set$5(valueElement, value !== null && value !== void 0 ? value : '');\n        }\n      };\n      updateAttrs();\n      updateClasses();\n      updateStyles();\n      definition.innerHtml.fold(updateChildren, updateHtml);\n      updateValue();\n      return obsoleted;\n    };\n\n    const introduceToDom = definition => {\n      const subject = SugarElement.fromTag(definition.tag);\n      setAll$1(subject, definition.attributes);\n      add$1(subject, definition.classes);\n      setAll(subject, definition.styles);\n      definition.innerHtml.each(html => set$6(subject, html));\n      const children = definition.domChildren;\n      append$1(subject, children);\n      definition.value.each(value => {\n        set$5(subject, value);\n      });\n      return subject;\n    };\n    const attemptPatch = (definition, obsoleted) => {\n      try {\n        const e = reconcileToDom(definition, obsoleted);\n        return Optional.some(e);\n      } catch (err) {\n        return Optional.none();\n      }\n    };\n    const hasMixedChildren = definition => definition.innerHtml.isSome() && definition.domChildren.length > 0;\n    const renderToDom = (definition, optObsoleted) => {\n      const canBePatched = candidate => name$3(candidate) === definition.tag && !hasMixedChildren(definition) && !isPremade(candidate);\n      const elem = optObsoleted.filter(canBePatched).bind(obsoleted => attemptPatch(definition, obsoleted)).getOrThunk(() => introduceToDom(definition));\n      writeOnly(elem, definition.uid);\n      return elem;\n    };\n\n    const getBehaviours$2 = spec => {\n      const behaviours = get$h(spec, 'behaviours').getOr({});\n      return bind$3(keys(behaviours), name => {\n        const behaviour = behaviours[name];\n        return isNonNullable(behaviour) ? [behaviour.me] : [];\n      });\n    };\n    const generateFrom = (spec, all) => generateFrom$1(spec, all);\n    const generate$4 = spec => {\n      const all = getBehaviours$2(spec);\n      return generateFrom(spec, all);\n    };\n\n    const getDomDefinition = (info, bList, bData) => {\n      const definition = toDefinition(info);\n      const infoModification = toModification(info);\n      const baseModification = { 'alloy.base.modification': infoModification };\n      const modification = bList.length > 0 ? combine$2(bData, baseModification, bList, definition) : infoModification;\n      return merge(definition, modification);\n    };\n    const getEvents = (info, bList, bData) => {\n      const baseEvents = { 'alloy.base.behaviour': toEvents(info) };\n      return combine$1(bData, info.eventOrder, bList, baseEvents).getOrDie();\n    };\n    const build$2 = (spec, obsoleted) => {\n      const getMe = () => me;\n      const systemApi = Cell(singleton);\n      const info = getOrDie(toInfo(spec));\n      const bBlob = generate$4(spec);\n      const bList = getBehaviours$3(bBlob);\n      const bData = getData$2(bBlob);\n      const modDefinition = getDomDefinition(info, bList, bData);\n      const item = renderToDom(modDefinition, obsoleted);\n      const events = getEvents(info, bList, bData);\n      const subcomponents = Cell(info.components);\n      const connect = newApi => {\n        systemApi.set(newApi);\n      };\n      const disconnect = () => {\n        systemApi.set(NoContextApi(getMe));\n      };\n      const syncComponents = () => {\n        const children$1 = children(item);\n        const subs = bind$3(children$1, child => systemApi.get().getByDom(child).fold(() => [], pure$2));\n        subcomponents.set(subs);\n      };\n      const config = behaviour => {\n        const b = bData;\n        const f = isFunction(b[behaviour.name()]) ? b[behaviour.name()] : () => {\n          throw new Error('Could not find ' + behaviour.name() + ' in ' + JSON.stringify(spec, null, 2));\n        };\n        return f();\n      };\n      const hasConfigured = behaviour => isFunction(bData[behaviour.name()]);\n      const getApis = () => info.apis;\n      const readState = behaviourName => bData[behaviourName]().map(b => b.state.readState()).getOr('not enabled');\n      const me = {\n        uid: spec.uid,\n        getSystem: systemApi.get,\n        config,\n        hasConfigured,\n        spec,\n        readState,\n        getApis,\n        connect,\n        disconnect,\n        element: item,\n        syncComponents,\n        components: subcomponents.get,\n        events\n      };\n      return me;\n    };\n\n    const buildSubcomponents = (spec, obsoleted) => {\n      const components = get$h(spec, 'components').getOr([]);\n      return obsoleted.fold(() => map$2(components, build$1), obs => map$2(components, (c, i) => {\n        return buildOrPatch(c, child$2(obs, i));\n      }));\n    };\n    const buildFromSpec = (userSpec, obsoleted) => {\n      const {\n        events: specEvents,\n        ...spec\n      } = make$8(userSpec);\n      const components = buildSubcomponents(spec, obsoleted);\n      const completeSpec = {\n        ...spec,\n        events: {\n          ...DefaultEvents,\n          ...specEvents\n        },\n        components\n      };\n      return Result.value(build$2(completeSpec, obsoleted));\n    };\n    const text$2 = textContent => {\n      const element = SugarElement.fromText(textContent);\n      return external$1({ element });\n    };\n    const external$1 = spec => {\n      const extSpec = asRawOrDie$1('external.component', objOfOnly([\n        required$1('element'),\n        option$3('uid')\n      ]), spec);\n      const systemApi = Cell(NoContextApi());\n      const connect = newApi => {\n        systemApi.set(newApi);\n      };\n      const disconnect = () => {\n        systemApi.set(NoContextApi(() => me));\n      };\n      const uid = extSpec.uid.getOrThunk(() => generate$5('external'));\n      writeOnly(extSpec.element, uid);\n      const me = {\n        uid,\n        getSystem: systemApi.get,\n        config: Optional.none,\n        hasConfigured: never,\n        connect,\n        disconnect,\n        getApis: () => ({}),\n        element: extSpec.element,\n        spec,\n        readState: constant$1('No state'),\n        syncComponents: noop,\n        components: constant$1([]),\n        events: {}\n      };\n      return premade$1(me);\n    };\n    const uids = generate$5;\n    const isSketchSpec$1 = spec => has$2(spec, 'uid');\n    const buildOrPatch = (spec, obsoleted) => getPremade(spec).getOrThunk(() => {\n      const userSpecWithUid = isSketchSpec$1(spec) ? spec : {\n        uid: uids(''),\n        ...spec\n      };\n      return buildFromSpec(userSpecWithUid, obsoleted).getOrDie();\n    });\n    const build$1 = spec => buildOrPatch(spec, Optional.none());\n    const premade = premade$1;\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n      if (is(scope, a)) {\n        return Optional.some(scope);\n      } else if (isFunction(isRoot) && isRoot(scope)) {\n        return Optional.none();\n      } else {\n        return ancestor(scope, a, isRoot);\n      }\n    };\n\n    const ancestor$1 = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$3 = (scope, predicate, isRoot) => {\n      const is = (s, test) => test(s);\n      return ClosestOrAncestor(is, ancestor$1, scope, predicate, isRoot);\n    };\n    const sibling$1 = (scope, predicate) => {\n      const element = scope.dom;\n      if (!element.parentNode) {\n        return Optional.none();\n      }\n      return child$1(SugarElement.fromDom(element.parentNode), x => !eq(scope, x) && predicate(x));\n    };\n    const child$1 = (scope, predicate) => {\n      const pred = node => predicate(SugarElement.fromDom(node));\n      const result = find$5(scope.dom.childNodes, pred);\n      return result.map(SugarElement.fromDom);\n    };\n    const descendant$1 = (scope, predicate) => {\n      const descend = node => {\n        for (let i = 0; i < node.childNodes.length; i++) {\n          const child = SugarElement.fromDom(node.childNodes[i]);\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(node.childNodes[i]);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope.dom);\n    };\n\n    const closest$2 = (scope, predicate, isRoot) => closest$3(scope, predicate, isRoot).isSome();\n\n    const first$1 = selector => one(selector);\n    const ancestor = (scope, selector, isRoot) => ancestor$1(scope, e => is(e, selector), isRoot);\n    const sibling = (scope, selector) => sibling$1(scope, e => is(e, selector));\n    const child = (scope, selector) => child$1(scope, e => is(e, selector));\n    const descendant = (scope, selector) => one(selector, scope);\n    const closest$1 = (scope, selector, isRoot) => {\n      const is$1 = (element, selector) => is(element, selector);\n      return ClosestOrAncestor(is$1, ancestor, scope, selector, isRoot);\n    };\n\n    const attribute = 'aria-controls';\n    const find$1 = queryElem => {\n      const dependent = closest$3(queryElem, elem => {\n        if (!isElement$1(elem)) {\n          return false;\n        }\n        const id = get$g(elem, 'id');\n        return id !== undefined && id.indexOf(attribute) > -1;\n      });\n      return dependent.bind(dep => {\n        const id = get$g(dep, 'id');\n        const dos = getRootNode(dep);\n        return descendant(dos, `[${ attribute }=\"${ id }\"]`);\n      });\n    };\n    const manager = () => {\n      const ariaId = generate$6(attribute);\n      const link = elem => {\n        set$9(elem, attribute, ariaId);\n      };\n      const unlink = elem => {\n        remove$8(elem, attribute);\n      };\n      return {\n        id: ariaId,\n        link,\n        unlink\n      };\n    };\n\n    const isAriaPartOf = (component, queryElem) => find$1(queryElem).exists(owner => isPartOf$1(component, owner));\n    const isPartOf$1 = (component, queryElem) => closest$2(queryElem, el => eq(el, component.element), never) || isAriaPartOf(component, queryElem);\n\n    const nu$6 = (x, y, bubble, direction, placement, boundsRestriction, labelPrefix, alwaysFit = false) => ({\n      x,\n      y,\n      bubble,\n      direction,\n      placement,\n      restriction: boundsRestriction,\n      label: `${ labelPrefix }-${ placement }`,\n      alwaysFit\n    });\n\n    const adt$a = Adt.generate([\n      { southeast: [] },\n      { southwest: [] },\n      { northeast: [] },\n      { northwest: [] },\n      { south: [] },\n      { north: [] },\n      { east: [] },\n      { west: [] }\n    ]);\n    const cata$2 = (subject, southeast, southwest, northeast, northwest, south, north, east, west) => subject.fold(southeast, southwest, northeast, northwest, south, north, east, west);\n    const cataVertical = (subject, south, middle, north) => subject.fold(south, south, north, north, south, north, middle, middle);\n    const cataHorizontal = (subject, east, middle, west) => subject.fold(east, west, east, west, middle, middle, east, west);\n    const southeast$3 = adt$a.southeast;\n    const southwest$3 = adt$a.southwest;\n    const northeast$3 = adt$a.northeast;\n    const northwest$3 = adt$a.northwest;\n    const south$3 = adt$a.south;\n    const north$3 = adt$a.north;\n    const east$3 = adt$a.east;\n    const west$3 = adt$a.west;\n\n    const cycleBy = (value, delta, min, max) => {\n      const r = value + delta;\n      if (r > max) {\n        return min;\n      } else if (r < min) {\n        return max;\n      } else {\n        return r;\n      }\n    };\n    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);\n\n    const getRestriction = (anchor, restriction) => {\n      switch (restriction) {\n      case 1:\n        return anchor.x;\n      case 0:\n        return anchor.x + anchor.width;\n      case 2:\n        return anchor.y;\n      case 3:\n        return anchor.y + anchor.height;\n      }\n    };\n    const boundsRestriction = (anchor, restrictions) => mapToObject([\n      'left',\n      'right',\n      'top',\n      'bottom'\n    ], dir => get$h(restrictions, dir).map(restriction => getRestriction(anchor, restriction)));\n    const adjustBounds = (bounds$1, restriction, bubbleOffset) => {\n      const applyRestriction = (dir, current) => restriction[dir].map(pos => {\n        const isVerticalAxis = dir === 'top' || dir === 'bottom';\n        const offset = isVerticalAxis ? bubbleOffset.top : bubbleOffset.left;\n        const comparator = dir === 'left' || dir === 'top' ? Math.max : Math.min;\n        const newPos = comparator(pos, current) + offset;\n        return isVerticalAxis ? clamp(newPos, bounds$1.y, bounds$1.bottom) : clamp(newPos, bounds$1.x, bounds$1.right);\n      }).getOr(current);\n      const adjustedLeft = applyRestriction('left', bounds$1.x);\n      const adjustedTop = applyRestriction('top', bounds$1.y);\n      const adjustedRight = applyRestriction('right', bounds$1.right);\n      const adjustedBottom = applyRestriction('bottom', bounds$1.bottom);\n      return bounds(adjustedLeft, adjustedTop, adjustedRight - adjustedLeft, adjustedBottom - adjustedTop);\n    };\n\n    const labelPrefix$2 = 'layout';\n    const eastX$1 = anchor => anchor.x;\n    const middleX$1 = (anchor, element) => anchor.x + anchor.width / 2 - element.width / 2;\n    const westX$1 = (anchor, element) => anchor.x + anchor.width - element.width;\n    const northY$2 = (anchor, element) => anchor.y - element.height;\n    const southY$2 = anchor => anchor.y + anchor.height;\n    const centreY$1 = (anchor, element) => anchor.y + anchor.height / 2 - element.height / 2;\n    const eastEdgeX$1 = anchor => anchor.x + anchor.width;\n    const westEdgeX$1 = (anchor, element) => anchor.x - element.width;\n    const southeast$2 = (anchor, element, bubbles) => nu$6(eastX$1(anchor), southY$2(anchor), bubbles.southeast(), southeast$3(), 'southeast', boundsRestriction(anchor, {\n      left: 1,\n      top: 3\n    }), labelPrefix$2);\n    const southwest$2 = (anchor, element, bubbles) => nu$6(westX$1(anchor, element), southY$2(anchor), bubbles.southwest(), southwest$3(), 'southwest', boundsRestriction(anchor, {\n      right: 0,\n      top: 3\n    }), labelPrefix$2);\n    const northeast$2 = (anchor, element, bubbles) => nu$6(eastX$1(anchor), northY$2(anchor, element), bubbles.northeast(), northeast$3(), 'northeast', boundsRestriction(anchor, {\n      left: 1,\n      bottom: 2\n    }), labelPrefix$2);\n    const northwest$2 = (anchor, element, bubbles) => nu$6(westX$1(anchor, element), northY$2(anchor, element), bubbles.northwest(), northwest$3(), 'northwest', boundsRestriction(anchor, {\n      right: 0,\n      bottom: 2\n    }), labelPrefix$2);\n    const north$2 = (anchor, element, bubbles) => nu$6(middleX$1(anchor, element), northY$2(anchor, element), bubbles.north(), north$3(), 'north', boundsRestriction(anchor, { bottom: 2 }), labelPrefix$2);\n    const south$2 = (anchor, element, bubbles) => nu$6(middleX$1(anchor, element), southY$2(anchor), bubbles.south(), south$3(), 'south', boundsRestriction(anchor, { top: 3 }), labelPrefix$2);\n    const east$2 = (anchor, element, bubbles) => nu$6(eastEdgeX$1(anchor), centreY$1(anchor, element), bubbles.east(), east$3(), 'east', boundsRestriction(anchor, { left: 0 }), labelPrefix$2);\n    const west$2 = (anchor, element, bubbles) => nu$6(westEdgeX$1(anchor, element), centreY$1(anchor, element), bubbles.west(), west$3(), 'west', boundsRestriction(anchor, { right: 1 }), labelPrefix$2);\n    const all$1 = () => [\n      southeast$2,\n      southwest$2,\n      northeast$2,\n      northwest$2,\n      south$2,\n      north$2,\n      east$2,\n      west$2\n    ];\n    const allRtl$1 = () => [\n      southwest$2,\n      southeast$2,\n      northwest$2,\n      northeast$2,\n      south$2,\n      north$2,\n      east$2,\n      west$2\n    ];\n    const aboveOrBelow = () => [\n      northeast$2,\n      northwest$2,\n      southeast$2,\n      southwest$2,\n      north$2,\n      south$2\n    ];\n    const aboveOrBelowRtl = () => [\n      northwest$2,\n      northeast$2,\n      southwest$2,\n      southeast$2,\n      north$2,\n      south$2\n    ];\n    const belowOrAbove = () => [\n      southeast$2,\n      southwest$2,\n      northeast$2,\n      northwest$2,\n      south$2,\n      north$2\n    ];\n    const belowOrAboveRtl = () => [\n      southwest$2,\n      southeast$2,\n      northwest$2,\n      northeast$2,\n      south$2,\n      north$2\n    ];\n\n    const chooseChannels = (channels, message) => message.universal ? channels : filter$2(channels, ch => contains$2(message.channels, ch));\n    const events$g = receiveConfig => derive$2([run$1(receive(), (component, message) => {\n        const channelMap = receiveConfig.channels;\n        const channels = keys(channelMap);\n        const receivingData = message;\n        const targetChannels = chooseChannels(channels, receivingData);\n        each$1(targetChannels, ch => {\n          const channelInfo = channelMap[ch];\n          const channelSchema = channelInfo.schema;\n          const data = asRawOrDie$1('channel[' + ch + '] data\\nReceiver: ' + element(component.element), channelSchema, receivingData.data);\n          channelInfo.onReceive(component, data);\n        });\n      })]);\n\n    var ActiveReceiving = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        events: events$g\n    });\n\n    var ReceivingSchema = [requiredOf('channels', setOf(Result.value, objOfOnly([\n        onStrictHandler('onReceive'),\n        defaulted('schema', anyValue())\n      ])))];\n\n    const Receiving = create$4({\n      fields: ReceivingSchema,\n      name: 'receiving',\n      active: ActiveReceiving\n    });\n\n    const exhibit$6 = (base, posConfig) => nu$8({\n      classes: [],\n      styles: posConfig.useFixed() ? {} : { position: 'relative' }\n    });\n\n    var ActivePosition = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        exhibit: exhibit$6\n    });\n\n    const focus$3 = (element, preventScroll = false) => element.dom.focus({ preventScroll });\n    const blur$1 = element => element.dom.blur();\n    const hasFocus = element => {\n      const root = getRootNode(element).dom;\n      return element.dom === root.activeElement;\n    };\n    const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\n    const search = element => active$1(getRootNode(element)).filter(e => element.dom.contains(e.dom));\n\n    const preserve$1 = (f, container) => {\n      const dos = getRootNode(container);\n      const refocus = active$1(dos).bind(focused => {\n        const hasFocus = elem => eq(focused, elem);\n        return hasFocus(container) ? Optional.some(container) : descendant$1(container, hasFocus);\n      });\n      const result = f(container);\n      refocus.each(oldFocus => {\n        active$1(dos).filter(newFocus => eq(newFocus, oldFocus)).fold(() => {\n          focus$3(oldFocus);\n        }, noop);\n      });\n      return result;\n    };\n\n    const adt$9 = Adt.generate([\n      { none: [] },\n      {\n        relative: [\n          'x',\n          'y',\n          'width',\n          'height'\n        ]\n      },\n      {\n        fixed: [\n          'x',\n          'y',\n          'width',\n          'height'\n        ]\n      }\n    ]);\n    const positionWithDirection = (posName, decision, x, y, width, height) => {\n      const decisionRect = decision.rect;\n      const decisionX = decisionRect.x - x;\n      const decisionY = decisionRect.y - y;\n      const decisionWidth = decisionRect.width;\n      const decisionHeight = decisionRect.height;\n      const decisionRight = width - (decisionX + decisionWidth);\n      const decisionBottom = height - (decisionY + decisionHeight);\n      const left = Optional.some(decisionX);\n      const top = Optional.some(decisionY);\n      const right = Optional.some(decisionRight);\n      const bottom = Optional.some(decisionBottom);\n      const none = Optional.none();\n      return cata$2(decision.direction, () => NuPositionCss(posName, left, top, none, none), () => NuPositionCss(posName, none, top, right, none), () => NuPositionCss(posName, left, none, none, bottom), () => NuPositionCss(posName, none, none, right, bottom), () => NuPositionCss(posName, left, top, none, none), () => NuPositionCss(posName, left, none, none, bottom), () => NuPositionCss(posName, left, top, none, none), () => NuPositionCss(posName, none, top, right, none));\n    };\n    const reposition = (origin, decision) => origin.fold(() => {\n      const decisionRect = decision.rect;\n      return NuPositionCss('absolute', Optional.some(decisionRect.x), Optional.some(decisionRect.y), Optional.none(), Optional.none());\n    }, (x, y, width, height) => {\n      return positionWithDirection('absolute', decision, x, y, width, height);\n    }, (x, y, width, height) => {\n      return positionWithDirection('fixed', decision, x, y, width, height);\n    });\n    const toBox = (origin, element) => {\n      const rel = curry(find$2, element);\n      const position = origin.fold(rel, rel, () => {\n        const scroll = get$c();\n        return find$2(element).translate(-scroll.left, -scroll.top);\n      });\n      const width = getOuter$1(element);\n      const height = getOuter$2(element);\n      return bounds(position.left, position.top, width, height);\n    };\n    const viewport = (origin, optBounds) => optBounds.fold(() => origin.fold(win, win, bounds), bounds$1 => origin.fold(constant$1(bounds$1), constant$1(bounds$1), () => {\n      const pos = translate$2(origin, bounds$1.x, bounds$1.y);\n      return bounds(pos.left, pos.top, bounds$1.width, bounds$1.height);\n    }));\n    const translate$2 = (origin, x, y) => {\n      const pos = SugarPosition(x, y);\n      const removeScroll = () => {\n        const outerScroll = get$c();\n        return pos.translate(-outerScroll.left, -outerScroll.top);\n      };\n      return origin.fold(constant$1(pos), constant$1(pos), removeScroll);\n    };\n    const cata$1 = (subject, onNone, onRelative, onFixed) => subject.fold(onNone, onRelative, onFixed);\n    adt$9.none;\n    const relative$1 = adt$9.relative;\n    const fixed$1 = adt$9.fixed;\n\n    const anchor = (anchorBox, origin) => ({\n      anchorBox,\n      origin\n    });\n    const box = (anchorBox, origin) => anchor(anchorBox, origin);\n\n    const placementAttribute = 'data-alloy-placement';\n    const setPlacement$1 = (element, placement) => {\n      set$9(element, placementAttribute, placement);\n    };\n    const getPlacement = element => getOpt(element, placementAttribute);\n    const reset$1 = element => remove$8(element, placementAttribute);\n\n    const adt$8 = Adt.generate([\n      { fit: ['reposition'] },\n      {\n        nofit: [\n          'reposition',\n          'visibleW',\n          'visibleH',\n          'isVisible'\n        ]\n      }\n    ]);\n    const determinePosition = (box, bounds) => {\n      const {\n        x: boundsX,\n        y: boundsY,\n        right: boundsRight,\n        bottom: boundsBottom\n      } = bounds;\n      const {x, y, right, bottom, width, height} = box;\n      const xInBounds = x >= boundsX && x <= boundsRight;\n      const yInBounds = y >= boundsY && y <= boundsBottom;\n      const originInBounds = xInBounds && yInBounds;\n      const rightInBounds = right <= boundsRight && right >= boundsX;\n      const bottomInBounds = bottom <= boundsBottom && bottom >= boundsY;\n      const sizeInBounds = rightInBounds && bottomInBounds;\n      const visibleW = Math.min(width, x >= boundsX ? boundsRight - x : right - boundsX);\n      const visibleH = Math.min(height, y >= boundsY ? boundsBottom - y : bottom - boundsY);\n      return {\n        originInBounds,\n        sizeInBounds,\n        visibleW,\n        visibleH\n      };\n    };\n    const calcReposition = (box, bounds$1) => {\n      const {\n        x: boundsX,\n        y: boundsY,\n        right: boundsRight,\n        bottom: boundsBottom\n      } = bounds$1;\n      const {x, y, width, height} = box;\n      const maxX = Math.max(boundsX, boundsRight - width);\n      const maxY = Math.max(boundsY, boundsBottom - height);\n      const restrictedX = clamp(x, boundsX, maxX);\n      const restrictedY = clamp(y, boundsY, maxY);\n      const restrictedWidth = Math.min(restrictedX + width, boundsRight) - restrictedX;\n      const restrictedHeight = Math.min(restrictedY + height, boundsBottom) - restrictedY;\n      return bounds(restrictedX, restrictedY, restrictedWidth, restrictedHeight);\n    };\n    const calcMaxSizes = (direction, box, bounds) => {\n      const upAvailable = constant$1(box.bottom - bounds.y);\n      const downAvailable = constant$1(bounds.bottom - box.y);\n      const maxHeight = cataVertical(direction, downAvailable, downAvailable, upAvailable);\n      const westAvailable = constant$1(box.right - bounds.x);\n      const eastAvailable = constant$1(bounds.right - box.x);\n      const maxWidth = cataHorizontal(direction, eastAvailable, eastAvailable, westAvailable);\n      return {\n        maxWidth,\n        maxHeight\n      };\n    };\n    const attempt = (candidate, width, height, bounds$1) => {\n      const bubble = candidate.bubble;\n      const bubbleOffset = bubble.offset;\n      const adjustedBounds = adjustBounds(bounds$1, candidate.restriction, bubbleOffset);\n      const newX = candidate.x + bubbleOffset.left;\n      const newY = candidate.y + bubbleOffset.top;\n      const box = bounds(newX, newY, width, height);\n      const {originInBounds, sizeInBounds, visibleW, visibleH} = determinePosition(box, adjustedBounds);\n      const fits = originInBounds && sizeInBounds;\n      const fittedBox = fits ? box : calcReposition(box, adjustedBounds);\n      const isPartlyVisible = fittedBox.width > 0 && fittedBox.height > 0;\n      const {maxWidth, maxHeight} = calcMaxSizes(candidate.direction, fittedBox, bounds$1);\n      const reposition = {\n        rect: fittedBox,\n        maxHeight,\n        maxWidth,\n        direction: candidate.direction,\n        placement: candidate.placement,\n        classes: {\n          on: bubble.classesOn,\n          off: bubble.classesOff\n        },\n        layout: candidate.label,\n        testY: newY\n      };\n      return fits || candidate.alwaysFit ? adt$8.fit(reposition) : adt$8.nofit(reposition, visibleW, visibleH, isPartlyVisible);\n    };\n    const attempts = (element, candidates, anchorBox, elementBox, bubbles, bounds) => {\n      const panelWidth = elementBox.width;\n      const panelHeight = elementBox.height;\n      const attemptBestFit = (layout, reposition, visibleW, visibleH, isVisible) => {\n        const next = layout(anchorBox, elementBox, bubbles, element, bounds);\n        const attemptLayout = attempt(next, panelWidth, panelHeight, bounds);\n        return attemptLayout.fold(constant$1(attemptLayout), (newReposition, newVisibleW, newVisibleH, newIsVisible) => {\n          const improved = isVisible === newIsVisible ? newVisibleH > visibleH || newVisibleW > visibleW : !isVisible && newIsVisible;\n          return improved ? attemptLayout : adt$8.nofit(reposition, visibleW, visibleH, isVisible);\n        });\n      };\n      const abc = foldl(candidates, (b, a) => {\n        const bestNext = curry(attemptBestFit, a);\n        return b.fold(constant$1(b), bestNext);\n      }, adt$8.nofit({\n        rect: anchorBox,\n        maxHeight: elementBox.height,\n        maxWidth: elementBox.width,\n        direction: southeast$3(),\n        placement: 'southeast',\n        classes: {\n          on: [],\n          off: []\n        },\n        layout: 'none',\n        testY: anchorBox.y\n      }, -1, -1, false));\n      return abc.fold(identity, identity);\n    };\n\n    const filter = always;\n    const bind = (element, event, handler) => bind$2(element, event, filter, handler);\n    const capture = (element, event, handler) => capture$1(element, event, filter, handler);\n    const fromRawEvent = fromRawEvent$1;\n\n    const properties = [\n      'top',\n      'bottom',\n      'right',\n      'left'\n    ];\n    const timerAttr = 'data-alloy-transition-timer';\n    const isTransitioning$1 = (element, transition) => hasAll(element, transition.classes);\n    const shouldApplyTransitionCss = (transition, decision, lastPlacement) => {\n      return lastPlacement.exists(placer => {\n        const mode = transition.mode;\n        return mode === 'all' ? true : placer[mode] !== decision[mode];\n      });\n    };\n    const hasChanges = (position, intermediate) => {\n      const round = value => parseFloat(value).toFixed(3);\n      return find$4(intermediate, (value, key) => {\n        const newValue = position[key].map(round);\n        const val = value.map(round);\n        return !equals(newValue, val);\n      }).isSome();\n    };\n    const getTransitionDuration = element => {\n      const get = name => {\n        const style = get$f(element, name);\n        const times = style.split(/\\s*,\\s*/);\n        return filter$2(times, isNotEmpty);\n      };\n      const parse = value => {\n        if (isString(value) && /^[\\d.]+/.test(value)) {\n          const num = parseFloat(value);\n          return endsWith(value, 'ms') ? num : num * 1000;\n        } else {\n          return 0;\n        }\n      };\n      const delay = get('transition-delay');\n      const duration = get('transition-duration');\n      return foldl(duration, (acc, dur, i) => {\n        const time = parse(delay[i]) + parse(dur);\n        return Math.max(acc, time);\n      }, 0);\n    };\n    const setupTransitionListeners = (element, transition) => {\n      const transitionEnd = unbindable();\n      const transitionCancel = unbindable();\n      let timer;\n      const isSourceTransition = e => {\n        var _a;\n        const pseudoElement = (_a = e.raw.pseudoElement) !== null && _a !== void 0 ? _a : '';\n        return eq(e.target, element) && isEmpty(pseudoElement) && contains$2(properties, e.raw.propertyName);\n      };\n      const transitionDone = e => {\n        if (isNullable(e) || isSourceTransition(e)) {\n          transitionEnd.clear();\n          transitionCancel.clear();\n          const type = e === null || e === void 0 ? void 0 : e.raw.type;\n          if (isNullable(type) || type === transitionend()) {\n            clearTimeout(timer);\n            remove$8(element, timerAttr);\n            remove$2(element, transition.classes);\n          }\n        }\n      };\n      const transitionStart = bind(element, transitionstart(), e => {\n        if (isSourceTransition(e)) {\n          transitionStart.unbind();\n          transitionEnd.set(bind(element, transitionend(), transitionDone));\n          transitionCancel.set(bind(element, transitioncancel(), transitionDone));\n        }\n      });\n      const duration = getTransitionDuration(element);\n      requestAnimationFrame(() => {\n        timer = setTimeout(transitionDone, duration + 17);\n        set$9(element, timerAttr, timer);\n      });\n    };\n    const startTransitioning = (element, transition) => {\n      add$1(element, transition.classes);\n      getOpt(element, timerAttr).each(timerId => {\n        clearTimeout(parseInt(timerId, 10));\n        remove$8(element, timerAttr);\n      });\n      setupTransitionListeners(element, transition);\n    };\n    const applyTransitionCss = (element, origin, position, transition, decision, lastPlacement) => {\n      const shouldTransition = shouldApplyTransitionCss(transition, decision, lastPlacement);\n      if (shouldTransition || isTransitioning$1(element, transition)) {\n        set$8(element, 'position', position.position);\n        const rect = toBox(origin, element);\n        const intermediatePosition = reposition(origin, {\n          ...decision,\n          rect\n        });\n        const intermediateCssOptions = mapToObject(properties, prop => intermediatePosition[prop]);\n        if (hasChanges(position, intermediateCssOptions)) {\n          setOptions(element, intermediateCssOptions);\n          if (shouldTransition) {\n            startTransitioning(element, transition);\n          }\n          reflow(element);\n        }\n      } else {\n        remove$2(element, transition.classes);\n      }\n    };\n\n    const elementSize = p => ({\n      width: getOuter$1(p),\n      height: getOuter$2(p)\n    });\n    const layout = (anchorBox, element, bubbles, options) => {\n      remove$7(element, 'max-height');\n      remove$7(element, 'max-width');\n      const elementBox = elementSize(element);\n      return attempts(element, options.preference, anchorBox, elementBox, bubbles, options.bounds);\n    };\n    const setClasses = (element, decision) => {\n      const classInfo = decision.classes;\n      remove$2(element, classInfo.off);\n      add$1(element, classInfo.on);\n    };\n    const setHeight = (element, decision, options) => {\n      const maxHeightFunction = options.maxHeightFunction;\n      maxHeightFunction(element, decision.maxHeight);\n    };\n    const setWidth = (element, decision, options) => {\n      const maxWidthFunction = options.maxWidthFunction;\n      maxWidthFunction(element, decision.maxWidth);\n    };\n    const position$2 = (element, decision, options) => {\n      const positionCss = reposition(options.origin, decision);\n      options.transition.each(transition => {\n        applyTransitionCss(element, options.origin, positionCss, transition, decision, options.lastPlacement);\n      });\n      applyPositionCss(element, positionCss);\n    };\n    const setPlacement = (element, decision) => {\n      setPlacement$1(element, decision.placement);\n    };\n\n    const setMaxHeight = (element, maxHeight) => {\n      setMax$1(element, Math.floor(maxHeight));\n    };\n    const anchored = constant$1((element, available) => {\n      setMaxHeight(element, available);\n      setAll(element, {\n        'overflow-x': 'hidden',\n        'overflow-y': 'auto'\n      });\n    });\n    const expandable$1 = constant$1((element, available) => {\n      setMaxHeight(element, available);\n    });\n\n    const defaultOr = (options, key, dephault) => options[key] === undefined ? dephault : options[key];\n    const simple = (anchor, element, bubble, layouts, lastPlacement, optBounds, overrideOptions, transition) => {\n      const maxHeightFunction = defaultOr(overrideOptions, 'maxHeightFunction', anchored());\n      const maxWidthFunction = defaultOr(overrideOptions, 'maxWidthFunction', noop);\n      const anchorBox = anchor.anchorBox;\n      const origin = anchor.origin;\n      const options = {\n        bounds: viewport(origin, optBounds),\n        origin,\n        preference: layouts,\n        maxHeightFunction,\n        maxWidthFunction,\n        lastPlacement,\n        transition\n      };\n      return go(anchorBox, element, bubble, options);\n    };\n    const go = (anchorBox, element, bubble, options) => {\n      const decision = layout(anchorBox, element, bubble, options);\n      position$2(element, decision, options);\n      setPlacement(element, decision);\n      setClasses(element, decision);\n      setHeight(element, decision, options);\n      setWidth(element, decision, options);\n      return {\n        layout: decision.layout,\n        placement: decision.placement\n      };\n    };\n\n    const allAlignments = [\n      'valignCentre',\n      'alignLeft',\n      'alignRight',\n      'alignCentre',\n      'top',\n      'bottom',\n      'left',\n      'right',\n      'inset'\n    ];\n    const nu$5 = (xOffset, yOffset, classes, insetModifier = 1) => {\n      const insetXOffset = xOffset * insetModifier;\n      const insetYOffset = yOffset * insetModifier;\n      const getClasses = prop => get$h(classes, prop).getOr([]);\n      const make = (xDelta, yDelta, alignmentsOn) => {\n        const alignmentsOff = difference(allAlignments, alignmentsOn);\n        return {\n          offset: SugarPosition(xDelta, yDelta),\n          classesOn: bind$3(alignmentsOn, getClasses),\n          classesOff: bind$3(alignmentsOff, getClasses)\n        };\n      };\n      return {\n        southeast: () => make(-xOffset, yOffset, [\n          'top',\n          'alignLeft'\n        ]),\n        southwest: () => make(xOffset, yOffset, [\n          'top',\n          'alignRight'\n        ]),\n        south: () => make(-xOffset / 2, yOffset, [\n          'top',\n          'alignCentre'\n        ]),\n        northeast: () => make(-xOffset, -yOffset, [\n          'bottom',\n          'alignLeft'\n        ]),\n        northwest: () => make(xOffset, -yOffset, [\n          'bottom',\n          'alignRight'\n        ]),\n        north: () => make(-xOffset / 2, -yOffset, [\n          'bottom',\n          'alignCentre'\n        ]),\n        east: () => make(xOffset, -yOffset / 2, [\n          'valignCentre',\n          'left'\n        ]),\n        west: () => make(-xOffset, -yOffset / 2, [\n          'valignCentre',\n          'right'\n        ]),\n        insetNortheast: () => make(insetXOffset, insetYOffset, [\n          'top',\n          'alignLeft',\n          'inset'\n        ]),\n        insetNorthwest: () => make(-insetXOffset, insetYOffset, [\n          'top',\n          'alignRight',\n          'inset'\n        ]),\n        insetNorth: () => make(-insetXOffset / 2, insetYOffset, [\n          'top',\n          'alignCentre',\n          'inset'\n        ]),\n        insetSoutheast: () => make(insetXOffset, -insetYOffset, [\n          'bottom',\n          'alignLeft',\n          'inset'\n        ]),\n        insetSouthwest: () => make(-insetXOffset, -insetYOffset, [\n          'bottom',\n          'alignRight',\n          'inset'\n        ]),\n        insetSouth: () => make(-insetXOffset / 2, -insetYOffset, [\n          'bottom',\n          'alignCentre',\n          'inset'\n        ]),\n        insetEast: () => make(-insetXOffset, -insetYOffset / 2, [\n          'valignCentre',\n          'right',\n          'inset'\n        ]),\n        insetWest: () => make(insetXOffset, -insetYOffset / 2, [\n          'valignCentre',\n          'left',\n          'inset'\n        ])\n      };\n    };\n    const fallback = () => nu$5(0, 0, {});\n\n    const nu$4 = identity;\n\n    const onDirection = (isLtr, isRtl) => element => getDirection(element) === 'rtl' ? isRtl : isLtr;\n    const getDirection = element => get$f(element, 'direction') === 'rtl' ? 'rtl' : 'ltr';\n\n    var AttributeValue;\n    (function (AttributeValue) {\n      AttributeValue['TopToBottom'] = 'toptobottom';\n      AttributeValue['BottomToTop'] = 'bottomtotop';\n    }(AttributeValue || (AttributeValue = {})));\n    const Attribute = 'data-alloy-vertical-dir';\n    const isBottomToTopDir = el => closest$2(el, current => isElement$1(current) && get$g(current, 'data-alloy-vertical-dir') === AttributeValue.BottomToTop);\n\n    const schema$y = () => optionObjOf('layouts', [\n      required$1('onLtr'),\n      required$1('onRtl'),\n      option$3('onBottomLtr'),\n      option$3('onBottomRtl')\n    ]);\n    const get$6 = (elem, info, defaultLtr, defaultRtl, defaultBottomLtr, defaultBottomRtl, dirElement) => {\n      const isBottomToTop = dirElement.map(isBottomToTopDir).getOr(false);\n      const customLtr = info.layouts.map(ls => ls.onLtr(elem));\n      const customRtl = info.layouts.map(ls => ls.onRtl(elem));\n      const ltr = isBottomToTop ? info.layouts.bind(ls => ls.onBottomLtr.map(f => f(elem))).or(customLtr).getOr(defaultBottomLtr) : customLtr.getOr(defaultLtr);\n      const rtl = isBottomToTop ? info.layouts.bind(ls => ls.onBottomRtl.map(f => f(elem))).or(customRtl).getOr(defaultBottomRtl) : customRtl.getOr(defaultRtl);\n      const f = onDirection(ltr, rtl);\n      return f(elem);\n    };\n\n    const placement$4 = (component, anchorInfo, origin) => {\n      const hotspot = anchorInfo.hotspot;\n      const anchorBox = toBox(origin, hotspot.element);\n      const layouts = get$6(component.element, anchorInfo, belowOrAbove(), belowOrAboveRtl(), aboveOrBelow(), aboveOrBelowRtl(), Optional.some(anchorInfo.hotspot.element));\n      return Optional.some(nu$4({\n        anchorBox,\n        bubble: anchorInfo.bubble.getOr(fallback()),\n        overrides: anchorInfo.overrides,\n        layouts\n      }));\n    };\n    var HotspotAnchor = [\n      required$1('hotspot'),\n      option$3('bubble'),\n      defaulted('overrides', {}),\n      schema$y(),\n      output$1('placement', placement$4)\n    ];\n\n    const placement$3 = (component, anchorInfo, origin) => {\n      const pos = translate$2(origin, anchorInfo.x, anchorInfo.y);\n      const anchorBox = bounds(pos.left, pos.top, anchorInfo.width, anchorInfo.height);\n      const layouts = get$6(component.element, anchorInfo, all$1(), allRtl$1(), all$1(), allRtl$1(), Optional.none());\n      return Optional.some(nu$4({\n        anchorBox,\n        bubble: anchorInfo.bubble,\n        overrides: anchorInfo.overrides,\n        layouts\n      }));\n    };\n    var MakeshiftAnchor = [\n      required$1('x'),\n      required$1('y'),\n      defaulted('height', 0),\n      defaulted('width', 0),\n      defaulted('bubble', fallback()),\n      defaulted('overrides', {}),\n      schema$y(),\n      output$1('placement', placement$3)\n    ];\n\n    const adt$7 = Adt.generate([\n      { screen: ['point'] },\n      {\n        absolute: [\n          'point',\n          'scrollLeft',\n          'scrollTop'\n        ]\n      }\n    ]);\n    const toFixed = pos => pos.fold(identity, (point, scrollLeft, scrollTop) => point.translate(-scrollLeft, -scrollTop));\n    const toAbsolute = pos => pos.fold(identity, identity);\n    const sum = points => foldl(points, (b, a) => b.translate(a.left, a.top), SugarPosition(0, 0));\n    const sumAsFixed = positions => {\n      const points = map$2(positions, toFixed);\n      return sum(points);\n    };\n    const sumAsAbsolute = positions => {\n      const points = map$2(positions, toAbsolute);\n      return sum(points);\n    };\n    const screen = adt$7.screen;\n    const absolute$1 = adt$7.absolute;\n\n    const getOffset = (component, origin, anchorInfo) => {\n      const win = defaultView(anchorInfo.root).dom;\n      const hasSameOwner = frame => {\n        const frameOwner = owner$4(frame);\n        const compOwner = owner$4(component.element);\n        return eq(frameOwner, compOwner);\n      };\n      return Optional.from(win.frameElement).map(SugarElement.fromDom).filter(hasSameOwner).map(absolute$3);\n    };\n    const getRootPoint = (component, origin, anchorInfo) => {\n      const doc = owner$4(component.element);\n      const outerScroll = get$c(doc);\n      const offset = getOffset(component, origin, anchorInfo).getOr(outerScroll);\n      return absolute$1(offset, outerScroll.left, outerScroll.top);\n    };\n\n    const getBox = (left, top, width, height) => {\n      const point = screen(SugarPosition(left, top));\n      return Optional.some(pointed(point, width, height));\n    };\n    const calcNewAnchor = (optBox, rootPoint, anchorInfo, origin, elem) => optBox.map(box => {\n      const points = [\n        rootPoint,\n        box.point\n      ];\n      const topLeft = cata$1(origin, () => sumAsAbsolute(points), () => sumAsAbsolute(points), () => sumAsFixed(points));\n      const anchorBox = rect(topLeft.left, topLeft.top, box.width, box.height);\n      const layoutsLtr = anchorInfo.showAbove ? aboveOrBelow() : belowOrAbove();\n      const layoutsRtl = anchorInfo.showAbove ? aboveOrBelowRtl() : belowOrAboveRtl();\n      const layouts = get$6(elem, anchorInfo, layoutsLtr, layoutsRtl, layoutsLtr, layoutsRtl, Optional.none());\n      return nu$4({\n        anchorBox,\n        bubble: anchorInfo.bubble.getOr(fallback()),\n        overrides: anchorInfo.overrides,\n        layouts\n      });\n    });\n\n    const placement$2 = (component, anchorInfo, origin) => {\n      const rootPoint = getRootPoint(component, origin, anchorInfo);\n      return anchorInfo.node.filter(inBody).bind(target => {\n        const rect = target.dom.getBoundingClientRect();\n        const nodeBox = getBox(rect.left, rect.top, rect.width, rect.height);\n        const elem = anchorInfo.node.getOr(component.element);\n        return calcNewAnchor(nodeBox, rootPoint, anchorInfo, origin, elem);\n      });\n    };\n    var NodeAnchor = [\n      required$1('node'),\n      required$1('root'),\n      option$3('bubble'),\n      schema$y(),\n      defaulted('overrides', {}),\n      defaulted('showAbove', false),\n      output$1('placement', placement$2)\n    ];\n\n    const zeroWidth = '\\uFEFF';\n    const nbsp = '\\xA0';\n\n    const create$3 = (start, soffset, finish, foffset) => ({\n      start,\n      soffset,\n      finish,\n      foffset\n    });\n    const SimRange = { create: create$3 };\n\n    const adt$6 = Adt.generate([\n      { before: ['element'] },\n      {\n        on: [\n          'element',\n          'offset'\n        ]\n      },\n      { after: ['element'] }\n    ]);\n    const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\n    const getStart$1 = situ => situ.fold(identity, identity, identity);\n    const before = adt$6.before;\n    const on$1 = adt$6.on;\n    const after$1 = adt$6.after;\n    const Situ = {\n      before,\n      on: on$1,\n      after: after$1,\n      cata,\n      getStart: getStart$1\n    };\n\n    const adt$5 = Adt.generate([\n      { domRange: ['rng'] },\n      {\n        relative: [\n          'startSitu',\n          'finishSitu'\n        ]\n      },\n      {\n        exact: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const exactFromRange = simRange => adt$5.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n    const getStart = selection => selection.match({\n      domRange: rng => SugarElement.fromDom(rng.startContainer),\n      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\n      exact: (start, _soffset, _finish, _foffset) => start\n    });\n    const domRange = adt$5.domRange;\n    const relative = adt$5.relative;\n    const exact = adt$5.exact;\n    const getWin = selection => {\n      const start = getStart(selection);\n      return defaultView(start);\n    };\n    const range$1 = SimRange.create;\n    const SimSelection = {\n      domRange,\n      relative,\n      exact,\n      exactFromRange,\n      getWin,\n      range: range$1\n    };\n\n    const setStart = (rng, situ) => {\n      situ.fold(e => {\n        rng.setStartBefore(e.dom);\n      }, (e, o) => {\n        rng.setStart(e.dom, o);\n      }, e => {\n        rng.setStartAfter(e.dom);\n      });\n    };\n    const setFinish = (rng, situ) => {\n      situ.fold(e => {\n        rng.setEndBefore(e.dom);\n      }, (e, o) => {\n        rng.setEnd(e.dom, o);\n      }, e => {\n        rng.setEndAfter(e.dom);\n      });\n    };\n    const relativeToNative = (win, startSitu, finishSitu) => {\n      const range = win.document.createRange();\n      setStart(range, startSitu);\n      setFinish(range, finishSitu);\n      return range;\n    };\n    const exactToNative = (win, start, soffset, finish, foffset) => {\n      const rng = win.document.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n    const toRect = rect => ({\n      left: rect.left,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      width: rect.width,\n      height: rect.height\n    });\n    const getFirstRect$1 = rng => {\n      const rects = rng.getClientRects();\n      const rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();\n      return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();\n    };\n    const getBounds$2 = rng => {\n      const rect = rng.getBoundingClientRect();\n      return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();\n    };\n\n    const adt$4 = Adt.generate([\n      {\n        ltr: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      },\n      {\n        rtl: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n    const getRanges = (win, selection) => selection.match({\n      domRange: rng => {\n        return {\n          ltr: constant$1(rng),\n          rtl: Optional.none\n        };\n      },\n      relative: (startSitu, finishSitu) => {\n        return {\n          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\n          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\n        };\n      },\n      exact: (start, soffset, finish, foffset) => {\n        return {\n          ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\n          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\n        };\n      }\n    });\n    const doDiagnose = (win, ranges) => {\n      const rng = ranges.ltr();\n      if (rng.collapsed) {\n        const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\n        return reversed.map(rev => adt$4.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$4.ltr, rng));\n      } else {\n        return fromRange(win, adt$4.ltr, rng);\n      }\n    };\n    const diagnose = (win, selection) => {\n      const ranges = getRanges(win, selection);\n      return doDiagnose(win, ranges);\n    };\n    const asLtrRange = (win, selection) => {\n      const diagnosis = diagnose(win, selection);\n      return diagnosis.match({\n        ltr: (start, soffset, finish, foffset) => {\n          const rng = win.document.createRange();\n          rng.setStart(start.dom, soffset);\n          rng.setEnd(finish.dom, foffset);\n          return rng;\n        },\n        rtl: (start, soffset, finish, foffset) => {\n          const rng = win.document.createRange();\n          rng.setStart(finish.dom, foffset);\n          rng.setEnd(start.dom, soffset);\n          return rng;\n        }\n      });\n    };\n    adt$4.ltr;\n    adt$4.rtl;\n\n    const ancestors = (scope, predicate, isRoot) => filter$2(parents(scope, isRoot), predicate);\n\n    const descendants = (scope, selector) => all$3(selector, scope);\n\n    const makeRange = (start, soffset, finish, foffset) => {\n      const doc = owner$4(start);\n      const rng = doc.dom.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n    const after = (start, soffset, finish, foffset) => {\n      const r = makeRange(start, soffset, finish, foffset);\n      const same = eq(start, finish) && soffset === foffset;\n      return r.collapsed && !same;\n    };\n\n    const getNativeSelection = win => Optional.from(win.getSelection());\n    const readRange = selection => {\n      if (selection.rangeCount > 0) {\n        const firstRng = selection.getRangeAt(0);\n        const lastRng = selection.getRangeAt(selection.rangeCount - 1);\n        return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));\n      } else {\n        return Optional.none();\n      }\n    };\n    const doGetExact = selection => {\n      if (selection.anchorNode === null || selection.focusNode === null) {\n        return readRange(selection);\n      } else {\n        const anchor = SugarElement.fromDom(selection.anchorNode);\n        const focus = SugarElement.fromDom(selection.focusNode);\n        return after(anchor, selection.anchorOffset, focus, selection.focusOffset) ? Optional.some(SimRange.create(anchor, selection.anchorOffset, focus, selection.focusOffset)) : readRange(selection);\n      }\n    };\n    const getExact = win => getNativeSelection(win).filter(sel => sel.rangeCount > 0).bind(doGetExact);\n    const getFirstRect = (win, selection) => {\n      const rng = asLtrRange(win, selection);\n      return getFirstRect$1(rng);\n    };\n    const getBounds$1 = (win, selection) => {\n      const rng = asLtrRange(win, selection);\n      return getBounds$2(rng);\n    };\n\n    const NodeValue = (is, name) => {\n      const get = element => {\n        if (!is(element)) {\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n        }\n        return getOption(element).getOr('');\n      };\n      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n      const set = (element, value) => {\n        if (!is(element)) {\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n        }\n        element.dom.nodeValue = value;\n      };\n      return {\n        get,\n        getOption,\n        set\n      };\n    };\n\n    const api = NodeValue(isText, 'text');\n    const get$5 = element => api.get(element);\n\n    const point = (element, offset) => ({\n      element,\n      offset\n    });\n    const descendOnce$1 = (element, offset) => {\n      const children$1 = children(element);\n      if (children$1.length === 0) {\n        return point(element, offset);\n      } else if (offset < children$1.length) {\n        return point(children$1[offset], 0);\n      } else {\n        const last = children$1[children$1.length - 1];\n        const len = isText(last) ? get$5(last).length : children(last).length;\n        return point(last, len);\n      }\n    };\n\n    const descendOnce = (element, offset) => isText(element) ? point(element, offset) : descendOnce$1(element, offset);\n    const isSimRange = detail => detail.foffset !== undefined;\n    const getAnchorSelection = (win, anchorInfo) => {\n      const getSelection = anchorInfo.getSelection.getOrThunk(() => () => getExact(win));\n      return getSelection().map(sel => {\n        if (isSimRange(sel)) {\n          const modStart = descendOnce(sel.start, sel.soffset);\n          const modFinish = descendOnce(sel.finish, sel.foffset);\n          return SimSelection.range(modStart.element, modStart.offset, modFinish.element, modFinish.offset);\n        } else {\n          return sel;\n        }\n      });\n    };\n    const placement$1 = (component, anchorInfo, origin) => {\n      const win = defaultView(anchorInfo.root).dom;\n      const rootPoint = getRootPoint(component, origin, anchorInfo);\n      const selectionBox = getAnchorSelection(win, anchorInfo).bind(sel => {\n        if (isSimRange(sel)) {\n          const optRect = getBounds$1(win, SimSelection.exactFromRange(sel)).orThunk(() => {\n            const zeroWidth$1 = SugarElement.fromText(zeroWidth);\n            before$1(sel.start, zeroWidth$1);\n            const rect = getFirstRect(win, SimSelection.exact(zeroWidth$1, 0, zeroWidth$1, 1));\n            remove$6(zeroWidth$1);\n            return rect;\n          });\n          return optRect.bind(rawRect => {\n            return getBox(rawRect.left, rawRect.top, rawRect.width, rawRect.height);\n          });\n        } else {\n          const selectionRect = map$1(sel, cell => cell.dom.getBoundingClientRect());\n          const bounds = {\n            left: Math.min(selectionRect.firstCell.left, selectionRect.lastCell.left),\n            right: Math.max(selectionRect.firstCell.right, selectionRect.lastCell.right),\n            top: Math.min(selectionRect.firstCell.top, selectionRect.lastCell.top),\n            bottom: Math.max(selectionRect.firstCell.bottom, selectionRect.lastCell.bottom)\n          };\n          return getBox(bounds.left, bounds.top, bounds.right - bounds.left, bounds.bottom - bounds.top);\n        }\n      });\n      const targetElement = getAnchorSelection(win, anchorInfo).bind(sel => {\n        if (isSimRange(sel)) {\n          return isElement$1(sel.start) ? Optional.some(sel.start) : parentElement(sel.start);\n        } else {\n          return Optional.some(sel.firstCell);\n        }\n      });\n      const elem = targetElement.getOr(component.element);\n      return calcNewAnchor(selectionBox, rootPoint, anchorInfo, origin, elem);\n    };\n    var SelectionAnchor = [\n      option$3('getSelection'),\n      required$1('root'),\n      option$3('bubble'),\n      schema$y(),\n      defaulted('overrides', {}),\n      defaulted('showAbove', false),\n      output$1('placement', placement$1)\n    ];\n\n    const labelPrefix$1 = 'link-layout';\n    const eastX = anchor => anchor.x + anchor.width;\n    const westX = (anchor, element) => anchor.x - element.width;\n    const northY$1 = (anchor, element) => anchor.y - element.height + anchor.height;\n    const southY$1 = anchor => anchor.y;\n    const southeast$1 = (anchor, element, bubbles) => nu$6(eastX(anchor), southY$1(anchor), bubbles.southeast(), southeast$3(), 'southeast', boundsRestriction(anchor, {\n      left: 0,\n      top: 2\n    }), labelPrefix$1);\n    const southwest$1 = (anchor, element, bubbles) => nu$6(westX(anchor, element), southY$1(anchor), bubbles.southwest(), southwest$3(), 'southwest', boundsRestriction(anchor, {\n      right: 1,\n      top: 2\n    }), labelPrefix$1);\n    const northeast$1 = (anchor, element, bubbles) => nu$6(eastX(anchor), northY$1(anchor, element), bubbles.northeast(), northeast$3(), 'northeast', boundsRestriction(anchor, {\n      left: 0,\n      bottom: 3\n    }), labelPrefix$1);\n    const northwest$1 = (anchor, element, bubbles) => nu$6(westX(anchor, element), northY$1(anchor, element), bubbles.northwest(), northwest$3(), 'northwest', boundsRestriction(anchor, {\n      right: 1,\n      bottom: 3\n    }), labelPrefix$1);\n    const all = () => [\n      southeast$1,\n      southwest$1,\n      northeast$1,\n      northwest$1\n    ];\n    const allRtl = () => [\n      southwest$1,\n      southeast$1,\n      northwest$1,\n      northeast$1\n    ];\n\n    const placement = (component, submenuInfo, origin) => {\n      const anchorBox = toBox(origin, submenuInfo.item.element);\n      const layouts = get$6(component.element, submenuInfo, all(), allRtl(), all(), allRtl(), Optional.none());\n      return Optional.some(nu$4({\n        anchorBox,\n        bubble: fallback(),\n        overrides: submenuInfo.overrides,\n        layouts\n      }));\n    };\n    var SubmenuAnchor = [\n      required$1('item'),\n      schema$y(),\n      defaulted('overrides', {}),\n      output$1('placement', placement)\n    ];\n\n    var AnchorSchema = choose$1('type', {\n      selection: SelectionAnchor,\n      node: NodeAnchor,\n      hotspot: HotspotAnchor,\n      submenu: SubmenuAnchor,\n      makeshift: MakeshiftAnchor\n    });\n\n    const TransitionSchema = [\n      requiredArrayOf('classes', string),\n      defaultedStringEnum('mode', 'all', [\n        'all',\n        'layout',\n        'placement'\n      ])\n    ];\n    const PositionSchema = [\n      defaulted('useFixed', never),\n      option$3('getBounds')\n    ];\n    const PlacementSchema = [\n      requiredOf('anchor', AnchorSchema),\n      optionObjOf('transition', TransitionSchema)\n    ];\n\n    const getFixedOrigin = () => {\n      const html = document.documentElement;\n      return fixed$1(0, 0, html.clientWidth, html.clientHeight);\n    };\n    const getRelativeOrigin = component => {\n      const position = absolute$3(component.element);\n      const bounds = component.element.dom.getBoundingClientRect();\n      return relative$1(position.left, position.top, bounds.width, bounds.height);\n    };\n    const place = (origin, anchoring, optBounds, placee, lastPlace, transition) => {\n      const anchor = box(anchoring.anchorBox, origin);\n      return simple(anchor, placee.element, anchoring.bubble, anchoring.layouts, lastPlace, optBounds, anchoring.overrides, transition);\n    };\n    const position$1 = (component, posConfig, posState, placee, placementSpec) => {\n      const optWithinBounds = Optional.none();\n      positionWithinBounds(component, posConfig, posState, placee, placementSpec, optWithinBounds);\n    };\n    const positionWithinBounds = (component, posConfig, posState, placee, placementSpec, optWithinBounds) => {\n      const placeeDetail = asRawOrDie$1('placement.info', objOf(PlacementSchema), placementSpec);\n      const anchorage = placeeDetail.anchor;\n      const element = placee.element;\n      const placeeState = posState.get(placee.uid);\n      preserve$1(() => {\n        set$8(element, 'position', 'fixed');\n        const oldVisibility = getRaw(element, 'visibility');\n        set$8(element, 'visibility', 'hidden');\n        const origin = posConfig.useFixed() ? getFixedOrigin() : getRelativeOrigin(component);\n        anchorage.placement(component, anchorage, origin).each(anchoring => {\n          const optBounds = optWithinBounds.orThunk(() => posConfig.getBounds.map(apply$1));\n          const newState = place(origin, anchoring, optBounds, placee, placeeState, placeeDetail.transition);\n          posState.set(placee.uid, newState);\n        });\n        oldVisibility.fold(() => {\n          remove$7(element, 'visibility');\n        }, vis => {\n          set$8(element, 'visibility', vis);\n        });\n        if (getRaw(element, 'left').isNone() && getRaw(element, 'top').isNone() && getRaw(element, 'right').isNone() && getRaw(element, 'bottom').isNone() && is$1(getRaw(element, 'position'), 'fixed')) {\n          remove$7(element, 'position');\n        }\n      }, element);\n    };\n    const getMode = (component, pConfig, _pState) => pConfig.useFixed() ? 'fixed' : 'absolute';\n    const reset = (component, pConfig, posState, placee) => {\n      const element = placee.element;\n      each$1([\n        'position',\n        'left',\n        'right',\n        'top',\n        'bottom'\n      ], prop => remove$7(element, prop));\n      reset$1(element);\n      posState.clear(placee.uid);\n    };\n\n    var PositionApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        position: position$1,\n        positionWithinBounds: positionWithinBounds,\n        getMode: getMode,\n        reset: reset\n    });\n\n    const init$f = () => {\n      let state = {};\n      const set = (id, data) => {\n        state[id] = data;\n      };\n      const get = id => get$h(state, id);\n      const clear = id => {\n        if (isNonNullable(id)) {\n          delete state[id];\n        } else {\n          state = {};\n        }\n      };\n      return nu$7({\n        readState: () => state,\n        clear,\n        set,\n        get\n      });\n    };\n\n    var PositioningState = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        init: init$f\n    });\n\n    const Positioning = create$4({\n      fields: PositionSchema,\n      name: 'positioning',\n      active: ActivePosition,\n      apis: PositionApis,\n      state: PositioningState\n    });\n\n    const isConnected = comp => comp.getSystem().isConnected();\n    const fireDetaching = component => {\n      emit(component, detachedFromDom());\n      const children = component.components();\n      each$1(children, fireDetaching);\n    };\n    const fireAttaching = component => {\n      const children = component.components();\n      each$1(children, fireAttaching);\n      emit(component, attachedToDom());\n    };\n    const virtualAttach = (parent, child) => {\n      parent.getSystem().addToWorld(child);\n      if (inBody(parent.element)) {\n        fireAttaching(child);\n      }\n    };\n    const virtualDetach = comp => {\n      fireDetaching(comp);\n      comp.getSystem().removeFromWorld(comp);\n    };\n    const attach$1 = (parent, child) => {\n      append$2(parent.element, child.element);\n    };\n    const detachChildren$1 = component => {\n      each$1(component.components(), childComp => remove$6(childComp.element));\n      empty(component.element);\n      component.syncComponents();\n    };\n    const replaceChildren = (component, newSpecs, buildNewChildren) => {\n      const subs = component.components();\n      detachChildren$1(component);\n      const newChildren = buildNewChildren(newSpecs);\n      const deleted = difference(subs, newChildren);\n      each$1(deleted, comp => {\n        fireDetaching(comp);\n        component.getSystem().removeFromWorld(comp);\n      });\n      each$1(newChildren, childComp => {\n        if (!isConnected(childComp)) {\n          component.getSystem().addToWorld(childComp);\n          attach$1(component, childComp);\n          if (inBody(component.element)) {\n            fireAttaching(childComp);\n          }\n        } else {\n          attach$1(component, childComp);\n        }\n      });\n      component.syncComponents();\n    };\n    const virtualReplaceChildren = (component, newSpecs, buildNewChildren) => {\n      const subs = component.components();\n      const existingComps = bind$3(newSpecs, spec => getPremade(spec).toArray());\n      each$1(subs, childComp => {\n        if (!contains$2(existingComps, childComp)) {\n          virtualDetach(childComp);\n        }\n      });\n      const newChildren = buildNewChildren(newSpecs);\n      const deleted = difference(subs, newChildren);\n      each$1(deleted, deletedComp => {\n        if (isConnected(deletedComp)) {\n          virtualDetach(deletedComp);\n        }\n      });\n      each$1(newChildren, childComp => {\n        if (!isConnected(childComp)) {\n          virtualAttach(component, childComp);\n        }\n      });\n      component.syncComponents();\n    };\n\n    const attach = (parent, child) => {\n      attachWith(parent, child, append$2);\n    };\n    const attachWith = (parent, child, insertion) => {\n      parent.getSystem().addToWorld(child);\n      insertion(parent.element, child.element);\n      if (inBody(parent.element)) {\n        fireAttaching(child);\n      }\n      parent.syncComponents();\n    };\n    const doDetach = component => {\n      fireDetaching(component);\n      remove$6(component.element);\n      component.getSystem().removeFromWorld(component);\n    };\n    const detach = component => {\n      const parent$1 = parent(component.element).bind(p => component.getSystem().getByDom(p).toOptional());\n      doDetach(component);\n      parent$1.each(p => {\n        p.syncComponents();\n      });\n    };\n    const detachChildren = component => {\n      const subs = component.components();\n      each$1(subs, doDetach);\n      empty(component.element);\n      component.syncComponents();\n    };\n    const attachSystem = (element, guiSystem) => {\n      attachSystemWith(element, guiSystem, append$2);\n    };\n    const attachSystemAfter = (element, guiSystem) => {\n      attachSystemWith(element, guiSystem, after$2);\n    };\n    const attachSystemWith = (element, guiSystem, inserter) => {\n      inserter(element, guiSystem.element);\n      const children$1 = children(guiSystem.element);\n      each$1(children$1, child => {\n        guiSystem.getByDom(child).each(fireAttaching);\n      });\n    };\n    const detachSystem = guiSystem => {\n      const children$1 = children(guiSystem.element);\n      each$1(children$1, child => {\n        guiSystem.getByDom(child).each(fireDetaching);\n      });\n      remove$6(guiSystem.element);\n    };\n\n    const rebuild = (sandbox, sConfig, sState, data) => {\n      sState.get().each(_data => {\n        detachChildren(sandbox);\n      });\n      const point = sConfig.getAttachPoint(sandbox);\n      attach(point, sandbox);\n      const built = sandbox.getSystem().build(data);\n      attach(sandbox, built);\n      sState.set(built);\n      return built;\n    };\n    const open$1 = (sandbox, sConfig, sState, data) => {\n      const newState = rebuild(sandbox, sConfig, sState, data);\n      sConfig.onOpen(sandbox, newState);\n      return newState;\n    };\n    const setContent = (sandbox, sConfig, sState, data) => sState.get().map(() => rebuild(sandbox, sConfig, sState, data));\n    const openWhileCloaked = (sandbox, sConfig, sState, data, transaction) => {\n      cloak(sandbox, sConfig);\n      open$1(sandbox, sConfig, sState, data);\n      transaction();\n      decloak(sandbox, sConfig);\n    };\n    const close$1 = (sandbox, sConfig, sState) => {\n      sState.get().each(data => {\n        detachChildren(sandbox);\n        detach(sandbox);\n        sConfig.onClose(sandbox, data);\n        sState.clear();\n      });\n    };\n    const isOpen$1 = (_sandbox, _sConfig, sState) => sState.isOpen();\n    const isPartOf = (sandbox, sConfig, sState, queryElem) => isOpen$1(sandbox, sConfig, sState) && sState.get().exists(data => sConfig.isPartOf(sandbox, data, queryElem));\n    const getState$2 = (_sandbox, _sConfig, sState) => sState.get();\n    const store = (sandbox, cssKey, attr, newValue) => {\n      getRaw(sandbox.element, cssKey).fold(() => {\n        remove$8(sandbox.element, attr);\n      }, v => {\n        set$9(sandbox.element, attr, v);\n      });\n      set$8(sandbox.element, cssKey, newValue);\n    };\n    const restore = (sandbox, cssKey, attr) => {\n      getOpt(sandbox.element, attr).fold(() => remove$7(sandbox.element, cssKey), oldValue => set$8(sandbox.element, cssKey, oldValue));\n    };\n    const cloak = (sandbox, sConfig, _sState) => {\n      const sink = sConfig.getAttachPoint(sandbox);\n      set$8(sandbox.element, 'position', Positioning.getMode(sink));\n      store(sandbox, 'visibility', sConfig.cloakVisibilityAttr, 'hidden');\n    };\n    const hasPosition = element => exists([\n      'top',\n      'left',\n      'right',\n      'bottom'\n    ], pos => getRaw(element, pos).isSome());\n    const decloak = (sandbox, sConfig, _sState) => {\n      if (!hasPosition(sandbox.element)) {\n        remove$7(sandbox.element, 'position');\n      }\n      restore(sandbox, 'visibility', sConfig.cloakVisibilityAttr);\n    };\n\n    var SandboxApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        cloak: cloak,\n        decloak: decloak,\n        open: open$1,\n        openWhileCloaked: openWhileCloaked,\n        close: close$1,\n        isOpen: isOpen$1,\n        isPartOf: isPartOf,\n        getState: getState$2,\n        setContent: setContent\n    });\n\n    const events$f = (sandboxConfig, sandboxState) => derive$2([run$1(sandboxClose(), (sandbox, _simulatedEvent) => {\n        close$1(sandbox, sandboxConfig, sandboxState);\n      })]);\n\n    var ActiveSandbox = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        events: events$f\n    });\n\n    var SandboxSchema = [\n      onHandler('onOpen'),\n      onHandler('onClose'),\n      required$1('isPartOf'),\n      required$1('getAttachPoint'),\n      defaulted('cloakVisibilityAttr', 'data-precloak-visibility')\n    ];\n\n    const init$e = () => {\n      const contents = value$4();\n      const readState = constant$1('not-implemented');\n      return nu$7({\n        readState,\n        isOpen: contents.isSet,\n        clear: contents.clear,\n        set: contents.set,\n        get: contents.get\n      });\n    };\n\n    var SandboxState = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        init: init$e\n    });\n\n    const Sandboxing = create$4({\n      fields: SandboxSchema,\n      name: 'sandboxing',\n      active: ActiveSandbox,\n      apis: SandboxApis,\n      state: SandboxState\n    });\n\n    const dismissPopups = constant$1('dismiss.popups');\n    const repositionPopups = constant$1('reposition.popups');\n    const mouseReleased = constant$1('mouse.released');\n\n    const schema$x = objOfOnly([\n      defaulted('isExtraPart', never),\n      optionObjOf('fireEventInstead', [defaulted('event', dismissRequested())])\n    ]);\n    const receivingChannel$1 = rawSpec => {\n      const detail = asRawOrDie$1('Dismissal', schema$x, rawSpec);\n      return {\n        [dismissPopups()]: {\n          schema: objOfOnly([required$1('target')]),\n          onReceive: (sandbox, data) => {\n            if (Sandboxing.isOpen(sandbox)) {\n              const isPart = Sandboxing.isPartOf(sandbox, data.target) || detail.isExtraPart(sandbox, data.target);\n              if (!isPart) {\n                detail.fireEventInstead.fold(() => Sandboxing.close(sandbox), fe => emit(sandbox, fe.event));\n              }\n            }\n          }\n        }\n      };\n    };\n\n    const schema$w = objOfOnly([\n      optionObjOf('fireEventInstead', [defaulted('event', repositionRequested())]),\n      requiredFunction('doReposition')\n    ]);\n    const receivingChannel = rawSpec => {\n      const detail = asRawOrDie$1('Reposition', schema$w, rawSpec);\n      return {\n        [repositionPopups()]: {\n          onReceive: sandbox => {\n            if (Sandboxing.isOpen(sandbox)) {\n              detail.fireEventInstead.fold(() => detail.doReposition(sandbox), fe => emit(sandbox, fe.event));\n            }\n          }\n        }\n      };\n    };\n\n    const onLoad$5 = (component, repConfig, repState) => {\n      repConfig.store.manager.onLoad(component, repConfig, repState);\n    };\n    const onUnload$2 = (component, repConfig, repState) => {\n      repConfig.store.manager.onUnload(component, repConfig, repState);\n    };\n    const setValue$3 = (component, repConfig, repState, data) => {\n      repConfig.store.manager.setValue(component, repConfig, repState, data);\n    };\n    const getValue$3 = (component, repConfig, repState) => repConfig.store.manager.getValue(component, repConfig, repState);\n    const getState$1 = (component, repConfig, repState) => repState;\n\n    var RepresentApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        onLoad: onLoad$5,\n        onUnload: onUnload$2,\n        setValue: setValue$3,\n        getValue: getValue$3,\n        getState: getState$1\n    });\n\n    const events$e = (repConfig, repState) => {\n      const es = repConfig.resetOnDom ? [\n        runOnAttached((comp, _se) => {\n          onLoad$5(comp, repConfig, repState);\n        }),\n        runOnDetached((comp, _se) => {\n          onUnload$2(comp, repConfig, repState);\n        })\n      ] : [loadEvent(repConfig, repState, onLoad$5)];\n      return derive$2(es);\n    };\n\n    var ActiveRepresenting = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        events: events$e\n    });\n\n    const memory$1 = () => {\n      const data = Cell(null);\n      const readState = () => ({\n        mode: 'memory',\n        value: data.get()\n      });\n      const isNotSet = () => data.get() === null;\n      const clear = () => {\n        data.set(null);\n      };\n      return nu$7({\n        set: data.set,\n        get: data.get,\n        isNotSet,\n        clear,\n        readState\n      });\n    };\n    const manual = () => {\n      const readState = noop;\n      return nu$7({ readState });\n    };\n    const dataset = () => {\n      const dataByValue = Cell({});\n      const dataByText = Cell({});\n      const readState = () => ({\n        mode: 'dataset',\n        dataByValue: dataByValue.get(),\n        dataByText: dataByText.get()\n      });\n      const clear = () => {\n        dataByValue.set({});\n        dataByText.set({});\n      };\n      const lookup = itemString => get$h(dataByValue.get(), itemString).orThunk(() => get$h(dataByText.get(), itemString));\n      const update = items => {\n        const currentDataByValue = dataByValue.get();\n        const currentDataByText = dataByText.get();\n        const newDataByValue = {};\n        const newDataByText = {};\n        each$1(items, item => {\n          newDataByValue[item.value] = item;\n          get$h(item, 'meta').each(meta => {\n            get$h(meta, 'text').each(text => {\n              newDataByText[text] = item;\n            });\n          });\n        });\n        dataByValue.set({\n          ...currentDataByValue,\n          ...newDataByValue\n        });\n        dataByText.set({\n          ...currentDataByText,\n          ...newDataByText\n        });\n      };\n      return nu$7({\n        readState,\n        lookup,\n        update,\n        clear\n      });\n    };\n    const init$d = spec => spec.store.manager.state(spec);\n\n    var RepresentState = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        memory: memory$1,\n        dataset: dataset,\n        manual: manual,\n        init: init$d\n    });\n\n    const setValue$2 = (component, repConfig, repState, data) => {\n      const store = repConfig.store;\n      repState.update([data]);\n      store.setValue(component, data);\n      repConfig.onSetValue(component, data);\n    };\n    const getValue$2 = (component, repConfig, repState) => {\n      const store = repConfig.store;\n      const key = store.getDataKey(component);\n      return repState.lookup(key).getOrThunk(() => store.getFallbackEntry(key));\n    };\n    const onLoad$4 = (component, repConfig, repState) => {\n      const store = repConfig.store;\n      store.initialValue.each(data => {\n        setValue$2(component, repConfig, repState, data);\n      });\n    };\n    const onUnload$1 = (component, repConfig, repState) => {\n      repState.clear();\n    };\n    var DatasetStore = [\n      option$3('initialValue'),\n      required$1('getFallbackEntry'),\n      required$1('getDataKey'),\n      required$1('setValue'),\n      output$1('manager', {\n        setValue: setValue$2,\n        getValue: getValue$2,\n        onLoad: onLoad$4,\n        onUnload: onUnload$1,\n        state: dataset\n      })\n    ];\n\n    const getValue$1 = (component, repConfig, _repState) => repConfig.store.getValue(component);\n    const setValue$1 = (component, repConfig, _repState, data) => {\n      repConfig.store.setValue(component, data);\n      repConfig.onSetValue(component, data);\n    };\n    const onLoad$3 = (component, repConfig, _repState) => {\n      repConfig.store.initialValue.each(data => {\n        repConfig.store.setValue(component, data);\n      });\n    };\n    var ManualStore = [\n      required$1('getValue'),\n      defaulted('setValue', noop),\n      option$3('initialValue'),\n      output$1('manager', {\n        setValue: setValue$1,\n        getValue: getValue$1,\n        onLoad: onLoad$3,\n        onUnload: noop,\n        state: NoState.init\n      })\n    ];\n\n    const setValue = (component, repConfig, repState, data) => {\n      repState.set(data);\n      repConfig.onSetValue(component, data);\n    };\n    const getValue = (component, repConfig, repState) => repState.get();\n    const onLoad$2 = (component, repConfig, repState) => {\n      repConfig.store.initialValue.each(initVal => {\n        if (repState.isNotSet()) {\n          repState.set(initVal);\n        }\n      });\n    };\n    const onUnload = (component, repConfig, repState) => {\n      repState.clear();\n    };\n    var MemoryStore = [\n      option$3('initialValue'),\n      output$1('manager', {\n        setValue,\n        getValue,\n        onLoad: onLoad$2,\n        onUnload,\n        state: memory$1\n      })\n    ];\n\n    var RepresentSchema = [\n      defaultedOf('store', { mode: 'memory' }, choose$1('mode', {\n        memory: MemoryStore,\n        manual: ManualStore,\n        dataset: DatasetStore\n      })),\n      onHandler('onSetValue'),\n      defaulted('resetOnDom', false)\n    ];\n\n    const Representing = create$4({\n      fields: RepresentSchema,\n      name: 'representing',\n      active: ActiveRepresenting,\n      apis: RepresentApis,\n      extra: {\n        setValueFrom: (component, source) => {\n          const value = Representing.getValue(source);\n          Representing.setValue(component, value);\n        }\n      },\n      state: RepresentState\n    });\n\n    const field = (name, forbidden) => defaultedObjOf(name, {}, map$2(forbidden, f => forbid(f.name(), 'Cannot configure ' + f.name() + ' for ' + name)).concat([customField('dump', identity)]));\n    const get$4 = data => data.dump;\n    const augment = (data, original) => ({\n      ...derive$1(original),\n      ...data.dump\n    });\n    const SketchBehaviours = {\n      field,\n      augment,\n      get: get$4\n    };\n\n    const _placeholder = 'placeholder';\n    const adt$3 = Adt.generate([\n      {\n        single: [\n          'required',\n          'valueThunk'\n        ]\n      },\n      {\n        multiple: [\n          'required',\n          'valueThunks'\n        ]\n      }\n    ]);\n    const isSubstituted = spec => has$2(spec, 'uiType');\n    const subPlaceholder = (owner, detail, compSpec, placeholders) => {\n      if (owner.exists(o => o !== compSpec.owner)) {\n        return adt$3.single(true, constant$1(compSpec));\n      }\n      return get$h(placeholders, compSpec.name).fold(() => {\n        throw new Error('Unknown placeholder component: ' + compSpec.name + '\\nKnown: [' + keys(placeholders) + ']\\nNamespace: ' + owner.getOr('none') + '\\nSpec: ' + JSON.stringify(compSpec, null, 2));\n      }, newSpec => newSpec.replace());\n    };\n    const scan = (owner, detail, compSpec, placeholders) => {\n      if (isSubstituted(compSpec) && compSpec.uiType === _placeholder) {\n        return subPlaceholder(owner, detail, compSpec, placeholders);\n      } else {\n        return adt$3.single(false, constant$1(compSpec));\n      }\n    };\n    const substitute = (owner, detail, compSpec, placeholders) => {\n      const base = scan(owner, detail, compSpec, placeholders);\n      return base.fold((req, valueThunk) => {\n        const value = isSubstituted(compSpec) ? valueThunk(detail, compSpec.config, compSpec.validated) : valueThunk(detail);\n        const childSpecs = get$h(value, 'components').getOr([]);\n        const substituted = bind$3(childSpecs, c => substitute(owner, detail, c, placeholders));\n        return [{\n            ...value,\n            components: substituted\n          }];\n      }, (req, valuesThunk) => {\n        if (isSubstituted(compSpec)) {\n          const values = valuesThunk(detail, compSpec.config, compSpec.validated);\n          const preprocessor = compSpec.validated.preprocess.getOr(identity);\n          return preprocessor(values);\n        } else {\n          return valuesThunk(detail);\n        }\n      });\n    };\n    const substituteAll = (owner, detail, components, placeholders) => bind$3(components, c => substitute(owner, detail, c, placeholders));\n    const oneReplace = (label, replacements) => {\n      let called = false;\n      const used = () => called;\n      const replace = () => {\n        if (called) {\n          throw new Error('Trying to use the same placeholder more than once: ' + label);\n        }\n        called = true;\n        return replacements;\n      };\n      const required = () => replacements.fold((req, _) => req, (req, _) => req);\n      return {\n        name: constant$1(label),\n        required,\n        used,\n        replace\n      };\n    };\n    const substitutePlaces = (owner, detail, components, placeholders) => {\n      const ps = map$1(placeholders, (ph, name) => oneReplace(name, ph));\n      const outcome = substituteAll(owner, detail, components, ps);\n      each(ps, p => {\n        if (p.used() === false && p.required()) {\n          throw new Error('Placeholder: ' + p.name() + ' was not found in components list\\nNamespace: ' + owner.getOr('none') + '\\nComponents: ' + JSON.stringify(detail.components, null, 2));\n        }\n      });\n      return outcome;\n    };\n    const single$2 = adt$3.single;\n    const multiple = adt$3.multiple;\n    const placeholder = constant$1(_placeholder);\n\n    const adt$2 = Adt.generate([\n      { required: ['data'] },\n      { external: ['data'] },\n      { optional: ['data'] },\n      { group: ['data'] }\n    ]);\n    const fFactory = defaulted('factory', { sketch: identity });\n    const fSchema = defaulted('schema', []);\n    const fName = required$1('name');\n    const fPname = field$1('pname', 'pname', defaultedThunk(typeSpec => '<alloy.' + generate$6(typeSpec.name) + '>'), anyValue());\n    const fGroupSchema = customField('schema', () => [option$3('preprocess')]);\n    const fDefaults = defaulted('defaults', constant$1({}));\n    const fOverrides = defaulted('overrides', constant$1({}));\n    const requiredSpec = objOf([\n      fFactory,\n      fSchema,\n      fName,\n      fPname,\n      fDefaults,\n      fOverrides\n    ]);\n    const externalSpec = objOf([\n      fFactory,\n      fSchema,\n      fName,\n      fDefaults,\n      fOverrides\n    ]);\n    const optionalSpec = objOf([\n      fFactory,\n      fSchema,\n      fName,\n      fPname,\n      fDefaults,\n      fOverrides\n    ]);\n    const groupSpec = objOf([\n      fFactory,\n      fGroupSchema,\n      fName,\n      required$1('unit'),\n      fPname,\n      fDefaults,\n      fOverrides\n    ]);\n    const asNamedPart = part => {\n      return part.fold(Optional.some, Optional.none, Optional.some, Optional.some);\n    };\n    const name$2 = part => {\n      const get = data => data.name;\n      return part.fold(get, get, get, get);\n    };\n    const asCommon = part => {\n      return part.fold(identity, identity, identity, identity);\n    };\n    const convert = (adtConstructor, partSchema) => spec => {\n      const data = asRawOrDie$1('Converting part type', partSchema, spec);\n      return adtConstructor(data);\n    };\n    const required = convert(adt$2.required, requiredSpec);\n    const external = convert(adt$2.external, externalSpec);\n    const optional = convert(adt$2.optional, optionalSpec);\n    const group = convert(adt$2.group, groupSpec);\n    const original = constant$1('entirety');\n\n    var PartType = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        required: required,\n        external: external,\n        optional: optional,\n        group: group,\n        asNamedPart: asNamedPart,\n        name: name$2,\n        asCommon: asCommon,\n        original: original\n    });\n\n    const combine = (detail, data, partSpec, partValidated) => deepMerge(data.defaults(detail, partSpec, partValidated), partSpec, { uid: detail.partUids[data.name] }, data.overrides(detail, partSpec, partValidated));\n    const subs = (owner, detail, parts) => {\n      const internals = {};\n      const externals = {};\n      each$1(parts, part => {\n        part.fold(data => {\n          internals[data.pname] = single$2(true, (detail, partSpec, partValidated) => data.factory.sketch(combine(detail, data, partSpec, partValidated)));\n        }, data => {\n          const partSpec = detail.parts[data.name];\n          externals[data.name] = constant$1(data.factory.sketch(combine(detail, data, partSpec[original()]), partSpec));\n        }, data => {\n          internals[data.pname] = single$2(false, (detail, partSpec, partValidated) => data.factory.sketch(combine(detail, data, partSpec, partValidated)));\n        }, data => {\n          internals[data.pname] = multiple(true, (detail, _partSpec, _partValidated) => {\n            const units = detail[data.name];\n            return map$2(units, u => data.factory.sketch(deepMerge(data.defaults(detail, u, _partValidated), u, data.overrides(detail, u))));\n          });\n        });\n      });\n      return {\n        internals: constant$1(internals),\n        externals: constant$1(externals)\n      };\n    };\n\n    const generate$3 = (owner, parts) => {\n      const r = {};\n      each$1(parts, part => {\n        asNamedPart(part).each(np => {\n          const g = doGenerateOne(owner, np.pname);\n          r[np.name] = config => {\n            const validated = asRawOrDie$1('Part: ' + np.name + ' in ' + owner, objOf(np.schema), config);\n            return {\n              ...g,\n              config,\n              validated\n            };\n          };\n        });\n      });\n      return r;\n    };\n    const doGenerateOne = (owner, pname) => ({\n      uiType: placeholder(),\n      owner,\n      name: pname\n    });\n    const generateOne$1 = (owner, pname, config) => ({\n      uiType: placeholder(),\n      owner,\n      name: pname,\n      config,\n      validated: {}\n    });\n    const schemas = parts => bind$3(parts, part => part.fold(Optional.none, Optional.some, Optional.none, Optional.none).map(data => requiredObjOf(data.name, data.schema.concat([snapshot(original())]))).toArray());\n    const names = parts => map$2(parts, name$2);\n    const substitutes = (owner, detail, parts) => subs(owner, detail, parts);\n    const components$1 = (owner, detail, internals) => substitutePlaces(Optional.some(owner), detail, detail.components, internals);\n    const getPart = (component, detail, partKey) => {\n      const uid = detail.partUids[partKey];\n      return component.getSystem().getByUid(uid).toOptional();\n    };\n    const getPartOrDie = (component, detail, partKey) => getPart(component, detail, partKey).getOrDie('Could not find part: ' + partKey);\n    const getParts = (component, detail, partKeys) => {\n      const r = {};\n      const uids = detail.partUids;\n      const system = component.getSystem();\n      each$1(partKeys, pk => {\n        r[pk] = constant$1(system.getByUid(uids[pk]));\n      });\n      return r;\n    };\n    const getAllParts = (component, detail) => {\n      const system = component.getSystem();\n      return map$1(detail.partUids, (pUid, _k) => constant$1(system.getByUid(pUid)));\n    };\n    const getAllPartNames = detail => keys(detail.partUids);\n    const getPartsOrDie = (component, detail, partKeys) => {\n      const r = {};\n      const uids = detail.partUids;\n      const system = component.getSystem();\n      each$1(partKeys, pk => {\n        r[pk] = constant$1(system.getByUid(uids[pk]).getOrDie());\n      });\n      return r;\n    };\n    const defaultUids = (baseUid, partTypes) => {\n      const partNames = names(partTypes);\n      return wrapAll(map$2(partNames, pn => ({\n        key: pn,\n        value: baseUid + '-' + pn\n      })));\n    };\n    const defaultUidsSchema = partTypes => field$1('partUids', 'partUids', mergeWithThunk(spec => defaultUids(spec.uid, partTypes)), anyValue());\n\n    var AlloyParts = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        generate: generate$3,\n        generateOne: generateOne$1,\n        schemas: schemas,\n        names: names,\n        substitutes: substitutes,\n        components: components$1,\n        defaultUids: defaultUids,\n        defaultUidsSchema: defaultUidsSchema,\n        getAllParts: getAllParts,\n        getAllPartNames: getAllPartNames,\n        getPart: getPart,\n        getPartOrDie: getPartOrDie,\n        getParts: getParts,\n        getPartsOrDie: getPartsOrDie\n    });\n\n    const base = (partSchemas, partUidsSchemas) => {\n      const ps = partSchemas.length > 0 ? [requiredObjOf('parts', partSchemas)] : [];\n      return ps.concat([\n        required$1('uid'),\n        defaulted('dom', {}),\n        defaulted('components', []),\n        snapshot('originalSpec'),\n        defaulted('debug.sketcher', {})\n      ]).concat(partUidsSchemas);\n    };\n    const asRawOrDie = (label, schema, spec, partSchemas, partUidsSchemas) => {\n      const baseS = base(partSchemas, partUidsSchemas);\n      return asRawOrDie$1(label + ' [SpecSchema]', objOfOnly(baseS.concat(schema)), spec);\n    };\n\n    const single$1 = (owner, schema, factory, spec) => {\n      const specWithUid = supplyUid(spec);\n      const detail = asRawOrDie(owner, schema, specWithUid, [], []);\n      return factory(detail, specWithUid);\n    };\n    const composite$1 = (owner, schema, partTypes, factory, spec) => {\n      const specWithUid = supplyUid(spec);\n      const partSchemas = schemas(partTypes);\n      const partUidsSchema = defaultUidsSchema(partTypes);\n      const detail = asRawOrDie(owner, schema, specWithUid, partSchemas, [partUidsSchema]);\n      const subs = substitutes(owner, detail, partTypes);\n      const components = components$1(owner, detail, subs.internals());\n      return factory(detail, components, specWithUid, subs.externals());\n    };\n    const hasUid = spec => has$2(spec, 'uid');\n    const supplyUid = spec => {\n      return hasUid(spec) ? spec : {\n        ...spec,\n        uid: generate$5('uid')\n      };\n    };\n\n    const isSketchSpec = spec => {\n      return spec.uid !== undefined;\n    };\n    const singleSchema = objOfOnly([\n      required$1('name'),\n      required$1('factory'),\n      required$1('configFields'),\n      defaulted('apis', {}),\n      defaulted('extraApis', {})\n    ]);\n    const compositeSchema = objOfOnly([\n      required$1('name'),\n      required$1('factory'),\n      required$1('configFields'),\n      required$1('partFields'),\n      defaulted('apis', {}),\n      defaulted('extraApis', {})\n    ]);\n    const single = rawConfig => {\n      const config = asRawOrDie$1('Sketcher for ' + rawConfig.name, singleSchema, rawConfig);\n      const sketch = spec => single$1(config.name, config.configFields, config.factory, spec);\n      const apis = map$1(config.apis, makeApi);\n      const extraApis = map$1(config.extraApis, (f, k) => markAsExtraApi(f, k));\n      return {\n        name: config.name,\n        configFields: config.configFields,\n        sketch,\n        ...apis,\n        ...extraApis\n      };\n    };\n    const composite = rawConfig => {\n      const config = asRawOrDie$1('Sketcher for ' + rawConfig.name, compositeSchema, rawConfig);\n      const sketch = spec => composite$1(config.name, config.configFields, config.partFields, config.factory, spec);\n      const parts = generate$3(config.name, config.partFields);\n      const apis = map$1(config.apis, makeApi);\n      const extraApis = map$1(config.extraApis, (f, k) => markAsExtraApi(f, k));\n      return {\n        name: config.name,\n        partFields: config.partFields,\n        configFields: config.configFields,\n        sketch,\n        parts,\n        ...apis,\n        ...extraApis\n      };\n    };\n\n    const inside = target => isTag('input')(target) && get$g(target, 'type') !== 'radio' || isTag('textarea')(target);\n\n    const getCurrent = (component, composeConfig, _composeState) => composeConfig.find(component);\n\n    var ComposeApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        getCurrent: getCurrent\n    });\n\n    const ComposeSchema = [required$1('find')];\n\n    const Composing = create$4({\n      fields: ComposeSchema,\n      name: 'composing',\n      apis: ComposeApis\n    });\n\n    const nativeDisabled = [\n      'input',\n      'button',\n      'textarea',\n      'select'\n    ];\n    const onLoad$1 = (component, disableConfig, disableState) => {\n      const f = disableConfig.disabled() ? disable : enable;\n      f(component, disableConfig);\n    };\n    const hasNative = (component, config) => config.useNative === true && contains$2(nativeDisabled, name$3(component.element));\n    const nativeIsDisabled = component => has$1(component.element, 'disabled');\n    const nativeDisable = component => {\n      set$9(component.element, 'disabled', 'disabled');\n    };\n    const nativeEnable = component => {\n      remove$8(component.element, 'disabled');\n    };\n    const ariaIsDisabled = component => get$g(component.element, 'aria-disabled') === 'true';\n    const ariaDisable = component => {\n      set$9(component.element, 'aria-disabled', 'true');\n    };\n    const ariaEnable = component => {\n      set$9(component.element, 'aria-disabled', 'false');\n    };\n    const disable = (component, disableConfig, _disableState) => {\n      disableConfig.disableClass.each(disableClass => {\n        add$2(component.element, disableClass);\n      });\n      const f = hasNative(component, disableConfig) ? nativeDisable : ariaDisable;\n      f(component);\n      disableConfig.onDisabled(component);\n    };\n    const enable = (component, disableConfig, _disableState) => {\n      disableConfig.disableClass.each(disableClass => {\n        remove$3(component.element, disableClass);\n      });\n      const f = hasNative(component, disableConfig) ? nativeEnable : ariaEnable;\n      f(component);\n      disableConfig.onEnabled(component);\n    };\n    const isDisabled = (component, disableConfig) => hasNative(component, disableConfig) ? nativeIsDisabled(component) : ariaIsDisabled(component);\n    const set$4 = (component, disableConfig, disableState, disabled) => {\n      const f = disabled ? disable : enable;\n      f(component, disableConfig);\n    };\n\n    var DisableApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        enable: enable,\n        disable: disable,\n        isDisabled: isDisabled,\n        onLoad: onLoad$1,\n        set: set$4\n    });\n\n    const exhibit$5 = (base, disableConfig) => nu$8({ classes: disableConfig.disabled() ? disableConfig.disableClass.toArray() : [] });\n    const events$d = (disableConfig, disableState) => derive$2([\n      abort(execute$5(), (component, _simulatedEvent) => isDisabled(component, disableConfig)),\n      loadEvent(disableConfig, disableState, onLoad$1)\n    ]);\n\n    var ActiveDisable = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        exhibit: exhibit$5,\n        events: events$d\n    });\n\n    var DisableSchema = [\n      defaultedFunction('disabled', never),\n      defaulted('useNative', true),\n      option$3('disableClass'),\n      onHandler('onDisabled'),\n      onHandler('onEnabled')\n    ];\n\n    const Disabling = create$4({\n      fields: DisableSchema,\n      name: 'disabling',\n      active: ActiveDisable,\n      apis: DisableApis\n    });\n\n    const dehighlightAllExcept = (component, hConfig, hState, skip) => {\n      const highlighted = descendants(component.element, '.' + hConfig.highlightClass);\n      each$1(highlighted, h => {\n        const shouldSkip = exists(skip, skipComp => eq(skipComp.element, h));\n        if (!shouldSkip) {\n          remove$3(h, hConfig.highlightClass);\n          component.getSystem().getByDom(h).each(target => {\n            hConfig.onDehighlight(component, target);\n            emit(target, dehighlight$1());\n          });\n        }\n      });\n    };\n    const dehighlightAll = (component, hConfig, hState) => dehighlightAllExcept(component, hConfig, hState, []);\n    const dehighlight = (component, hConfig, hState, target) => {\n      if (isHighlighted(component, hConfig, hState, target)) {\n        remove$3(target.element, hConfig.highlightClass);\n        hConfig.onDehighlight(component, target);\n        emit(target, dehighlight$1());\n      }\n    };\n    const highlight = (component, hConfig, hState, target) => {\n      dehighlightAllExcept(component, hConfig, hState, [target]);\n      if (!isHighlighted(component, hConfig, hState, target)) {\n        add$2(target.element, hConfig.highlightClass);\n        hConfig.onHighlight(component, target);\n        emit(target, highlight$1());\n      }\n    };\n    const highlightFirst = (component, hConfig, hState) => {\n      getFirst(component, hConfig).each(firstComp => {\n        highlight(component, hConfig, hState, firstComp);\n      });\n    };\n    const highlightLast = (component, hConfig, hState) => {\n      getLast(component, hConfig).each(lastComp => {\n        highlight(component, hConfig, hState, lastComp);\n      });\n    };\n    const highlightAt = (component, hConfig, hState, index) => {\n      getByIndex(component, hConfig, hState, index).fold(err => {\n        throw err;\n      }, firstComp => {\n        highlight(component, hConfig, hState, firstComp);\n      });\n    };\n    const highlightBy = (component, hConfig, hState, predicate) => {\n      const candidates = getCandidates(component, hConfig);\n      const targetComp = find$5(candidates, predicate);\n      targetComp.each(c => {\n        highlight(component, hConfig, hState, c);\n      });\n    };\n    const isHighlighted = (component, hConfig, hState, queryTarget) => has(queryTarget.element, hConfig.highlightClass);\n    const getHighlighted = (component, hConfig, _hState) => descendant(component.element, '.' + hConfig.highlightClass).bind(e => component.getSystem().getByDom(e).toOptional());\n    const getByIndex = (component, hConfig, hState, index) => {\n      const items = descendants(component.element, '.' + hConfig.itemClass);\n      return Optional.from(items[index]).fold(() => Result.error(new Error('No element found with index ' + index)), component.getSystem().getByDom);\n    };\n    const getFirst = (component, hConfig, _hState) => descendant(component.element, '.' + hConfig.itemClass).bind(e => component.getSystem().getByDom(e).toOptional());\n    const getLast = (component, hConfig, _hState) => {\n      const items = descendants(component.element, '.' + hConfig.itemClass);\n      const last = items.length > 0 ? Optional.some(items[items.length - 1]) : Optional.none();\n      return last.bind(c => component.getSystem().getByDom(c).toOptional());\n    };\n    const getDelta$2 = (component, hConfig, hState, delta) => {\n      const items = descendants(component.element, '.' + hConfig.itemClass);\n      const current = findIndex$1(items, item => has(item, hConfig.highlightClass));\n      return current.bind(selected => {\n        const dest = cycleBy(selected, delta, 0, items.length - 1);\n        return component.getSystem().getByDom(items[dest]).toOptional();\n      });\n    };\n    const getPrevious = (component, hConfig, hState) => getDelta$2(component, hConfig, hState, -1);\n    const getNext = (component, hConfig, hState) => getDelta$2(component, hConfig, hState, +1);\n    const getCandidates = (component, hConfig, _hState) => {\n      const items = descendants(component.element, '.' + hConfig.itemClass);\n      return cat(map$2(items, i => component.getSystem().getByDom(i).toOptional()));\n    };\n\n    var HighlightApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        dehighlightAll: dehighlightAll,\n        dehighlight: dehighlight,\n        highlight: highlight,\n        highlightFirst: highlightFirst,\n        highlightLast: highlightLast,\n        highlightAt: highlightAt,\n        highlightBy: highlightBy,\n        isHighlighted: isHighlighted,\n        getHighlighted: getHighlighted,\n        getFirst: getFirst,\n        getLast: getLast,\n        getPrevious: getPrevious,\n        getNext: getNext,\n        getCandidates: getCandidates\n    });\n\n    var HighlightSchema = [\n      required$1('highlightClass'),\n      required$1('itemClass'),\n      onHandler('onHighlight'),\n      onHandler('onDehighlight')\n    ];\n\n    const Highlighting = create$4({\n      fields: HighlightSchema,\n      name: 'highlighting',\n      apis: HighlightApis\n    });\n\n    const BACKSPACE = [8];\n    const TAB = [9];\n    const ENTER = [13];\n    const ESCAPE = [27];\n    const SPACE = [32];\n    const LEFT = [37];\n    const UP = [38];\n    const RIGHT = [39];\n    const DOWN = [40];\n\n    const cyclePrev = (values, index, predicate) => {\n      const before = reverse(values.slice(0, index));\n      const after = reverse(values.slice(index + 1));\n      return find$5(before.concat(after), predicate);\n    };\n    const tryPrev = (values, index, predicate) => {\n      const before = reverse(values.slice(0, index));\n      return find$5(before, predicate);\n    };\n    const cycleNext = (values, index, predicate) => {\n      const before = values.slice(0, index);\n      const after = values.slice(index + 1);\n      return find$5(after.concat(before), predicate);\n    };\n    const tryNext = (values, index, predicate) => {\n      const after = values.slice(index + 1);\n      return find$5(after, predicate);\n    };\n\n    const inSet = keys => event => {\n      const raw = event.raw;\n      return contains$2(keys, raw.which);\n    };\n    const and = preds => event => forall(preds, pred => pred(event));\n    const isShift$1 = event => {\n      const raw = event.raw;\n      return raw.shiftKey === true;\n    };\n    const isControl = event => {\n      const raw = event.raw;\n      return raw.ctrlKey === true;\n    };\n    const isNotShift = not(isShift$1);\n\n    const rule = (matches, action) => ({\n      matches,\n      classification: action\n    });\n    const choose = (transitions, event) => {\n      const transition = find$5(transitions, t => t.matches(event));\n      return transition.map(t => t.classification);\n    };\n\n    const reportFocusShifting = (component, prevFocus, newFocus) => {\n      const noChange = prevFocus.exists(p => newFocus.exists(n => eq(n, p)));\n      if (!noChange) {\n        emitWith(component, focusShifted(), {\n          prevFocus,\n          newFocus\n        });\n      }\n    };\n    const dom$2 = () => {\n      const get = component => search(component.element);\n      const set = (component, focusee) => {\n        const prevFocus = get(component);\n        component.getSystem().triggerFocus(focusee, component.element);\n        const newFocus = get(component);\n        reportFocusShifting(component, prevFocus, newFocus);\n      };\n      return {\n        get,\n        set\n      };\n    };\n    const highlights = () => {\n      const get = component => Highlighting.getHighlighted(component).map(item => item.element);\n      const set = (component, element) => {\n        const prevFocus = get(component);\n        component.getSystem().getByDom(element).fold(noop, item => {\n          Highlighting.highlight(component, item);\n        });\n        const newFocus = get(component);\n        reportFocusShifting(component, prevFocus, newFocus);\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    var FocusInsideModes;\n    (function (FocusInsideModes) {\n      FocusInsideModes['OnFocusMode'] = 'onFocus';\n      FocusInsideModes['OnEnterOrSpaceMode'] = 'onEnterOrSpace';\n      FocusInsideModes['OnApiMode'] = 'onApi';\n    }(FocusInsideModes || (FocusInsideModes = {})));\n\n    const typical = (infoSchema, stateInit, getKeydownRules, getKeyupRules, optFocusIn) => {\n      const schema = () => infoSchema.concat([\n        defaulted('focusManager', dom$2()),\n        defaultedOf('focusInside', 'onFocus', valueOf(val => contains$2([\n          'onFocus',\n          'onEnterOrSpace',\n          'onApi'\n        ], val) ? Result.value(val) : Result.error('Invalid value for focusInside'))),\n        output$1('handler', me),\n        output$1('state', stateInit),\n        output$1('sendFocusIn', optFocusIn)\n      ]);\n      const processKey = (component, simulatedEvent, getRules, keyingConfig, keyingState) => {\n        const rules = getRules(component, simulatedEvent, keyingConfig, keyingState);\n        return choose(rules, simulatedEvent.event).bind(rule => rule(component, simulatedEvent, keyingConfig, keyingState));\n      };\n      const toEvents = (keyingConfig, keyingState) => {\n        const onFocusHandler = keyingConfig.focusInside !== FocusInsideModes.OnFocusMode ? Optional.none() : optFocusIn(keyingConfig).map(focusIn => run$1(focus$4(), (component, simulatedEvent) => {\n          focusIn(component, keyingConfig, keyingState);\n          simulatedEvent.stop();\n        }));\n        const tryGoInsideComponent = (component, simulatedEvent) => {\n          const isEnterOrSpace = inSet(SPACE.concat(ENTER))(simulatedEvent.event);\n          if (keyingConfig.focusInside === FocusInsideModes.OnEnterOrSpaceMode && isEnterOrSpace && isSource(component, simulatedEvent)) {\n            optFocusIn(keyingConfig).each(focusIn => {\n              focusIn(component, keyingConfig, keyingState);\n              simulatedEvent.stop();\n            });\n          }\n        };\n        const keyboardEvents = [\n          run$1(keydown(), (component, simulatedEvent) => {\n            processKey(component, simulatedEvent, getKeydownRules, keyingConfig, keyingState).fold(() => {\n              tryGoInsideComponent(component, simulatedEvent);\n            }, _ => {\n              simulatedEvent.stop();\n            });\n          }),\n          run$1(keyup(), (component, simulatedEvent) => {\n            processKey(component, simulatedEvent, getKeyupRules, keyingConfig, keyingState).each(_ => {\n              simulatedEvent.stop();\n            });\n          })\n        ];\n        return derive$2(onFocusHandler.toArray().concat(keyboardEvents));\n      };\n      const me = {\n        schema,\n        processKey,\n        toEvents\n      };\n      return me;\n    };\n\n    const create$2 = cyclicField => {\n      const schema = [\n        option$3('onEscape'),\n        option$3('onEnter'),\n        defaulted('selector', '[data-alloy-tabstop=\"true\"]:not(:disabled)'),\n        defaulted('firstTabstop', 0),\n        defaulted('useTabstopAt', always),\n        option$3('visibilitySelector')\n      ].concat([cyclicField]);\n      const isVisible = (tabbingConfig, element) => {\n        const target = tabbingConfig.visibilitySelector.bind(sel => closest$1(element, sel)).getOr(element);\n        return get$e(target) > 0;\n      };\n      const findInitial = (component, tabbingConfig) => {\n        const tabstops = descendants(component.element, tabbingConfig.selector);\n        const visibles = filter$2(tabstops, elem => isVisible(tabbingConfig, elem));\n        return Optional.from(visibles[tabbingConfig.firstTabstop]);\n      };\n      const findCurrent = (component, tabbingConfig) => tabbingConfig.focusManager.get(component).bind(elem => closest$1(elem, tabbingConfig.selector));\n      const isTabstop = (tabbingConfig, element) => isVisible(tabbingConfig, element) && tabbingConfig.useTabstopAt(element);\n      const focusIn = (component, tabbingConfig, _tabbingState) => {\n        findInitial(component, tabbingConfig).each(target => {\n          tabbingConfig.focusManager.set(component, target);\n        });\n      };\n      const goFromTabstop = (component, tabstops, stopIndex, tabbingConfig, cycle) => cycle(tabstops, stopIndex, elem => isTabstop(tabbingConfig, elem)).fold(() => tabbingConfig.cyclic ? Optional.some(true) : Optional.none(), target => {\n        tabbingConfig.focusManager.set(component, target);\n        return Optional.some(true);\n      });\n      const go = (component, _simulatedEvent, tabbingConfig, cycle) => {\n        const tabstops = descendants(component.element, tabbingConfig.selector);\n        return findCurrent(component, tabbingConfig).bind(tabstop => {\n          const optStopIndex = findIndex$1(tabstops, curry(eq, tabstop));\n          return optStopIndex.bind(stopIndex => goFromTabstop(component, tabstops, stopIndex, tabbingConfig, cycle));\n        });\n      };\n      const goBackwards = (component, simulatedEvent, tabbingConfig) => {\n        const navigate = tabbingConfig.cyclic ? cyclePrev : tryPrev;\n        return go(component, simulatedEvent, tabbingConfig, navigate);\n      };\n      const goForwards = (component, simulatedEvent, tabbingConfig) => {\n        const navigate = tabbingConfig.cyclic ? cycleNext : tryNext;\n        return go(component, simulatedEvent, tabbingConfig, navigate);\n      };\n      const isFirstChild = elem => parentNode(elem).bind(firstChild).exists(child => eq(child, elem));\n      const goFromPseudoTabstop = (component, simulatedEvent, tabbingConfig) => findCurrent(component, tabbingConfig).filter(elem => !tabbingConfig.useTabstopAt(elem)).bind(elem => (isFirstChild(elem) ? goBackwards : goForwards)(component, simulatedEvent, tabbingConfig));\n      const execute = (component, simulatedEvent, tabbingConfig) => tabbingConfig.onEnter.bind(f => f(component, simulatedEvent));\n      const exit = (component, simulatedEvent, tabbingConfig) => tabbingConfig.onEscape.bind(f => f(component, simulatedEvent));\n      const getKeydownRules = constant$1([\n        rule(and([\n          isShift$1,\n          inSet(TAB)\n        ]), goBackwards),\n        rule(inSet(TAB), goForwards),\n        rule(and([\n          isNotShift,\n          inSet(ENTER)\n        ]), execute)\n      ]);\n      const getKeyupRules = constant$1([\n        rule(inSet(ESCAPE), exit),\n        rule(inSet(TAB), goFromPseudoTabstop)\n      ]);\n      return typical(schema, NoState.init, getKeydownRules, getKeyupRules, () => Optional.some(focusIn));\n    };\n\n    var AcyclicType = create$2(customField('cyclic', never));\n\n    var CyclicType = create$2(customField('cyclic', always));\n\n    const doDefaultExecute = (component, _simulatedEvent, focused) => {\n      dispatch(component, focused, execute$5());\n      return Optional.some(true);\n    };\n    const defaultExecute = (component, simulatedEvent, focused) => {\n      const isComplex = inside(focused) && inSet(SPACE)(simulatedEvent.event);\n      return isComplex ? Optional.none() : doDefaultExecute(component, simulatedEvent, focused);\n    };\n    const stopEventForFirefox = (_component, _simulatedEvent) => Optional.some(true);\n\n    const schema$v = [\n      defaulted('execute', defaultExecute),\n      defaulted('useSpace', false),\n      defaulted('useEnter', true),\n      defaulted('useControlEnter', false),\n      defaulted('useDown', false)\n    ];\n    const execute$4 = (component, simulatedEvent, executeConfig) => executeConfig.execute(component, simulatedEvent, component.element);\n    const getKeydownRules$5 = (component, _simulatedEvent, executeConfig, _executeState) => {\n      const spaceExec = executeConfig.useSpace && !inside(component.element) ? SPACE : [];\n      const enterExec = executeConfig.useEnter ? ENTER : [];\n      const downExec = executeConfig.useDown ? DOWN : [];\n      const execKeys = spaceExec.concat(enterExec).concat(downExec);\n      return [rule(inSet(execKeys), execute$4)].concat(executeConfig.useControlEnter ? [rule(and([\n          isControl,\n          inSet(ENTER)\n        ]), execute$4)] : []);\n    };\n    const getKeyupRules$5 = (component, _simulatedEvent, executeConfig, _executeState) => executeConfig.useSpace && !inside(component.element) ? [rule(inSet(SPACE), stopEventForFirefox)] : [];\n    var ExecutionType = typical(schema$v, NoState.init, getKeydownRules$5, getKeyupRules$5, () => Optional.none());\n\n    const flatgrid$1 = () => {\n      const dimensions = value$4();\n      const setGridSize = (numRows, numColumns) => {\n        dimensions.set({\n          numRows,\n          numColumns\n        });\n      };\n      const getNumRows = () => dimensions.get().map(d => d.numRows);\n      const getNumColumns = () => dimensions.get().map(d => d.numColumns);\n      return nu$7({\n        readState: () => dimensions.get().map(d => ({\n          numRows: String(d.numRows),\n          numColumns: String(d.numColumns)\n        })).getOr({\n          numRows: '?',\n          numColumns: '?'\n        }),\n        setGridSize,\n        getNumRows,\n        getNumColumns\n      });\n    };\n    const init$c = spec => spec.state(spec);\n\n    var KeyingState = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        flatgrid: flatgrid$1,\n        init: init$c\n    });\n\n    const useH = movement => (component, simulatedEvent, config, state) => {\n      const move = movement(component.element);\n      return use(move, component, simulatedEvent, config, state);\n    };\n    const west$1 = (moveLeft, moveRight) => {\n      const movement = onDirection(moveLeft, moveRight);\n      return useH(movement);\n    };\n    const east$1 = (moveLeft, moveRight) => {\n      const movement = onDirection(moveRight, moveLeft);\n      return useH(movement);\n    };\n    const useV = move => (component, simulatedEvent, config, state) => use(move, component, simulatedEvent, config, state);\n    const use = (move, component, simulatedEvent, config, state) => {\n      const outcome = config.focusManager.get(component).bind(focused => move(component.element, focused, config, state));\n      return outcome.map(newFocus => {\n        config.focusManager.set(component, newFocus);\n        return true;\n      });\n    };\n    const north$1 = useV;\n    const south$1 = useV;\n    const move$1 = useV;\n\n    const isHidden$1 = dom => dom.offsetWidth <= 0 && dom.offsetHeight <= 0;\n    const isVisible = element => !isHidden$1(element.dom);\n\n    const locate = (candidates, predicate) => findIndex$1(candidates, predicate).map(index => ({\n      index,\n      candidates\n    }));\n\n    const locateVisible = (container, current, selector) => {\n      const predicate = x => eq(x, current);\n      const candidates = descendants(container, selector);\n      const visible = filter$2(candidates, isVisible);\n      return locate(visible, predicate);\n    };\n    const findIndex = (elements, target) => findIndex$1(elements, elem => eq(target, elem));\n\n    const withGrid = (values, index, numCols, f) => {\n      const oldRow = Math.floor(index / numCols);\n      const oldColumn = index % numCols;\n      return f(oldRow, oldColumn).bind(address => {\n        const newIndex = address.row * numCols + address.column;\n        return newIndex >= 0 && newIndex < values.length ? Optional.some(values[newIndex]) : Optional.none();\n      });\n    };\n    const cycleHorizontal$1 = (values, index, numRows, numCols, delta) => withGrid(values, index, numCols, (oldRow, oldColumn) => {\n      const onLastRow = oldRow === numRows - 1;\n      const colsInRow = onLastRow ? values.length - oldRow * numCols : numCols;\n      const newColumn = cycleBy(oldColumn, delta, 0, colsInRow - 1);\n      return Optional.some({\n        row: oldRow,\n        column: newColumn\n      });\n    });\n    const cycleVertical$1 = (values, index, numRows, numCols, delta) => withGrid(values, index, numCols, (oldRow, oldColumn) => {\n      const newRow = cycleBy(oldRow, delta, 0, numRows - 1);\n      const onLastRow = newRow === numRows - 1;\n      const colsInRow = onLastRow ? values.length - newRow * numCols : numCols;\n      const newCol = clamp(oldColumn, 0, colsInRow - 1);\n      return Optional.some({\n        row: newRow,\n        column: newCol\n      });\n    });\n    const cycleRight$1 = (values, index, numRows, numCols) => cycleHorizontal$1(values, index, numRows, numCols, +1);\n    const cycleLeft$1 = (values, index, numRows, numCols) => cycleHorizontal$1(values, index, numRows, numCols, -1);\n    const cycleUp$1 = (values, index, numRows, numCols) => cycleVertical$1(values, index, numRows, numCols, -1);\n    const cycleDown$1 = (values, index, numRows, numCols) => cycleVertical$1(values, index, numRows, numCols, +1);\n\n    const schema$u = [\n      required$1('selector'),\n      defaulted('execute', defaultExecute),\n      onKeyboardHandler('onEscape'),\n      defaulted('captureTab', false),\n      initSize()\n    ];\n    const focusIn$3 = (component, gridConfig, _gridState) => {\n      descendant(component.element, gridConfig.selector).each(first => {\n        gridConfig.focusManager.set(component, first);\n      });\n    };\n    const findCurrent$1 = (component, gridConfig) => gridConfig.focusManager.get(component).bind(elem => closest$1(elem, gridConfig.selector));\n    const execute$3 = (component, simulatedEvent, gridConfig, _gridState) => findCurrent$1(component, gridConfig).bind(focused => gridConfig.execute(component, simulatedEvent, focused));\n    const doMove$2 = cycle => (element, focused, gridConfig, gridState) => locateVisible(element, focused, gridConfig.selector).bind(identified => cycle(identified.candidates, identified.index, gridState.getNumRows().getOr(gridConfig.initSize.numRows), gridState.getNumColumns().getOr(gridConfig.initSize.numColumns)));\n    const handleTab = (_component, _simulatedEvent, gridConfig) => gridConfig.captureTab ? Optional.some(true) : Optional.none();\n    const doEscape$1 = (component, simulatedEvent, gridConfig) => gridConfig.onEscape(component, simulatedEvent);\n    const moveLeft$3 = doMove$2(cycleLeft$1);\n    const moveRight$3 = doMove$2(cycleRight$1);\n    const moveNorth$1 = doMove$2(cycleUp$1);\n    const moveSouth$1 = doMove$2(cycleDown$1);\n    const getKeydownRules$4 = constant$1([\n      rule(inSet(LEFT), west$1(moveLeft$3, moveRight$3)),\n      rule(inSet(RIGHT), east$1(moveLeft$3, moveRight$3)),\n      rule(inSet(UP), north$1(moveNorth$1)),\n      rule(inSet(DOWN), south$1(moveSouth$1)),\n      rule(and([\n        isShift$1,\n        inSet(TAB)\n      ]), handleTab),\n      rule(and([\n        isNotShift,\n        inSet(TAB)\n      ]), handleTab),\n      rule(inSet(SPACE.concat(ENTER)), execute$3)\n    ]);\n    const getKeyupRules$4 = constant$1([\n      rule(inSet(ESCAPE), doEscape$1),\n      rule(inSet(SPACE), stopEventForFirefox)\n    ]);\n    var FlatgridType = typical(schema$u, flatgrid$1, getKeydownRules$4, getKeyupRules$4, () => Optional.some(focusIn$3));\n\n    const f = (container, selector, current, delta, getNewIndex) => {\n      const isDisabledButton = candidate => name$3(candidate) === 'button' && get$g(candidate, 'disabled') === 'disabled';\n      const tryNewIndex = (initial, index, candidates) => getNewIndex(initial, index, delta, 0, candidates.length - 1, candidates[index], newIndex => isDisabledButton(candidates[newIndex]) ? tryNewIndex(initial, newIndex, candidates) : Optional.from(candidates[newIndex]));\n      return locateVisible(container, current, selector).bind(identified => {\n        const index = identified.index;\n        const candidates = identified.candidates;\n        return tryNewIndex(index, index, candidates);\n      });\n    };\n    const horizontalWithoutCycles = (container, selector, current, delta) => f(container, selector, current, delta, (prevIndex, v, d, min, max, oldCandidate, onNewIndex) => {\n      const newIndex = clamp(v + d, min, max);\n      return newIndex === prevIndex ? Optional.from(oldCandidate) : onNewIndex(newIndex);\n    });\n    const horizontal = (container, selector, current, delta) => f(container, selector, current, delta, (prevIndex, v, d, min, max, _oldCandidate, onNewIndex) => {\n      const newIndex = cycleBy(v, d, min, max);\n      return newIndex === prevIndex ? Optional.none() : onNewIndex(newIndex);\n    });\n\n    const schema$t = [\n      required$1('selector'),\n      defaulted('getInitial', Optional.none),\n      defaulted('execute', defaultExecute),\n      onKeyboardHandler('onEscape'),\n      defaulted('executeOnMove', false),\n      defaulted('allowVertical', true),\n      defaulted('allowHorizontal', true),\n      defaulted('cycles', true)\n    ];\n    const findCurrent = (component, flowConfig) => flowConfig.focusManager.get(component).bind(elem => closest$1(elem, flowConfig.selector));\n    const execute$2 = (component, simulatedEvent, flowConfig) => findCurrent(component, flowConfig).bind(focused => flowConfig.execute(component, simulatedEvent, focused));\n    const focusIn$2 = (component, flowConfig, _state) => {\n      flowConfig.getInitial(component).orThunk(() => descendant(component.element, flowConfig.selector)).each(first => {\n        flowConfig.focusManager.set(component, first);\n      });\n    };\n    const moveLeft$2 = (element, focused, info) => (info.cycles ? horizontal : horizontalWithoutCycles)(element, info.selector, focused, -1);\n    const moveRight$2 = (element, focused, info) => (info.cycles ? horizontal : horizontalWithoutCycles)(element, info.selector, focused, +1);\n    const doMove$1 = movement => (component, simulatedEvent, flowConfig, flowState) => movement(component, simulatedEvent, flowConfig, flowState).bind(() => flowConfig.executeOnMove ? execute$2(component, simulatedEvent, flowConfig) : Optional.some(true));\n    const doEscape = (component, simulatedEvent, flowConfig) => flowConfig.onEscape(component, simulatedEvent);\n    const getKeydownRules$3 = (_component, _se, flowConfig, _flowState) => {\n      const westMovers = [...flowConfig.allowHorizontal ? LEFT : []].concat(flowConfig.allowVertical ? UP : []);\n      const eastMovers = [...flowConfig.allowHorizontal ? RIGHT : []].concat(flowConfig.allowVertical ? DOWN : []);\n      return [\n        rule(inSet(westMovers), doMove$1(west$1(moveLeft$2, moveRight$2))),\n        rule(inSet(eastMovers), doMove$1(east$1(moveLeft$2, moveRight$2))),\n        rule(inSet(ENTER), execute$2),\n        rule(inSet(SPACE), execute$2)\n      ];\n    };\n    const getKeyupRules$3 = constant$1([\n      rule(inSet(SPACE), stopEventForFirefox),\n      rule(inSet(ESCAPE), doEscape)\n    ]);\n    var FlowType = typical(schema$t, NoState.init, getKeydownRules$3, getKeyupRules$3, () => Optional.some(focusIn$2));\n\n    const toCell = (matrix, rowIndex, columnIndex) => Optional.from(matrix[rowIndex]).bind(row => Optional.from(row[columnIndex]).map(cell => ({\n      rowIndex,\n      columnIndex,\n      cell\n    })));\n    const cycleHorizontal = (matrix, rowIndex, startCol, deltaCol) => {\n      const row = matrix[rowIndex];\n      const colsInRow = row.length;\n      const newColIndex = cycleBy(startCol, deltaCol, 0, colsInRow - 1);\n      return toCell(matrix, rowIndex, newColIndex);\n    };\n    const cycleVertical = (matrix, colIndex, startRow, deltaRow) => {\n      const nextRowIndex = cycleBy(startRow, deltaRow, 0, matrix.length - 1);\n      const colsInNextRow = matrix[nextRowIndex].length;\n      const nextColIndex = clamp(colIndex, 0, colsInNextRow - 1);\n      return toCell(matrix, nextRowIndex, nextColIndex);\n    };\n    const moveHorizontal = (matrix, rowIndex, startCol, deltaCol) => {\n      const row = matrix[rowIndex];\n      const colsInRow = row.length;\n      const newColIndex = clamp(startCol + deltaCol, 0, colsInRow - 1);\n      return toCell(matrix, rowIndex, newColIndex);\n    };\n    const moveVertical = (matrix, colIndex, startRow, deltaRow) => {\n      const nextRowIndex = clamp(startRow + deltaRow, 0, matrix.length - 1);\n      const colsInNextRow = matrix[nextRowIndex].length;\n      const nextColIndex = clamp(colIndex, 0, colsInNextRow - 1);\n      return toCell(matrix, nextRowIndex, nextColIndex);\n    };\n    const cycleRight = (matrix, startRow, startCol) => cycleHorizontal(matrix, startRow, startCol, +1);\n    const cycleLeft = (matrix, startRow, startCol) => cycleHorizontal(matrix, startRow, startCol, -1);\n    const cycleUp = (matrix, startRow, startCol) => cycleVertical(matrix, startCol, startRow, -1);\n    const cycleDown = (matrix, startRow, startCol) => cycleVertical(matrix, startCol, startRow, +1);\n    const moveLeft$1 = (matrix, startRow, startCol) => moveHorizontal(matrix, startRow, startCol, -1);\n    const moveRight$1 = (matrix, startRow, startCol) => moveHorizontal(matrix, startRow, startCol, +1);\n    const moveUp$1 = (matrix, startRow, startCol) => moveVertical(matrix, startCol, startRow, -1);\n    const moveDown$1 = (matrix, startRow, startCol) => moveVertical(matrix, startCol, startRow, +1);\n\n    const schema$s = [\n      requiredObjOf('selectors', [\n        required$1('row'),\n        required$1('cell')\n      ]),\n      defaulted('cycles', true),\n      defaulted('previousSelector', Optional.none),\n      defaulted('execute', defaultExecute)\n    ];\n    const focusIn$1 = (component, matrixConfig, _state) => {\n      const focused = matrixConfig.previousSelector(component).orThunk(() => {\n        const selectors = matrixConfig.selectors;\n        return descendant(component.element, selectors.cell);\n      });\n      focused.each(cell => {\n        matrixConfig.focusManager.set(component, cell);\n      });\n    };\n    const execute$1 = (component, simulatedEvent, matrixConfig) => search(component.element).bind(focused => matrixConfig.execute(component, simulatedEvent, focused));\n    const toMatrix = (rows, matrixConfig) => map$2(rows, row => descendants(row, matrixConfig.selectors.cell));\n    const doMove = (ifCycle, ifMove) => (element, focused, matrixConfig) => {\n      const move = matrixConfig.cycles ? ifCycle : ifMove;\n      return closest$1(focused, matrixConfig.selectors.row).bind(inRow => {\n        const cellsInRow = descendants(inRow, matrixConfig.selectors.cell);\n        return findIndex(cellsInRow, focused).bind(colIndex => {\n          const allRows = descendants(element, matrixConfig.selectors.row);\n          return findIndex(allRows, inRow).bind(rowIndex => {\n            const matrix = toMatrix(allRows, matrixConfig);\n            return move(matrix, rowIndex, colIndex).map(next => next.cell);\n          });\n        });\n      });\n    };\n    const moveLeft = doMove(cycleLeft, moveLeft$1);\n    const moveRight = doMove(cycleRight, moveRight$1);\n    const moveNorth = doMove(cycleUp, moveUp$1);\n    const moveSouth = doMove(cycleDown, moveDown$1);\n    const getKeydownRules$2 = constant$1([\n      rule(inSet(LEFT), west$1(moveLeft, moveRight)),\n      rule(inSet(RIGHT), east$1(moveLeft, moveRight)),\n      rule(inSet(UP), north$1(moveNorth)),\n      rule(inSet(DOWN), south$1(moveSouth)),\n      rule(inSet(SPACE.concat(ENTER)), execute$1)\n    ]);\n    const getKeyupRules$2 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);\n    var MatrixType = typical(schema$s, NoState.init, getKeydownRules$2, getKeyupRules$2, () => Optional.some(focusIn$1));\n\n    const schema$r = [\n      required$1('selector'),\n      defaulted('execute', defaultExecute),\n      defaulted('moveOnTab', false)\n    ];\n    const execute = (component, simulatedEvent, menuConfig) => menuConfig.focusManager.get(component).bind(focused => menuConfig.execute(component, simulatedEvent, focused));\n    const focusIn = (component, menuConfig, _state) => {\n      descendant(component.element, menuConfig.selector).each(first => {\n        menuConfig.focusManager.set(component, first);\n      });\n    };\n    const moveUp = (element, focused, info) => horizontal(element, info.selector, focused, -1);\n    const moveDown = (element, focused, info) => horizontal(element, info.selector, focused, +1);\n    const fireShiftTab = (component, simulatedEvent, menuConfig, menuState) => menuConfig.moveOnTab ? move$1(moveUp)(component, simulatedEvent, menuConfig, menuState) : Optional.none();\n    const fireTab = (component, simulatedEvent, menuConfig, menuState) => menuConfig.moveOnTab ? move$1(moveDown)(component, simulatedEvent, menuConfig, menuState) : Optional.none();\n    const getKeydownRules$1 = constant$1([\n      rule(inSet(UP), move$1(moveUp)),\n      rule(inSet(DOWN), move$1(moveDown)),\n      rule(and([\n        isShift$1,\n        inSet(TAB)\n      ]), fireShiftTab),\n      rule(and([\n        isNotShift,\n        inSet(TAB)\n      ]), fireTab),\n      rule(inSet(ENTER), execute),\n      rule(inSet(SPACE), execute)\n    ]);\n    const getKeyupRules$1 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);\n    var MenuType = typical(schema$r, NoState.init, getKeydownRules$1, getKeyupRules$1, () => Optional.some(focusIn));\n\n    const schema$q = [\n      onKeyboardHandler('onSpace'),\n      onKeyboardHandler('onEnter'),\n      onKeyboardHandler('onShiftEnter'),\n      onKeyboardHandler('onLeft'),\n      onKeyboardHandler('onRight'),\n      onKeyboardHandler('onTab'),\n      onKeyboardHandler('onShiftTab'),\n      onKeyboardHandler('onUp'),\n      onKeyboardHandler('onDown'),\n      onKeyboardHandler('onEscape'),\n      defaulted('stopSpaceKeyup', false),\n      option$3('focusIn')\n    ];\n    const getKeydownRules = (component, simulatedEvent, specialInfo) => [\n      rule(inSet(SPACE), specialInfo.onSpace),\n      rule(and([\n        isNotShift,\n        inSet(ENTER)\n      ]), specialInfo.onEnter),\n      rule(and([\n        isShift$1,\n        inSet(ENTER)\n      ]), specialInfo.onShiftEnter),\n      rule(and([\n        isShift$1,\n        inSet(TAB)\n      ]), specialInfo.onShiftTab),\n      rule(and([\n        isNotShift,\n        inSet(TAB)\n      ]), specialInfo.onTab),\n      rule(inSet(UP), specialInfo.onUp),\n      rule(inSet(DOWN), specialInfo.onDown),\n      rule(inSet(LEFT), specialInfo.onLeft),\n      rule(inSet(RIGHT), specialInfo.onRight),\n      rule(inSet(SPACE), specialInfo.onSpace)\n    ];\n    const getKeyupRules = (component, simulatedEvent, specialInfo) => [\n      ...specialInfo.stopSpaceKeyup ? [rule(inSet(SPACE), stopEventForFirefox)] : [],\n      rule(inSet(ESCAPE), specialInfo.onEscape)\n    ];\n    var SpecialType = typical(schema$q, NoState.init, getKeydownRules, getKeyupRules, specialInfo => specialInfo.focusIn);\n\n    const acyclic = AcyclicType.schema();\n    const cyclic = CyclicType.schema();\n    const flow = FlowType.schema();\n    const flatgrid = FlatgridType.schema();\n    const matrix = MatrixType.schema();\n    const execution = ExecutionType.schema();\n    const menu = MenuType.schema();\n    const special = SpecialType.schema();\n\n    var KeyboardBranches = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        acyclic: acyclic,\n        cyclic: cyclic,\n        flow: flow,\n        flatgrid: flatgrid,\n        matrix: matrix,\n        execution: execution,\n        menu: menu,\n        special: special\n    });\n\n    const isFlatgridState = keyState => hasNonNullableKey(keyState, 'setGridSize');\n    const Keying = createModes({\n      branchKey: 'mode',\n      branches: KeyboardBranches,\n      name: 'keying',\n      active: {\n        events: (keyingConfig, keyingState) => {\n          const handler = keyingConfig.handler;\n          return handler.toEvents(keyingConfig, keyingState);\n        }\n      },\n      apis: {\n        focusIn: (component, keyConfig, keyState) => {\n          keyConfig.sendFocusIn(keyConfig).fold(() => {\n            component.getSystem().triggerFocus(component.element, component.element);\n          }, sendFocusIn => {\n            sendFocusIn(component, keyConfig, keyState);\n          });\n        },\n        setGridSize: (component, keyConfig, keyState, numRows, numColumns) => {\n          if (!isFlatgridState(keyState)) {\n            console.error('Layout does not support setGridSize');\n          } else {\n            keyState.setGridSize(numRows, numColumns);\n          }\n        }\n      },\n      state: KeyingState\n    });\n\n    const withoutReuse = (parent, data) => {\n      preserve$1(() => {\n        replaceChildren(parent, data, () => map$2(data, parent.getSystem().build));\n      }, parent.element);\n    };\n    const withReuse = (parent, data) => {\n      preserve$1(() => {\n        virtualReplaceChildren(parent, data, () => {\n          return patchSpecChildren(parent.element, data, parent.getSystem().buildOrPatch);\n        });\n      }, parent.element);\n    };\n\n    const virtualReplace = (component, replacee, replaceeIndex, childSpec) => {\n      virtualDetach(replacee);\n      const child = patchSpecChild(component.element, replaceeIndex, childSpec, component.getSystem().buildOrPatch);\n      virtualAttach(component, child);\n      component.syncComponents();\n    };\n    const insert = (component, insertion, childSpec) => {\n      const child = component.getSystem().build(childSpec);\n      attachWith(component, child, insertion);\n    };\n    const replace = (component, replacee, replaceeIndex, childSpec) => {\n      detach(replacee);\n      insert(component, (p, c) => appendAt(p, c, replaceeIndex), childSpec);\n    };\n    const set$3 = (component, replaceConfig, replaceState, data) => {\n      const replacer = replaceConfig.reuseDom ? withReuse : withoutReuse;\n      return replacer(component, data);\n    };\n    const append = (component, replaceConfig, replaceState, appendee) => {\n      insert(component, append$2, appendee);\n    };\n    const prepend = (component, replaceConfig, replaceState, prependee) => {\n      insert(component, prepend$1, prependee);\n    };\n    const remove$1 = (component, replaceConfig, replaceState, removee) => {\n      const children = contents(component);\n      const foundChild = find$5(children, child => eq(removee.element, child.element));\n      foundChild.each(detach);\n    };\n    const contents = (component, _replaceConfig) => component.components();\n    const replaceAt = (component, replaceConfig, replaceState, replaceeIndex, replacer) => {\n      const children = contents(component);\n      return Optional.from(children[replaceeIndex]).map(replacee => {\n        replacer.fold(() => detach(replacee), r => {\n          const replacer = replaceConfig.reuseDom ? virtualReplace : replace;\n          replacer(component, replacee, replaceeIndex, r);\n        });\n        return replacee;\n      });\n    };\n    const replaceBy = (component, replaceConfig, replaceState, replaceePred, replacer) => {\n      const children = contents(component);\n      return findIndex$1(children, replaceePred).bind(replaceeIndex => replaceAt(component, replaceConfig, replaceState, replaceeIndex, replacer));\n    };\n\n    var ReplaceApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        append: append,\n        prepend: prepend,\n        remove: remove$1,\n        replaceAt: replaceAt,\n        replaceBy: replaceBy,\n        set: set$3,\n        contents: contents\n    });\n\n    const Replacing = create$4({\n      fields: [defaultedBoolean('reuseDom', true)],\n      name: 'replacing',\n      apis: ReplaceApis\n    });\n\n    const events$c = (name, eventHandlers) => {\n      const events = derive$2(eventHandlers);\n      return create$4({\n        fields: [required$1('enabled')],\n        name,\n        active: { events: constant$1(events) }\n      });\n    };\n    const config = (name, eventHandlers) => {\n      const me = events$c(name, eventHandlers);\n      return {\n        key: name,\n        value: {\n          config: {},\n          me,\n          configAsRaw: constant$1({}),\n          initialConfig: {},\n          state: NoState\n        }\n      };\n    };\n\n    const focus$2 = (component, focusConfig) => {\n      if (!focusConfig.ignore) {\n        focus$3(component.element);\n        focusConfig.onFocus(component);\n      }\n    };\n    const blur = (component, focusConfig) => {\n      if (!focusConfig.ignore) {\n        blur$1(component.element);\n      }\n    };\n    const isFocused = component => hasFocus(component.element);\n\n    var FocusApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        focus: focus$2,\n        blur: blur,\n        isFocused: isFocused\n    });\n\n    const exhibit$4 = (base, focusConfig) => {\n      const mod = focusConfig.ignore ? {} : { attributes: { tabindex: '-1' } };\n      return nu$8(mod);\n    };\n    const events$b = focusConfig => derive$2([run$1(focus$4(), (component, simulatedEvent) => {\n        focus$2(component, focusConfig);\n        simulatedEvent.stop();\n      })].concat(focusConfig.stopMousedown ? [run$1(mousedown(), (_, simulatedEvent) => {\n        simulatedEvent.event.prevent();\n      })] : []));\n\n    var ActiveFocus = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        exhibit: exhibit$4,\n        events: events$b\n    });\n\n    var FocusSchema = [\n      onHandler('onFocus'),\n      defaulted('stopMousedown', false),\n      defaulted('ignore', false)\n    ];\n\n    const Focusing = create$4({\n      fields: FocusSchema,\n      name: 'focusing',\n      active: ActiveFocus,\n      apis: FocusApis\n    });\n\n    const SetupBehaviourCellState = initialState => {\n      const init = () => {\n        const cell = Cell(initialState);\n        const get = () => cell.get();\n        const set = newState => cell.set(newState);\n        const clear = () => cell.set(initialState);\n        const readState = () => cell.get();\n        return {\n          get,\n          set,\n          clear,\n          readState\n        };\n      };\n      return { init };\n    };\n\n    const updateAriaState = (component, toggleConfig, toggleState) => {\n      const ariaInfo = toggleConfig.aria;\n      ariaInfo.update(component, ariaInfo, toggleState.get());\n    };\n    const updateClass = (component, toggleConfig, toggleState) => {\n      toggleConfig.toggleClass.each(toggleClass => {\n        if (toggleState.get()) {\n          add$2(component.element, toggleClass);\n        } else {\n          remove$3(component.element, toggleClass);\n        }\n      });\n    };\n    const set$2 = (component, toggleConfig, toggleState, state) => {\n      const initialState = toggleState.get();\n      toggleState.set(state);\n      updateClass(component, toggleConfig, toggleState);\n      updateAriaState(component, toggleConfig, toggleState);\n      if (initialState !== state) {\n        toggleConfig.onToggled(component, state);\n      }\n    };\n    const toggle$2 = (component, toggleConfig, toggleState) => {\n      set$2(component, toggleConfig, toggleState, !toggleState.get());\n    };\n    const on = (component, toggleConfig, toggleState) => {\n      set$2(component, toggleConfig, toggleState, true);\n    };\n    const off = (component, toggleConfig, toggleState) => {\n      set$2(component, toggleConfig, toggleState, false);\n    };\n    const isOn = (component, toggleConfig, toggleState) => toggleState.get();\n    const onLoad = (component, toggleConfig, toggleState) => {\n      set$2(component, toggleConfig, toggleState, toggleConfig.selected);\n    };\n\n    var ToggleApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        onLoad: onLoad,\n        toggle: toggle$2,\n        isOn: isOn,\n        on: on,\n        off: off,\n        set: set$2\n    });\n\n    const exhibit$3 = () => nu$8({});\n    const events$a = (toggleConfig, toggleState) => {\n      const execute = executeEvent(toggleConfig, toggleState, toggle$2);\n      const load = loadEvent(toggleConfig, toggleState, onLoad);\n      return derive$2(flatten([\n        toggleConfig.toggleOnExecute ? [execute] : [],\n        [load]\n      ]));\n    };\n\n    var ActiveToggle = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        exhibit: exhibit$3,\n        events: events$a\n    });\n\n    const updatePressed = (component, ariaInfo, status) => {\n      set$9(component.element, 'aria-pressed', status);\n      if (ariaInfo.syncWithExpanded) {\n        updateExpanded(component, ariaInfo, status);\n      }\n    };\n    const updateSelected = (component, ariaInfo, status) => {\n      set$9(component.element, 'aria-selected', status);\n    };\n    const updateChecked = (component, ariaInfo, status) => {\n      set$9(component.element, 'aria-checked', status);\n    };\n    const updateExpanded = (component, ariaInfo, status) => {\n      set$9(component.element, 'aria-expanded', status);\n    };\n\n    var ToggleSchema = [\n      defaulted('selected', false),\n      option$3('toggleClass'),\n      defaulted('toggleOnExecute', true),\n      onHandler('onToggled'),\n      defaultedOf('aria', { mode: 'none' }, choose$1('mode', {\n        pressed: [\n          defaulted('syncWithExpanded', false),\n          output$1('update', updatePressed)\n        ],\n        checked: [output$1('update', updateChecked)],\n        expanded: [output$1('update', updateExpanded)],\n        selected: [output$1('update', updateSelected)],\n        none: [output$1('update', noop)]\n      }))\n    ];\n\n    const Toggling = create$4({\n      fields: ToggleSchema,\n      name: 'toggling',\n      active: ActiveToggle,\n      apis: ToggleApis,\n      state: SetupBehaviourCellState(false)\n    });\n\n    const pointerEvents = () => {\n      const onClick = (component, simulatedEvent) => {\n        simulatedEvent.stop();\n        emitExecute(component);\n      };\n      return [\n        run$1(click(), onClick),\n        run$1(tap(), onClick),\n        cutter(touchstart()),\n        cutter(mousedown())\n      ];\n    };\n    const events$9 = optAction => {\n      const executeHandler = action => runOnExecute$1((component, simulatedEvent) => {\n        action(component);\n        simulatedEvent.stop();\n      });\n      return derive$2(flatten([\n        optAction.map(executeHandler).toArray(),\n        pointerEvents()\n      ]));\n    };\n\n    const hoverEvent = 'alloy.item-hover';\n    const focusEvent = 'alloy.item-focus';\n    const toggledEvent = 'alloy.item-toggled';\n    const onHover = item => {\n      if (search(item.element).isNone() || Focusing.isFocused(item)) {\n        if (!Focusing.isFocused(item)) {\n          Focusing.focus(item);\n        }\n        emitWith(item, hoverEvent, { item });\n      }\n    };\n    const onFocus$1 = item => {\n      emitWith(item, focusEvent, { item });\n    };\n    const onToggled = (item, state) => {\n      emitWith(item, toggledEvent, {\n        item,\n        state\n      });\n    };\n    const hover = constant$1(hoverEvent);\n    const focus$1 = constant$1(focusEvent);\n    const toggled = constant$1(toggledEvent);\n\n    const getItemRole = detail => detail.role.fold(() => detail.toggling.map(toggling => toggling.exclusive ? 'menuitemradio' : 'menuitemcheckbox').getOr('menuitem'), identity);\n    const getTogglingSpec = (tConfig, isOption) => ({\n      aria: { mode: isOption ? 'selected' : 'checked' },\n      ...filter$1(tConfig, (_value, name) => name !== 'exclusive'),\n      onToggled: (component, state) => {\n        if (isFunction(tConfig.onToggled)) {\n          tConfig.onToggled(component, state);\n        }\n        onToggled(component, state);\n      }\n    });\n    const builder$2 = detail => ({\n      dom: detail.dom,\n      domModification: {\n        ...detail.domModification,\n        attributes: {\n          'role': getItemRole(detail),\n          ...detail.domModification.attributes,\n          'aria-haspopup': detail.hasSubmenu,\n          ...detail.hasSubmenu ? { 'aria-expanded': false } : {}\n        }\n      },\n      behaviours: SketchBehaviours.augment(detail.itemBehaviours, [\n        detail.toggling.fold(Toggling.revoke, tConfig => Toggling.config(getTogglingSpec(tConfig, detail.role.exists(role => role === 'option')))),\n        Focusing.config({\n          ignore: detail.ignoreFocus,\n          stopMousedown: detail.ignoreFocus,\n          onFocus: component => {\n            onFocus$1(component);\n          }\n        }),\n        Keying.config({ mode: 'execution' }),\n        Representing.config({\n          store: {\n            mode: 'memory',\n            initialValue: detail.data\n          }\n        }),\n        config('item-type-events', [\n          ...pointerEvents(),\n          run$1(mouseover(), onHover),\n          run$1(focusItem(), Focusing.focus)\n        ])\n      ]),\n      components: detail.components,\n      eventOrder: detail.eventOrder\n    });\n    const schema$p = [\n      required$1('data'),\n      required$1('components'),\n      required$1('dom'),\n      defaulted('hasSubmenu', false),\n      option$3('toggling'),\n      option$3('role'),\n      SketchBehaviours.field('itemBehaviours', [\n        Toggling,\n        Focusing,\n        Keying,\n        Representing\n      ]),\n      defaulted('ignoreFocus', false),\n      defaulted('domModification', {}),\n      output$1('builder', builder$2),\n      defaulted('eventOrder', {})\n    ];\n\n    const builder$1 = detail => ({\n      dom: detail.dom,\n      components: detail.components,\n      events: derive$2([stopper(focusItem())])\n    });\n    const schema$o = [\n      required$1('dom'),\n      required$1('components'),\n      output$1('builder', builder$1)\n    ];\n\n    const owner$2 = constant$1('item-widget');\n    const parts$h = constant$1([required({\n        name: 'widget',\n        overrides: detail => {\n          return {\n            behaviours: derive$1([Representing.config({\n                store: {\n                  mode: 'manual',\n                  getValue: _component => {\n                    return detail.data;\n                  },\n                  setValue: noop\n                }\n              })])\n          };\n        }\n      })]);\n\n    const builder = detail => {\n      const subs = substitutes(owner$2(), detail, parts$h());\n      const components = components$1(owner$2(), detail, subs.internals());\n      const focusWidget = component => getPart(component, detail, 'widget').map(widget => {\n        Keying.focusIn(widget);\n        return widget;\n      });\n      const onHorizontalArrow = (component, simulatedEvent) => inside(simulatedEvent.event.target) ? Optional.none() : (() => {\n        if (detail.autofocus) {\n          simulatedEvent.setSource(component.element);\n          return Optional.none();\n        } else {\n          return Optional.none();\n        }\n      })();\n      return {\n        dom: detail.dom,\n        components,\n        domModification: detail.domModification,\n        events: derive$2([\n          runOnExecute$1((component, simulatedEvent) => {\n            focusWidget(component).each(_widget => {\n              simulatedEvent.stop();\n            });\n          }),\n          run$1(mouseover(), onHover),\n          run$1(focusItem(), (component, _simulatedEvent) => {\n            if (detail.autofocus) {\n              focusWidget(component);\n            } else {\n              Focusing.focus(component);\n            }\n          })\n        ]),\n        behaviours: SketchBehaviours.augment(detail.widgetBehaviours, [\n          Representing.config({\n            store: {\n              mode: 'memory',\n              initialValue: detail.data\n            }\n          }),\n          Focusing.config({\n            ignore: detail.ignoreFocus,\n            onFocus: component => {\n              onFocus$1(component);\n            }\n          }),\n          Keying.config({\n            mode: 'special',\n            focusIn: detail.autofocus ? component => {\n              focusWidget(component);\n            } : revoke(),\n            onLeft: onHorizontalArrow,\n            onRight: onHorizontalArrow,\n            onEscape: (component, simulatedEvent) => {\n              if (!Focusing.isFocused(component) && !detail.autofocus) {\n                Focusing.focus(component);\n                return Optional.some(true);\n              } else if (detail.autofocus) {\n                simulatedEvent.setSource(component.element);\n                return Optional.none();\n              } else {\n                return Optional.none();\n              }\n            }\n          })\n        ])\n      };\n    };\n    const schema$n = [\n      required$1('uid'),\n      required$1('data'),\n      required$1('components'),\n      required$1('dom'),\n      defaulted('autofocus', false),\n      defaulted('ignoreFocus', false),\n      SketchBehaviours.field('widgetBehaviours', [\n        Representing,\n        Focusing,\n        Keying\n      ]),\n      defaulted('domModification', {}),\n      defaultUidsSchema(parts$h()),\n      output$1('builder', builder)\n    ];\n\n    const itemSchema$2 = choose$1('type', {\n      widget: schema$n,\n      item: schema$p,\n      separator: schema$o\n    });\n    const configureGrid = (detail, movementInfo) => ({\n      mode: 'flatgrid',\n      selector: '.' + detail.markers.item,\n      initSize: {\n        numColumns: movementInfo.initSize.numColumns,\n        numRows: movementInfo.initSize.numRows\n      },\n      focusManager: detail.focusManager\n    });\n    const configureMatrix = (detail, movementInfo) => ({\n      mode: 'matrix',\n      selectors: {\n        row: movementInfo.rowSelector,\n        cell: '.' + detail.markers.item\n      },\n      previousSelector: movementInfo.previousSelector,\n      focusManager: detail.focusManager\n    });\n    const configureMenu = (detail, movementInfo) => ({\n      mode: 'menu',\n      selector: '.' + detail.markers.item,\n      moveOnTab: movementInfo.moveOnTab,\n      focusManager: detail.focusManager\n    });\n    const parts$g = constant$1([group({\n        factory: {\n          sketch: spec => {\n            const itemInfo = asRawOrDie$1('menu.spec item', itemSchema$2, spec);\n            return itemInfo.builder(itemInfo);\n          }\n        },\n        name: 'items',\n        unit: 'item',\n        defaults: (detail, u) => {\n          return has$2(u, 'uid') ? u : {\n            ...u,\n            uid: generate$5('item')\n          };\n        },\n        overrides: (detail, u) => {\n          return {\n            type: u.type,\n            ignoreFocus: detail.fakeFocus,\n            domModification: { classes: [detail.markers.item] }\n          };\n        }\n      })]);\n    const schema$m = constant$1([\n      optionString('role'),\n      required$1('value'),\n      required$1('items'),\n      required$1('dom'),\n      required$1('components'),\n      defaulted('eventOrder', {}),\n      field('menuBehaviours', [\n        Highlighting,\n        Representing,\n        Composing,\n        Keying\n      ]),\n      defaultedOf('movement', {\n        mode: 'menu',\n        moveOnTab: true\n      }, choose$1('mode', {\n        grid: [\n          initSize(),\n          output$1('config', configureGrid)\n        ],\n        matrix: [\n          output$1('config', configureMatrix),\n          required$1('rowSelector'),\n          defaulted('previousSelector', Optional.none)\n        ],\n        menu: [\n          defaulted('moveOnTab', true),\n          output$1('config', configureMenu)\n        ]\n      })),\n      itemMarkers(),\n      defaulted('fakeFocus', false),\n      defaulted('focusManager', dom$2()),\n      onHandler('onHighlight'),\n      onHandler('onDehighlight'),\n      defaulted('showMenuRole', true)\n    ]);\n\n    const focus = constant$1('alloy.menu-focus');\n\n    const deselectOtherRadioItems = (menu, item) => {\n      const checkedRadioItems = descendants(menu.element, '[role=\"menuitemradio\"][aria-checked=\"true\"]');\n      each$1(checkedRadioItems, ele => {\n        if (!eq(ele, item.element)) {\n          menu.getSystem().getByDom(ele).each(c => {\n            Toggling.off(c);\n          });\n        }\n      });\n    };\n    const make$7 = (detail, components, _spec, _externals) => ({\n      uid: detail.uid,\n      dom: detail.dom,\n      markers: detail.markers,\n      behaviours: augment(detail.menuBehaviours, [\n        Highlighting.config({\n          highlightClass: detail.markers.selectedItem,\n          itemClass: detail.markers.item,\n          onHighlight: detail.onHighlight,\n          onDehighlight: detail.onDehighlight\n        }),\n        Representing.config({\n          store: {\n            mode: 'memory',\n            initialValue: detail.value\n          }\n        }),\n        Composing.config({ find: Optional.some }),\n        Keying.config(detail.movement.config(detail, detail.movement))\n      ]),\n      events: derive$2([\n        run$1(focus$1(), (menu, simulatedEvent) => {\n          const event = simulatedEvent.event;\n          menu.getSystem().getByDom(event.target).each(item => {\n            Highlighting.highlight(menu, item);\n            simulatedEvent.stop();\n            emitWith(menu, focus(), {\n              menu,\n              item\n            });\n          });\n        }),\n        run$1(hover(), (menu, simulatedEvent) => {\n          const item = simulatedEvent.event.item;\n          Highlighting.highlight(menu, item);\n        }),\n        run$1(toggled(), (menu, simulatedEvent) => {\n          const {item, state} = simulatedEvent.event;\n          if (state && get$g(item.element, 'role') === 'menuitemradio') {\n            deselectOtherRadioItems(menu, item);\n          }\n        })\n      ]),\n      components,\n      eventOrder: detail.eventOrder,\n      ...detail.showMenuRole ? { domModification: { attributes: { role: detail.role.getOr('menu') } } } : {}\n    });\n\n    const Menu = composite({\n      name: 'Menu',\n      configFields: schema$m(),\n      partFields: parts$g(),\n      factory: make$7\n    });\n\n    const transpose$1 = obj => tupleMap(obj, (v, k) => ({\n      k: v,\n      v: k\n    }));\n    const trace = (items, byItem, byMenu, finish) => get$h(byMenu, finish).bind(triggerItem => get$h(items, triggerItem).bind(triggerMenu => {\n      const rest = trace(items, byItem, byMenu, triggerMenu);\n      return Optional.some([triggerMenu].concat(rest));\n    })).getOr([]);\n    const generate$2 = (menus, expansions) => {\n      const items = {};\n      each(menus, (menuItems, menu) => {\n        each$1(menuItems, item => {\n          items[item] = menu;\n        });\n      });\n      const byItem = expansions;\n      const byMenu = transpose$1(expansions);\n      const menuPaths = map$1(byMenu, (_triggerItem, submenu) => [submenu].concat(trace(items, byItem, byMenu, submenu)));\n      return map$1(items, menu => get$h(menuPaths, menu).getOr([menu]));\n    };\n\n    const init$b = () => {\n      const expansions = Cell({});\n      const menus = Cell({});\n      const paths = Cell({});\n      const primary = value$4();\n      const directory = Cell({});\n      const clear = () => {\n        expansions.set({});\n        menus.set({});\n        paths.set({});\n        primary.clear();\n      };\n      const isClear = () => primary.get().isNone();\n      const setMenuBuilt = (menuName, built) => {\n        menus.set({\n          ...menus.get(),\n          [menuName]: {\n            type: 'prepared',\n            menu: built\n          }\n        });\n      };\n      const setContents = (sPrimary, sMenus, sExpansions, dir) => {\n        primary.set(sPrimary);\n        expansions.set(sExpansions);\n        menus.set(sMenus);\n        directory.set(dir);\n        const sPaths = generate$2(dir, sExpansions);\n        paths.set(sPaths);\n      };\n      const getTriggeringItem = menuValue => find$4(expansions.get(), (v, _k) => v === menuValue);\n      const getTriggerData = (menuValue, getItemByValue, path) => getPreparedMenu(menuValue).bind(menu => getTriggeringItem(menuValue).bind(triggeringItemValue => getItemByValue(triggeringItemValue).map(triggeredItem => ({\n        triggeredMenu: menu,\n        triggeringItem: triggeredItem,\n        triggeringPath: path\n      }))));\n      const getTriggeringPath = (itemValue, getItemByValue) => {\n        const extraPath = filter$2(lookupItem(itemValue).toArray(), menuValue => getPreparedMenu(menuValue).isSome());\n        return get$h(paths.get(), itemValue).bind(path => {\n          const revPath = reverse(extraPath.concat(path));\n          const triggers = bind$3(revPath, (menuValue, menuIndex) => getTriggerData(menuValue, getItemByValue, revPath.slice(0, menuIndex + 1)).fold(() => is$1(primary.get(), menuValue) ? [] : [Optional.none()], data => [Optional.some(data)]));\n          return sequence(triggers);\n        });\n      };\n      const expand = itemValue => get$h(expansions.get(), itemValue).map(menu => {\n        const current = get$h(paths.get(), itemValue).getOr([]);\n        return [menu].concat(current);\n      });\n      const collapse = itemValue => get$h(paths.get(), itemValue).bind(path => path.length > 1 ? Optional.some(path.slice(1)) : Optional.none());\n      const refresh = itemValue => get$h(paths.get(), itemValue);\n      const getPreparedMenu = menuValue => lookupMenu(menuValue).bind(extractPreparedMenu);\n      const lookupMenu = menuValue => get$h(menus.get(), menuValue);\n      const lookupItem = itemValue => get$h(expansions.get(), itemValue);\n      const otherMenus = path => {\n        const menuValues = directory.get();\n        return difference(keys(menuValues), path);\n      };\n      const getPrimary = () => primary.get().bind(getPreparedMenu);\n      const getMenus = () => menus.get();\n      return {\n        setMenuBuilt,\n        setContents,\n        expand,\n        refresh,\n        collapse,\n        lookupMenu,\n        lookupItem,\n        otherMenus,\n        getPrimary,\n        getMenus,\n        clear,\n        isClear,\n        getTriggeringPath\n      };\n    };\n    const extractPreparedMenu = prep => prep.type === 'prepared' ? Optional.some(prep.menu) : Optional.none();\n    const LayeredState = {\n      init: init$b,\n      extractPreparedMenu\n    };\n\n    const onMenuItemHighlightedEvent = generate$6('tiered-menu-item-highlight');\n    const onMenuItemDehighlightedEvent = generate$6('tiered-menu-item-dehighlight');\n\n    var HighlightOnOpen;\n    (function (HighlightOnOpen) {\n      HighlightOnOpen[HighlightOnOpen['HighlightMenuAndItem'] = 0] = 'HighlightMenuAndItem';\n      HighlightOnOpen[HighlightOnOpen['HighlightJustMenu'] = 1] = 'HighlightJustMenu';\n      HighlightOnOpen[HighlightOnOpen['HighlightNone'] = 2] = 'HighlightNone';\n    }(HighlightOnOpen || (HighlightOnOpen = {})));\n\n    const make$6 = (detail, _rawUiSpec) => {\n      const submenuParentItems = value$4();\n      const buildMenus = (container, primaryName, menus) => map$1(menus, (spec, name) => {\n        const makeSketch = () => Menu.sketch({\n          ...spec,\n          value: name,\n          markers: detail.markers,\n          fakeFocus: detail.fakeFocus,\n          onHighlight: (menuComp, itemComp) => {\n            const highlightData = {\n              menuComp,\n              itemComp\n            };\n            emitWith(menuComp, onMenuItemHighlightedEvent, highlightData);\n          },\n          onDehighlight: (menuComp, itemComp) => {\n            const dehighlightData = {\n              menuComp,\n              itemComp\n            };\n            emitWith(menuComp, onMenuItemDehighlightedEvent, dehighlightData);\n          },\n          focusManager: detail.fakeFocus ? highlights() : dom$2()\n        });\n        return name === primaryName ? {\n          type: 'prepared',\n          menu: container.getSystem().build(makeSketch())\n        } : {\n          type: 'notbuilt',\n          nbMenu: makeSketch\n        };\n      });\n      const layeredState = LayeredState.init();\n      const setup = container => {\n        const componentMap = buildMenus(container, detail.data.primary, detail.data.menus);\n        const directory = toDirectory();\n        layeredState.setContents(detail.data.primary, componentMap, detail.data.expansions, directory);\n        return layeredState.getPrimary();\n      };\n      const getItemValue = item => Representing.getValue(item).value;\n      const getItemByValue = (_container, menus, itemValue) => findMap(menus, menu => {\n        if (!menu.getSystem().isConnected()) {\n          return Optional.none();\n        }\n        const candidates = Highlighting.getCandidates(menu);\n        return find$5(candidates, c => getItemValue(c) === itemValue);\n      });\n      const toDirectory = _container => map$1(detail.data.menus, (data, _menuName) => bind$3(data.items, item => item.type === 'separator' ? [] : [item.data.value]));\n      const setActiveMenu = Highlighting.highlight;\n      const setActiveMenuAndItem = (container, menu) => {\n        setActiveMenu(container, menu);\n        Highlighting.getHighlighted(menu).orThunk(() => Highlighting.getFirst(menu)).each(item => {\n          if (detail.fakeFocus) {\n            Highlighting.highlight(menu, item);\n          } else {\n            dispatch(container, item.element, focusItem());\n          }\n        });\n      };\n      const getMenus = (state, menuValues) => cat(map$2(menuValues, mv => state.lookupMenu(mv).bind(prep => prep.type === 'prepared' ? Optional.some(prep.menu) : Optional.none())));\n      const closeOthers = (container, state, path) => {\n        const others = getMenus(state, state.otherMenus(path));\n        each$1(others, o => {\n          remove$2(o.element, [detail.markers.backgroundMenu]);\n          if (!detail.stayInDom) {\n            Replacing.remove(container, o);\n          }\n        });\n      };\n      const getSubmenuParents = container => submenuParentItems.get().getOrThunk(() => {\n        const r = {};\n        const items = descendants(container.element, `.${ detail.markers.item }`);\n        const parentItems = filter$2(items, i => get$g(i, 'aria-haspopup') === 'true');\n        each$1(parentItems, i => {\n          container.getSystem().getByDom(i).each(itemComp => {\n            const key = getItemValue(itemComp);\n            r[key] = itemComp;\n          });\n        });\n        submenuParentItems.set(r);\n        return r;\n      });\n      const updateAriaExpansions = (container, path) => {\n        const parentItems = getSubmenuParents(container);\n        each(parentItems, (v, k) => {\n          const expanded = contains$2(path, k);\n          set$9(v.element, 'aria-expanded', expanded);\n        });\n      };\n      const updateMenuPath = (container, state, path) => Optional.from(path[0]).bind(latestMenuName => state.lookupMenu(latestMenuName).bind(menuPrep => {\n        if (menuPrep.type === 'notbuilt') {\n          return Optional.none();\n        } else {\n          const activeMenu = menuPrep.menu;\n          const rest = getMenus(state, path.slice(1));\n          each$1(rest, r => {\n            add$2(r.element, detail.markers.backgroundMenu);\n          });\n          if (!inBody(activeMenu.element)) {\n            Replacing.append(container, premade(activeMenu));\n          }\n          remove$2(activeMenu.element, [detail.markers.backgroundMenu]);\n          setActiveMenuAndItem(container, activeMenu);\n          closeOthers(container, state, path);\n          return Optional.some(activeMenu);\n        }\n      }));\n      let ExpandHighlightDecision;\n      (function (ExpandHighlightDecision) {\n        ExpandHighlightDecision[ExpandHighlightDecision['HighlightSubmenu'] = 0] = 'HighlightSubmenu';\n        ExpandHighlightDecision[ExpandHighlightDecision['HighlightParent'] = 1] = 'HighlightParent';\n      }(ExpandHighlightDecision || (ExpandHighlightDecision = {})));\n      const buildIfRequired = (container, menuName, menuPrep) => {\n        if (menuPrep.type === 'notbuilt') {\n          const menu = container.getSystem().build(menuPrep.nbMenu());\n          layeredState.setMenuBuilt(menuName, menu);\n          return menu;\n        } else {\n          return menuPrep.menu;\n        }\n      };\n      const expandRight = (container, item, decision = ExpandHighlightDecision.HighlightSubmenu) => {\n        if (item.hasConfigured(Disabling) && Disabling.isDisabled(item)) {\n          return Optional.some(item);\n        } else {\n          const value = getItemValue(item);\n          return layeredState.expand(value).bind(path => {\n            updateAriaExpansions(container, path);\n            return Optional.from(path[0]).bind(menuName => layeredState.lookupMenu(menuName).bind(activeMenuPrep => {\n              const activeMenu = buildIfRequired(container, menuName, activeMenuPrep);\n              if (!inBody(activeMenu.element)) {\n                Replacing.append(container, premade(activeMenu));\n              }\n              detail.onOpenSubmenu(container, item, activeMenu, reverse(path));\n              if (decision === ExpandHighlightDecision.HighlightSubmenu) {\n                Highlighting.highlightFirst(activeMenu);\n                return updateMenuPath(container, layeredState, path);\n              } else {\n                Highlighting.dehighlightAll(activeMenu);\n                return Optional.some(item);\n              }\n            }));\n          });\n        }\n      };\n      const collapseLeft = (container, item) => {\n        const value = getItemValue(item);\n        return layeredState.collapse(value).bind(path => {\n          updateAriaExpansions(container, path);\n          return updateMenuPath(container, layeredState, path).map(activeMenu => {\n            detail.onCollapseMenu(container, item, activeMenu);\n            return activeMenu;\n          });\n        });\n      };\n      const updateView = (container, item) => {\n        const value = getItemValue(item);\n        return layeredState.refresh(value).bind(path => {\n          updateAriaExpansions(container, path);\n          return updateMenuPath(container, layeredState, path);\n        });\n      };\n      const onRight = (container, item) => inside(item.element) ? Optional.none() : expandRight(container, item, ExpandHighlightDecision.HighlightSubmenu);\n      const onLeft = (container, item) => inside(item.element) ? Optional.none() : collapseLeft(container, item);\n      const onEscape = (container, item) => collapseLeft(container, item).orThunk(() => detail.onEscape(container, item).map(() => container));\n      const keyOnItem = f => (container, simulatedEvent) => {\n        return closest$1(simulatedEvent.getSource(), `.${ detail.markers.item }`).bind(target => container.getSystem().getByDom(target).toOptional().bind(item => f(container, item).map(always)));\n      };\n      const events = derive$2([\n        run$1(focus(), (tmenu, simulatedEvent) => {\n          const item = simulatedEvent.event.item;\n          layeredState.lookupItem(getItemValue(item)).each(() => {\n            const menu = simulatedEvent.event.menu;\n            Highlighting.highlight(tmenu, menu);\n            const value = getItemValue(simulatedEvent.event.item);\n            layeredState.refresh(value).each(path => closeOthers(tmenu, layeredState, path));\n          });\n        }),\n        runOnExecute$1((component, simulatedEvent) => {\n          const target = simulatedEvent.event.target;\n          component.getSystem().getByDom(target).each(item => {\n            const itemValue = getItemValue(item);\n            if (itemValue.indexOf('collapse-item') === 0) {\n              collapseLeft(component, item);\n            }\n            expandRight(component, item, ExpandHighlightDecision.HighlightSubmenu).fold(() => {\n              detail.onExecute(component, item);\n            }, noop);\n          });\n        }),\n        runOnAttached((container, _simulatedEvent) => {\n          setup(container).each(primary => {\n            Replacing.append(container, premade(primary));\n            detail.onOpenMenu(container, primary);\n            if (detail.highlightOnOpen === HighlightOnOpen.HighlightMenuAndItem) {\n              setActiveMenuAndItem(container, primary);\n            } else if (detail.highlightOnOpen === HighlightOnOpen.HighlightJustMenu) {\n              setActiveMenu(container, primary);\n            }\n          });\n        }),\n        run$1(onMenuItemHighlightedEvent, (tmenuComp, se) => {\n          detail.onHighlightItem(tmenuComp, se.event.menuComp, se.event.itemComp);\n        }),\n        run$1(onMenuItemDehighlightedEvent, (tmenuComp, se) => {\n          detail.onDehighlightItem(tmenuComp, se.event.menuComp, se.event.itemComp);\n        }),\n        ...detail.navigateOnHover ? [run$1(hover(), (tmenu, simulatedEvent) => {\n            const item = simulatedEvent.event.item;\n            updateView(tmenu, item);\n            expandRight(tmenu, item, ExpandHighlightDecision.HighlightParent);\n            detail.onHover(tmenu, item);\n          })] : []\n      ]);\n      const getActiveItem = container => Highlighting.getHighlighted(container).bind(Highlighting.getHighlighted);\n      const collapseMenuApi = container => {\n        getActiveItem(container).each(currentItem => {\n          collapseLeft(container, currentItem);\n        });\n      };\n      const highlightPrimary = container => {\n        layeredState.getPrimary().each(primary => {\n          setActiveMenuAndItem(container, primary);\n        });\n      };\n      const extractMenuFromContainer = container => Optional.from(container.components()[0]).filter(comp => get$g(comp.element, 'role') === 'menu');\n      const repositionMenus = container => {\n        const maybeActivePrimary = layeredState.getPrimary().bind(primary => getActiveItem(container).bind(currentItem => {\n          const itemValue = getItemValue(currentItem);\n          const allMenus = values(layeredState.getMenus());\n          const preparedMenus = cat(map$2(allMenus, LayeredState.extractPreparedMenu));\n          return layeredState.getTriggeringPath(itemValue, v => getItemByValue(container, preparedMenus, v));\n        }).map(triggeringPath => ({\n          primary,\n          triggeringPath\n        })));\n        maybeActivePrimary.fold(() => {\n          extractMenuFromContainer(container).each(primaryMenu => {\n            detail.onRepositionMenu(container, primaryMenu, []);\n          });\n        }, ({primary, triggeringPath}) => {\n          detail.onRepositionMenu(container, primary, triggeringPath);\n        });\n      };\n      const apis = {\n        collapseMenu: collapseMenuApi,\n        highlightPrimary,\n        repositionMenus\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        markers: detail.markers,\n        behaviours: augment(detail.tmenuBehaviours, [\n          Keying.config({\n            mode: 'special',\n            onRight: keyOnItem(onRight),\n            onLeft: keyOnItem(onLeft),\n            onEscape: keyOnItem(onEscape),\n            focusIn: (container, _keyInfo) => {\n              layeredState.getPrimary().each(primary => {\n                dispatch(container, primary.element, focusItem());\n              });\n            }\n          }),\n          Highlighting.config({\n            highlightClass: detail.markers.selectedMenu,\n            itemClass: detail.markers.menu\n          }),\n          Composing.config({\n            find: container => {\n              return Highlighting.getHighlighted(container);\n            }\n          }),\n          Replacing.config({})\n        ]),\n        eventOrder: detail.eventOrder,\n        apis,\n        events\n      };\n    };\n    const collapseItem$1 = constant$1('collapse-item');\n\n    const tieredData = (primary, menus, expansions) => ({\n      primary,\n      menus,\n      expansions\n    });\n    const singleData = (name, menu) => ({\n      primary: name,\n      menus: wrap$1(name, menu),\n      expansions: {}\n    });\n    const collapseItem = text => ({\n      value: generate$6(collapseItem$1()),\n      meta: { text }\n    });\n    const tieredMenu = single({\n      name: 'TieredMenu',\n      configFields: [\n        onStrictKeyboardHandler('onExecute'),\n        onStrictKeyboardHandler('onEscape'),\n        onStrictHandler('onOpenMenu'),\n        onStrictHandler('onOpenSubmenu'),\n        onHandler('onRepositionMenu'),\n        onHandler('onCollapseMenu'),\n        defaulted('highlightOnOpen', HighlightOnOpen.HighlightMenuAndItem),\n        requiredObjOf('data', [\n          required$1('primary'),\n          required$1('menus'),\n          required$1('expansions')\n        ]),\n        defaulted('fakeFocus', false),\n        onHandler('onHighlightItem'),\n        onHandler('onDehighlightItem'),\n        onHandler('onHover'),\n        tieredMenuMarkers(),\n        required$1('dom'),\n        defaulted('navigateOnHover', true),\n        defaulted('stayInDom', false),\n        field('tmenuBehaviours', [\n          Keying,\n          Highlighting,\n          Composing,\n          Replacing\n        ]),\n        defaulted('eventOrder', {})\n      ],\n      apis: {\n        collapseMenu: (apis, tmenu) => {\n          apis.collapseMenu(tmenu);\n        },\n        highlightPrimary: (apis, tmenu) => {\n          apis.highlightPrimary(tmenu);\n        },\n        repositionMenus: (apis, tmenu) => {\n          apis.repositionMenus(tmenu);\n        }\n      },\n      factory: make$6,\n      extraApis: {\n        tieredData,\n        singleData,\n        collapseItem\n      }\n    });\n\n    const makeMenu = (detail, menuSandbox, placementSpec, menuSpec, getBounds) => {\n      const lazySink = () => detail.lazySink(menuSandbox);\n      const layouts = menuSpec.type === 'horizontal' ? {\n        layouts: {\n          onLtr: () => belowOrAbove(),\n          onRtl: () => belowOrAboveRtl()\n        }\n      } : {};\n      const isFirstTierSubmenu = triggeringPaths => triggeringPaths.length === 2;\n      const getSubmenuLayouts = triggeringPaths => isFirstTierSubmenu(triggeringPaths) ? layouts : {};\n      return tieredMenu.sketch({\n        dom: { tag: 'div' },\n        data: menuSpec.data,\n        markers: menuSpec.menu.markers,\n        highlightOnOpen: menuSpec.menu.highlightOnOpen,\n        fakeFocus: menuSpec.menu.fakeFocus,\n        onEscape: () => {\n          Sandboxing.close(menuSandbox);\n          detail.onEscape.map(handler => handler(menuSandbox));\n          return Optional.some(true);\n        },\n        onExecute: () => {\n          return Optional.some(true);\n        },\n        onOpenMenu: (tmenu, menu) => {\n          Positioning.positionWithinBounds(lazySink().getOrDie(), menu, placementSpec, getBounds());\n        },\n        onOpenSubmenu: (tmenu, item, submenu, triggeringPaths) => {\n          const sink = lazySink().getOrDie();\n          Positioning.position(sink, submenu, {\n            anchor: {\n              type: 'submenu',\n              item,\n              ...getSubmenuLayouts(triggeringPaths)\n            }\n          });\n        },\n        onRepositionMenu: (tmenu, primaryMenu, submenuTriggers) => {\n          const sink = lazySink().getOrDie();\n          Positioning.positionWithinBounds(sink, primaryMenu, placementSpec, getBounds());\n          each$1(submenuTriggers, st => {\n            const submenuLayouts = getSubmenuLayouts(st.triggeringPath);\n            Positioning.position(sink, st.triggeredMenu, {\n              anchor: {\n                type: 'submenu',\n                item: st.triggeringItem,\n                ...submenuLayouts\n              }\n            });\n          });\n        }\n      });\n    };\n    const factory$o = (detail, spec) => {\n      const isPartOfRelated = (sandbox, queryElem) => {\n        const related = detail.getRelated(sandbox);\n        return related.exists(rel => isPartOf$1(rel, queryElem));\n      };\n      const setContent = (sandbox, thing) => {\n        Sandboxing.setContent(sandbox, thing);\n      };\n      const showAt = (sandbox, thing, placementSpec) => {\n        const getBounds = Optional.none;\n        showWithinBounds(sandbox, thing, placementSpec, getBounds);\n      };\n      const showWithinBounds = (sandbox, thing, placementSpec, getBounds) => {\n        const sink = detail.lazySink(sandbox).getOrDie();\n        Sandboxing.openWhileCloaked(sandbox, thing, () => Positioning.positionWithinBounds(sink, sandbox, placementSpec, getBounds()));\n        Representing.setValue(sandbox, Optional.some({\n          mode: 'position',\n          config: placementSpec,\n          getBounds\n        }));\n      };\n      const showMenuAt = (sandbox, placementSpec, menuSpec) => {\n        showMenuWithinBounds(sandbox, placementSpec, menuSpec, Optional.none);\n      };\n      const showMenuWithinBounds = (sandbox, placementSpec, menuSpec, getBounds) => {\n        const menu = makeMenu(detail, sandbox, placementSpec, menuSpec, getBounds);\n        Sandboxing.open(sandbox, menu);\n        Representing.setValue(sandbox, Optional.some({\n          mode: 'menu',\n          menu\n        }));\n      };\n      const hide = sandbox => {\n        if (Sandboxing.isOpen(sandbox)) {\n          Representing.setValue(sandbox, Optional.none());\n          Sandboxing.close(sandbox);\n        }\n      };\n      const getContent = sandbox => Sandboxing.getState(sandbox);\n      const reposition = sandbox => {\n        if (Sandboxing.isOpen(sandbox)) {\n          Representing.getValue(sandbox).each(state => {\n            switch (state.mode) {\n            case 'menu':\n              Sandboxing.getState(sandbox).each(tieredMenu.repositionMenus);\n              break;\n            case 'position':\n              const sink = detail.lazySink(sandbox).getOrDie();\n              Positioning.positionWithinBounds(sink, sandbox, state.config, state.getBounds());\n              break;\n            }\n          });\n        }\n      };\n      const apis = {\n        setContent,\n        showAt,\n        showWithinBounds,\n        showMenuAt,\n        showMenuWithinBounds,\n        hide,\n        getContent,\n        reposition,\n        isOpen: Sandboxing.isOpen\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        behaviours: augment(detail.inlineBehaviours, [\n          Sandboxing.config({\n            isPartOf: (sandbox, data, queryElem) => {\n              return isPartOf$1(data, queryElem) || isPartOfRelated(sandbox, queryElem);\n            },\n            getAttachPoint: sandbox => {\n              return detail.lazySink(sandbox).getOrDie();\n            },\n            onOpen: sandbox => {\n              detail.onShow(sandbox);\n            },\n            onClose: sandbox => {\n              detail.onHide(sandbox);\n            }\n          }),\n          Representing.config({\n            store: {\n              mode: 'memory',\n              initialValue: Optional.none()\n            }\n          }),\n          Receiving.config({\n            channels: {\n              ...receivingChannel$1({\n                isExtraPart: spec.isExtraPart,\n                ...detail.fireDismissalEventInstead.map(fe => ({ fireEventInstead: { event: fe.event } })).getOr({})\n              }),\n              ...receivingChannel({\n                ...detail.fireRepositionEventInstead.map(fe => ({ fireEventInstead: { event: fe.event } })).getOr({}),\n                doReposition: reposition\n              })\n            }\n          })\n        ]),\n        eventOrder: detail.eventOrder,\n        apis\n      };\n    };\n    const InlineView = single({\n      name: 'InlineView',\n      configFields: [\n        required$1('lazySink'),\n        onHandler('onShow'),\n        onHandler('onHide'),\n        optionFunction('onEscape'),\n        field('inlineBehaviours', [\n          Sandboxing,\n          Representing,\n          Receiving\n        ]),\n        optionObjOf('fireDismissalEventInstead', [defaulted('event', dismissRequested())]),\n        optionObjOf('fireRepositionEventInstead', [defaulted('event', repositionRequested())]),\n        defaulted('getRelated', Optional.none),\n        defaulted('isExtraPart', never),\n        defaulted('eventOrder', Optional.none)\n      ],\n      factory: factory$o,\n      apis: {\n        showAt: (apis, component, anchor, thing) => {\n          apis.showAt(component, anchor, thing);\n        },\n        showWithinBounds: (apis, component, anchor, thing, bounds) => {\n          apis.showWithinBounds(component, anchor, thing, bounds);\n        },\n        showMenuAt: (apis, component, anchor, menuSpec) => {\n          apis.showMenuAt(component, anchor, menuSpec);\n        },\n        showMenuWithinBounds: (apis, component, anchor, menuSpec, bounds) => {\n          apis.showMenuWithinBounds(component, anchor, menuSpec, bounds);\n        },\n        hide: (apis, component) => {\n          apis.hide(component);\n        },\n        isOpen: (apis, component) => apis.isOpen(component),\n        getContent: (apis, component) => apis.getContent(component),\n        setContent: (apis, component, thing) => {\n          apis.setContent(component, thing);\n        },\n        reposition: (apis, component) => {\n          apis.reposition(component);\n        }\n      }\n    });\n\n    var global$9 = tinymce.util.Tools.resolve('tinymce.util.Delay');\n\n    var global$8 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');\n\n    var global$7 = tinymce.util.Tools.resolve('tinymce.EditorManager');\n\n    var global$6 = tinymce.util.Tools.resolve('tinymce.Env');\n\n    var ToolbarMode$1;\n    (function (ToolbarMode) {\n      ToolbarMode['default'] = 'wrap';\n      ToolbarMode['floating'] = 'floating';\n      ToolbarMode['sliding'] = 'sliding';\n      ToolbarMode['scrolling'] = 'scrolling';\n    }(ToolbarMode$1 || (ToolbarMode$1 = {})));\n    var ToolbarLocation$1;\n    (function (ToolbarLocation) {\n      ToolbarLocation['auto'] = 'auto';\n      ToolbarLocation['top'] = 'top';\n      ToolbarLocation['bottom'] = 'bottom';\n    }(ToolbarLocation$1 || (ToolbarLocation$1 = {})));\n    const option$2 = name => editor => editor.options.get(name);\n    const wrapOptional = fn => editor => Optional.from(fn(editor));\n    const register$e = editor => {\n      const isPhone = global$6.deviceType.isPhone();\n      const isMobile = global$6.deviceType.isTablet() || isPhone;\n      const registerOption = editor.options.register;\n      const stringOrFalseProcessor = value => isString(value) || value === false;\n      const stringOrNumberProcessor = value => isString(value) || isNumber(value);\n      registerOption('skin', {\n        processor: value => isString(value) || value === false,\n        default: 'oxide'\n      });\n      registerOption('skin_url', { processor: 'string' });\n      registerOption('height', {\n        processor: stringOrNumberProcessor,\n        default: Math.max(editor.getElement().offsetHeight, 400)\n      });\n      registerOption('width', {\n        processor: stringOrNumberProcessor,\n        default: global$8.DOM.getStyle(editor.getElement(), 'width')\n      });\n      registerOption('min_height', {\n        processor: 'number',\n        default: 100\n      });\n      registerOption('min_width', { processor: 'number' });\n      registerOption('max_height', { processor: 'number' });\n      registerOption('max_width', { processor: 'number' });\n      registerOption('style_formats', { processor: 'object[]' });\n      registerOption('style_formats_merge', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('style_formats_autohide', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('line_height_formats', {\n        processor: 'string',\n        default: '1 1.1 1.2 1.3 1.4 1.5 2'\n      });\n      registerOption('font_family_formats', {\n        processor: 'string',\n        default: 'Andale Mono=andale mono,monospace;' + 'Arial=arial,helvetica,sans-serif;' + 'Arial Black=arial black,sans-serif;' + 'Book Antiqua=book antiqua,palatino,serif;' + 'Comic Sans MS=comic sans ms,sans-serif;' + 'Courier New=courier new,courier,monospace;' + 'Georgia=georgia,palatino,serif;' + 'Helvetica=helvetica,arial,sans-serif;' + 'Impact=impact,sans-serif;' + 'Symbol=symbol;' + 'Tahoma=tahoma,arial,helvetica,sans-serif;' + 'Terminal=terminal,monaco,monospace;' + 'Times New Roman=times new roman,times,serif;' + 'Trebuchet MS=trebuchet ms,geneva,sans-serif;' + 'Verdana=verdana,geneva,sans-serif;' + 'Webdings=webdings;' + 'Wingdings=wingdings,zapf dingbats'\n      });\n      registerOption('font_size_formats', {\n        processor: 'string',\n        default: '8pt 10pt 12pt 14pt 18pt 24pt 36pt'\n      });\n      registerOption('font_size_input_default_unit', {\n        processor: 'string',\n        default: 'pt'\n      });\n      registerOption('block_formats', {\n        processor: 'string',\n        default: 'Paragraph=p;' + 'Heading 1=h1;' + 'Heading 2=h2;' + 'Heading 3=h3;' + 'Heading 4=h4;' + 'Heading 5=h5;' + 'Heading 6=h6;' + 'Preformatted=pre'\n      });\n      registerOption('content_langs', { processor: 'object[]' });\n      registerOption('removed_menuitems', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('menubar', {\n        processor: value => isString(value) || isBoolean(value),\n        default: !isPhone\n      });\n      registerOption('menu', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('toolbar', {\n        processor: value => {\n          if (isBoolean(value) || isString(value) || isArray(value)) {\n            return {\n              value,\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a boolean, string or array.'\n            };\n          }\n        },\n        default: true\n      });\n      range$2(9, num => {\n        registerOption('toolbar' + (num + 1), { processor: 'string' });\n      });\n      registerOption('toolbar_mode', {\n        processor: 'string',\n        default: isMobile ? 'scrolling' : 'floating'\n      });\n      registerOption('toolbar_groups', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('toolbar_location', {\n        processor: 'string',\n        default: ToolbarLocation$1.auto\n      });\n      registerOption('toolbar_persist', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('toolbar_sticky', {\n        processor: 'boolean',\n        default: editor.inline\n      });\n      registerOption('toolbar_sticky_offset', {\n        processor: 'number',\n        default: 0\n      });\n      registerOption('fixed_toolbar_container', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('fixed_toolbar_container_target', { processor: 'object' });\n      registerOption('ui_mode', {\n        processor: 'string',\n        default: 'combined'\n      });\n      registerOption('file_picker_callback', { processor: 'function' });\n      registerOption('file_picker_validator_handler', { processor: 'function' });\n      registerOption('file_picker_types', { processor: 'string' });\n      registerOption('typeahead_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('anchor_top', {\n        processor: stringOrFalseProcessor,\n        default: '#top'\n      });\n      registerOption('anchor_bottom', {\n        processor: stringOrFalseProcessor,\n        default: '#bottom'\n      });\n      registerOption('draggable_modal', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('statusbar', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('elementpath', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('branding', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('promotion', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('resize', {\n        processor: value => value === 'both' || isBoolean(value),\n        default: !global$6.deviceType.isTouch()\n      });\n      registerOption('sidebar_show', { processor: 'string' });\n      registerOption('help_accessibility', {\n        processor: 'boolean',\n        default: editor.hasPlugin('help')\n      });\n      registerOption('default_font_stack', {\n        processor: 'string[]',\n        default: []\n      });\n    };\n    const isReadOnly = option$2('readonly');\n    const getHeightOption = option$2('height');\n    const getWidthOption = option$2('width');\n    const getMinWidthOption = wrapOptional(option$2('min_width'));\n    const getMinHeightOption = wrapOptional(option$2('min_height'));\n    const getMaxWidthOption = wrapOptional(option$2('max_width'));\n    const getMaxHeightOption = wrapOptional(option$2('max_height'));\n    const getUserStyleFormats = wrapOptional(option$2('style_formats'));\n    const shouldMergeStyleFormats = option$2('style_formats_merge');\n    const shouldAutoHideStyleFormats = option$2('style_formats_autohide');\n    const getContentLanguages = option$2('content_langs');\n    const getRemovedMenuItems = option$2('removed_menuitems');\n    const getToolbarMode = option$2('toolbar_mode');\n    const getToolbarGroups = option$2('toolbar_groups');\n    const getToolbarLocation = option$2('toolbar_location');\n    const fixedContainerSelector = option$2('fixed_toolbar_container');\n    const fixedToolbarContainerTarget = option$2('fixed_toolbar_container_target');\n    const isToolbarPersist = option$2('toolbar_persist');\n    const getStickyToolbarOffset = option$2('toolbar_sticky_offset');\n    const getMenubar = option$2('menubar');\n    const getToolbar = option$2('toolbar');\n    const getFilePickerCallback = option$2('file_picker_callback');\n    const getFilePickerValidatorHandler = option$2('file_picker_validator_handler');\n    const getFontSizeInputDefaultUnit = option$2('font_size_input_default_unit');\n    const getFilePickerTypes = option$2('file_picker_types');\n    const useTypeaheadUrls = option$2('typeahead_urls');\n    const getAnchorTop = option$2('anchor_top');\n    const getAnchorBottom = option$2('anchor_bottom');\n    const isDraggableModal$1 = option$2('draggable_modal');\n    const useStatusBar = option$2('statusbar');\n    const useElementPath = option$2('elementpath');\n    const useBranding = option$2('branding');\n    const getResize = option$2('resize');\n    const getPasteAsText = option$2('paste_as_text');\n    const getSidebarShow = option$2('sidebar_show');\n    const promotionEnabled = option$2('promotion');\n    const useHelpAccessibility = option$2('help_accessibility');\n    const getDefaultFontStack = option$2('default_font_stack');\n    const isSkinDisabled = editor => editor.options.get('skin') === false;\n    const isMenubarEnabled = editor => editor.options.get('menubar') !== false;\n    const getSkinUrl = editor => {\n      const skinUrl = editor.options.get('skin_url');\n      if (isSkinDisabled(editor)) {\n        return skinUrl;\n      } else {\n        if (skinUrl) {\n          return editor.documentBaseURI.toAbsolute(skinUrl);\n        } else {\n          const skin = editor.options.get('skin');\n          return global$7.baseURL + '/skins/ui/' + skin;\n        }\n      }\n    };\n    const getSkinUrlOption = editor => Optional.from(editor.options.get('skin_url'));\n    const getLineHeightFormats = editor => editor.options.get('line_height_formats').split(' ');\n    const isToolbarEnabled = editor => {\n      const toolbar = getToolbar(editor);\n      const isToolbarString = isString(toolbar);\n      const isToolbarObjectArray = isArray(toolbar) && toolbar.length > 0;\n      return !isMultipleToolbars(editor) && (isToolbarObjectArray || isToolbarString || toolbar === true);\n    };\n    const getMultipleToolbarsOption = editor => {\n      const toolbars = range$2(9, num => editor.options.get('toolbar' + (num + 1)));\n      const toolbarArray = filter$2(toolbars, isString);\n      return someIf(toolbarArray.length > 0, toolbarArray);\n    };\n    const isMultipleToolbars = editor => getMultipleToolbarsOption(editor).fold(() => {\n      const toolbar = getToolbar(editor);\n      return isArrayOf(toolbar, isString) && toolbar.length > 0;\n    }, always);\n    const isToolbarLocationBottom = editor => getToolbarLocation(editor) === ToolbarLocation$1.bottom;\n    const fixedContainerTarget = editor => {\n      var _a;\n      if (!editor.inline) {\n        return Optional.none();\n      }\n      const selector = (_a = fixedContainerSelector(editor)) !== null && _a !== void 0 ? _a : '';\n      if (selector.length > 0) {\n        return descendant(body(), selector);\n      }\n      const element = fixedToolbarContainerTarget(editor);\n      if (isNonNullable(element)) {\n        return Optional.some(SugarElement.fromDom(element));\n      }\n      return Optional.none();\n    };\n    const useFixedContainer = editor => editor.inline && fixedContainerTarget(editor).isSome();\n    const getUiContainer = editor => {\n      const fixedContainer = fixedContainerTarget(editor);\n      return fixedContainer.getOrThunk(() => getContentContainer(getRootNode(SugarElement.fromDom(editor.getElement()))));\n    };\n    const isDistractionFree = editor => editor.inline && !isMenubarEnabled(editor) && !isToolbarEnabled(editor) && !isMultipleToolbars(editor);\n    const isStickyToolbar = editor => {\n      const isStickyToolbar = editor.options.get('toolbar_sticky');\n      return (isStickyToolbar || editor.inline) && !useFixedContainer(editor) && !isDistractionFree(editor);\n    };\n    const isSplitUiMode = editor => !useFixedContainer(editor) && editor.options.get('ui_mode') === 'split';\n    const getMenus = editor => {\n      const menu = editor.options.get('menu');\n      return map$1(menu, menu => ({\n        ...menu,\n        items: menu.items\n      }));\n    };\n\n    var Options = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        get ToolbarMode () { return ToolbarMode$1; },\n        get ToolbarLocation () { return ToolbarLocation$1; },\n        register: register$e,\n        getSkinUrl: getSkinUrl,\n        getSkinUrlOption: getSkinUrlOption,\n        isReadOnly: isReadOnly,\n        isSkinDisabled: isSkinDisabled,\n        getHeightOption: getHeightOption,\n        getWidthOption: getWidthOption,\n        getMinWidthOption: getMinWidthOption,\n        getMinHeightOption: getMinHeightOption,\n        getMaxWidthOption: getMaxWidthOption,\n        getMaxHeightOption: getMaxHeightOption,\n        getUserStyleFormats: getUserStyleFormats,\n        shouldMergeStyleFormats: shouldMergeStyleFormats,\n        shouldAutoHideStyleFormats: shouldAutoHideStyleFormats,\n        getLineHeightFormats: getLineHeightFormats,\n        getContentLanguages: getContentLanguages,\n        getRemovedMenuItems: getRemovedMenuItems,\n        isMenubarEnabled: isMenubarEnabled,\n        isMultipleToolbars: isMultipleToolbars,\n        isToolbarEnabled: isToolbarEnabled,\n        isToolbarPersist: isToolbarPersist,\n        getMultipleToolbarsOption: getMultipleToolbarsOption,\n        getUiContainer: getUiContainer,\n        useFixedContainer: useFixedContainer,\n        isSplitUiMode: isSplitUiMode,\n        getToolbarMode: getToolbarMode,\n        isDraggableModal: isDraggableModal$1,\n        isDistractionFree: isDistractionFree,\n        isStickyToolbar: isStickyToolbar,\n        getStickyToolbarOffset: getStickyToolbarOffset,\n        getToolbarLocation: getToolbarLocation,\n        isToolbarLocationBottom: isToolbarLocationBottom,\n        getToolbarGroups: getToolbarGroups,\n        getMenus: getMenus,\n        getMenubar: getMenubar,\n        getToolbar: getToolbar,\n        getFilePickerCallback: getFilePickerCallback,\n        getFilePickerTypes: getFilePickerTypes,\n        useTypeaheadUrls: useTypeaheadUrls,\n        getAnchorTop: getAnchorTop,\n        getAnchorBottom: getAnchorBottom,\n        getFilePickerValidatorHandler: getFilePickerValidatorHandler,\n        getFontSizeInputDefaultUnit: getFontSizeInputDefaultUnit,\n        useStatusBar: useStatusBar,\n        useElementPath: useElementPath,\n        promotionEnabled: promotionEnabled,\n        useBranding: useBranding,\n        getResize: getResize,\n        getPasteAsText: getPasteAsText,\n        getSidebarShow: getSidebarShow,\n        useHelpAccessibility: useHelpAccessibility,\n        getDefaultFontStack: getDefaultFontStack\n    });\n\n    const nonScrollingOverflows = [\n      'visible',\n      'hidden',\n      'clip'\n    ];\n    const isScrollingOverflowValue = value => trim$1(value).length > 0 && !contains$2(nonScrollingOverflows, value);\n    const isScroller = elem => {\n      if (isHTMLElement(elem)) {\n        const overflowX = get$f(elem, 'overflow-x');\n        const overflowY = get$f(elem, 'overflow-y');\n        return isScrollingOverflowValue(overflowX) || isScrollingOverflowValue(overflowY);\n      } else {\n        return false;\n      }\n    };\n    const detect = popupSinkElem => {\n      const ancestorsScrollers = ancestors(popupSinkElem, isScroller);\n      const scrollers = ancestorsScrollers.length === 0 ? getShadowRoot(popupSinkElem).map(getShadowHost).map(x => ancestors(x, isScroller)).getOr([]) : ancestorsScrollers;\n      return head(scrollers).map(element => ({\n        element,\n        others: scrollers.slice(1)\n      }));\n    };\n    const detectWhenSplitUiMode = (editor, popupSinkElem) => isSplitUiMode(editor) ? detect(popupSinkElem) : Optional.none();\n    const getBoundsFrom = sc => {\n      const scrollableBoxes = [\n        ...map$2(sc.others, box$1),\n        win()\n      ];\n      return constrainByMany(box$1(sc.element), scrollableBoxes);\n    };\n\n    const factory$n = detail => {\n      const events = events$9(detail.action);\n      const tag = detail.dom.tag;\n      const lookupAttr = attr => get$h(detail.dom, 'attributes').bind(attrs => get$h(attrs, attr));\n      const getModAttributes = () => {\n        if (tag === 'button') {\n          const type = lookupAttr('type').getOr('button');\n          const roleAttrs = lookupAttr('role').map(role => ({ role })).getOr({});\n          return {\n            type,\n            ...roleAttrs\n          };\n        } else {\n          const role = detail.role.getOr(lookupAttr('role').getOr('button'));\n          return { role };\n        }\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components: detail.components,\n        events,\n        behaviours: SketchBehaviours.augment(detail.buttonBehaviours, [\n          Focusing.config({}),\n          Keying.config({\n            mode: 'execution',\n            useSpace: true,\n            useEnter: true\n          })\n        ]),\n        domModification: { attributes: getModAttributes() },\n        eventOrder: detail.eventOrder\n      };\n    };\n    const Button = single({\n      name: 'Button',\n      factory: factory$n,\n      configFields: [\n        defaulted('uid', undefined),\n        required$1('dom'),\n        defaulted('components', []),\n        SketchBehaviours.field('buttonBehaviours', [\n          Focusing,\n          Keying\n        ]),\n        option$3('action'),\n        option$3('role'),\n        defaulted('eventOrder', {})\n      ]\n    });\n\n    const getAttrs = elem => {\n      const attributes = elem.dom.attributes !== undefined ? elem.dom.attributes : [];\n      return foldl(attributes, (b, attr) => {\n        if (attr.name === 'class') {\n          return b;\n        } else {\n          return {\n            ...b,\n            [attr.name]: attr.value\n          };\n        }\n      }, {});\n    };\n    const getClasses = elem => Array.prototype.slice.call(elem.dom.classList, 0);\n    const fromHtml = html => {\n      const elem = SugarElement.fromHtml(html);\n      const children$1 = children(elem);\n      const attrs = getAttrs(elem);\n      const classes = getClasses(elem);\n      const contents = children$1.length === 0 ? {} : { innerHtml: get$8(elem) };\n      return {\n        tag: name$3(elem),\n        classes,\n        attributes: attrs,\n        ...contents\n      };\n    };\n\n    const record = spec => {\n      const uid = isSketchSpec(spec) && hasNonNullableKey(spec, 'uid') ? spec.uid : generate$5('memento');\n      const get = anyInSystem => anyInSystem.getSystem().getByUid(uid).getOrDie();\n      const getOpt = anyInSystem => anyInSystem.getSystem().getByUid(uid).toOptional();\n      const asSpec = () => ({\n        ...spec,\n        uid\n      });\n      return {\n        get,\n        getOpt,\n        asSpec\n      };\n    };\n\n    const exhibit$2 = (base, tabConfig) => nu$8({\n      attributes: wrapAll([{\n          key: tabConfig.tabAttr,\n          value: 'true'\n        }])\n    });\n\n    var ActiveTabstopping = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        exhibit: exhibit$2\n    });\n\n    var TabstopSchema = [defaulted('tabAttr', 'data-alloy-tabstop')];\n\n    const Tabstopping = create$4({\n      fields: TabstopSchema,\n      name: 'tabstopping',\n      active: ActiveTabstopping\n    });\n\n    const ExclusivityChannel = generate$6('tooltip.exclusive');\n    const ShowTooltipEvent = generate$6('tooltip.show');\n    const HideTooltipEvent = generate$6('tooltip.hide');\n    const ImmediateHideTooltipEvent = generate$6('tooltip.immediateHide');\n    const ImmediateShowTooltipEvent = generate$6('tooltip.immediateShow');\n\n    const hideAllExclusive = (component, _tConfig, _tState) => {\n      component.getSystem().broadcastOn([ExclusivityChannel], {});\n    };\n    const setComponents = (component, tConfig, tState, specs) => {\n      tState.getTooltip().each(tooltip => {\n        if (tooltip.getSystem().isConnected()) {\n          Replacing.set(tooltip, specs);\n        }\n      });\n    };\n\n    var TooltippingApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        hideAllExclusive: hideAllExclusive,\n        setComponents: setComponents\n    });\n\n    const events$8 = (tooltipConfig, state) => {\n      const hide = comp => {\n        state.getTooltip().each(p => {\n          if (p.getSystem().isConnected()) {\n            detach(p);\n            tooltipConfig.onHide(comp, p);\n            state.clearTooltip();\n          }\n        });\n        state.clearTimer();\n      };\n      const show = comp => {\n        if (!state.isShowing()) {\n          hideAllExclusive(comp);\n          const sink = tooltipConfig.lazySink(comp).getOrDie();\n          const popup = comp.getSystem().build({\n            dom: tooltipConfig.tooltipDom,\n            components: tooltipConfig.tooltipComponents,\n            events: derive$2(tooltipConfig.mode === 'normal' ? [\n              run$1(mouseover(), _ => {\n                emit(comp, ShowTooltipEvent);\n              }),\n              run$1(mouseout(), _ => {\n                emit(comp, HideTooltipEvent);\n              })\n            ] : []),\n            behaviours: derive$1([Replacing.config({})])\n          });\n          state.setTooltip(popup);\n          attach(sink, popup);\n          tooltipConfig.onShow(comp, popup);\n          Positioning.position(sink, popup, { anchor: tooltipConfig.anchor(comp) });\n        }\n      };\n      const reposition = comp => {\n        state.getTooltip().each(tooltip => {\n          const sink = tooltipConfig.lazySink(comp).getOrDie();\n          Positioning.position(sink, tooltip, { anchor: tooltipConfig.anchor(comp) });\n        });\n      };\n      const getEvents = () => {\n        switch (tooltipConfig.mode) {\n        case 'normal':\n          return [\n            run$1(focusin(), comp => {\n              emit(comp, ImmediateShowTooltipEvent);\n            }),\n            run$1(postBlur(), comp => {\n              emit(comp, ImmediateHideTooltipEvent);\n            }),\n            run$1(mouseover(), comp => {\n              emit(comp, ShowTooltipEvent);\n            }),\n            run$1(mouseout(), comp => {\n              emit(comp, HideTooltipEvent);\n            })\n          ];\n        case 'follow-highlight':\n          return [\n            run$1(highlight$1(), (comp, _se) => {\n              emit(comp, ShowTooltipEvent);\n            }),\n            run$1(dehighlight$1(), comp => {\n              emit(comp, HideTooltipEvent);\n            })\n          ];\n        case 'children-normal':\n          return [\n            run$1(focusin(), (comp, se) => {\n              search(comp.element).each(_ => {\n                if (is(se.event.target, '[data-mce-tooltip]')) {\n                  state.getTooltip().fold(() => {\n                    emit(comp, ImmediateShowTooltipEvent);\n                  }, tooltip => {\n                    if (state.isShowing()) {\n                      tooltipConfig.onShow(comp, tooltip);\n                      reposition(comp);\n                    }\n                  });\n                }\n              });\n            }),\n            run$1(postBlur(), comp => {\n              search(comp.element).fold(() => {\n                emit(comp, ImmediateHideTooltipEvent);\n              }, noop);\n            }),\n            run$1(mouseover(), comp => {\n              descendant(comp.element, '[data-mce-tooltip]:hover').each(_ => {\n                state.getTooltip().fold(() => {\n                  emit(comp, ShowTooltipEvent);\n                }, tooltip => {\n                  if (state.isShowing()) {\n                    tooltipConfig.onShow(comp, tooltip);\n                    reposition(comp);\n                  }\n                });\n              });\n            }),\n            run$1(mouseout(), comp => {\n              descendant(comp.element, '[data-mce-tooltip]:hover').fold(() => {\n                emit(comp, HideTooltipEvent);\n              }, noop);\n            })\n          ];\n        default:\n          return [\n            run$1(focusin(), (comp, se) => {\n              search(comp.element).each(_ => {\n                if (is(se.event.target, '[data-mce-tooltip]')) {\n                  state.getTooltip().fold(() => {\n                    emit(comp, ImmediateShowTooltipEvent);\n                  }, tooltip => {\n                    if (state.isShowing()) {\n                      tooltipConfig.onShow(comp, tooltip);\n                      reposition(comp);\n                    }\n                  });\n                }\n              });\n            }),\n            run$1(postBlur(), comp => {\n              search(comp.element).fold(() => {\n                emit(comp, ImmediateHideTooltipEvent);\n              }, noop);\n            })\n          ];\n        }\n      };\n      return derive$2(flatten([\n        [\n          run$1(ShowTooltipEvent, comp => {\n            state.resetTimer(() => {\n              show(comp);\n            }, tooltipConfig.delayForShow());\n          }),\n          run$1(HideTooltipEvent, comp => {\n            state.resetTimer(() => {\n              hide(comp);\n            }, tooltipConfig.delayForHide());\n          }),\n          run$1(ImmediateShowTooltipEvent, comp => {\n            state.resetTimer(() => {\n              show(comp);\n            }, 0);\n          }),\n          run$1(ImmediateHideTooltipEvent, comp => {\n            state.resetTimer(() => {\n              hide(comp);\n            }, 0);\n          }),\n          run$1(receive(), (comp, message) => {\n            const receivingData = message;\n            if (!receivingData.universal) {\n              if (contains$2(receivingData.channels, ExclusivityChannel)) {\n                hide(comp);\n              }\n            }\n          }),\n          runOnDetached(comp => {\n            hide(comp);\n          })\n        ],\n        getEvents()\n      ]));\n    };\n\n    var ActiveTooltipping = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        events: events$8\n    });\n\n    var TooltippingSchema = [\n      required$1('lazySink'),\n      required$1('tooltipDom'),\n      defaulted('exclusive', true),\n      defaulted('tooltipComponents', []),\n      defaultedFunction('delayForShow', constant$1(300)),\n      defaultedFunction('delayForHide', constant$1(300)),\n      defaultedStringEnum('mode', 'normal', [\n        'normal',\n        'follow-highlight',\n        'children-keyboard-focus',\n        'children-normal'\n      ]),\n      defaulted('anchor', comp => ({\n        type: 'hotspot',\n        hotspot: comp,\n        layouts: {\n          onLtr: constant$1([\n            south$2,\n            north$2,\n            southeast$2,\n            northeast$2,\n            southwest$2,\n            northwest$2\n          ]),\n          onRtl: constant$1([\n            south$2,\n            north$2,\n            southeast$2,\n            northeast$2,\n            southwest$2,\n            northwest$2\n          ])\n        },\n        bubble: nu$5(0, -2, {})\n      })),\n      onHandler('onHide'),\n      onHandler('onShow')\n    ];\n\n    const init$a = () => {\n      const timer = value$4();\n      const popup = value$4();\n      const clearTimer = () => {\n        timer.on(clearTimeout);\n      };\n      const resetTimer = (f, delay) => {\n        clearTimer();\n        timer.set(setTimeout(f, delay));\n      };\n      const readState = constant$1('not-implemented');\n      return nu$7({\n        getTooltip: popup.get,\n        isShowing: popup.isSet,\n        setTooltip: popup.set,\n        clearTooltip: popup.clear,\n        clearTimer,\n        resetTimer,\n        readState\n      });\n    };\n\n    var TooltippingState = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        init: init$a\n    });\n\n    const Tooltipping = create$4({\n      fields: TooltippingSchema,\n      name: 'tooltipping',\n      active: ActiveTooltipping,\n      state: TooltippingState,\n      apis: TooltippingApis\n    });\n\n    const {entries, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor} = Object;\n    let {freeze, seal, create: create$1} = Object;\n    let {apply, construct} = typeof Reflect !== 'undefined' && Reflect;\n    if (!apply) {\n      apply = function apply(fun, thisValue, args) {\n        return fun.apply(thisValue, args);\n      };\n    }\n    if (!freeze) {\n      freeze = function freeze(x) {\n        return x;\n      };\n    }\n    if (!seal) {\n      seal = function seal(x) {\n        return x;\n      };\n    }\n    if (!construct) {\n      construct = function construct(Func, args) {\n        return new Func(...args);\n      };\n    }\n    const arrayForEach = unapply(Array.prototype.forEach);\n    const arrayPop = unapply(Array.prototype.pop);\n    const arrayPush = unapply(Array.prototype.push);\n    const stringToLowerCase = unapply(String.prototype.toLowerCase);\n    const stringToString = unapply(String.prototype.toString);\n    const stringMatch = unapply(String.prototype.match);\n    const stringReplace = unapply(String.prototype.replace);\n    const stringIndexOf = unapply(String.prototype.indexOf);\n    const stringTrim = unapply(String.prototype.trim);\n    const regExpTest = unapply(RegExp.prototype.test);\n    const typeErrorCreate = unconstruct(TypeError);\n    function unapply(func) {\n      return function (thisArg) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        return apply(func, thisArg, args);\n      };\n    }\n    function unconstruct(func) {\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return construct(func, args);\n      };\n    }\n    function addToSet(set, array, transformCaseFunc) {\n      var _transformCaseFunc;\n      transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;\n      if (setPrototypeOf) {\n        setPrototypeOf(set, null);\n      }\n      let l = array.length;\n      while (l--) {\n        let element = array[l];\n        if (typeof element === 'string') {\n          const lcElement = transformCaseFunc(element);\n          if (lcElement !== element) {\n            if (!isFrozen(array)) {\n              array[l] = lcElement;\n            }\n            element = lcElement;\n          }\n        }\n        set[element] = true;\n      }\n      return set;\n    }\n    function clone(object) {\n      const newObject = create$1(null);\n      for (const [property, value] of entries(object)) {\n        newObject[property] = value;\n      }\n      return newObject;\n    }\n    function lookupGetter(object, prop) {\n      while (object !== null) {\n        const desc = getOwnPropertyDescriptor(object, prop);\n        if (desc) {\n          if (desc.get) {\n            return unapply(desc.get);\n          }\n          if (typeof desc.value === 'function') {\n            return unapply(desc.value);\n          }\n        }\n        object = getPrototypeOf(object);\n      }\n      function fallbackValue(element) {\n        console.warn('fallback value for', element);\n        return null;\n      }\n      return fallbackValue;\n    }\n    const html$1 = freeze([\n      'a',\n      'abbr',\n      'acronym',\n      'address',\n      'area',\n      'article',\n      'aside',\n      'audio',\n      'b',\n      'bdi',\n      'bdo',\n      'big',\n      'blink',\n      'blockquote',\n      'body',\n      'br',\n      'button',\n      'canvas',\n      'caption',\n      'center',\n      'cite',\n      'code',\n      'col',\n      'colgroup',\n      'content',\n      'data',\n      'datalist',\n      'dd',\n      'decorator',\n      'del',\n      'details',\n      'dfn',\n      'dialog',\n      'dir',\n      'div',\n      'dl',\n      'dt',\n      'element',\n      'em',\n      'fieldset',\n      'figcaption',\n      'figure',\n      'font',\n      'footer',\n      'form',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'head',\n      'header',\n      'hgroup',\n      'hr',\n      'html',\n      'i',\n      'img',\n      'input',\n      'ins',\n      'kbd',\n      'label',\n      'legend',\n      'li',\n      'main',\n      'map',\n      'mark',\n      'marquee',\n      'menu',\n      'menuitem',\n      'meter',\n      'nav',\n      'nobr',\n      'ol',\n      'optgroup',\n      'option',\n      'output',\n      'p',\n      'picture',\n      'pre',\n      'progress',\n      'q',\n      'rp',\n      'rt',\n      'ruby',\n      's',\n      'samp',\n      'section',\n      'select',\n      'shadow',\n      'small',\n      'source',\n      'spacer',\n      'span',\n      'strike',\n      'strong',\n      'style',\n      'sub',\n      'summary',\n      'sup',\n      'table',\n      'tbody',\n      'td',\n      'template',\n      'textarea',\n      'tfoot',\n      'th',\n      'thead',\n      'time',\n      'tr',\n      'track',\n      'tt',\n      'u',\n      'ul',\n      'var',\n      'video',\n      'wbr'\n    ]);\n    const svg$1 = freeze([\n      'svg',\n      'a',\n      'altglyph',\n      'altglyphdef',\n      'altglyphitem',\n      'animatecolor',\n      'animatemotion',\n      'animatetransform',\n      'circle',\n      'clippath',\n      'defs',\n      'desc',\n      'ellipse',\n      'filter',\n      'font',\n      'g',\n      'glyph',\n      'glyphref',\n      'hkern',\n      'image',\n      'line',\n      'lineargradient',\n      'marker',\n      'mask',\n      'metadata',\n      'mpath',\n      'path',\n      'pattern',\n      'polygon',\n      'polyline',\n      'radialgradient',\n      'rect',\n      'stop',\n      'style',\n      'switch',\n      'symbol',\n      'text',\n      'textpath',\n      'title',\n      'tref',\n      'tspan',\n      'view',\n      'vkern'\n    ]);\n    const svgFilters = freeze([\n      'feBlend',\n      'feColorMatrix',\n      'feComponentTransfer',\n      'feComposite',\n      'feConvolveMatrix',\n      'feDiffuseLighting',\n      'feDisplacementMap',\n      'feDistantLight',\n      'feDropShadow',\n      'feFlood',\n      'feFuncA',\n      'feFuncB',\n      'feFuncG',\n      'feFuncR',\n      'feGaussianBlur',\n      'feImage',\n      'feMerge',\n      'feMergeNode',\n      'feMorphology',\n      'feOffset',\n      'fePointLight',\n      'feSpecularLighting',\n      'feSpotLight',\n      'feTile',\n      'feTurbulence'\n    ]);\n    const svgDisallowed = freeze([\n      'animate',\n      'color-profile',\n      'cursor',\n      'discard',\n      'font-face',\n      'font-face-format',\n      'font-face-name',\n      'font-face-src',\n      'font-face-uri',\n      'foreignobject',\n      'hatch',\n      'hatchpath',\n      'mesh',\n      'meshgradient',\n      'meshpatch',\n      'meshrow',\n      'missing-glyph',\n      'script',\n      'set',\n      'solidcolor',\n      'unknown',\n      'use'\n    ]);\n    const mathMl$1 = freeze([\n      'math',\n      'menclose',\n      'merror',\n      'mfenced',\n      'mfrac',\n      'mglyph',\n      'mi',\n      'mlabeledtr',\n      'mmultiscripts',\n      'mn',\n      'mo',\n      'mover',\n      'mpadded',\n      'mphantom',\n      'mroot',\n      'mrow',\n      'ms',\n      'mspace',\n      'msqrt',\n      'mstyle',\n      'msub',\n      'msup',\n      'msubsup',\n      'mtable',\n      'mtd',\n      'mtext',\n      'mtr',\n      'munder',\n      'munderover',\n      'mprescripts'\n    ]);\n    const mathMlDisallowed = freeze([\n      'maction',\n      'maligngroup',\n      'malignmark',\n      'mlongdiv',\n      'mscarries',\n      'mscarry',\n      'msgroup',\n      'mstack',\n      'msline',\n      'msrow',\n      'semantics',\n      'annotation',\n      'annotation-xml',\n      'mprescripts',\n      'none'\n    ]);\n    const text$1 = freeze(['#text']);\n    const html = freeze([\n      'accept',\n      'action',\n      'align',\n      'alt',\n      'autocapitalize',\n      'autocomplete',\n      'autopictureinpicture',\n      'autoplay',\n      'background',\n      'bgcolor',\n      'border',\n      'capture',\n      'cellpadding',\n      'cellspacing',\n      'checked',\n      'cite',\n      'class',\n      'clear',\n      'color',\n      'cols',\n      'colspan',\n      'controls',\n      'controlslist',\n      'coords',\n      'crossorigin',\n      'datetime',\n      'decoding',\n      'default',\n      'dir',\n      'disabled',\n      'disablepictureinpicture',\n      'disableremoteplayback',\n      'download',\n      'draggable',\n      'enctype',\n      'enterkeyhint',\n      'face',\n      'for',\n      'headers',\n      'height',\n      'hidden',\n      'high',\n      'href',\n      'hreflang',\n      'id',\n      'inputmode',\n      'integrity',\n      'ismap',\n      'kind',\n      'label',\n      'lang',\n      'list',\n      'loading',\n      'loop',\n      'low',\n      'max',\n      'maxlength',\n      'media',\n      'method',\n      'min',\n      'minlength',\n      'multiple',\n      'muted',\n      'name',\n      'nonce',\n      'noshade',\n      'novalidate',\n      'nowrap',\n      'open',\n      'optimum',\n      'pattern',\n      'placeholder',\n      'playsinline',\n      'poster',\n      'preload',\n      'pubdate',\n      'radiogroup',\n      'readonly',\n      'rel',\n      'required',\n      'rev',\n      'reversed',\n      'role',\n      'rows',\n      'rowspan',\n      'spellcheck',\n      'scope',\n      'selected',\n      'shape',\n      'size',\n      'sizes',\n      'span',\n      'srclang',\n      'start',\n      'src',\n      'srcset',\n      'step',\n      'style',\n      'summary',\n      'tabindex',\n      'title',\n      'translate',\n      'type',\n      'usemap',\n      'valign',\n      'value',\n      'width',\n      'xmlns',\n      'slot'\n    ]);\n    const svg = freeze([\n      'accent-height',\n      'accumulate',\n      'additive',\n      'alignment-baseline',\n      'ascent',\n      'attributename',\n      'attributetype',\n      'azimuth',\n      'basefrequency',\n      'baseline-shift',\n      'begin',\n      'bias',\n      'by',\n      'class',\n      'clip',\n      'clippathunits',\n      'clip-path',\n      'clip-rule',\n      'color',\n      'color-interpolation',\n      'color-interpolation-filters',\n      'color-profile',\n      'color-rendering',\n      'cx',\n      'cy',\n      'd',\n      'dx',\n      'dy',\n      'diffuseconstant',\n      'direction',\n      'display',\n      'divisor',\n      'dur',\n      'edgemode',\n      'elevation',\n      'end',\n      'fill',\n      'fill-opacity',\n      'fill-rule',\n      'filter',\n      'filterunits',\n      'flood-color',\n      'flood-opacity',\n      'font-family',\n      'font-size',\n      'font-size-adjust',\n      'font-stretch',\n      'font-style',\n      'font-variant',\n      'font-weight',\n      'fx',\n      'fy',\n      'g1',\n      'g2',\n      'glyph-name',\n      'glyphref',\n      'gradientunits',\n      'gradienttransform',\n      'height',\n      'href',\n      'id',\n      'image-rendering',\n      'in',\n      'in2',\n      'k',\n      'k1',\n      'k2',\n      'k3',\n      'k4',\n      'kerning',\n      'keypoints',\n      'keysplines',\n      'keytimes',\n      'lang',\n      'lengthadjust',\n      'letter-spacing',\n      'kernelmatrix',\n      'kernelunitlength',\n      'lighting-color',\n      'local',\n      'marker-end',\n      'marker-mid',\n      'marker-start',\n      'markerheight',\n      'markerunits',\n      'markerwidth',\n      'maskcontentunits',\n      'maskunits',\n      'max',\n      'mask',\n      'media',\n      'method',\n      'mode',\n      'min',\n      'name',\n      'numoctaves',\n      'offset',\n      'operator',\n      'opacity',\n      'order',\n      'orient',\n      'orientation',\n      'origin',\n      'overflow',\n      'paint-order',\n      'path',\n      'pathlength',\n      'patterncontentunits',\n      'patterntransform',\n      'patternunits',\n      'points',\n      'preservealpha',\n      'preserveaspectratio',\n      'primitiveunits',\n      'r',\n      'rx',\n      'ry',\n      'radius',\n      'refx',\n      'refy',\n      'repeatcount',\n      'repeatdur',\n      'restart',\n      'result',\n      'rotate',\n      'scale',\n      'seed',\n      'shape-rendering',\n      'specularconstant',\n      'specularexponent',\n      'spreadmethod',\n      'startoffset',\n      'stddeviation',\n      'stitchtiles',\n      'stop-color',\n      'stop-opacity',\n      'stroke-dasharray',\n      'stroke-dashoffset',\n      'stroke-linecap',\n      'stroke-linejoin',\n      'stroke-miterlimit',\n      'stroke-opacity',\n      'stroke',\n      'stroke-width',\n      'style',\n      'surfacescale',\n      'systemlanguage',\n      'tabindex',\n      'targetx',\n      'targety',\n      'transform',\n      'transform-origin',\n      'text-anchor',\n      'text-decoration',\n      'text-rendering',\n      'textlength',\n      'type',\n      'u1',\n      'u2',\n      'unicode',\n      'values',\n      'viewbox',\n      'visibility',\n      'version',\n      'vert-adv-y',\n      'vert-origin-x',\n      'vert-origin-y',\n      'width',\n      'word-spacing',\n      'wrap',\n      'writing-mode',\n      'xchannelselector',\n      'ychannelselector',\n      'x',\n      'x1',\n      'x2',\n      'xmlns',\n      'y',\n      'y1',\n      'y2',\n      'z',\n      'zoomandpan'\n    ]);\n    const mathMl = freeze([\n      'accent',\n      'accentunder',\n      'align',\n      'bevelled',\n      'close',\n      'columnsalign',\n      'columnlines',\n      'columnspan',\n      'denomalign',\n      'depth',\n      'dir',\n      'display',\n      'displaystyle',\n      'encoding',\n      'fence',\n      'frame',\n      'height',\n      'href',\n      'id',\n      'largeop',\n      'length',\n      'linethickness',\n      'lspace',\n      'lquote',\n      'mathbackground',\n      'mathcolor',\n      'mathsize',\n      'mathvariant',\n      'maxsize',\n      'minsize',\n      'movablelimits',\n      'notation',\n      'numalign',\n      'open',\n      'rowalign',\n      'rowlines',\n      'rowspacing',\n      'rowspan',\n      'rspace',\n      'rquote',\n      'scriptlevel',\n      'scriptminsize',\n      'scriptsizemultiplier',\n      'selection',\n      'separator',\n      'separators',\n      'stretchy',\n      'subscriptshift',\n      'supscriptshift',\n      'symmetric',\n      'voffset',\n      'width',\n      'xmlns'\n    ]);\n    const xml = freeze([\n      'xlink:href',\n      'xml:id',\n      'xlink:title',\n      'xml:space',\n      'xmlns:xlink'\n    ]);\n    const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm);\n    const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n    const TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\n    const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/);\n    const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/);\n    const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i);\n    const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n    const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g);\n    const DOCTYPE_NAME = seal(/^html$/i);\n    var EXPRESSIONS = Object.freeze({\n      __proto__: null,\n      MUSTACHE_EXPR: MUSTACHE_EXPR,\n      ERB_EXPR: ERB_EXPR,\n      TMPLIT_EXPR: TMPLIT_EXPR,\n      DATA_ATTR: DATA_ATTR,\n      ARIA_ATTR: ARIA_ATTR,\n      IS_ALLOWED_URI: IS_ALLOWED_URI,\n      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE: ATTR_WHITESPACE,\n      DOCTYPE_NAME: DOCTYPE_NAME\n    });\n    const getGlobal = () => typeof window === 'undefined' ? null : window;\n    const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n      if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n        return null;\n      }\n      let suffix = null;\n      const ATTR_NAME = 'data-tt-policy-suffix';\n      if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n        suffix = purifyHostElement.getAttribute(ATTR_NAME);\n      }\n      const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n      try {\n        return trustedTypes.createPolicy(policyName, {\n          createHTML(html) {\n            return html;\n          },\n          createScriptURL(scriptUrl) {\n            return scriptUrl;\n          }\n        });\n      } catch (_) {\n        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n        return null;\n      }\n    };\n    function createDOMPurify() {\n      let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n      const DOMPurify = root => createDOMPurify(root);\n      DOMPurify.version = '3.0.5';\n      DOMPurify.removed = [];\n      if (!window || !window.document || window.document.nodeType !== 9) {\n        DOMPurify.isSupported = false;\n        return DOMPurify;\n      }\n      const originalDocument = window.document;\n      const currentScript = originalDocument.currentScript;\n      let {document} = window;\n      const {DocumentFragment, HTMLTemplateElement, Node, Element, NodeFilter, NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap, HTMLFormElement, DOMParser, trustedTypes} = window;\n      const ElementPrototype = Element.prototype;\n      const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n      const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n      const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n      const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n      if (typeof HTMLTemplateElement === 'function') {\n        const template = document.createElement('template');\n        if (template.content && template.content.ownerDocument) {\n          document = template.content.ownerDocument;\n        }\n      }\n      let trustedTypesPolicy;\n      let emptyHTML = '';\n      const {implementation, createNodeIterator, createDocumentFragment, getElementsByTagName} = document;\n      const {importNode} = originalDocument;\n      let hooks = {};\n      DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n      const {MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR, DATA_ATTR, ARIA_ATTR, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE} = EXPRESSIONS;\n      let {IS_ALLOWED_URI: IS_ALLOWED_URI$1} = EXPRESSIONS;\n      let ALLOWED_TAGS = null;\n      const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n        ...html$1,\n        ...svg$1,\n        ...svgFilters,\n        ...mathMl$1,\n        ...text$1\n      ]);\n      let ALLOWED_ATTR = null;\n      const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n        ...html,\n        ...svg,\n        ...mathMl,\n        ...xml\n      ]);\n      let CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\n        tagNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        attributeNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        allowCustomizedBuiltInElements: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: false\n        }\n      }));\n      let FORBID_TAGS = null;\n      let FORBID_ATTR = null;\n      let ALLOW_ARIA_ATTR = true;\n      let ALLOW_DATA_ATTR = true;\n      let ALLOW_UNKNOWN_PROTOCOLS = false;\n      let ALLOW_SELF_CLOSE_IN_ATTR = true;\n      let SAFE_FOR_TEMPLATES = false;\n      let WHOLE_DOCUMENT = false;\n      let SET_CONFIG = false;\n      let FORCE_BODY = false;\n      let RETURN_DOM = false;\n      let RETURN_DOM_FRAGMENT = false;\n      let RETURN_TRUSTED_TYPE = false;\n      let SANITIZE_DOM = true;\n      let SANITIZE_NAMED_PROPS = false;\n      const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n      let KEEP_CONTENT = true;\n      let IN_PLACE = false;\n      let USE_PROFILES = {};\n      let FORBID_CONTENTS = null;\n      const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n        'annotation-xml',\n        'audio',\n        'colgroup',\n        'desc',\n        'foreignobject',\n        'head',\n        'iframe',\n        'math',\n        'mi',\n        'mn',\n        'mo',\n        'ms',\n        'mtext',\n        'noembed',\n        'noframes',\n        'noscript',\n        'plaintext',\n        'script',\n        'style',\n        'svg',\n        'template',\n        'thead',\n        'title',\n        'video',\n        'xmp'\n      ]);\n      let DATA_URI_TAGS = null;\n      const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n        'audio',\n        'video',\n        'img',\n        'source',\n        'image',\n        'track'\n      ]);\n      let URI_SAFE_ATTRIBUTES = null;\n      const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n        'alt',\n        'class',\n        'for',\n        'id',\n        'label',\n        'name',\n        'pattern',\n        'placeholder',\n        'role',\n        'summary',\n        'title',\n        'value',\n        'style',\n        'xmlns'\n      ]);\n      const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n      const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n      const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n      let NAMESPACE = HTML_NAMESPACE;\n      let IS_EMPTY_INPUT = false;\n      let ALLOWED_NAMESPACES = null;\n      const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [\n        MATHML_NAMESPACE,\n        SVG_NAMESPACE,\n        HTML_NAMESPACE\n      ], stringToString);\n      let PARSER_MEDIA_TYPE;\n      const SUPPORTED_PARSER_MEDIA_TYPES = [\n        'application/xhtml+xml',\n        'text/html'\n      ];\n      const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n      let transformCaseFunc;\n      let CONFIG = null;\n      const formElement = document.createElement('form');\n      const isRegexOrFunction = function isRegexOrFunction(testValue) {\n        return testValue instanceof RegExp || testValue instanceof Function;\n      };\n      const _parseConfig = function _parseConfig(cfg) {\n        if (CONFIG && CONFIG === cfg) {\n          return;\n        }\n        if (!cfg || typeof cfg !== 'object') {\n          cfg = {};\n        }\n        cfg = clone(cfg);\n        PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n        ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n        URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\n        DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\n        FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n        FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n        FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n        USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;\n        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;\n        RETURN_DOM = cfg.RETURN_DOM || false;\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;\n        FORCE_BODY = cfg.FORCE_BODY || false;\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false;\n        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false;\n        IN_PLACE = cfg.IN_PLACE || false;\n        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n          ALLOW_DATA_ATTR = false;\n        }\n        if (RETURN_DOM_FRAGMENT) {\n          RETURN_DOM = true;\n        }\n        if (USE_PROFILES) {\n          ALLOWED_TAGS = addToSet({}, [...text$1]);\n          ALLOWED_ATTR = [];\n          if (USE_PROFILES.html === true) {\n            addToSet(ALLOWED_TAGS, html$1);\n            addToSet(ALLOWED_ATTR, html);\n          }\n          if (USE_PROFILES.svg === true) {\n            addToSet(ALLOWED_TAGS, svg$1);\n            addToSet(ALLOWED_ATTR, svg);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.svgFilters === true) {\n            addToSet(ALLOWED_TAGS, svgFilters);\n            addToSet(ALLOWED_ATTR, svg);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.mathMl === true) {\n            addToSet(ALLOWED_TAGS, mathMl$1);\n            addToSet(ALLOWED_ATTR, mathMl);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n        }\n        if (cfg.ADD_TAGS) {\n          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n            ALLOWED_TAGS = clone(ALLOWED_TAGS);\n          }\n          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n        }\n        if (cfg.ADD_ATTR) {\n          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n            ALLOWED_ATTR = clone(ALLOWED_ATTR);\n          }\n          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n        }\n        if (cfg.ADD_URI_SAFE_ATTR) {\n          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n        }\n        if (cfg.FORBID_CONTENTS) {\n          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n            FORBID_CONTENTS = clone(FORBID_CONTENTS);\n          }\n          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n        }\n        if (KEEP_CONTENT) {\n          ALLOWED_TAGS['#text'] = true;\n        }\n        if (WHOLE_DOCUMENT) {\n          addToSet(ALLOWED_TAGS, [\n            'html',\n            'head',\n            'body'\n          ]);\n        }\n        if (ALLOWED_TAGS.table) {\n          addToSet(ALLOWED_TAGS, ['tbody']);\n          delete FORBID_TAGS.tbody;\n        }\n        if (cfg.TRUSTED_TYPES_POLICY) {\n          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n          }\n          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n          }\n          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n          emptyHTML = trustedTypesPolicy.createHTML('');\n        } else {\n          if (trustedTypesPolicy === undefined) {\n            trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n          }\n          if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n            emptyHTML = trustedTypesPolicy.createHTML('');\n          }\n        }\n        if (freeze) {\n          freeze(cfg);\n        }\n        CONFIG = cfg;\n      };\n      const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n        'mi',\n        'mo',\n        'mn',\n        'ms',\n        'mtext'\n      ]);\n      const HTML_INTEGRATION_POINTS = addToSet({}, [\n        'foreignobject',\n        'desc',\n        'title',\n        'annotation-xml'\n      ]);\n      const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n        'title',\n        'style',\n        'font',\n        'a',\n        'script'\n      ]);\n      const ALL_SVG_TAGS = addToSet({}, svg$1);\n      addToSet(ALL_SVG_TAGS, svgFilters);\n      addToSet(ALL_SVG_TAGS, svgDisallowed);\n      const ALL_MATHML_TAGS = addToSet({}, mathMl$1);\n      addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n      const _checkValidNamespace = function _checkValidNamespace(element) {\n        let parent = getParentNode(element);\n        if (!parent || !parent.tagName) {\n          parent = {\n            namespaceURI: NAMESPACE,\n            tagName: 'template'\n          };\n        }\n        const tagName = stringToLowerCase(element.tagName);\n        const parentTagName = stringToLowerCase(parent.tagName);\n        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n          return false;\n        }\n        if (element.namespaceURI === SVG_NAMESPACE) {\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'svg';\n          }\n          if (parent.namespaceURI === MATHML_NAMESPACE) {\n            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n          }\n          return Boolean(ALL_SVG_TAGS[tagName]);\n        }\n        if (element.namespaceURI === MATHML_NAMESPACE) {\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'math';\n          }\n          if (parent.namespaceURI === SVG_NAMESPACE) {\n            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n          }\n          return Boolean(ALL_MATHML_TAGS[tagName]);\n        }\n        if (element.namespaceURI === HTML_NAMESPACE) {\n          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n        }\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n          return true;\n        }\n        return false;\n      };\n      const _forceRemove = function _forceRemove(node) {\n        arrayPush(DOMPurify.removed, { element: node });\n        try {\n          node.parentNode.removeChild(node);\n        } catch (_) {\n          node.remove();\n        }\n      };\n      const _removeAttribute = function _removeAttribute(name, node) {\n        try {\n          arrayPush(DOMPurify.removed, {\n            attribute: node.getAttributeNode(name),\n            from: node\n          });\n        } catch (_) {\n          arrayPush(DOMPurify.removed, {\n            attribute: null,\n            from: node\n          });\n        }\n        node.removeAttribute(name);\n        if (name === 'is' && !ALLOWED_ATTR[name]) {\n          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n            try {\n              _forceRemove(node);\n            } catch (_) {\n            }\n          } else {\n            try {\n              node.setAttribute(name, '');\n            } catch (_) {\n            }\n          }\n        }\n      };\n      const _initDocument = function _initDocument(dirty) {\n        let doc;\n        let leadingWhitespace;\n        if (FORCE_BODY) {\n          dirty = '<remove></remove>' + dirty;\n        } else {\n          const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n          leadingWhitespace = matches && matches[0];\n        }\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n          dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n        }\n        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        if (NAMESPACE === HTML_NAMESPACE) {\n          try {\n            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n          } catch (_) {\n          }\n        }\n        if (!doc || !doc.documentElement) {\n          doc = implementation.createDocument(NAMESPACE, 'template', null);\n          try {\n            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n          } catch (_) {\n          }\n        }\n        const body = doc.body || doc.documentElement;\n        if (dirty && leadingWhitespace) {\n          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n        }\n        if (NAMESPACE === HTML_NAMESPACE) {\n          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n        }\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\n      };\n      const _createIterator = function _createIterator(root) {\n        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n      };\n      const _isClobbered = function _isClobbered(elm) {\n        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');\n      };\n      const _isNode = function _isNode(object) {\n        return typeof Node === 'object' ? object instanceof Node : object && typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n      };\n      const _executeHook = function _executeHook(entryPoint, currentNode, data) {\n        if (!hooks[entryPoint]) {\n          return;\n        }\n        arrayForEach(hooks[entryPoint], hook => {\n          hook.call(DOMPurify, currentNode, data, CONFIG);\n        });\n      };\n      const _sanitizeElements = function _sanitizeElements(currentNode) {\n        let content;\n        _executeHook('beforeSanitizeElements', currentNode, null);\n        if (_isClobbered(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        const tagName = transformCaseFunc(currentNode.nodeName);\n        _executeHook('uponSanitizeElement', currentNode, {\n          tagName,\n          allowedTags: ALLOWED_TAGS\n        });\n        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))\n              return false;\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))\n              return false;\n          }\n          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n            const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n            const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n            if (childNodes && parentNode) {\n              const childCount = childNodes.length;\n              for (let i = childCount - 1; i >= 0; --i) {\n                parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n              }\n            }\n          }\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n          content = currentNode.textContent;\n          content = stringReplace(content, MUSTACHE_EXPR, ' ');\n          content = stringReplace(content, ERB_EXPR, ' ');\n          content = stringReplace(content, TMPLIT_EXPR, ' ');\n          if (currentNode.textContent !== content) {\n            arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n            currentNode.textContent = content;\n          }\n        }\n        _executeHook('afterSanitizeElements', currentNode, null);\n        return false;\n      };\n      const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n          return false;\n        }\n        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName));\n        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName));\n        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n          if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)));\n          else {\n            return false;\n          }\n        } else if (URI_SAFE_ATTRIBUTES[lcName]);\n        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, '')));\n        else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]);\n        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, '')));\n        else if (value) {\n          return false;\n        } else ;\n        return true;\n      };\n      const _basicCustomElementTest = function _basicCustomElementTest(tagName) {\n        return tagName.indexOf('-') > 0;\n      };\n      const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n        let attr;\n        let value;\n        let lcName;\n        let l;\n        _executeHook('beforeSanitizeAttributes', currentNode, null);\n        const {attributes} = currentNode;\n        if (!attributes) {\n          return;\n        }\n        const hookEvent = {\n          attrName: '',\n          attrValue: '',\n          keepAttr: true,\n          allowedAttributes: ALLOWED_ATTR\n        };\n        l = attributes.length;\n        while (l--) {\n          attr = attributes[l];\n          const {name, namespaceURI} = attr;\n          value = name === 'value' ? attr.value : stringTrim(attr.value);\n          const initValue = value;\n          lcName = transformCaseFunc(name);\n          hookEvent.attrName = lcName;\n          hookEvent.attrValue = value;\n          hookEvent.keepAttr = true;\n          hookEvent.forceKeepAttr = undefined;\n          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n          value = hookEvent.attrValue;\n          if (hookEvent.forceKeepAttr) {\n            continue;\n          }\n          if (!hookEvent.keepAttr) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (SAFE_FOR_TEMPLATES) {\n            value = stringReplace(value, MUSTACHE_EXPR, ' ');\n            value = stringReplace(value, ERB_EXPR, ' ');\n            value = stringReplace(value, TMPLIT_EXPR, ' ');\n          }\n          const lcTag = transformCaseFunc(currentNode.nodeName);\n          if (!_isValidAttribute(lcTag, lcName, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n            _removeAttribute(name, currentNode);\n            value = SANITIZE_NAMED_PROPS_PREFIX + value;\n          }\n          if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n            if (namespaceURI);\n            else {\n              switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n              case 'TrustedHTML': {\n                  value = trustedTypesPolicy.createHTML(value);\n                  break;\n                }\n              case 'TrustedScriptURL': {\n                  value = trustedTypesPolicy.createScriptURL(value);\n                  break;\n                }\n              }\n            }\n          }\n          if (value !== initValue) {\n            try {\n              if (namespaceURI) {\n                currentNode.setAttributeNS(namespaceURI, name, value);\n              } else {\n                currentNode.setAttribute(name, value);\n              }\n            } catch (_) {\n              _removeAttribute(name, currentNode);\n            }\n          }\n        }\n        _executeHook('afterSanitizeAttributes', currentNode, null);\n      };\n      const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n        let shadowNode;\n        const shadowIterator = _createIterator(fragment);\n        _executeHook('beforeSanitizeShadowDOM', fragment, null);\n        while (shadowNode = shadowIterator.nextNode()) {\n          _executeHook('uponSanitizeShadowNode', shadowNode, null);\n          if (_sanitizeElements(shadowNode)) {\n            continue;\n          }\n          if (shadowNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(shadowNode.content);\n          }\n          _sanitizeAttributes(shadowNode);\n        }\n        _executeHook('afterSanitizeShadowDOM', fragment, null);\n      };\n      DOMPurify.sanitize = function (dirty) {\n        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let body;\n        let importedNode;\n        let currentNode;\n        let returnNode;\n        IS_EMPTY_INPUT = !dirty;\n        if (IS_EMPTY_INPUT) {\n          dirty = '<!-->';\n        }\n        if (typeof dirty !== 'string' && !_isNode(dirty)) {\n          if (typeof dirty.toString === 'function') {\n            dirty = dirty.toString();\n            if (typeof dirty !== 'string') {\n              throw typeErrorCreate('dirty is not a string, aborting');\n            }\n          } else {\n            throw typeErrorCreate('toString is not a function');\n          }\n        }\n        if (!DOMPurify.isSupported) {\n          return dirty;\n        }\n        if (!SET_CONFIG) {\n          _parseConfig(cfg);\n        }\n        DOMPurify.removed = [];\n        if (typeof dirty === 'string') {\n          IN_PLACE = false;\n        }\n        if (IN_PLACE) {\n          if (dirty.nodeName) {\n            const tagName = transformCaseFunc(dirty.nodeName);\n            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n            }\n          }\n        } else if (dirty instanceof Node) {\n          body = _initDocument('<!---->');\n          importedNode = body.ownerDocument.importNode(dirty, true);\n          if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n            body = importedNode;\n          } else if (importedNode.nodeName === 'HTML') {\n            body = importedNode;\n          } else {\n            body.appendChild(importedNode);\n          }\n        } else {\n          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {\n            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n          }\n          body = _initDocument(dirty);\n          if (!body) {\n            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n          }\n        }\n        if (body && FORCE_BODY) {\n          _forceRemove(body.firstChild);\n        }\n        const nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n        while (currentNode = nodeIterator.nextNode()) {\n          if (_sanitizeElements(currentNode)) {\n            continue;\n          }\n          if (currentNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(currentNode.content);\n          }\n          _sanitizeAttributes(currentNode);\n        }\n        if (IN_PLACE) {\n          return dirty;\n        }\n        if (RETURN_DOM) {\n          if (RETURN_DOM_FRAGMENT) {\n            returnNode = createDocumentFragment.call(body.ownerDocument);\n            while (body.firstChild) {\n              returnNode.appendChild(body.firstChild);\n            }\n          } else {\n            returnNode = body;\n          }\n          if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n            returnNode = importNode.call(originalDocument, returnNode, true);\n          }\n          return returnNode;\n        }\n        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n          serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR, ' ');\n          serializedHTML = stringReplace(serializedHTML, ERB_EXPR, ' ');\n          serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR, ' ');\n        }\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n      };\n      DOMPurify.setConfig = function (cfg) {\n        _parseConfig(cfg);\n        SET_CONFIG = true;\n      };\n      DOMPurify.clearConfig = function () {\n        CONFIG = null;\n        SET_CONFIG = false;\n      };\n      DOMPurify.isValidAttribute = function (tag, attr, value) {\n        if (!CONFIG) {\n          _parseConfig({});\n        }\n        const lcTag = transformCaseFunc(tag);\n        const lcName = transformCaseFunc(attr);\n        return _isValidAttribute(lcTag, lcName, value);\n      };\n      DOMPurify.addHook = function (entryPoint, hookFunction) {\n        if (typeof hookFunction !== 'function') {\n          return;\n        }\n        hooks[entryPoint] = hooks[entryPoint] || [];\n        arrayPush(hooks[entryPoint], hookFunction);\n      };\n      DOMPurify.removeHook = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          return arrayPop(hooks[entryPoint]);\n        }\n      };\n      DOMPurify.removeHooks = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          hooks[entryPoint] = [];\n        }\n      };\n      DOMPurify.removeAllHooks = function () {\n        hooks = {};\n      };\n      return DOMPurify;\n    }\n    var purify = createDOMPurify();\n\n    const sanitizeHtmlString = html => purify().sanitize(html);\n\n    var global$5 = tinymce.util.Tools.resolve('tinymce.util.I18n');\n\n    const rtlTransform = {\n      'indent': true,\n      'outdent': true,\n      'table-insert-column-after': true,\n      'table-insert-column-before': true,\n      'paste-column-after': true,\n      'paste-column-before': true,\n      'unordered-list': true,\n      'list-bull-circle': true,\n      'list-bull-default': true,\n      'list-bull-square': true\n    };\n    const defaultIconName = 'temporary-placeholder';\n    const defaultIcon = icons => () => get$h(icons, defaultIconName).getOr('!not found!');\n    const getIconName = (name, icons) => {\n      const lcName = name.toLowerCase();\n      if (global$5.isRtl()) {\n        const rtlName = ensureTrailing(lcName, '-rtl');\n        return has$2(icons, rtlName) ? rtlName : lcName;\n      } else {\n        return lcName;\n      }\n    };\n    const lookupIcon = (name, icons) => get$h(icons, getIconName(name, icons));\n    const get$3 = (name, iconProvider) => {\n      const icons = iconProvider();\n      return lookupIcon(name, icons).getOrThunk(defaultIcon(icons));\n    };\n    const getOr = (name, iconProvider, fallbackIcon) => {\n      const icons = iconProvider();\n      return lookupIcon(name, icons).or(fallbackIcon).getOrThunk(defaultIcon(icons));\n    };\n    const needsRtlTransform = iconName => global$5.isRtl() ? has$2(rtlTransform, iconName) : false;\n    const addFocusableBehaviour = () => config('add-focusable', [runOnAttached(comp => {\n        child(comp.element, 'svg').each(svg => set$9(svg, 'focusable', 'false'));\n      })]);\n    const renderIcon$3 = (spec, iconName, icons, fallbackIcon) => {\n      var _a, _b;\n      const rtlIconClasses = needsRtlTransform(iconName) ? ['tox-icon--flip'] : [];\n      const iconHtml = get$h(icons, getIconName(iconName, icons)).or(fallbackIcon).getOrThunk(defaultIcon(icons));\n      return {\n        dom: {\n          tag: spec.tag,\n          attributes: (_a = spec.attributes) !== null && _a !== void 0 ? _a : {},\n          classes: spec.classes.concat(rtlIconClasses),\n          innerHtml: iconHtml\n        },\n        behaviours: derive$1([\n          ...(_b = spec.behaviours) !== null && _b !== void 0 ? _b : [],\n          addFocusableBehaviour()\n        ])\n      };\n    };\n    const render$3 = (iconName, spec, iconProvider, fallbackIcon = Optional.none()) => renderIcon$3(spec, iconName, iconProvider(), fallbackIcon);\n    const renderFirst = (iconNames, spec, iconProvider) => {\n      const icons = iconProvider();\n      const iconName = find$5(iconNames, name => has$2(icons, getIconName(name, icons)));\n      return renderIcon$3(spec, iconName.getOr(defaultIconName), icons, Optional.none());\n    };\n\n    const notificationIconMap = {\n      success: 'checkmark',\n      error: 'warning',\n      err: 'error',\n      warning: 'warning',\n      warn: 'warning',\n      info: 'info'\n    };\n    const factory$m = detail => {\n      const notificationTextId = generate$6('notification-text');\n      const memBannerText = record({\n        dom: fromHtml(`<p id=${ notificationTextId }>${ sanitizeHtmlString(detail.backstageProvider.translate(detail.text)) }</p>`),\n        behaviours: derive$1([Replacing.config({})])\n      });\n      const renderPercentBar = percent => ({\n        dom: {\n          tag: 'div',\n          classes: ['tox-bar'],\n          styles: { width: `${ percent }%` }\n        }\n      });\n      const renderPercentText = percent => ({\n        dom: {\n          tag: 'div',\n          classes: ['tox-text'],\n          innerHtml: `${ percent }%`\n        }\n      });\n      const memBannerProgress = record({\n        dom: {\n          tag: 'div',\n          classes: detail.progress ? [\n            'tox-progress-bar',\n            'tox-progress-indicator'\n          ] : ['tox-progress-bar']\n        },\n        components: [\n          {\n            dom: {\n              tag: 'div',\n              classes: ['tox-bar-container']\n            },\n            components: [renderPercentBar(0)]\n          },\n          renderPercentText(0)\n        ],\n        behaviours: derive$1([Replacing.config({})])\n      });\n      const updateProgress = (comp, percent) => {\n        if (comp.getSystem().isConnected()) {\n          memBannerProgress.getOpt(comp).each(progress => {\n            Replacing.set(progress, [\n              {\n                dom: {\n                  tag: 'div',\n                  classes: ['tox-bar-container']\n                },\n                components: [renderPercentBar(percent)]\n              },\n              renderPercentText(percent)\n            ]);\n          });\n        }\n      };\n      const updateText = (comp, text) => {\n        if (comp.getSystem().isConnected()) {\n          const banner = memBannerText.get(comp);\n          Replacing.set(banner, [text$2(text)]);\n        }\n      };\n      const apis = {\n        updateProgress,\n        updateText\n      };\n      const iconChoices = flatten([\n        detail.icon.toArray(),\n        detail.level.toArray(),\n        detail.level.bind(level => Optional.from(notificationIconMap[level])).toArray()\n      ]);\n      const memButton = record(Button.sketch({\n        dom: {\n          tag: 'button',\n          classes: [\n            'tox-notification__dismiss',\n            'tox-button',\n            'tox-button--naked',\n            'tox-button--icon'\n          ],\n          attributes: { 'aria-label': detail.backstageProvider.translate('Close') }\n        },\n        components: [render$3('close', {\n            tag: 'span',\n            classes: ['tox-icon']\n          }, detail.iconProvider)],\n        buttonBehaviours: derive$1([\n          Tabstopping.config({}),\n          Tooltipping.config({ ...detail.backstageProvider.tooltips.getConfig({ tooltipText: detail.backstageProvider.translate('Close') }) })\n        ]),\n        action: comp => {\n          detail.onAction(comp);\n        }\n      }));\n      const notificationIconSpec = renderFirst(iconChoices, {\n        tag: 'div',\n        classes: ['tox-notification__icon']\n      }, detail.iconProvider);\n      const notificationBodySpec = {\n        dom: {\n          tag: 'div',\n          classes: ['tox-notification__body']\n        },\n        components: [memBannerText.asSpec()],\n        behaviours: derive$1([Replacing.config({})])\n      };\n      const components = [\n        notificationIconSpec,\n        notificationBodySpec\n      ];\n      return {\n        uid: detail.uid,\n        dom: {\n          tag: 'div',\n          attributes: {\n            'role': 'alert',\n            'aria-labelledby': notificationTextId\n          },\n          classes: detail.level.map(level => [\n            'tox-notification',\n            'tox-notification--in',\n            `tox-notification--${ level }`\n          ]).getOr([\n            'tox-notification',\n            'tox-notification--in'\n          ])\n        },\n        behaviours: derive$1([\n          Tabstopping.config({}),\n          Focusing.config({}),\n          Keying.config({\n            mode: 'special',\n            onEscape: comp => {\n              detail.onAction(comp);\n              return Optional.some(true);\n            }\n          })\n        ]),\n        components: components.concat(detail.progress ? [memBannerProgress.asSpec()] : []).concat([memButton.asSpec()]),\n        apis\n      };\n    };\n    const Notification = single({\n      name: 'Notification',\n      factory: factory$m,\n      configFields: [\n        option$3('level'),\n        required$1('progress'),\n        option$3('icon'),\n        required$1('onAction'),\n        required$1('text'),\n        required$1('iconProvider'),\n        required$1('backstageProvider')\n      ],\n      apis: {\n        updateProgress: (apis, comp, percent) => {\n          apis.updateProgress(comp, percent);\n        },\n        updateText: (apis, comp, text) => {\n          apis.updateText(comp, text);\n        }\n      }\n    });\n\n    var NotificationManagerImpl = (editor, extras, uiMothership, notificationRegion) => {\n      const sharedBackstage = extras.backstage.shared;\n      const getBounds = () => {\n        const contentArea = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));\n        return Optional.some(contentArea);\n      };\n      const clampComponentsToBounds = components => {\n        getBounds().each(bounds => {\n          each$1(components, comp => {\n            if (get$d(comp.element) > bounds.width) {\n              set$8(comp.element, 'width', bounds.width + 'px');\n            }\n          });\n        });\n      };\n      const open = (settings, closeCallback, isEditorOrUIFocused) => {\n        const close = () => {\n          const removeNotificationAndReposition = region => {\n            Replacing.remove(region, notification);\n            reposition();\n          };\n          const manageRegionVisibility = (region, editorOrUiFocused) => {\n            if (children(region.element).length === 0) {\n              handleEmptyRegion(region, editorOrUiFocused);\n            } else {\n              handleRegionWithChildren(region, editorOrUiFocused);\n            }\n          };\n          const handleEmptyRegion = (region, editorOrUIFocused) => {\n            InlineView.hide(region);\n            notificationRegion.clear();\n            if (editorOrUIFocused) {\n              editor.focus();\n            }\n          };\n          const handleRegionWithChildren = (region, editorOrUIFocused) => {\n            if (editorOrUIFocused) {\n              Keying.focusIn(region);\n            }\n          };\n          notificationRegion.on(region => {\n            closeCallback();\n            const editorOrUIFocused = isEditorOrUIFocused();\n            removeNotificationAndReposition(region);\n            manageRegionVisibility(region, editorOrUIFocused);\n          });\n        };\n        const notification = build$1(Notification.sketch({\n          text: settings.text,\n          level: contains$2([\n            'success',\n            'error',\n            'warning',\n            'warn',\n            'info'\n          ], settings.type) ? settings.type : undefined,\n          progress: settings.progressBar === true,\n          icon: settings.icon,\n          onAction: close,\n          iconProvider: sharedBackstage.providers.icons,\n          backstageProvider: sharedBackstage.providers\n        }));\n        if (!notificationRegion.isSet()) {\n          const notificationWrapper = build$1(InlineView.sketch({\n            dom: {\n              tag: 'div',\n              classes: ['tox-notifications-container'],\n              attributes: {\n                'aria-label': 'Notifications',\n                'role': 'region'\n              }\n            },\n            lazySink: sharedBackstage.getSink,\n            fireDismissalEventInstead: {},\n            ...sharedBackstage.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} },\n            inlineBehaviours: derive$1([\n              Keying.config({\n                mode: 'cyclic',\n                selector: '.tox-notification, .tox-notification a, .tox-notification button'\n              }),\n              Replacing.config({}),\n              ...isStickyToolbar(editor) && !sharedBackstage.header.isPositionedAtTop() ? [] : [Docking.config({\n                  contextual: {\n                    lazyContext: () => Optional.some(box$1(SugarElement.fromDom(editor.getContentAreaContainer()))),\n                    fadeInClass: 'tox-notification-container-dock-fadein',\n                    fadeOutClass: 'tox-notification-container-dock-fadeout',\n                    transitionClass: 'tox-notification-container-dock-transition'\n                  },\n                  modes: ['top'],\n                  lazyViewport: comp => {\n                    const optScrollingContext = detectWhenSplitUiMode(editor, comp.element);\n                    return optScrollingContext.map(sc => {\n                      const combinedBounds = getBoundsFrom(sc);\n                      return {\n                        bounds: combinedBounds,\n                        optScrollEnv: Optional.some({\n                          currentScrollTop: sc.element.dom.scrollTop,\n                          scrollElmTop: absolute$3(sc.element).top\n                        })\n                      };\n                    }).getOrThunk(() => ({\n                      bounds: win(),\n                      optScrollEnv: Optional.none()\n                    }));\n                  }\n                })]\n            ])\n          }));\n          const notificationSpec = premade(notification);\n          const anchorOverrides = { maxHeightFunction: expandable$1() };\n          const anchor = {\n            ...sharedBackstage.anchors.banner(),\n            overrides: anchorOverrides\n          };\n          notificationRegion.set(notificationWrapper);\n          uiMothership.add(notificationWrapper);\n          InlineView.showWithinBounds(notificationWrapper, notificationSpec, { anchor }, getBounds);\n        } else {\n          const notificationSpec = premade(notification);\n          notificationRegion.on(notificationWrapper => {\n            Replacing.append(notificationWrapper, notificationSpec);\n            InlineView.reposition(notificationWrapper);\n            Docking.refresh(notificationWrapper);\n            clampComponentsToBounds(notificationWrapper.components());\n          });\n        }\n        if (isNumber(settings.timeout) && settings.timeout > 0) {\n          global$9.setEditorTimeout(editor, () => {\n            close();\n          }, settings.timeout);\n        }\n        const reposition = () => {\n          notificationRegion.on(region => {\n            InlineView.reposition(region);\n            Docking.refresh(region);\n            clampComponentsToBounds(region.components());\n          });\n        };\n        const thisNotification = {\n          close,\n          reposition,\n          text: nuText => {\n            Notification.updateText(notification, nuText);\n          },\n          settings,\n          getEl: () => notification.element.dom,\n          progressBar: {\n            value: percent => {\n              Notification.updateProgress(notification, percent);\n            }\n          }\n        };\n        return thisNotification;\n      };\n      const close = notification => {\n        notification.close();\n      };\n      const getArgs = notification => {\n        return notification.settings;\n      };\n      return {\n        open,\n        close,\n        getArgs\n      };\n    };\n\n    const setup$e = (api, editor) => {\n      const redirectKeyToItem = (item, e) => {\n        emitWith(item, keydown(), { raw: e });\n      };\n      const getItem = () => api.getMenu().bind(Highlighting.getHighlighted);\n      editor.on('keydown', e => {\n        const keyCode = e.which;\n        if (!api.isActive()) {\n          return;\n        }\n        if (api.isMenuOpen()) {\n          if (keyCode === 13) {\n            getItem().each(emitExecute);\n            e.preventDefault();\n          } else if (keyCode === 40) {\n            getItem().fold(() => {\n              api.getMenu().each(Highlighting.highlightFirst);\n            }, item => {\n              redirectKeyToItem(item, e);\n            });\n            e.preventDefault();\n            e.stopImmediatePropagation();\n          } else if (keyCode === 37 || keyCode === 38 || keyCode === 39) {\n            getItem().each(item => {\n              redirectKeyToItem(item, e);\n              e.preventDefault();\n              e.stopImmediatePropagation();\n            });\n          }\n        } else {\n          if (keyCode === 13 || keyCode === 38 || keyCode === 40) {\n            api.cancelIfNecessary();\n          }\n        }\n      });\n      editor.on('NodeChange', () => {\n        if (api.isActive() && !api.isProcessingAction() && !editor.queryCommandState('mceAutoCompleterInRange')) {\n          api.cancelIfNecessary();\n        }\n      });\n    };\n    const AutocompleterEditorEvents = { setup: setup$e };\n\n    var ItemResponse;\n    (function (ItemResponse) {\n      ItemResponse[ItemResponse['CLOSE_ON_EXECUTE'] = 0] = 'CLOSE_ON_EXECUTE';\n      ItemResponse[ItemResponse['BUBBLE_TO_SANDBOX'] = 1] = 'BUBBLE_TO_SANDBOX';\n    }(ItemResponse || (ItemResponse = {})));\n    var ItemResponse$1 = ItemResponse;\n\n    const navClass = 'tox-menu-nav__js';\n    const selectableClass = 'tox-collection__item';\n    const colorClass = 'tox-swatch';\n    const presetClasses = {\n      normal: navClass,\n      color: colorClass\n    };\n    const tickedClass = 'tox-collection__item--enabled';\n    const groupHeadingClass = 'tox-collection__group-heading';\n    const iconClass = 'tox-collection__item-icon';\n    const textClass = 'tox-collection__item-label';\n    const accessoryClass = 'tox-collection__item-accessory';\n    const caretClass = 'tox-collection__item-caret';\n    const checkmarkClass = 'tox-collection__item-checkmark';\n    const activeClass = 'tox-collection__item--active';\n    const containerClass = 'tox-collection__item-container';\n    const containerColumnClass = 'tox-collection__item-container--column';\n    const containerRowClass = 'tox-collection__item-container--row';\n    const containerAlignRightClass = 'tox-collection__item-container--align-right';\n    const containerAlignLeftClass = 'tox-collection__item-container--align-left';\n    const containerValignTopClass = 'tox-collection__item-container--valign-top';\n    const containerValignMiddleClass = 'tox-collection__item-container--valign-middle';\n    const containerValignBottomClass = 'tox-collection__item-container--valign-bottom';\n    const classForPreset = presets => get$h(presetClasses, presets).getOr(navClass);\n\n    const forMenu = presets => {\n      if (presets === 'color') {\n        return 'tox-swatches';\n      } else {\n        return 'tox-menu';\n      }\n    };\n    const classes = presets => ({\n      backgroundMenu: 'tox-background-menu',\n      selectedMenu: 'tox-selected-menu',\n      selectedItem: 'tox-collection__item--active',\n      hasIcons: 'tox-menu--has-icons',\n      menu: forMenu(presets),\n      tieredMenu: 'tox-tiered-menu'\n    });\n\n    const markers = presets => {\n      const menuClasses = classes(presets);\n      return {\n        backgroundMenu: menuClasses.backgroundMenu,\n        selectedMenu: menuClasses.selectedMenu,\n        menu: menuClasses.menu,\n        selectedItem: menuClasses.selectedItem,\n        item: classForPreset(presets)\n      };\n    };\n    const dom$1 = (hasIcons, columns, presets) => {\n      const menuClasses = classes(presets);\n      return {\n        tag: 'div',\n        classes: flatten([\n          [\n            menuClasses.menu,\n            `tox-menu-${ columns }-column`\n          ],\n          hasIcons ? [menuClasses.hasIcons] : []\n        ])\n      };\n    };\n    const components = [Menu.parts.items({})];\n    const part = (hasIcons, columns, presets) => {\n      const menuClasses = classes(presets);\n      const d = {\n        tag: 'div',\n        classes: flatten([[menuClasses.tieredMenu]])\n      };\n      return {\n        dom: d,\n        markers: markers(presets)\n      };\n    };\n\n    const schema$l = constant$1([\n      option$3('data'),\n      defaulted('inputAttributes', {}),\n      defaulted('inputStyles', {}),\n      defaulted('tag', 'input'),\n      defaulted('inputClasses', []),\n      onHandler('onSetValue'),\n      defaulted('styles', {}),\n      defaulted('eventOrder', {}),\n      field('inputBehaviours', [\n        Representing,\n        Focusing\n      ]),\n      defaulted('selectOnFocus', true)\n    ]);\n    const focusBehaviours = detail => derive$1([Focusing.config({\n        onFocus: !detail.selectOnFocus ? noop : component => {\n          const input = component.element;\n          const value = get$7(input);\n          input.dom.setSelectionRange(0, value.length);\n        }\n      })]);\n    const behaviours = detail => ({\n      ...focusBehaviours(detail),\n      ...augment(detail.inputBehaviours, [Representing.config({\n          store: {\n            mode: 'manual',\n            ...detail.data.map(data => ({ initialValue: data })).getOr({}),\n            getValue: input => {\n              return get$7(input.element);\n            },\n            setValue: (input, data) => {\n              const current = get$7(input.element);\n              if (current !== data) {\n                set$5(input.element, data);\n              }\n            }\n          },\n          onSetValue: detail.onSetValue\n        })])\n    });\n    const dom = detail => ({\n      tag: detail.tag,\n      attributes: {\n        type: 'text',\n        ...detail.inputAttributes\n      },\n      styles: detail.inputStyles,\n      classes: detail.inputClasses\n    });\n\n    const factory$l = (detail, _spec) => ({\n      uid: detail.uid,\n      dom: dom(detail),\n      components: [],\n      behaviours: behaviours(detail),\n      eventOrder: detail.eventOrder\n    });\n    const Input = single({\n      name: 'Input',\n      configFields: schema$l(),\n      factory: factory$l\n    });\n\n    const refetchTriggerEvent = generate$6('refetch-trigger-event');\n    const redirectMenuItemInteractionEvent = generate$6('redirect-menu-item-interaction');\n\n    const menuSearcherClass = 'tox-menu__searcher';\n    const findWithinSandbox = sandboxComp => {\n      return descendant(sandboxComp.element, `.${ menuSearcherClass }`).bind(inputElem => sandboxComp.getSystem().getByDom(inputElem).toOptional());\n    };\n    const findWithinMenu = findWithinSandbox;\n    const restoreState = (inputComp, searcherState) => {\n      Representing.setValue(inputComp, searcherState.fetchPattern);\n      inputComp.element.dom.selectionStart = searcherState.selectionStart;\n      inputComp.element.dom.selectionEnd = searcherState.selectionEnd;\n    };\n    const saveState = inputComp => {\n      const fetchPattern = Representing.getValue(inputComp);\n      const selectionStart = inputComp.element.dom.selectionStart;\n      const selectionEnd = inputComp.element.dom.selectionEnd;\n      return {\n        fetchPattern,\n        selectionStart,\n        selectionEnd\n      };\n    };\n    const setActiveDescendant = (inputComp, active) => {\n      getOpt(active.element, 'id').each(id => set$9(inputComp.element, 'aria-activedescendant', id));\n    };\n    const renderMenuSearcher = spec => {\n      const handleByBrowser = (comp, se) => {\n        se.cut();\n        return Optional.none();\n      };\n      const handleByHighlightedItem = (comp, se) => {\n        const eventData = {\n          interactionEvent: se.event,\n          eventType: se.event.raw.type\n        };\n        emitWith(comp, redirectMenuItemInteractionEvent, eventData);\n        return Optional.some(true);\n      };\n      const customSearcherEventsName = 'searcher-events';\n      return {\n        dom: {\n          tag: 'div',\n          classes: [selectableClass]\n        },\n        components: [Input.sketch({\n            inputClasses: [\n              menuSearcherClass,\n              'tox-textfield'\n            ],\n            inputAttributes: {\n              ...spec.placeholder.map(placeholder => ({ placeholder: spec.i18n(placeholder) })).getOr({}),\n              'type': 'search',\n              'aria-autocomplete': 'list'\n            },\n            inputBehaviours: derive$1([\n              config(customSearcherEventsName, [\n                run$1(input(), inputComp => {\n                  emit(inputComp, refetchTriggerEvent);\n                }),\n                run$1(keydown(), (inputComp, se) => {\n                  if (se.event.raw.key === 'Escape') {\n                    se.stop();\n                  }\n                })\n              ]),\n              Keying.config({\n                mode: 'special',\n                onLeft: handleByBrowser,\n                onRight: handleByBrowser,\n                onSpace: handleByBrowser,\n                onEnter: handleByHighlightedItem,\n                onEscape: handleByHighlightedItem,\n                onUp: handleByHighlightedItem,\n                onDown: handleByHighlightedItem\n              })\n            ]),\n            eventOrder: {\n              keydown: [\n                customSearcherEventsName,\n                Keying.name()\n              ]\n            }\n          })]\n      };\n    };\n\n    const searchResultsClass = 'tox-collection--results__js';\n    const augmentWithAria = item => {\n      var _a;\n      if (item.dom) {\n        return {\n          ...item,\n          dom: {\n            ...item.dom,\n            attributes: {\n              ...(_a = item.dom.attributes) !== null && _a !== void 0 ? _a : {},\n              'id': generate$6('aria-item-search-result-id'),\n              'aria-selected': 'false'\n            }\n          }\n        };\n      } else {\n        return item;\n      }\n    };\n\n    const chunk = (rowDom, numColumns) => items => {\n      const chunks = chunk$1(items, numColumns);\n      return map$2(chunks, c => ({\n        dom: rowDom,\n        components: c\n      }));\n    };\n    const forSwatch = columns => ({\n      dom: {\n        tag: 'div',\n        classes: [\n          'tox-menu',\n          'tox-swatches-menu'\n        ]\n      },\n      components: [{\n          dom: {\n            tag: 'div',\n            classes: ['tox-swatches']\n          },\n          components: [Menu.parts.items({\n              preprocess: columns !== 'auto' ? chunk({\n                tag: 'div',\n                classes: ['tox-swatches__row']\n              }, columns) : identity\n            })]\n        }]\n    });\n    const forToolbar = columns => ({\n      dom: {\n        tag: 'div',\n        classes: [\n          'tox-menu',\n          'tox-collection',\n          'tox-collection--toolbar',\n          'tox-collection--toolbar-lg'\n        ]\n      },\n      components: [Menu.parts.items({\n          preprocess: chunk({\n            tag: 'div',\n            classes: ['tox-collection__group']\n          }, columns)\n        })]\n    });\n    const preprocessCollection = (items, isSeparator) => {\n      const allSplits = [];\n      let currentSplit = [];\n      each$1(items, (item, i) => {\n        if (isSeparator(item, i)) {\n          if (currentSplit.length > 0) {\n            allSplits.push(currentSplit);\n          }\n          currentSplit = [];\n          if (has$2(item.dom, 'innerHtml') || item.components && item.components.length > 0) {\n            currentSplit.push(item);\n          }\n        } else {\n          currentSplit.push(item);\n        }\n      });\n      if (currentSplit.length > 0) {\n        allSplits.push(currentSplit);\n      }\n      return map$2(allSplits, s => ({\n        dom: {\n          tag: 'div',\n          classes: ['tox-collection__group']\n        },\n        components: s\n      }));\n    };\n    const insertItemsPlaceholder = (columns, initItems, onItem) => {\n      return Menu.parts.items({\n        preprocess: rawItems => {\n          const enrichedItems = map$2(rawItems, onItem);\n          if (columns !== 'auto' && columns > 1) {\n            return chunk({\n              tag: 'div',\n              classes: ['tox-collection__group']\n            }, columns)(enrichedItems);\n          } else {\n            return preprocessCollection(enrichedItems, (_item, i) => initItems[i].type === 'separator');\n          }\n        }\n      });\n    };\n    const forCollection = (columns, initItems, _hasIcons = true) => ({\n      dom: {\n        tag: 'div',\n        classes: [\n          'tox-menu',\n          'tox-collection'\n        ].concat(columns === 1 ? ['tox-collection--list'] : ['tox-collection--grid'])\n      },\n      components: [insertItemsPlaceholder(columns, initItems, identity)]\n    });\n    const forCollectionWithSearchResults = (columns, initItems, _hasIcons = true) => {\n      const ariaControlsSearchResults = generate$6('aria-controls-search-results');\n      return {\n        dom: {\n          tag: 'div',\n          classes: [\n            'tox-menu',\n            'tox-collection',\n            searchResultsClass\n          ].concat(columns === 1 ? ['tox-collection--list'] : ['tox-collection--grid']),\n          attributes: { id: ariaControlsSearchResults }\n        },\n        components: [insertItemsPlaceholder(columns, initItems, augmentWithAria)]\n      };\n    };\n    const forCollectionWithSearchField = (columns, initItems, searchField) => {\n      const ariaControlsSearchResults = generate$6('aria-controls-search-results');\n      return {\n        dom: {\n          tag: 'div',\n          classes: [\n            'tox-menu',\n            'tox-collection'\n          ].concat(columns === 1 ? ['tox-collection--list'] : ['tox-collection--grid'])\n        },\n        components: [\n          renderMenuSearcher({\n            i18n: global$5.translate,\n            placeholder: searchField.placeholder\n          }),\n          {\n            dom: {\n              tag: 'div',\n              classes: [\n                ...columns === 1 ? ['tox-collection--list'] : ['tox-collection--grid'],\n                searchResultsClass\n              ],\n              attributes: { id: ariaControlsSearchResults }\n            },\n            components: [insertItemsPlaceholder(columns, initItems, augmentWithAria)]\n          }\n        ]\n      };\n    };\n    const forHorizontalCollection = (initItems, _hasIcons = true) => ({\n      dom: {\n        tag: 'div',\n        classes: [\n          'tox-collection',\n          'tox-collection--horizontal'\n        ]\n      },\n      components: [Menu.parts.items({ preprocess: items => preprocessCollection(items, (_item, i) => initItems[i].type === 'separator') })]\n    });\n\n    const menuHasIcons = xs => exists(xs, item => 'icon' in item && item.icon !== undefined);\n    const handleError = error => {\n      console.error(formatError(error));\n      console.log(error);\n      return Optional.none();\n    };\n    const createHorizontalPartialMenuWithAlloyItems = (value, _hasIcons, items, _columns, _menuLayout) => {\n      const structure = forHorizontalCollection(items);\n      return {\n        value,\n        dom: structure.dom,\n        components: structure.components,\n        items\n      };\n    };\n    const createPartialMenuWithAlloyItems = (value, hasIcons, items, columns, menuLayout) => {\n      const getNormalStructure = () => {\n        if (menuLayout.menuType !== 'searchable') {\n          return forCollection(columns, items);\n        } else {\n          return menuLayout.searchMode.searchMode === 'search-with-field' ? forCollectionWithSearchField(columns, items, menuLayout.searchMode) : forCollectionWithSearchResults(columns, items);\n        }\n      };\n      if (menuLayout.menuType === 'color') {\n        const structure = forSwatch(columns);\n        return {\n          value,\n          dom: structure.dom,\n          components: structure.components,\n          items\n        };\n      } else if (menuLayout.menuType === 'normal' && columns === 'auto') {\n        const structure = forCollection(columns, items);\n        return {\n          value,\n          dom: structure.dom,\n          components: structure.components,\n          items\n        };\n      } else if (menuLayout.menuType === 'normal' || menuLayout.menuType === 'searchable') {\n        const structure = getNormalStructure();\n        return {\n          value,\n          dom: structure.dom,\n          components: structure.components,\n          items\n        };\n      } else if (menuLayout.menuType === 'listpreview' && columns !== 'auto') {\n        const structure = forToolbar(columns);\n        return {\n          value,\n          dom: structure.dom,\n          components: structure.components,\n          items\n        };\n      } else {\n        return {\n          value,\n          dom: dom$1(hasIcons, columns, menuLayout.menuType),\n          components: components,\n          items\n        };\n      }\n    };\n\n    const type = requiredString('type');\n    const name$1 = requiredString('name');\n    const label = requiredString('label');\n    const text = requiredString('text');\n    const title = requiredString('title');\n    const icon = requiredString('icon');\n    const value$1 = requiredString('value');\n    const fetch$1 = requiredFunction('fetch');\n    const getSubmenuItems = requiredFunction('getSubmenuItems');\n    const onAction = requiredFunction('onAction');\n    const onItemAction = requiredFunction('onItemAction');\n    const onSetup = defaultedFunction('onSetup', () => noop);\n    const optionalName = optionString('name');\n    const optionalText = optionString('text');\n    const optionalRole = optionString('role');\n    const optionalIcon = optionString('icon');\n    const optionalTooltip = optionString('tooltip');\n    const optionalLabel = optionString('label');\n    const optionalShortcut = optionString('shortcut');\n    const optionalSelect = optionFunction('select');\n    const active = defaultedBoolean('active', false);\n    const borderless = defaultedBoolean('borderless', false);\n    const enabled = defaultedBoolean('enabled', true);\n    const primary = defaultedBoolean('primary', false);\n    const defaultedColumns = num => defaulted('columns', num);\n    const defaultedMeta = defaulted('meta', {});\n    const defaultedOnAction = defaultedFunction('onAction', noop);\n    const defaultedType = type => defaultedString('type', type);\n    const generatedName = namePrefix => field$1('name', 'name', defaultedThunk(() => generate$6(`${ namePrefix }-name`)), string);\n    const generatedValue = valuePrefix => field$1('value', 'value', defaultedThunk(() => generate$6(`${ valuePrefix }-value`)), anyValue());\n\n    const separatorMenuItemSchema = objOf([\n      type,\n      optionalText\n    ]);\n    const createSeparatorMenuItem = spec => asRaw('separatormenuitem', separatorMenuItemSchema, spec);\n\n    const autocompleterItemSchema = objOf([\n      defaultedType('autocompleteitem'),\n      active,\n      enabled,\n      defaultedMeta,\n      value$1,\n      optionalText,\n      optionalIcon\n    ]);\n    const createSeparatorItem = spec => asRaw('Autocompleter.Separator', separatorMenuItemSchema, spec);\n    const createAutocompleterItem = spec => asRaw('Autocompleter.Item', autocompleterItemSchema, spec);\n\n    const baseToolbarButtonFields = [\n      enabled,\n      optionalTooltip,\n      optionalIcon,\n      optionalText,\n      onSetup\n    ];\n    const toolbarButtonSchema = objOf([\n      type,\n      onAction,\n      optionalShortcut\n    ].concat(baseToolbarButtonFields));\n    const createToolbarButton = spec => asRaw('toolbarbutton', toolbarButtonSchema, spec);\n\n    const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);\n    const toggleButtonSchema = objOf(baseToolbarToggleButtonFields.concat([\n      type,\n      onAction,\n      optionalShortcut\n    ]));\n    const createToggleButton = spec => asRaw('ToggleButton', toggleButtonSchema, spec);\n\n    const contextBarFields = [\n      defaultedFunction('predicate', never),\n      defaultedStringEnum('scope', 'node', [\n        'node',\n        'editor'\n      ]),\n      defaultedStringEnum('position', 'selection', [\n        'node',\n        'selection',\n        'line'\n      ])\n    ];\n\n    const contextButtonFields = baseToolbarButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);\n    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);\n    const toggleOrNormal = choose$1('type', {\n      contextformbutton: contextButtonFields,\n      contextformtogglebutton: contextToggleButtonFields\n    });\n    const contextFormSchema = objOf([\n      defaultedType('contextform'),\n      defaultedFunction('initValue', constant$1('')),\n      optionalLabel,\n      requiredArrayOf('commands', toggleOrNormal),\n      optionOf('launch', choose$1('type', {\n        contextformbutton: launchButtonFields,\n        contextformtogglebutton: launchToggleButtonFields\n      }))\n    ].concat(contextBarFields));\n    const createContextForm = spec => asRaw('ContextForm', contextFormSchema, spec);\n\n    const contextToolbarSchema = objOf([\n      defaultedType('contexttoolbar'),\n      requiredString('items')\n    ].concat(contextBarFields));\n    const createContextToolbar = spec => asRaw('ContextToolbar', contextToolbarSchema, spec);\n\n    const cardImageFields = [\n      type,\n      requiredString('src'),\n      optionString('alt'),\n      defaultedArrayOf('classes', [], string)\n    ];\n    const cardImageSchema = objOf(cardImageFields);\n\n    const cardTextFields = [\n      type,\n      text,\n      optionalName,\n      defaultedArrayOf('classes', ['tox-collection__item-label'], string)\n    ];\n    const cardTextSchema = objOf(cardTextFields);\n\n    const itemSchema$1 = valueThunk(() => choose$2('type', {\n      cardimage: cardImageSchema,\n      cardtext: cardTextSchema,\n      cardcontainer: cardContainerSchema\n    }));\n    const cardContainerSchema = objOf([\n      type,\n      defaultedString('direction', 'horizontal'),\n      defaultedString('align', 'left'),\n      defaultedString('valign', 'middle'),\n      requiredArrayOf('items', itemSchema$1)\n    ]);\n\n    const commonMenuItemFields = [\n      enabled,\n      optionalText,\n      optionalRole,\n      optionalShortcut,\n      generatedValue('menuitem'),\n      defaultedMeta\n    ];\n\n    const cardMenuItemSchema = objOf([\n      type,\n      optionalLabel,\n      requiredArrayOf('items', itemSchema$1),\n      onSetup,\n      defaultedOnAction\n    ].concat(commonMenuItemFields));\n    const createCardMenuItem = spec => asRaw('cardmenuitem', cardMenuItemSchema, spec);\n\n    const choiceMenuItemSchema = objOf([\n      type,\n      active,\n      optionalIcon\n    ].concat(commonMenuItemFields));\n    const createChoiceMenuItem = spec => asRaw('choicemenuitem', choiceMenuItemSchema, spec);\n\n    const baseFields = [\n      type,\n      requiredString('fancytype'),\n      defaultedOnAction\n    ];\n    const insertTableFields = [defaulted('initData', {})].concat(baseFields);\n    const colorSwatchFields = [\n      optionFunction('select'),\n      defaultedObjOf('initData', {}, [\n        defaultedBoolean('allowCustomColors', true),\n        defaultedString('storageKey', 'default'),\n        optionArrayOf('colors', anyValue())\n      ])\n    ].concat(baseFields);\n    const fancyMenuItemSchema = choose$1('fancytype', {\n      inserttable: insertTableFields,\n      colorswatch: colorSwatchFields\n    });\n    const createFancyMenuItem = spec => asRaw('fancymenuitem', fancyMenuItemSchema, spec);\n\n    const menuItemSchema = objOf([\n      type,\n      onSetup,\n      defaultedOnAction,\n      optionalIcon\n    ].concat(commonMenuItemFields));\n    const createMenuItem = spec => asRaw('menuitem', menuItemSchema, spec);\n\n    const nestedMenuItemSchema = objOf([\n      type,\n      getSubmenuItems,\n      onSetup,\n      optionalIcon\n    ].concat(commonMenuItemFields));\n    const createNestedMenuItem = spec => asRaw('nestedmenuitem', nestedMenuItemSchema, spec);\n\n    const toggleMenuItemSchema = objOf([\n      type,\n      optionalIcon,\n      active,\n      onSetup,\n      onAction\n    ].concat(commonMenuItemFields));\n    const createToggleMenuItem = spec => asRaw('togglemenuitem', toggleMenuItemSchema, spec);\n\n    const detectSize = (comp, margin, selectorClass) => {\n      const descendants$1 = descendants(comp.element, '.' + selectorClass);\n      if (descendants$1.length > 0) {\n        const columnLength = findIndex$1(descendants$1, c => {\n          const thisTop = c.dom.getBoundingClientRect().top;\n          const cTop = descendants$1[0].dom.getBoundingClientRect().top;\n          return Math.abs(thisTop - cTop) > margin;\n        }).getOr(descendants$1.length);\n        return Optional.some({\n          numColumns: columnLength,\n          numRows: Math.ceil(descendants$1.length / columnLength)\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n\n    const namedEvents = (name, handlers) => derive$1([config(name, handlers)]);\n    const unnamedEvents = handlers => namedEvents(generate$6('unnamed-events'), handlers);\n    const SimpleBehaviours = {\n      namedEvents,\n      unnamedEvents\n    };\n\n    const escape = text => text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n    const ReadOnlyChannel = 'silver.readonly';\n    const ReadOnlyDataSchema = objOf([requiredBoolean('readonly')]);\n    const broadcastReadonly = (uiRefs, readonly) => {\n      const outerContainer = uiRefs.mainUi.outerContainer;\n      const target = outerContainer.element;\n      const motherships = [\n        uiRefs.mainUi.mothership,\n        ...uiRefs.uiMotherships\n      ];\n      if (readonly) {\n        each$1(motherships, m => {\n          m.broadcastOn([dismissPopups()], { target });\n        });\n      }\n      each$1(motherships, m => {\n        m.broadcastOn([ReadOnlyChannel], { readonly });\n      });\n    };\n    const setupReadonlyModeSwitch = (editor, uiRefs) => {\n      editor.on('init', () => {\n        if (editor.mode.isReadOnly()) {\n          broadcastReadonly(uiRefs, true);\n        }\n      });\n      editor.on('SwitchMode', () => broadcastReadonly(uiRefs, editor.mode.isReadOnly()));\n      if (isReadOnly(editor)) {\n        editor.mode.set('readonly');\n      }\n    };\n    const receivingConfig = () => Receiving.config({\n      channels: {\n        [ReadOnlyChannel]: {\n          schema: ReadOnlyDataSchema,\n          onReceive: (comp, data) => {\n            Disabling.set(comp, data.readonly);\n          }\n        }\n      }\n    });\n\n    const item = disabled => Disabling.config({\n      disabled,\n      disableClass: 'tox-collection__item--state-disabled'\n    });\n    const button = disabled => Disabling.config({ disabled });\n    const splitButton = disabled => Disabling.config({\n      disabled,\n      disableClass: 'tox-tbtn--disabled'\n    });\n    const toolbarButton = disabled => Disabling.config({\n      disabled,\n      disableClass: 'tox-tbtn--disabled',\n      useNative: false\n    });\n    const DisablingConfigs = {\n      item,\n      button,\n      splitButton,\n      toolbarButton\n    };\n\n    const runWithApi = (info, comp) => {\n      const api = info.getApi(comp);\n      return f => {\n        f(api);\n      };\n    };\n    const onControlAttached = (info, editorOffCell) => runOnAttached(comp => {\n      const run = runWithApi(info, comp);\n      run(api => {\n        const onDestroy = info.onSetup(api);\n        if (isFunction(onDestroy)) {\n          editorOffCell.set(onDestroy);\n        }\n      });\n    });\n    const onControlDetached = (getApi, editorOffCell) => runOnDetached(comp => runWithApi(getApi, comp)(editorOffCell.get()));\n\n    const onMenuItemExecute = (info, itemResponse) => runOnExecute$1((comp, simulatedEvent) => {\n      runWithApi(info, comp)(info.onAction);\n      if (!info.triggersSubmenu && itemResponse === ItemResponse$1.CLOSE_ON_EXECUTE) {\n        if (comp.getSystem().isConnected()) {\n          emit(comp, sandboxClose());\n        }\n        simulatedEvent.stop();\n      }\n    });\n    const menuItemEventOrder = {\n      [execute$5()]: [\n        'disabling',\n        'alloy.base.behaviour',\n        'toggling',\n        'item-events'\n      ]\n    };\n\n    const componentRenderPipeline = cat;\n    const renderCommonItem = (spec, structure, itemResponse, providersBackstage) => {\n      const editorOffCell = Cell(noop);\n      return {\n        type: 'item',\n        dom: structure.dom,\n        components: componentRenderPipeline(structure.optComponents),\n        data: spec.data,\n        eventOrder: menuItemEventOrder,\n        hasSubmenu: spec.triggersSubmenu,\n        itemBehaviours: derive$1([\n          config('item-events', [\n            onMenuItemExecute(spec, itemResponse),\n            onControlAttached(spec, editorOffCell),\n            onControlDetached(spec, editorOffCell)\n          ]),\n          DisablingConfigs.item(() => !spec.enabled || providersBackstage.isDisabled()),\n          receivingConfig(),\n          Replacing.config({})\n        ].concat(spec.itemBehaviours))\n      };\n    };\n    const buildData = source => ({\n      value: source.value,\n      meta: {\n        text: source.text.getOr(''),\n        ...source.meta\n      }\n    });\n\n    const convertText = source => {\n      const isMac = global$6.os.isMacOS() || global$6.os.isiOS();\n      const mac = {\n        alt: '\\u2325',\n        ctrl: '\\u2303',\n        shift: '\\u21E7',\n        meta: '\\u2318',\n        access: '\\u2303\\u2325'\n      };\n      const other = {\n        meta: 'Ctrl',\n        access: 'Shift+Alt'\n      };\n      const replace = isMac ? mac : other;\n      const shortcut = source.split('+');\n      const updated = map$2(shortcut, segment => {\n        const search = segment.toLowerCase().trim();\n        return has$2(replace, search) ? replace[search] : segment;\n      });\n      return isMac ? updated.join('') : updated.join('+');\n    };\n\n    const renderIcon$2 = (name, icons, classes = [iconClass]) => render$3(name, {\n      tag: 'div',\n      classes\n    }, icons);\n    const renderText = text => ({\n      dom: {\n        tag: 'div',\n        classes: [textClass]\n      },\n      components: [text$2(global$5.translate(text))]\n    });\n    const renderHtml = (html, classes) => ({\n      dom: {\n        tag: 'div',\n        classes,\n        innerHtml: html\n      }\n    });\n    const renderStyledText = (style, text) => ({\n      dom: {\n        tag: 'div',\n        classes: [textClass]\n      },\n      components: [{\n          dom: {\n            tag: style.tag,\n            styles: style.styles\n          },\n          components: [text$2(global$5.translate(text))]\n        }]\n    });\n    const renderShortcut = shortcut => ({\n      dom: {\n        tag: 'div',\n        classes: [accessoryClass]\n      },\n      components: [text$2(convertText(shortcut))]\n    });\n    const renderCheckmark = icons => renderIcon$2('checkmark', icons, [checkmarkClass]);\n    const renderSubmenuCaret = icons => renderIcon$2('chevron-right', icons, [caretClass]);\n    const renderDownwardsCaret = icons => renderIcon$2('chevron-down', icons, [caretClass]);\n    const renderContainer = (container, components) => {\n      const directionClass = container.direction === 'vertical' ? containerColumnClass : containerRowClass;\n      const alignClass = container.align === 'left' ? containerAlignLeftClass : containerAlignRightClass;\n      const getValignClass = () => {\n        switch (container.valign) {\n        case 'top':\n          return containerValignTopClass;\n        case 'middle':\n          return containerValignMiddleClass;\n        case 'bottom':\n          return containerValignBottomClass;\n        }\n      };\n      return {\n        dom: {\n          tag: 'div',\n          classes: [\n            containerClass,\n            directionClass,\n            alignClass,\n            getValignClass()\n          ]\n        },\n        components\n      };\n    };\n    const renderImage = (src, classes, alt) => ({\n      dom: {\n        tag: 'img',\n        classes,\n        attributes: {\n          src,\n          alt: alt.getOr('')\n        }\n      }\n    });\n\n    const renderColorStructure = (item, providerBackstage, fallbackIcon) => {\n      const colorPickerCommand = 'custom';\n      const removeColorCommand = 'remove';\n      const itemValue = item.value;\n      const iconSvg = item.iconContent.map(name => getOr(name, providerBackstage.icons, fallbackIcon));\n      const attributes = item.ariaLabel.map(al => ({\n        'aria-label': providerBackstage.translate(al),\n        'data-mce-name': al\n      })).getOr({});\n      const getDom = () => {\n        const common = colorClass;\n        const icon = iconSvg.getOr('');\n        const baseDom = {\n          tag: 'div',\n          attributes,\n          classes: [common]\n        };\n        if (itemValue === colorPickerCommand) {\n          return {\n            ...baseDom,\n            tag: 'button',\n            classes: [\n              ...baseDom.classes,\n              'tox-swatches__picker-btn'\n            ],\n            innerHtml: icon\n          };\n        } else if (itemValue === removeColorCommand) {\n          return {\n            ...baseDom,\n            classes: [\n              ...baseDom.classes,\n              'tox-swatch--remove'\n            ],\n            innerHtml: icon\n          };\n        } else if (isNonNullable(itemValue)) {\n          return {\n            ...baseDom,\n            attributes: {\n              ...baseDom.attributes,\n              'data-mce-color': itemValue\n            },\n            styles: { 'background-color': itemValue },\n            innerHtml: icon\n          };\n        } else {\n          return baseDom;\n        }\n      };\n      return {\n        dom: getDom(),\n        optComponents: []\n      };\n    };\n    const renderItemDomStructure = ariaLabel => {\n      const domTitle = ariaLabel.map(label => ({\n        attributes: {\n          'id': generate$6('menu-item'),\n          'aria-label': global$5.translate(label)\n        }\n      })).getOr({});\n      return {\n        tag: 'div',\n        classes: [\n          navClass,\n          selectableClass\n        ],\n        ...domTitle\n      };\n    };\n    const renderNormalItemStructure = (info, providersBackstage, renderIcons, fallbackIcon) => {\n      const iconSpec = {\n        tag: 'div',\n        classes: [iconClass]\n      };\n      const renderIcon = iconName => render$3(iconName, iconSpec, providersBackstage.icons, fallbackIcon);\n      const renderEmptyIcon = () => Optional.some({ dom: iconSpec });\n      const leftIcon = renderIcons ? info.iconContent.map(renderIcon).orThunk(renderEmptyIcon) : Optional.none();\n      const checkmark = info.checkMark;\n      const textRender = Optional.from(info.meta).fold(() => renderText, meta => has$2(meta, 'style') ? curry(renderStyledText, meta.style) : renderText);\n      const content = info.htmlContent.fold(() => info.textContent.map(textRender), html => Optional.some(renderHtml(html, [textClass])));\n      const menuItem = {\n        dom: renderItemDomStructure(info.ariaLabel),\n        optComponents: [\n          leftIcon,\n          content,\n          info.shortcutContent.map(renderShortcut),\n          checkmark,\n          info.caret\n        ]\n      };\n      return menuItem;\n    };\n    const renderItemStructure = (info, providersBackstage, renderIcons, fallbackIcon = Optional.none()) => {\n      if (info.presets === 'color') {\n        return renderColorStructure(info, providersBackstage, fallbackIcon);\n      } else {\n        return renderNormalItemStructure(info, providersBackstage, renderIcons, fallbackIcon);\n      }\n    };\n\n    const tooltipBehaviour = (meta, sharedBackstage, tooltipText) => get$h(meta, 'tooltipWorker').map(tooltipWorker => [Tooltipping.config({\n        lazySink: sharedBackstage.getSink,\n        tooltipDom: {\n          tag: 'div',\n          classes: ['tox-tooltip-worker-container']\n        },\n        tooltipComponents: [],\n        anchor: comp => ({\n          type: 'submenu',\n          item: comp,\n          overrides: { maxHeightFunction: expandable$1 }\n        }),\n        mode: 'follow-highlight',\n        onShow: (component, _tooltip) => {\n          tooltipWorker(elm => {\n            Tooltipping.setComponents(component, [external$1({ element: SugarElement.fromDom(elm) })]);\n          });\n        }\n      })]).getOrThunk(() => {\n      return tooltipText.map(text => [Tooltipping.config({\n          ...sharedBackstage.providers.tooltips.getConfig({ tooltipText: text }),\n          mode: 'follow-highlight'\n        })]).getOr([]);\n    });\n    const encodeText = text => global$8.DOM.encode(text);\n    const replaceText = (text, matchText) => {\n      const translated = global$5.translate(text);\n      const encoded = encodeText(translated);\n      if (matchText.length > 0) {\n        const escapedMatchRegex = new RegExp(escape(matchText), 'gi');\n        return encoded.replace(escapedMatchRegex, match => `<span class=\"tox-autocompleter-highlight\">${ match }</span>`);\n      } else {\n        return encoded;\n      }\n    };\n    const renderAutocompleteItem = (spec, matchText, useText, presets, onItemValueHandler, itemResponse, sharedBackstage, renderIcons = true) => {\n      const structure = renderItemStructure({\n        presets,\n        textContent: Optional.none(),\n        htmlContent: useText ? spec.text.map(text => replaceText(text, matchText)) : Optional.none(),\n        ariaLabel: spec.text,\n        iconContent: spec.icon,\n        shortcutContent: Optional.none(),\n        checkMark: Optional.none(),\n        caret: Optional.none(),\n        value: spec.value\n      }, sharedBackstage.providers, renderIcons, spec.icon);\n      const tooltipString = spec.text.filter(text => !useText && text !== '');\n      return renderCommonItem({\n        data: buildData(spec),\n        enabled: spec.enabled,\n        getApi: constant$1({}),\n        onAction: _api => onItemValueHandler(spec.value, spec.meta),\n        onSetup: constant$1(noop),\n        triggersSubmenu: false,\n        itemBehaviours: tooltipBehaviour(spec, sharedBackstage, tooltipString)\n      }, structure, itemResponse, sharedBackstage.providers);\n    };\n\n    const render$2 = (items, extras) => map$2(items, item => {\n      switch (item.type) {\n      case 'cardcontainer':\n        return renderContainer(item, render$2(item.items, extras));\n      case 'cardimage':\n        return renderImage(item.src, item.classes, item.alt);\n      case 'cardtext':\n        const shouldHighlight = item.name.exists(name => contains$2(extras.cardText.highlightOn, name));\n        const matchText = shouldHighlight ? Optional.from(extras.cardText.matchText).getOr('') : '';\n        return renderHtml(replaceText(item.text, matchText), item.classes);\n      }\n    });\n    const renderCardMenuItem = (spec, itemResponse, sharedBackstage, extras) => {\n      const getApi = component => ({\n        isEnabled: () => !Disabling.isDisabled(component),\n        setEnabled: state => {\n          Disabling.set(component, !state);\n          each$1(descendants(component.element, '*'), elm => {\n            component.getSystem().getByDom(elm).each(comp => {\n              if (comp.hasConfigured(Disabling)) {\n                Disabling.set(comp, !state);\n              }\n            });\n          });\n        }\n      });\n      const structure = {\n        dom: renderItemDomStructure(spec.label),\n        optComponents: [Optional.some({\n            dom: {\n              tag: 'div',\n              classes: [\n                containerClass,\n                containerRowClass\n              ]\n            },\n            components: render$2(spec.items, extras)\n          })]\n      };\n      return renderCommonItem({\n        data: buildData({\n          text: Optional.none(),\n          ...spec\n        }),\n        enabled: spec.enabled,\n        getApi,\n        onAction: spec.onAction,\n        onSetup: spec.onSetup,\n        triggersSubmenu: false,\n        itemBehaviours: Optional.from(extras.itemBehaviours).getOr([])\n      }, structure, itemResponse, sharedBackstage.providers);\n    };\n\n    const renderChoiceItem = (spec, useText, presets, onItemValueHandler, isSelected, itemResponse, providersBackstage, renderIcons = true) => {\n      const getApi = component => ({\n        setActive: state => {\n          Toggling.set(component, state);\n        },\n        isActive: () => Toggling.isOn(component),\n        isEnabled: () => !Disabling.isDisabled(component),\n        setEnabled: state => Disabling.set(component, !state)\n      });\n      const structure = renderItemStructure({\n        presets,\n        textContent: useText ? spec.text : Optional.none(),\n        htmlContent: Optional.none(),\n        ariaLabel: spec.text,\n        iconContent: spec.icon,\n        shortcutContent: useText ? spec.shortcut : Optional.none(),\n        checkMark: useText ? Optional.some(renderCheckmark(providersBackstage.icons)) : Optional.none(),\n        caret: Optional.none(),\n        value: spec.value\n      }, providersBackstage, renderIcons);\n      const optTooltipping = spec.text.filter(constant$1(!useText)).map(t => Tooltipping.config(providersBackstage.tooltips.getConfig({ tooltipText: providersBackstage.translate(t) })));\n      return deepMerge(renderCommonItem({\n        data: buildData(spec),\n        enabled: spec.enabled,\n        getApi,\n        onAction: _api => onItemValueHandler(spec.value),\n        onSetup: api => {\n          api.setActive(isSelected);\n          return noop;\n        },\n        triggersSubmenu: false,\n        itemBehaviours: [...optTooltipping.toArray()]\n      }, structure, itemResponse, providersBackstage), {\n        toggling: {\n          toggleClass: tickedClass,\n          toggleOnExecute: false,\n          selected: spec.active,\n          exclusive: true\n        }\n      });\n    };\n\n    const parts$f = generate$3(owner$2(), parts$h());\n\n    const hexColour = value => ({ value: normalizeHex(value) });\n    const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n    const longformRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\n    const isHexString = hex => shorthandRegex.test(hex) || longformRegex.test(hex);\n    const normalizeHex = hex => removeLeading(hex, '#').toUpperCase();\n    const fromString$1 = hex => isHexString(hex) ? Optional.some({ value: normalizeHex(hex) }) : Optional.none();\n    const getLongForm = hex => {\n      const hexString = hex.value.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);\n      return { value: hexString };\n    };\n    const extractValues = hex => {\n      const longForm = getLongForm(hex);\n      const splitForm = longformRegex.exec(longForm.value);\n      return splitForm === null ? [\n        'FFFFFF',\n        'FF',\n        'FF',\n        'FF'\n      ] : splitForm;\n    };\n    const toHex = component => {\n      const hex = component.toString(16);\n      return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\n    };\n    const fromRgba = rgbaColour => {\n      const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\n      return hexColour(value);\n    };\n\n    const min = Math.min;\n    const max = Math.max;\n    const round$1 = Math.round;\n    const rgbRegex = /^\\s*rgb\\s*\\(\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*\\)\\s*$/i;\n    const rgbaRegex = /^\\s*rgba\\s*\\(\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*((?:\\d?\\.\\d+|\\d+)%?)\\s*\\)\\s*$/i;\n    const rgbaColour = (red, green, blue, alpha) => ({\n      red,\n      green,\n      blue,\n      alpha\n    });\n    const isRgbaComponent = value => {\n      const num = parseInt(value, 10);\n      return num.toString() === value && num >= 0 && num <= 255;\n    };\n    const fromHsv = hsv => {\n      let r;\n      let g;\n      let b;\n      const hue = (hsv.hue || 0) % 360;\n      let saturation = hsv.saturation / 100;\n      let brightness = hsv.value / 100;\n      saturation = max(0, min(saturation, 1));\n      brightness = max(0, min(brightness, 1));\n      if (saturation === 0) {\n        r = g = b = round$1(255 * brightness);\n        return rgbaColour(r, g, b, 1);\n      }\n      const side = hue / 60;\n      const chroma = brightness * saturation;\n      const x = chroma * (1 - Math.abs(side % 2 - 1));\n      const match = brightness - chroma;\n      switch (Math.floor(side)) {\n      case 0:\n        r = chroma;\n        g = x;\n        b = 0;\n        break;\n      case 1:\n        r = x;\n        g = chroma;\n        b = 0;\n        break;\n      case 2:\n        r = 0;\n        g = chroma;\n        b = x;\n        break;\n      case 3:\n        r = 0;\n        g = x;\n        b = chroma;\n        break;\n      case 4:\n        r = x;\n        g = 0;\n        b = chroma;\n        break;\n      case 5:\n        r = chroma;\n        g = 0;\n        b = x;\n        break;\n      default:\n        r = g = b = 0;\n      }\n      r = round$1(255 * (r + match));\n      g = round$1(255 * (g + match));\n      b = round$1(255 * (b + match));\n      return rgbaColour(r, g, b, 1);\n    };\n    const fromHex = hexColour => {\n      const result = extractValues(hexColour);\n      const red = parseInt(result[1], 16);\n      const green = parseInt(result[2], 16);\n      const blue = parseInt(result[3], 16);\n      return rgbaColour(red, green, blue, 1);\n    };\n    const fromStringValues = (red, green, blue, alpha) => {\n      const r = parseInt(red, 10);\n      const g = parseInt(green, 10);\n      const b = parseInt(blue, 10);\n      const a = parseFloat(alpha);\n      return rgbaColour(r, g, b, a);\n    };\n    const fromString = rgbaString => {\n      const rgbMatch = rgbRegex.exec(rgbaString);\n      if (rgbMatch !== null) {\n        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\n      }\n      const rgbaMatch = rgbaRegex.exec(rgbaString);\n      if (rgbaMatch !== null) {\n        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\n      }\n      return Optional.none();\n    };\n    const toString = rgba => `rgba(${ rgba.red },${ rgba.green },${ rgba.blue },${ rgba.alpha })`;\n    const red = rgbaColour(255, 0, 0, 1);\n\n    const fireSkinLoaded$1 = editor => {\n      editor.dispatch('SkinLoaded');\n    };\n    const fireSkinLoadError$1 = (editor, error) => {\n      editor.dispatch('SkinLoadError', error);\n    };\n    const fireResizeEditor = editor => {\n      editor.dispatch('ResizeEditor');\n    };\n    const fireResizeContent = (editor, e) => {\n      editor.dispatch('ResizeContent', e);\n    };\n    const fireScrollContent = (editor, e) => {\n      editor.dispatch('ScrollContent', e);\n    };\n    const fireTextColorChange = (editor, data) => {\n      editor.dispatch('TextColorChange', data);\n    };\n    const fireAfterProgressState = (editor, state) => {\n      editor.dispatch('AfterProgressState', { state });\n    };\n    const fireResolveName = (editor, node) => editor.dispatch('ResolveName', {\n      name: node.nodeName.toLowerCase(),\n      target: node\n    });\n    const fireToggleToolbarDrawer = (editor, state) => {\n      editor.dispatch('ToggleToolbarDrawer', { state });\n    };\n    const fireStylesTextUpdate = (editor, data) => {\n      editor.dispatch('StylesTextUpdate', data);\n    };\n    const fireAlignTextUpdate = (editor, data) => {\n      editor.dispatch('AlignTextUpdate', data);\n    };\n    const fireFontSizeTextUpdate = (editor, data) => {\n      editor.dispatch('FontSizeTextUpdate', data);\n    };\n    const fireFontSizeInputTextUpdate = (editor, data) => {\n      editor.dispatch('FontSizeInputTextUpdate', data);\n    };\n    const fireBlocksTextUpdate = (editor, data) => {\n      editor.dispatch('BlocksTextUpdate', data);\n    };\n    const fireFontFamilyTextUpdate = (editor, data) => {\n      editor.dispatch('FontFamilyTextUpdate', data);\n    };\n\n    const composeUnbinders = (f, g) => () => {\n      f();\n      g();\n    };\n    const onSetupEditableToggle = editor => onSetupEvent(editor, 'NodeChange', api => {\n      api.setEnabled(editor.selection.isEditable());\n    });\n    const onSetupFormatToggle = (editor, name) => api => {\n      const boundFormatChangeCallback = unbindable();\n      const init = () => {\n        api.setActive(editor.formatter.match(name));\n        const binding = editor.formatter.formatChanged(name, api.setActive);\n        boundFormatChangeCallback.set(binding);\n      };\n      editor.initialized ? init() : editor.once('init', init);\n      return () => {\n        editor.off('init', init);\n        boundFormatChangeCallback.clear();\n      };\n    };\n    const onSetupStateToggle = (editor, name) => api => {\n      const unbindEditableToogle = onSetupEditableToggle(editor)(api);\n      const unbindFormatToggle = onSetupFormatToggle(editor, name)(api);\n      return () => {\n        unbindEditableToogle();\n        unbindFormatToggle();\n      };\n    };\n    const onSetupEvent = (editor, event, f) => api => {\n      const handleEvent = () => f(api);\n      const init = () => {\n        f(api);\n        editor.on(event, handleEvent);\n      };\n      editor.initialized ? init() : editor.once('init', init);\n      return () => {\n        editor.off('init', init);\n        editor.off(event, handleEvent);\n      };\n    };\n    const onActionToggleFormat$1 = editor => rawItem => () => {\n      editor.undoManager.transact(() => {\n        editor.focus();\n        editor.execCommand('mceToggleFormat', false, rawItem.format);\n      });\n    };\n    const onActionExecCommand = (editor, command) => () => editor.execCommand(command);\n\n    var global$4 = tinymce.util.Tools.resolve('tinymce.util.LocalStorage');\n\n    const cacheStorage = {};\n    const ColorCache = (storageId, max = 10) => {\n      const storageString = global$4.getItem(storageId);\n      const localstorage = isString(storageString) ? JSON.parse(storageString) : [];\n      const prune = list => {\n        const diff = max - list.length;\n        return diff < 0 ? list.slice(0, max) : list;\n      };\n      const cache = prune(localstorage);\n      const add = key => {\n        indexOf(cache, key).each(remove);\n        cache.unshift(key);\n        if (cache.length > max) {\n          cache.pop();\n        }\n        global$4.setItem(storageId, JSON.stringify(cache));\n      };\n      const remove = idx => {\n        cache.splice(idx, 1);\n      };\n      const state = () => cache.slice(0);\n      return {\n        add,\n        state\n      };\n    };\n    const getCacheForId = id => get$h(cacheStorage, id).getOrThunk(() => {\n      const storageId = `tinymce-custom-colors-${ id }`;\n      const currentData = global$4.getItem(storageId);\n      if (isNullable(currentData)) {\n        const legacyDefault = global$4.getItem('tinymce-custom-colors');\n        global$4.setItem(storageId, isNonNullable(legacyDefault) ? legacyDefault : '[]');\n      }\n      const storage = ColorCache(storageId, 10);\n      cacheStorage[id] = storage;\n      return storage;\n    });\n    const getCurrentColors = id => map$2(getCacheForId(id).state(), color => ({\n      type: 'choiceitem',\n      text: color,\n      icon: 'checkmark',\n      value: color\n    }));\n    const addColor = (id, color) => {\n      getCacheForId(id).add(color);\n    };\n\n    const hsvColour = (hue, saturation, value) => ({\n      hue,\n      saturation,\n      value\n    });\n    const fromRgb = rgbaColour => {\n      let h = 0;\n      let s = 0;\n      let v = 0;\n      const r = rgbaColour.red / 255;\n      const g = rgbaColour.green / 255;\n      const b = rgbaColour.blue / 255;\n      const minRGB = Math.min(r, Math.min(g, b));\n      const maxRGB = Math.max(r, Math.max(g, b));\n      if (minRGB === maxRGB) {\n        v = minRGB;\n        return hsvColour(0, 0, v * 100);\n      }\n      const d = r === minRGB ? g - b : b === minRGB ? r - g : b - r;\n      h = r === minRGB ? 3 : b === minRGB ? 1 : 5;\n      h = 60 * (h - d / (maxRGB - minRGB));\n      s = (maxRGB - minRGB) / maxRGB;\n      v = maxRGB;\n      return hsvColour(Math.round(h), Math.round(s * 100), Math.round(v * 100));\n    };\n\n    const hexToHsv = hex => fromRgb(fromHex(hex));\n    const hsvToHex = hsv => fromRgba(fromHsv(hsv));\n    const anyToHex = color => fromString$1(color).orThunk(() => fromString(color).map(fromRgba)).getOrThunk(() => {\n      const canvas = document.createElement('canvas');\n      canvas.height = 1;\n      canvas.width = 1;\n      const canvasContext = canvas.getContext('2d');\n      canvasContext.clearRect(0, 0, canvas.width, canvas.height);\n      canvasContext.fillStyle = '#FFFFFF';\n      canvasContext.fillStyle = color;\n      canvasContext.fillRect(0, 0, 1, 1);\n      const rgba = canvasContext.getImageData(0, 0, 1, 1).data;\n      const r = rgba[0];\n      const g = rgba[1];\n      const b = rgba[2];\n      const a = rgba[3];\n      return fromRgba(rgbaColour(r, g, b, a));\n    });\n\n    const foregroundId = 'forecolor';\n    const backgroundId = 'hilitecolor';\n    const fallbackCols = 5;\n    const mapColors = colorMap => {\n      const colors = [];\n      for (let i = 0; i < colorMap.length; i += 2) {\n        colors.push({\n          text: colorMap[i + 1],\n          value: '#' + anyToHex(colorMap[i]).value,\n          icon: 'checkmark',\n          type: 'choiceitem'\n        });\n      }\n      return colors;\n    };\n    const option$1 = name => editor => editor.options.get(name);\n    const fallbackColor = '#000000';\n    const register$d = editor => {\n      const registerOption = editor.options.register;\n      const colorProcessor = value => {\n        if (isArrayOf(value, isString)) {\n          return {\n            value: mapColors(value),\n            valid: true\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be an array of strings.'\n          };\n        }\n      };\n      const colorColsProcessor = value => {\n        if (isNumber(value) && value > 0) {\n          return {\n            value,\n            valid: true\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be a positive number.'\n          };\n        }\n      };\n      registerOption('color_map', {\n        processor: colorProcessor,\n        default: [\n          '#BFEDD2',\n          'Light Green',\n          '#FBEEB8',\n          'Light Yellow',\n          '#F8CAC6',\n          'Light Red',\n          '#ECCAFA',\n          'Light Purple',\n          '#C2E0F4',\n          'Light Blue',\n          '#2DC26B',\n          'Green',\n          '#F1C40F',\n          'Yellow',\n          '#E03E2D',\n          'Red',\n          '#B96AD9',\n          'Purple',\n          '#3598DB',\n          'Blue',\n          '#169179',\n          'Dark Turquoise',\n          '#E67E23',\n          'Orange',\n          '#BA372A',\n          'Dark Red',\n          '#843FA1',\n          'Dark Purple',\n          '#236FA1',\n          'Dark Blue',\n          '#ECF0F1',\n          'Light Gray',\n          '#CED4D9',\n          'Medium Gray',\n          '#95A5A6',\n          'Gray',\n          '#7E8C8D',\n          'Dark Gray',\n          '#34495E',\n          'Navy Blue',\n          '#000000',\n          'Black',\n          '#ffffff',\n          'White'\n        ]\n      });\n      registerOption('color_map_background', { processor: colorProcessor });\n      registerOption('color_map_foreground', { processor: colorProcessor });\n      registerOption('color_cols', {\n        processor: colorColsProcessor,\n        default: calcCols(editor)\n      });\n      registerOption('color_cols_foreground', {\n        processor: colorColsProcessor,\n        default: defaultCols(editor, foregroundId)\n      });\n      registerOption('color_cols_background', {\n        processor: colorColsProcessor,\n        default: defaultCols(editor, backgroundId)\n      });\n      registerOption('custom_colors', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('color_default_foreground', {\n        processor: 'string',\n        default: fallbackColor\n      });\n      registerOption('color_default_background', {\n        processor: 'string',\n        default: fallbackColor\n      });\n    };\n    const getColors$2 = (editor, id) => {\n      if (id === foregroundId && editor.options.isSet('color_map_foreground')) {\n        return option$1('color_map_foreground')(editor);\n      } else if (id === backgroundId && editor.options.isSet('color_map_background')) {\n        return option$1('color_map_background')(editor);\n      } else {\n        return option$1('color_map')(editor);\n      }\n    };\n    const calcCols = (editor, id = 'default') => Math.max(fallbackCols, Math.ceil(Math.sqrt(getColors$2(editor, id).length)));\n    const defaultCols = (editor, id) => {\n      const defaultCols = option$1('color_cols')(editor);\n      const calculatedCols = calcCols(editor, id);\n      if (defaultCols === calcCols(editor)) {\n        return calculatedCols;\n      } else {\n        return defaultCols;\n      }\n    };\n    const getColorCols$1 = (editor, id = 'default') => {\n      const getCols = () => {\n        if (id === foregroundId) {\n          return option$1('color_cols_foreground')(editor);\n        } else if (id === backgroundId) {\n          return option$1('color_cols_background')(editor);\n        } else {\n          return option$1('color_cols')(editor);\n        }\n      };\n      return Math.round(getCols());\n    };\n    const hasCustomColors$1 = option$1('custom_colors');\n    const getDefaultForegroundColor = option$1('color_default_foreground');\n    const getDefaultBackgroundColor = option$1('color_default_background');\n\n    const defaultBackgroundColor = 'rgba(0, 0, 0, 0)';\n    const isValidBackgroundColor = value => fromString(value).exists(c => c.alpha !== 0);\n    const getClosestCssBackgroundColorValue = scope => {\n      return closest$4(scope, node => {\n        if (isElement$1(node)) {\n          const color = get$f(node, 'background-color');\n          return someIf(isValidBackgroundColor(color), color);\n        } else {\n          return Optional.none();\n        }\n      }).getOr(defaultBackgroundColor);\n    };\n    const getCurrentColor = (editor, format) => {\n      const node = SugarElement.fromDom(editor.selection.getStart());\n      const cssRgbValue = format === 'hilitecolor' ? getClosestCssBackgroundColorValue(node) : get$f(node, 'color');\n      return fromString(cssRgbValue).map(rgba => '#' + fromRgba(rgba).value);\n    };\n    const applyFormat = (editor, format, value) => {\n      editor.undoManager.transact(() => {\n        editor.focus();\n        editor.formatter.apply(format, { value });\n        editor.nodeChanged();\n      });\n    };\n    const removeFormat = (editor, format) => {\n      editor.undoManager.transact(() => {\n        editor.focus();\n        editor.formatter.remove(format, { value: null }, undefined, true);\n        editor.nodeChanged();\n      });\n    };\n    const registerCommands = editor => {\n      editor.addCommand('mceApplyTextcolor', (format, value) => {\n        applyFormat(editor, format, value);\n      });\n      editor.addCommand('mceRemoveTextcolor', format => {\n        removeFormat(editor, format);\n      });\n    };\n    const getAdditionalColors = hasCustom => {\n      const type = 'choiceitem';\n      const remove = {\n        type,\n        text: 'Remove color',\n        icon: 'color-swatch-remove-color',\n        value: 'remove'\n      };\n      const custom = {\n        type,\n        text: 'Custom color',\n        icon: 'color-picker',\n        value: 'custom'\n      };\n      return hasCustom ? [\n        remove,\n        custom\n      ] : [remove];\n    };\n    const applyColor = (editor, format, value, onChoice) => {\n      if (value === 'custom') {\n        const dialog = colorPickerDialog(editor);\n        dialog(colorOpt => {\n          colorOpt.each(color => {\n            addColor(format, color);\n            editor.execCommand('mceApplyTextcolor', format, color);\n            onChoice(color);\n          });\n        }, getCurrentColor(editor, format).getOr(fallbackColor));\n      } else if (value === 'remove') {\n        onChoice('');\n        editor.execCommand('mceRemoveTextcolor', format);\n      } else {\n        onChoice(value);\n        editor.execCommand('mceApplyTextcolor', format, value);\n      }\n    };\n    const getColors$1 = (colors, id, hasCustom) => colors.concat(getCurrentColors(id).concat(getAdditionalColors(hasCustom)));\n    const getFetch$1 = (colors, id, hasCustom) => callback => {\n      callback(getColors$1(colors, id, hasCustom));\n    };\n    const setIconColor = (splitButtonApi, name, newColor) => {\n      const id = name === 'forecolor' ? 'tox-icon-text-color__color' : 'tox-icon-highlight-bg-color__color';\n      splitButtonApi.setIconFill(id, newColor);\n    };\n    const setTooltip = (buttonApi, tooltip) => {\n      buttonApi.setTooltip(tooltip);\n    };\n    const select$1 = (editor, format) => value => {\n      const optCurrentHex = getCurrentColor(editor, format);\n      return is$1(optCurrentHex, value.toUpperCase());\n    };\n    const getToolTipText = (editor, format, lastColor) => {\n      if (isEmpty(lastColor)) {\n        return format === 'forecolor' ? 'Text color' : 'Background color';\n      }\n      const tooltipPrefix = format === 'forecolor' ? 'Text color {0}' : 'Background color {0}';\n      const colors = getColors$1(getColors$2(editor, format), format, false);\n      const colorText = find$5(colors, c => c.value === lastColor).getOr({ text: '' }).text;\n      return editor.translate([\n        tooltipPrefix,\n        editor.translate(colorText)\n      ]);\n    };\n    const registerTextColorButton = (editor, name, format, lastColor) => {\n      editor.ui.registry.addSplitButton(name, {\n        tooltip: getToolTipText(editor, format, lastColor.get()),\n        presets: 'color',\n        icon: name === 'forecolor' ? 'text-color' : 'highlight-bg-color',\n        select: select$1(editor, format),\n        columns: getColorCols$1(editor, format),\n        fetch: getFetch$1(getColors$2(editor, format), format, hasCustomColors$1(editor)),\n        onAction: _splitButtonApi => {\n          applyColor(editor, format, lastColor.get(), noop);\n        },\n        onItemAction: (_splitButtonApi, value) => {\n          applyColor(editor, format, value, newColor => {\n            lastColor.set(newColor);\n            fireTextColorChange(editor, {\n              name,\n              color: newColor\n            });\n          });\n        },\n        onSetup: splitButtonApi => {\n          setIconColor(splitButtonApi, name, lastColor.get());\n          const handler = e => {\n            if (e.name === name) {\n              setIconColor(splitButtonApi, e.name, e.color);\n              setTooltip(splitButtonApi, getToolTipText(editor, format, e.color));\n            }\n          };\n          editor.on('TextColorChange', handler);\n          return composeUnbinders(onSetupEditableToggle(editor)(splitButtonApi), () => {\n            editor.off('TextColorChange', handler);\n          });\n        }\n      });\n    };\n    const registerTextColorMenuItem = (editor, name, format, text, lastColor) => {\n      editor.ui.registry.addNestedMenuItem(name, {\n        text,\n        icon: name === 'forecolor' ? 'text-color' : 'highlight-bg-color',\n        onSetup: api => {\n          setTooltip(api, getToolTipText(editor, format, lastColor.get()));\n          setIconColor(api, name, lastColor.get());\n          return onSetupEditableToggle(editor)(api);\n        },\n        getSubmenuItems: () => [{\n            type: 'fancymenuitem',\n            fancytype: 'colorswatch',\n            select: select$1(editor, format),\n            initData: { storageKey: format },\n            onAction: data => {\n              applyColor(editor, format, data.value, newColor => {\n                lastColor.set(newColor);\n                fireTextColorChange(editor, {\n                  name,\n                  color: newColor\n                });\n              });\n            }\n          }]\n      });\n    };\n    const colorPickerDialog = editor => (callback, value) => {\n      let isValid = false;\n      const onSubmit = api => {\n        const data = api.getData();\n        const hex = data.colorpicker;\n        if (isValid) {\n          callback(Optional.from(hex));\n          api.close();\n        } else {\n          editor.windowManager.alert(editor.translate([\n            'Invalid hex color code: {0}',\n            hex\n          ]));\n        }\n      };\n      const onAction = (_api, details) => {\n        if (details.name === 'hex-valid') {\n          isValid = details.value;\n        }\n      };\n      const initialData = { colorpicker: value };\n      editor.windowManager.open({\n        title: 'Color Picker',\n        size: 'normal',\n        body: {\n          type: 'panel',\n          items: [{\n              type: 'colorpicker',\n              name: 'colorpicker',\n              label: 'Color'\n            }]\n        },\n        buttons: [\n          {\n            type: 'cancel',\n            name: 'cancel',\n            text: 'Cancel'\n          },\n          {\n            type: 'submit',\n            name: 'save',\n            text: 'Save',\n            primary: true\n          }\n        ],\n        initialData,\n        onAction,\n        onSubmit,\n        onClose: noop,\n        onCancel: () => {\n          callback(Optional.none());\n        }\n      });\n    };\n    const register$c = editor => {\n      registerCommands(editor);\n      const fallbackColorForeground = getDefaultForegroundColor(editor);\n      const fallbackColorBackground = getDefaultBackgroundColor(editor);\n      const lastForeColor = Cell(fallbackColorForeground);\n      const lastBackColor = Cell(fallbackColorBackground);\n      registerTextColorButton(editor, 'forecolor', 'forecolor', lastForeColor);\n      registerTextColorButton(editor, 'backcolor', 'hilitecolor', lastBackColor);\n      registerTextColorMenuItem(editor, 'forecolor', 'forecolor', 'Text color', lastForeColor);\n      registerTextColorMenuItem(editor, 'backcolor', 'hilitecolor', 'Background color', lastBackColor);\n    };\n\n    const createPartialChoiceMenu = (value, items, onItemValueHandler, columns, presets, itemResponse, select, providersBackstage) => {\n      const hasIcons = menuHasIcons(items);\n      const presetItemTypes = presets !== 'color' ? 'normal' : 'color';\n      const alloyItems = createChoiceItems(items, onItemValueHandler, columns, presetItemTypes, itemResponse, select, providersBackstage);\n      const menuLayout = { menuType: presets };\n      return createPartialMenuWithAlloyItems(value, hasIcons, alloyItems, columns, menuLayout);\n    };\n    const createChoiceItems = (items, onItemValueHandler, columns, itemPresets, itemResponse, select, providersBackstage) => cat(map$2(items, item => {\n      if (item.type === 'choiceitem') {\n        return createChoiceMenuItem(item).fold(handleError, d => Optional.some(renderChoiceItem(d, columns === 1, itemPresets, onItemValueHandler, select(d.value), itemResponse, providersBackstage, menuHasIcons(items))));\n      } else {\n        return Optional.none();\n      }\n    }));\n\n    const deriveMenuMovement = (columns, presets) => {\n      const menuMarkers = markers(presets);\n      if (columns === 1) {\n        return {\n          mode: 'menu',\n          moveOnTab: true\n        };\n      } else if (columns === 'auto') {\n        return {\n          mode: 'grid',\n          selector: '.' + menuMarkers.item,\n          initSize: {\n            numColumns: 1,\n            numRows: 1\n          }\n        };\n      } else {\n        const rowClass = presets === 'color' ? 'tox-swatches__row' : 'tox-collection__group';\n        return {\n          mode: 'matrix',\n          rowSelector: '.' + rowClass,\n          previousSelector: menu => {\n            return presets === 'color' ? descendant(menu.element, '[aria-checked=true]') : Optional.none();\n          }\n        };\n      }\n    };\n    const deriveCollectionMovement = (columns, presets) => {\n      if (columns === 1) {\n        return {\n          mode: 'menu',\n          moveOnTab: false,\n          selector: '.tox-collection__item'\n        };\n      } else if (columns === 'auto') {\n        return {\n          mode: 'flatgrid',\n          selector: '.' + 'tox-collection__item',\n          initSize: {\n            numColumns: 1,\n            numRows: 1\n          }\n        };\n      } else {\n        return {\n          mode: 'matrix',\n          selectors: {\n            row: presets === 'color' ? '.tox-swatches__row' : '.tox-collection__group',\n            cell: presets === 'color' ? `.${ colorClass }` : `.${ selectableClass }`\n          }\n        };\n      }\n    };\n\n    const renderColorSwatchItem = (spec, backstage) => {\n      const items = getColorItems(spec, backstage);\n      const columns = backstage.colorinput.getColorCols(spec.initData.storageKey);\n      const presets = 'color';\n      const menuSpec = createPartialChoiceMenu(generate$6('menu-value'), items, value => {\n        spec.onAction({ value });\n      }, columns, presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(never), backstage.shared.providers);\n      const widgetSpec = {\n        ...menuSpec,\n        markers: markers(presets),\n        movement: deriveMenuMovement(columns, presets),\n        showMenuRole: false\n      };\n      return {\n        type: 'widget',\n        data: { value: generate$6('widget-id') },\n        dom: {\n          tag: 'div',\n          classes: ['tox-fancymenuitem']\n        },\n        autofocus: true,\n        components: [parts$f.widget(Menu.sketch(widgetSpec))]\n      };\n    };\n    const getColorItems = (spec, backstage) => {\n      const useCustomColors = spec.initData.allowCustomColors && backstage.colorinput.hasCustomColors();\n      return spec.initData.colors.fold(() => getColors$1(backstage.colorinput.getColors(spec.initData.storageKey), spec.initData.storageKey, useCustomColors), colors => colors.concat(getAdditionalColors(useCustomColors)));\n    };\n\n    const cellOverEvent = generate$6('cell-over');\n    const cellExecuteEvent = generate$6('cell-execute');\n    const makeAnnouncementText = backstage => (row, col) => backstage.shared.providers.translate([\n      '{0} columns, {1} rows',\n      col,\n      row\n    ]);\n    const makeCell = (row, col, label) => {\n      const emitCellOver = c => emitWith(c, cellOverEvent, {\n        row,\n        col\n      });\n      const emitExecute = c => emitWith(c, cellExecuteEvent, {\n        row,\n        col\n      });\n      const onClick = (c, se) => {\n        se.stop();\n        emitExecute(c);\n      };\n      return build$1({\n        dom: {\n          tag: 'div',\n          attributes: {\n            role: 'button',\n            ['aria-label']: label\n          }\n        },\n        behaviours: derive$1([\n          config('insert-table-picker-cell', [\n            run$1(mouseover(), Focusing.focus),\n            run$1(execute$5(), emitExecute),\n            run$1(click(), onClick),\n            run$1(tap(), onClick)\n          ]),\n          Toggling.config({\n            toggleClass: 'tox-insert-table-picker__selected',\n            toggleOnExecute: false\n          }),\n          Focusing.config({ onFocus: emitCellOver })\n        ])\n      });\n    };\n    const makeCells = (getCellLabel, numRows, numCols) => {\n      const cells = [];\n      for (let i = 0; i < numRows; i++) {\n        const row = [];\n        for (let j = 0; j < numCols; j++) {\n          const label = getCellLabel(i + 1, j + 1);\n          row.push(makeCell(i, j, label));\n        }\n        cells.push(row);\n      }\n      return cells;\n    };\n    const selectCells = (cells, selectedRow, selectedColumn, numRows, numColumns) => {\n      for (let i = 0; i < numRows; i++) {\n        for (let j = 0; j < numColumns; j++) {\n          Toggling.set(cells[i][j], i <= selectedRow && j <= selectedColumn);\n        }\n      }\n    };\n    const makeComponents = cells => bind$3(cells, cellRow => map$2(cellRow, premade));\n    const makeLabelText = (row, col) => text$2(`${ col }x${ row }`);\n    const renderInsertTableMenuItem = (spec, backstage) => {\n      const numRows = 10;\n      const numColumns = 10;\n      const getCellLabel = makeAnnouncementText(backstage);\n      const cells = makeCells(getCellLabel, numRows, numColumns);\n      const emptyLabelText = makeLabelText(0, 0);\n      const memLabel = record({\n        dom: {\n          tag: 'span',\n          classes: ['tox-insert-table-picker__label']\n        },\n        components: [emptyLabelText],\n        behaviours: derive$1([Replacing.config({})])\n      });\n      return {\n        type: 'widget',\n        data: { value: generate$6('widget-id') },\n        dom: {\n          tag: 'div',\n          classes: ['tox-fancymenuitem']\n        },\n        autofocus: true,\n        components: [parts$f.widget({\n            dom: {\n              tag: 'div',\n              classes: ['tox-insert-table-picker']\n            },\n            components: makeComponents(cells).concat(memLabel.asSpec()),\n            behaviours: derive$1([\n              config('insert-table-picker', [\n                runOnAttached(c => {\n                  Replacing.set(memLabel.get(c), [emptyLabelText]);\n                }),\n                runWithTarget(cellOverEvent, (c, t, e) => {\n                  const {row, col} = e.event;\n                  selectCells(cells, row, col, numRows, numColumns);\n                  Replacing.set(memLabel.get(c), [makeLabelText(row + 1, col + 1)]);\n                }),\n                runWithTarget(cellExecuteEvent, (c, _, e) => {\n                  const {row, col} = e.event;\n                  spec.onAction({\n                    numRows: row + 1,\n                    numColumns: col + 1\n                  });\n                  emit(c, sandboxClose());\n                })\n              ]),\n              Keying.config({\n                initSize: {\n                  numRows,\n                  numColumns\n                },\n                mode: 'flatgrid',\n                selector: '[role=\"button\"]'\n              })\n            ])\n          })]\n      };\n    };\n\n    const fancyMenuItems = {\n      inserttable: renderInsertTableMenuItem,\n      colorswatch: renderColorSwatchItem\n    };\n    const renderFancyMenuItem = (spec, backstage) => get$h(fancyMenuItems, spec.fancytype).map(render => render(spec, backstage));\n\n    const renderNestedItem = (spec, itemResponse, providersBackstage, renderIcons = true, downwardsCaret = false) => {\n      const caret = downwardsCaret ? renderDownwardsCaret(providersBackstage.icons) : renderSubmenuCaret(providersBackstage.icons);\n      const getApi = component => ({\n        isEnabled: () => !Disabling.isDisabled(component),\n        setEnabled: state => Disabling.set(component, !state),\n        setIconFill: (id, value) => {\n          descendant(component.element, `svg path[class=\"${ id }\"], rect[class=\"${ id }\"]`).each(underlinePath => {\n            set$9(underlinePath, 'fill', value);\n          });\n        },\n        setTooltip: tooltip => {\n          const translatedTooltip = providersBackstage.translate(tooltip);\n          set$9(component.element, 'aria-label', translatedTooltip);\n        }\n      });\n      const structure = renderItemStructure({\n        presets: 'normal',\n        iconContent: spec.icon,\n        textContent: spec.text,\n        htmlContent: Optional.none(),\n        ariaLabel: spec.text,\n        caret: Optional.some(caret),\n        checkMark: Optional.none(),\n        shortcutContent: spec.shortcut\n      }, providersBackstage, renderIcons);\n      return renderCommonItem({\n        data: buildData(spec),\n        getApi,\n        enabled: spec.enabled,\n        onAction: noop,\n        onSetup: spec.onSetup,\n        triggersSubmenu: true,\n        itemBehaviours: []\n      }, structure, itemResponse, providersBackstage);\n    };\n\n    const renderNormalItem = (spec, itemResponse, providersBackstage, renderIcons = true) => {\n      const getApi = component => ({\n        isEnabled: () => !Disabling.isDisabled(component),\n        setEnabled: state => Disabling.set(component, !state)\n      });\n      const structure = renderItemStructure({\n        presets: 'normal',\n        iconContent: spec.icon,\n        textContent: spec.text,\n        htmlContent: Optional.none(),\n        ariaLabel: spec.text,\n        caret: Optional.none(),\n        checkMark: Optional.none(),\n        shortcutContent: spec.shortcut\n      }, providersBackstage, renderIcons);\n      return renderCommonItem({\n        data: buildData(spec),\n        getApi,\n        enabled: spec.enabled,\n        onAction: spec.onAction,\n        onSetup: spec.onSetup,\n        triggersSubmenu: false,\n        itemBehaviours: []\n      }, structure, itemResponse, providersBackstage);\n    };\n\n    const renderSeparatorItem = spec => ({\n      type: 'separator',\n      dom: {\n        tag: 'div',\n        classes: [\n          selectableClass,\n          groupHeadingClass\n        ]\n      },\n      components: spec.text.map(text$2).toArray()\n    });\n\n    const renderToggleMenuItem = (spec, itemResponse, providersBackstage, renderIcons = true) => {\n      const getApi = component => ({\n        setActive: state => {\n          Toggling.set(component, state);\n        },\n        isActive: () => Toggling.isOn(component),\n        isEnabled: () => !Disabling.isDisabled(component),\n        setEnabled: state => Disabling.set(component, !state)\n      });\n      const structure = renderItemStructure({\n        iconContent: spec.icon,\n        textContent: spec.text,\n        htmlContent: Optional.none(),\n        ariaLabel: spec.text,\n        checkMark: Optional.some(renderCheckmark(providersBackstage.icons)),\n        caret: Optional.none(),\n        shortcutContent: spec.shortcut,\n        presets: 'normal',\n        meta: spec.meta\n      }, providersBackstage, renderIcons);\n      return deepMerge(renderCommonItem({\n        data: buildData(spec),\n        enabled: spec.enabled,\n        getApi,\n        onAction: spec.onAction,\n        onSetup: spec.onSetup,\n        triggersSubmenu: false,\n        itemBehaviours: []\n      }, structure, itemResponse, providersBackstage), {\n        toggling: {\n          toggleClass: tickedClass,\n          toggleOnExecute: false,\n          selected: spec.active\n        },\n        role: spec.role.getOrUndefined()\n      });\n    };\n\n    const autocomplete = renderAutocompleteItem;\n    const separator$3 = renderSeparatorItem;\n    const normal = renderNormalItem;\n    const nested = renderNestedItem;\n    const toggle$1 = renderToggleMenuItem;\n    const fancy = renderFancyMenuItem;\n    const card = renderCardMenuItem;\n\n    const getCoupled = (component, coupleConfig, coupleState, name) => coupleState.getOrCreate(component, coupleConfig, name);\n    const getExistingCoupled = (component, coupleConfig, coupleState, name) => coupleState.getExisting(component, coupleConfig, name);\n\n    var CouplingApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        getCoupled: getCoupled,\n        getExistingCoupled: getExistingCoupled\n    });\n\n    var CouplingSchema = [requiredOf('others', setOf(Result.value, anyValue()))];\n\n    const init$9 = () => {\n      const coupled = {};\n      const lookupCoupled = (coupleConfig, coupledName) => {\n        const available = keys(coupleConfig.others);\n        if (available.length === 0) {\n          throw new Error('Cannot find any known coupled components');\n        } else {\n          return get$h(coupled, coupledName);\n        }\n      };\n      const getOrCreate = (component, coupleConfig, name) => {\n        return lookupCoupled(coupleConfig, name).getOrThunk(() => {\n          const builder = get$h(coupleConfig.others, name).getOrDie('No information found for coupled component: ' + name);\n          const spec = builder(component);\n          const built = component.getSystem().build(spec);\n          coupled[name] = built;\n          return built;\n        });\n      };\n      const getExisting = (component, coupleConfig, name) => {\n        return lookupCoupled(coupleConfig, name).orThunk(() => {\n          get$h(coupleConfig.others, name).getOrDie('No information found for coupled component: ' + name);\n          return Optional.none();\n        });\n      };\n      const readState = constant$1({});\n      return nu$7({\n        readState,\n        getExisting,\n        getOrCreate\n      });\n    };\n\n    var CouplingState = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        init: init$9\n    });\n\n    const Coupling = create$4({\n      fields: CouplingSchema,\n      name: 'coupling',\n      apis: CouplingApis,\n      state: CouplingState\n    });\n\n    const nu$3 = baseFn => {\n      let data = Optional.none();\n      let callbacks = [];\n      const map = f => nu$3(nCallback => {\n        get(data => {\n          nCallback(f(data));\n        });\n      });\n      const get = nCallback => {\n        if (isReady()) {\n          call(nCallback);\n        } else {\n          callbacks.push(nCallback);\n        }\n      };\n      const set = x => {\n        if (!isReady()) {\n          data = Optional.some(x);\n          run(callbacks);\n          callbacks = [];\n        }\n      };\n      const isReady = () => data.isSome();\n      const run = cbs => {\n        each$1(cbs, call);\n      };\n      const call = cb => {\n        data.each(x => {\n          setTimeout(() => {\n            cb(x);\n          }, 0);\n        });\n      };\n      baseFn(set);\n      return {\n        get,\n        map,\n        isReady\n      };\n    };\n    const pure$1 = a => nu$3(callback => {\n      callback(a);\n    });\n    const LazyValue = {\n      nu: nu$3,\n      pure: pure$1\n    };\n\n    const errorReporter = err => {\n      setTimeout(() => {\n        throw err;\n      }, 0);\n    };\n    const make$5 = run => {\n      const get = callback => {\n        run().then(callback, errorReporter);\n      };\n      const map = fab => {\n        return make$5(() => run().then(fab));\n      };\n      const bind = aFutureB => {\n        return make$5(() => run().then(v => aFutureB(v).toPromise()));\n      };\n      const anonBind = futureB => {\n        return make$5(() => run().then(() => futureB.toPromise()));\n      };\n      const toLazy = () => {\n        return LazyValue.nu(get);\n      };\n      const toCached = () => {\n        let cache = null;\n        return make$5(() => {\n          if (cache === null) {\n            cache = run();\n          }\n          return cache;\n        });\n      };\n      const toPromise = run;\n      return {\n        map,\n        bind,\n        anonBind,\n        toLazy,\n        toCached,\n        toPromise,\n        get\n      };\n    };\n    const nu$2 = baseFn => {\n      return make$5(() => new Promise(baseFn));\n    };\n    const pure = a => {\n      return make$5(() => Promise.resolve(a));\n    };\n    const Future = {\n      nu: nu$2,\n      pure\n    };\n\n    const suffix = constant$1('sink');\n    const partType$1 = constant$1(optional({\n      name: suffix(),\n      overrides: constant$1({\n        dom: { tag: 'div' },\n        behaviours: derive$1([Positioning.config({ useFixed: always })]),\n        events: derive$2([\n          cutter(keydown()),\n          cutter(mousedown()),\n          cutter(click())\n        ])\n      })\n    }));\n\n    const getAnchor = (detail, component) => {\n      const hotspot = detail.getHotspot(component).getOr(component);\n      const type = 'hotspot';\n      const overrides = detail.getAnchorOverrides();\n      return detail.layouts.fold(() => ({\n        type,\n        hotspot,\n        overrides\n      }), layouts => ({\n        type,\n        hotspot,\n        overrides,\n        layouts\n      }));\n    };\n    const fetch = (detail, mapFetch, component) => {\n      const fetcher = detail.fetch;\n      return fetcher(component).map(mapFetch);\n    };\n    const openF = (detail, mapFetch, anchor, component, sandbox, externals, highlightOnOpen) => {\n      const futureData = fetch(detail, mapFetch, component);\n      const getLazySink = getSink(component, detail);\n      return futureData.map(tdata => tdata.bind(data => {\n        const primaryMenu = data.menus[data.primary];\n        Optional.from(primaryMenu).each(menu => {\n          detail.listRole.each(listRole => {\n            menu.role = listRole;\n          });\n        });\n        return Optional.from(tieredMenu.sketch({\n          ...externals.menu(),\n          uid: generate$5(''),\n          data,\n          highlightOnOpen,\n          onOpenMenu: (tmenu, menu) => {\n            const sink = getLazySink().getOrDie();\n            Positioning.position(sink, menu, { anchor });\n            Sandboxing.decloak(sandbox);\n          },\n          onOpenSubmenu: (tmenu, item, submenu) => {\n            const sink = getLazySink().getOrDie();\n            Positioning.position(sink, submenu, {\n              anchor: {\n                type: 'submenu',\n                item\n              }\n            });\n            Sandboxing.decloak(sandbox);\n          },\n          onRepositionMenu: (tmenu, primaryMenu, submenuTriggers) => {\n            const sink = getLazySink().getOrDie();\n            Positioning.position(sink, primaryMenu, { anchor });\n            each$1(submenuTriggers, st => {\n              Positioning.position(sink, st.triggeredMenu, {\n                anchor: {\n                  type: 'submenu',\n                  item: st.triggeringItem\n                }\n              });\n            });\n          },\n          onEscape: () => {\n            Focusing.focus(component);\n            Sandboxing.close(sandbox);\n            return Optional.some(true);\n          }\n        }));\n      }));\n    };\n    const open = (detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen) => {\n      const anchor = getAnchor(detail, hotspot);\n      const processed = openF(detail, mapFetch, anchor, hotspot, sandbox, externals, highlightOnOpen);\n      return processed.map(tdata => {\n        tdata.fold(() => {\n          if (Sandboxing.isOpen(sandbox)) {\n            Sandboxing.close(sandbox);\n          }\n        }, data => {\n          Sandboxing.cloak(sandbox);\n          Sandboxing.open(sandbox, data);\n          onOpenSync(sandbox);\n        });\n        return sandbox;\n      });\n    };\n    const close = (detail, mapFetch, component, sandbox, _externals, _onOpenSync, _highlightOnOpen) => {\n      Sandboxing.close(sandbox);\n      return Future.pure(sandbox);\n    };\n    const togglePopup = (detail, mapFetch, hotspot, externals, onOpenSync, highlightOnOpen) => {\n      const sandbox = Coupling.getCoupled(hotspot, 'sandbox');\n      const showing = Sandboxing.isOpen(sandbox);\n      const action = showing ? close : open;\n      return action(detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen);\n    };\n    const matchWidth = (hotspot, container, useMinWidth) => {\n      const menu = Composing.getCurrent(container).getOr(container);\n      const buttonWidth = get$d(hotspot.element);\n      if (useMinWidth) {\n        set$8(menu.element, 'min-width', buttonWidth + 'px');\n      } else {\n        set$7(menu.element, buttonWidth);\n      }\n    };\n    const getSink = (anyInSystem, sinkDetail) => anyInSystem.getSystem().getByUid(sinkDetail.uid + '-' + suffix()).map(internalSink => () => Result.value(internalSink)).getOrThunk(() => sinkDetail.lazySink.fold(() => () => Result.error(new Error('No internal sink is specified, nor could an external sink be found')), lazySinkFn => () => lazySinkFn(anyInSystem)));\n    const doRepositionMenus = sandbox => {\n      Sandboxing.getState(sandbox).each(tmenu => {\n        tieredMenu.repositionMenus(tmenu);\n      });\n    };\n    const makeSandbox$1 = (detail, hotspot, extras) => {\n      const ariaControls = manager();\n      const onOpen = (component, menu) => {\n        const anchor = getAnchor(detail, hotspot);\n        ariaControls.link(hotspot.element);\n        if (detail.matchWidth) {\n          matchWidth(anchor.hotspot, menu, detail.useMinWidth);\n        }\n        detail.onOpen(anchor, component, menu);\n        if (extras !== undefined && extras.onOpen !== undefined) {\n          extras.onOpen(component, menu);\n        }\n      };\n      const onClose = (component, menu) => {\n        ariaControls.unlink(hotspot.element);\n        lazySink().getOr(menu).element.dom.dispatchEvent(new window.FocusEvent('focusout'));\n        if (extras !== undefined && extras.onClose !== undefined) {\n          extras.onClose(component, menu);\n        }\n      };\n      const lazySink = getSink(hotspot, detail);\n      return {\n        dom: {\n          tag: 'div',\n          classes: detail.sandboxClasses,\n          attributes: { id: ariaControls.id }\n        },\n        behaviours: SketchBehaviours.augment(detail.sandboxBehaviours, [\n          Representing.config({\n            store: {\n              mode: 'memory',\n              initialValue: hotspot\n            }\n          }),\n          Sandboxing.config({\n            onOpen,\n            onClose,\n            isPartOf: (container, data, queryElem) => {\n              return isPartOf$1(data, queryElem) || isPartOf$1(hotspot, queryElem);\n            },\n            getAttachPoint: () => {\n              return lazySink().getOrDie();\n            }\n          }),\n          Composing.config({\n            find: sandbox => {\n              return Sandboxing.getState(sandbox).bind(menu => Composing.getCurrent(menu));\n            }\n          }),\n          Receiving.config({\n            channels: {\n              ...receivingChannel$1({ isExtraPart: never }),\n              ...receivingChannel({ doReposition: doRepositionMenus })\n            }\n          })\n        ])\n      };\n    };\n    const repositionMenus = comp => {\n      const sandbox = Coupling.getCoupled(comp, 'sandbox');\n      doRepositionMenus(sandbox);\n    };\n\n    const sandboxFields = () => [\n      defaulted('sandboxClasses', []),\n      SketchBehaviours.field('sandboxBehaviours', [\n        Composing,\n        Receiving,\n        Sandboxing,\n        Representing\n      ])\n    ];\n\n    const schema$k = constant$1([\n      required$1('dom'),\n      required$1('fetch'),\n      onHandler('onOpen'),\n      onKeyboardHandler('onExecute'),\n      defaulted('getHotspot', Optional.some),\n      defaulted('getAnchorOverrides', constant$1({})),\n      schema$y(),\n      field('dropdownBehaviours', [\n        Toggling,\n        Coupling,\n        Keying,\n        Focusing\n      ]),\n      required$1('toggleClass'),\n      defaulted('eventOrder', {}),\n      option$3('lazySink'),\n      defaulted('matchWidth', false),\n      defaulted('useMinWidth', false),\n      option$3('role'),\n      option$3('listRole')\n    ].concat(sandboxFields()));\n    const parts$e = constant$1([\n      external({\n        schema: [\n          tieredMenuMarkers(),\n          defaulted('fakeFocus', false)\n        ],\n        name: 'menu',\n        defaults: detail => {\n          return { onExecute: detail.onExecute };\n        }\n      }),\n      partType$1()\n    ]);\n\n    const factory$k = (detail, components, _spec, externals) => {\n      const lookupAttr = attr => get$h(detail.dom, 'attributes').bind(attrs => get$h(attrs, attr));\n      const switchToMenu = sandbox => {\n        Sandboxing.getState(sandbox).each(tmenu => {\n          tieredMenu.highlightPrimary(tmenu);\n        });\n      };\n      const togglePopup$1 = (dropdownComp, onOpenSync, highlightOnOpen) => {\n        return togglePopup(detail, identity, dropdownComp, externals, onOpenSync, highlightOnOpen);\n      };\n      const action = component => {\n        const onOpenSync = switchToMenu;\n        togglePopup$1(component, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop);\n      };\n      const apis = {\n        expand: comp => {\n          if (!Toggling.isOn(comp)) {\n            togglePopup$1(comp, noop, HighlightOnOpen.HighlightNone).get(noop);\n          }\n        },\n        open: comp => {\n          if (!Toggling.isOn(comp)) {\n            togglePopup$1(comp, noop, HighlightOnOpen.HighlightMenuAndItem).get(noop);\n          }\n        },\n        refetch: comp => {\n          const optSandbox = Coupling.getExistingCoupled(comp, 'sandbox');\n          return optSandbox.fold(() => {\n            return togglePopup$1(comp, noop, HighlightOnOpen.HighlightMenuAndItem).map(noop);\n          }, sandboxComp => {\n            return open(detail, identity, comp, sandboxComp, externals, noop, HighlightOnOpen.HighlightMenuAndItem).map(noop);\n          });\n        },\n        isOpen: Toggling.isOn,\n        close: comp => {\n          if (Toggling.isOn(comp)) {\n            togglePopup$1(comp, noop, HighlightOnOpen.HighlightMenuAndItem).get(noop);\n          }\n        },\n        repositionMenus: comp => {\n          if (Toggling.isOn(comp)) {\n            repositionMenus(comp);\n          }\n        }\n      };\n      const triggerExecute = (comp, _se) => {\n        emitExecute(comp);\n        return Optional.some(true);\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components,\n        behaviours: augment(detail.dropdownBehaviours, [\n          Toggling.config({\n            toggleClass: detail.toggleClass,\n            aria: { mode: 'expanded' }\n          }),\n          Coupling.config({\n            others: {\n              sandbox: hotspot => {\n                return makeSandbox$1(detail, hotspot, {\n                  onOpen: () => Toggling.on(hotspot),\n                  onClose: () => Toggling.off(hotspot)\n                });\n              }\n            }\n          }),\n          Keying.config({\n            mode: 'special',\n            onSpace: triggerExecute,\n            onEnter: triggerExecute,\n            onDown: (comp, _se) => {\n              if (Dropdown.isOpen(comp)) {\n                const sandbox = Coupling.getCoupled(comp, 'sandbox');\n                switchToMenu(sandbox);\n              } else {\n                Dropdown.open(comp);\n              }\n              return Optional.some(true);\n            },\n            onEscape: (comp, _se) => {\n              if (Dropdown.isOpen(comp)) {\n                Dropdown.close(comp);\n                return Optional.some(true);\n              } else {\n                return Optional.none();\n              }\n            }\n          }),\n          Focusing.config({})\n        ]),\n        events: events$9(Optional.some(action)),\n        eventOrder: {\n          ...detail.eventOrder,\n          [execute$5()]: [\n            'disabling',\n            'toggling',\n            'alloy.base.behaviour'\n          ]\n        },\n        apis,\n        domModification: {\n          attributes: {\n            'aria-haspopup': detail.listRole.getOr('true'),\n            ...detail.role.fold(() => ({}), role => ({ role })),\n            ...detail.dom.tag === 'button' ? { type: lookupAttr('type').getOr('button') } : {}\n          }\n        }\n      };\n    };\n    const Dropdown = composite({\n      name: 'Dropdown',\n      configFields: schema$k(),\n      partFields: parts$e(),\n      factory: factory$k,\n      apis: {\n        open: (apis, comp) => apis.open(comp),\n        refetch: (apis, comp) => apis.refetch(comp),\n        expand: (apis, comp) => apis.expand(comp),\n        close: (apis, comp) => apis.close(comp),\n        isOpen: (apis, comp) => apis.isOpen(comp),\n        repositionMenus: (apis, comp) => apis.repositionMenus(comp)\n      }\n    });\n\n    const identifyMenuLayout = searchMode => {\n      switch (searchMode.searchMode) {\n      case 'no-search': {\n          return { menuType: 'normal' };\n        }\n      default: {\n          return {\n            menuType: 'searchable',\n            searchMode\n          };\n        }\n      }\n    };\n    const handleRefetchTrigger = originalSandboxComp => {\n      const dropdown = Representing.getValue(originalSandboxComp);\n      const optSearcherState = findWithinSandbox(originalSandboxComp).map(saveState);\n      Dropdown.refetch(dropdown).get(() => {\n        const newSandboxComp = Coupling.getCoupled(dropdown, 'sandbox');\n        optSearcherState.each(searcherState => findWithinSandbox(newSandboxComp).each(inputComp => restoreState(inputComp, searcherState)));\n      });\n    };\n    const handleRedirectToMenuItem = (sandboxComp, se) => {\n      getActiveMenuItemFrom(sandboxComp).each(activeItem => {\n        retargetAndDispatchWith(sandboxComp, activeItem.element, se.event.eventType, se.event.interactionEvent);\n      });\n    };\n    const getActiveMenuItemFrom = sandboxComp => {\n      return Sandboxing.getState(sandboxComp).bind(Highlighting.getHighlighted).bind(Highlighting.getHighlighted);\n    };\n    const getSearchResults = activeMenuComp => {\n      return has(activeMenuComp.element, searchResultsClass) ? Optional.some(activeMenuComp.element) : descendant(activeMenuComp.element, '.' + searchResultsClass);\n    };\n    const updateAriaOnHighlight = (tmenuComp, menuComp, itemComp) => {\n      findWithinMenu(tmenuComp).each(inputComp => {\n        setActiveDescendant(inputComp, itemComp);\n        const optActiveResults = getSearchResults(menuComp);\n        optActiveResults.each(resultsElem => {\n          getOpt(resultsElem, 'id').each(controlledId => set$9(inputComp.element, 'aria-controls', controlledId));\n        });\n      });\n      set$9(itemComp.element, 'aria-selected', 'true');\n    };\n    const updateAriaOnDehighlight = (tmenuComp, menuComp, itemComp) => {\n      set$9(itemComp.element, 'aria-selected', 'false');\n    };\n    const focusSearchField = tmenuComp => {\n      findWithinMenu(tmenuComp).each(searcherComp => Focusing.focus(searcherComp));\n    };\n    const getSearchPattern = dropdownComp => {\n      const optSandboxComp = Coupling.getExistingCoupled(dropdownComp, 'sandbox');\n      return optSandboxComp.bind(findWithinSandbox).map(saveState).map(state => state.fetchPattern).getOr('');\n    };\n\n    var FocusMode;\n    (function (FocusMode) {\n      FocusMode[FocusMode['ContentFocus'] = 0] = 'ContentFocus';\n      FocusMode[FocusMode['UiFocus'] = 1] = 'UiFocus';\n    }(FocusMode || (FocusMode = {})));\n    const createMenuItemFromBridge = (item, itemResponse, backstage, menuHasIcons, isHorizontalMenu) => {\n      const providersBackstage = backstage.shared.providers;\n      const parseForHorizontalMenu = menuitem => !isHorizontalMenu ? menuitem : {\n        ...menuitem,\n        shortcut: Optional.none(),\n        icon: menuitem.text.isSome() ? Optional.none() : menuitem.icon\n      };\n      switch (item.type) {\n      case 'menuitem':\n        return createMenuItem(item).fold(handleError, d => Optional.some(normal(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons)));\n      case 'nestedmenuitem':\n        return createNestedMenuItem(item).fold(handleError, d => Optional.some(nested(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons, isHorizontalMenu)));\n      case 'togglemenuitem':\n        return createToggleMenuItem(item).fold(handleError, d => Optional.some(toggle$1(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons)));\n      case 'separator':\n        return createSeparatorMenuItem(item).fold(handleError, d => Optional.some(separator$3(d)));\n      case 'fancymenuitem':\n        return createFancyMenuItem(item).fold(handleError, d => fancy(d, backstage));\n      default: {\n          console.error('Unknown item in general menu', item);\n          return Optional.none();\n        }\n      }\n    };\n    const createAutocompleteItems = (items, matchText, onItemValueHandler, columns, itemResponse, sharedBackstage, highlightOn) => {\n      const renderText = columns === 1;\n      const renderIcons = !renderText || menuHasIcons(items);\n      return cat(map$2(items, item => {\n        switch (item.type) {\n        case 'separator':\n          return createSeparatorItem(item).fold(handleError, d => Optional.some(separator$3(d)));\n        case 'cardmenuitem':\n          return createCardMenuItem(item).fold(handleError, d => Optional.some(card({\n            ...d,\n            onAction: api => {\n              d.onAction(api);\n              onItemValueHandler(d.value, d.meta);\n            }\n          }, itemResponse, sharedBackstage, {\n            itemBehaviours: tooltipBehaviour(d.meta, sharedBackstage, Optional.none()),\n            cardText: {\n              matchText,\n              highlightOn\n            }\n          })));\n        case 'autocompleteitem':\n        default:\n          return createAutocompleterItem(item).fold(handleError, d => Optional.some(autocomplete(d, matchText, renderText, 'normal', onItemValueHandler, itemResponse, sharedBackstage, renderIcons)));\n        }\n      }));\n    };\n    const createPartialMenu = (value, items, itemResponse, backstage, isHorizontalMenu, searchMode) => {\n      const hasIcons = menuHasIcons(items);\n      const alloyItems = cat(map$2(items, item => {\n        const itemHasIcon = i => isHorizontalMenu ? !has$2(i, 'text') : hasIcons;\n        const createItem = i => createMenuItemFromBridge(i, itemResponse, backstage, itemHasIcon(i), isHorizontalMenu);\n        if (item.type === 'nestedmenuitem' && item.getSubmenuItems().length <= 0) {\n          return createItem({\n            ...item,\n            enabled: false\n          });\n        } else {\n          return createItem(item);\n        }\n      }));\n      const menuLayout = identifyMenuLayout(searchMode);\n      const createPartial = isHorizontalMenu ? createHorizontalPartialMenuWithAlloyItems : createPartialMenuWithAlloyItems;\n      return createPartial(value, hasIcons, alloyItems, 1, menuLayout);\n    };\n    const createTieredDataFrom = partialMenu => tieredMenu.singleData(partialMenu.value, partialMenu);\n    const createInlineMenuFrom = (partialMenu, columns, focusMode, presets) => {\n      const movement = deriveMenuMovement(columns, presets);\n      const menuMarkers = markers(presets);\n      return {\n        data: createTieredDataFrom({\n          ...partialMenu,\n          movement,\n          menuBehaviours: SimpleBehaviours.unnamedEvents(columns !== 'auto' ? [] : [runOnAttached((comp, _se) => {\n              detectSize(comp, 4, menuMarkers.item).each(({numColumns, numRows}) => {\n                Keying.setGridSize(comp, numRows, numColumns);\n              });\n            })])\n        }),\n        menu: {\n          markers: markers(presets),\n          fakeFocus: focusMode === FocusMode.ContentFocus\n        }\n      };\n    };\n\n    const rangeToSimRange = r => SimRange.create(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);\n    const register$b = (editor, sharedBackstage) => {\n      const autocompleterId = generate$6('autocompleter');\n      const processingAction = Cell(false);\n      const activeState = Cell(false);\n      const activeRange = value$4();\n      const autocompleter = build$1(InlineView.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-autocompleter'],\n          attributes: { id: autocompleterId }\n        },\n        components: [],\n        fireDismissalEventInstead: {},\n        inlineBehaviours: derive$1([config('dismissAutocompleter', [\n            run$1(dismissRequested(), () => cancelIfNecessary()),\n            run$1(highlight$1(), (_, se) => {\n              getOpt(se.event.target, 'id').each(id => set$9(SugarElement.fromDom(editor.getBody()), 'aria-activedescendant', id));\n            })\n          ])]),\n        lazySink: sharedBackstage.getSink\n      }));\n      const isMenuOpen = () => InlineView.isOpen(autocompleter);\n      const isActive = activeState.get;\n      const hideIfNecessary = () => {\n        if (isMenuOpen()) {\n          InlineView.hide(autocompleter);\n          editor.dom.remove(autocompleterId, false);\n          const editorBody = SugarElement.fromDom(editor.getBody());\n          getOpt(editorBody, 'aria-owns').filter(ariaOwnsAttr => ariaOwnsAttr === autocompleterId).each(() => {\n            remove$8(editorBody, 'aria-owns');\n            remove$8(editorBody, 'aria-activedescendant');\n          });\n        }\n      };\n      const getMenu = () => InlineView.getContent(autocompleter).bind(tmenu => {\n        return get$i(tmenu.components(), 0);\n      });\n      const cancelIfNecessary = () => editor.execCommand('mceAutocompleterClose');\n      const getCombinedItems = matches => {\n        const columns = findMap(matches, m => Optional.from(m.columns)).getOr(1);\n        return bind$3(matches, match => {\n          const choices = match.items;\n          return createAutocompleteItems(choices, match.matchText, (itemValue, itemMeta) => {\n            const autocompleterApi = {\n              hide: () => cancelIfNecessary(),\n              reload: fetchOptions => {\n                hideIfNecessary();\n                editor.execCommand('mceAutocompleterReload', false, { fetchOptions });\n              }\n            };\n            editor.execCommand('mceAutocompleterRefreshActiveRange');\n            activeRange.get().each(range => {\n              processingAction.set(true);\n              match.onAction(autocompleterApi, range, itemValue, itemMeta);\n              processingAction.set(false);\n            });\n          }, columns, ItemResponse$1.BUBBLE_TO_SANDBOX, sharedBackstage, match.highlightOn);\n        });\n      };\n      const display = (lookupData, items) => {\n        const columns = findMap(lookupData, ld => Optional.from(ld.columns)).getOr(1);\n        InlineView.showMenuAt(autocompleter, {\n          anchor: {\n            type: 'selection',\n            getSelection: () => activeRange.get().map(rangeToSimRange),\n            root: SugarElement.fromDom(editor.getBody())\n          }\n        }, createInlineMenuFrom(createPartialMenuWithAlloyItems('autocompleter-value', true, items, columns, { menuType: 'normal' }), columns, FocusMode.ContentFocus, 'normal'));\n        getMenu().each(Highlighting.highlightFirst);\n      };\n      const updateDisplay = lookupData => {\n        const combinedItems = getCombinedItems(lookupData);\n        if (combinedItems.length > 0) {\n          display(lookupData, combinedItems);\n          set$9(SugarElement.fromDom(editor.getBody()), 'aria-owns', autocompleterId);\n          if (!editor.inline) {\n            cloneAutocompleterToEditorDoc();\n          }\n        } else {\n          hideIfNecessary();\n        }\n      };\n      const cloneAutocompleterToEditorDoc = () => {\n        if (editor.dom.get(autocompleterId)) {\n          editor.dom.remove(autocompleterId, false);\n        }\n        const docElm = editor.getDoc().documentElement;\n        const selection = editor.selection.getNode();\n        const newElm = deep(autocompleter.element);\n        setAll(newElm, {\n          border: '0',\n          clip: 'rect(0 0 0 0)',\n          height: '1px',\n          margin: '-1px',\n          overflow: 'hidden',\n          padding: '0',\n          position: 'absolute',\n          width: '1px',\n          top: `${ selection.offsetTop }px`,\n          left: `${ selection.offsetLeft }px`\n        });\n        editor.dom.add(docElm, newElm.dom);\n        descendant(newElm, '[role=\"menu\"]').each(child => {\n          remove$7(child, 'position');\n          remove$7(child, 'max-height');\n        });\n      };\n      editor.on('AutocompleterStart', ({lookupData}) => {\n        activeState.set(true);\n        processingAction.set(false);\n        updateDisplay(lookupData);\n      });\n      editor.on('AutocompleterUpdate', ({lookupData}) => updateDisplay(lookupData));\n      editor.on('AutocompleterUpdateActiveRange', ({range}) => activeRange.set(range));\n      editor.on('AutocompleterEnd', () => {\n        hideIfNecessary();\n        activeState.set(false);\n        processingAction.set(false);\n        activeRange.clear();\n      });\n      const autocompleterUiApi = {\n        cancelIfNecessary,\n        isMenuOpen,\n        isActive,\n        isProcessingAction: processingAction.get,\n        getMenu\n      };\n      AutocompleterEditorEvents.setup(autocompleterUiApi, editor);\n    };\n    const Autocompleter = { register: register$b };\n\n    const closest = (scope, selector, isRoot) => closest$1(scope, selector, isRoot).isSome();\n\n    const DelayedFunction = (fun, delay) => {\n      let ref = null;\n      const schedule = (...args) => {\n        ref = setTimeout(() => {\n          fun.apply(null, args);\n          ref = null;\n        }, delay);\n      };\n      const cancel = () => {\n        if (ref !== null) {\n          clearTimeout(ref);\n          ref = null;\n        }\n      };\n      return {\n        cancel,\n        schedule\n      };\n    };\n\n    const SIGNIFICANT_MOVE = 5;\n    const LONGPRESS_DELAY = 400;\n    const getTouch = event => {\n      const raw = event.raw;\n      if (raw.touches === undefined || raw.touches.length !== 1) {\n        return Optional.none();\n      }\n      return Optional.some(raw.touches[0]);\n    };\n    const isFarEnough = (touch, data) => {\n      const distX = Math.abs(touch.clientX - data.x);\n      const distY = Math.abs(touch.clientY - data.y);\n      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\n    };\n    const monitor = settings => {\n      const startData = value$4();\n      const longpressFired = Cell(false);\n      const longpress$1 = DelayedFunction(event => {\n        settings.triggerEvent(longpress(), event);\n        longpressFired.set(true);\n      }, LONGPRESS_DELAY);\n      const handleTouchstart = event => {\n        getTouch(event).each(touch => {\n          longpress$1.cancel();\n          const data = {\n            x: touch.clientX,\n            y: touch.clientY,\n            target: event.target\n          };\n          longpress$1.schedule(event);\n          longpressFired.set(false);\n          startData.set(data);\n        });\n        return Optional.none();\n      };\n      const handleTouchmove = event => {\n        longpress$1.cancel();\n        getTouch(event).each(touch => {\n          startData.on(data => {\n            if (isFarEnough(touch, data)) {\n              startData.clear();\n            }\n          });\n        });\n        return Optional.none();\n      };\n      const handleTouchend = event => {\n        longpress$1.cancel();\n        const isSame = data => eq(data.target, event.target);\n        return startData.get().filter(isSame).map(_data => {\n          if (longpressFired.get()) {\n            event.prevent();\n            return false;\n          } else {\n            return settings.triggerEvent(tap(), event);\n          }\n        });\n      };\n      const handlers = wrapAll([\n        {\n          key: touchstart(),\n          value: handleTouchstart\n        },\n        {\n          key: touchmove(),\n          value: handleTouchmove\n        },\n        {\n          key: touchend(),\n          value: handleTouchend\n        }\n      ]);\n      const fireIfReady = (event, type) => get$h(handlers, type).bind(handler => handler(event));\n      return { fireIfReady };\n    };\n\n    const isDangerous = event => {\n      const keyEv = event.raw;\n      return keyEv.which === BACKSPACE[0] && !contains$2([\n        'input',\n        'textarea'\n      ], name$3(event.target)) && !closest(event.target, '[contenteditable=\"true\"]');\n    };\n    const setup$d = (container, rawSettings) => {\n      const settings = {\n        stopBackspace: true,\n        ...rawSettings\n      };\n      const pointerEvents = [\n        'touchstart',\n        'touchmove',\n        'touchend',\n        'touchcancel',\n        'gesturestart',\n        'mousedown',\n        'mouseup',\n        'mouseover',\n        'mousemove',\n        'mouseout',\n        'click'\n      ];\n      const tapEvent = monitor(settings);\n      const simpleEvents = map$2(pointerEvents.concat([\n        'selectstart',\n        'input',\n        'contextmenu',\n        'change',\n        'transitionend',\n        'transitioncancel',\n        'drag',\n        'dragstart',\n        'dragend',\n        'dragenter',\n        'dragleave',\n        'dragover',\n        'drop',\n        'keyup'\n      ]), type => bind(container, type, event => {\n        tapEvent.fireIfReady(event, type).each(tapStopped => {\n          if (tapStopped) {\n            event.kill();\n          }\n        });\n        const stopped = settings.triggerEvent(type, event);\n        if (stopped) {\n          event.kill();\n        }\n      }));\n      const pasteTimeout = value$4();\n      const onPaste = bind(container, 'paste', event => {\n        tapEvent.fireIfReady(event, 'paste').each(tapStopped => {\n          if (tapStopped) {\n            event.kill();\n          }\n        });\n        const stopped = settings.triggerEvent('paste', event);\n        if (stopped) {\n          event.kill();\n        }\n        pasteTimeout.set(setTimeout(() => {\n          settings.triggerEvent(postPaste(), event);\n        }, 0));\n      });\n      const onKeydown = bind(container, 'keydown', event => {\n        const stopped = settings.triggerEvent('keydown', event);\n        if (stopped) {\n          event.kill();\n        } else if (settings.stopBackspace && isDangerous(event)) {\n          event.prevent();\n        }\n      });\n      const onFocusIn = bind(container, 'focusin', event => {\n        const stopped = settings.triggerEvent('focusin', event);\n        if (stopped) {\n          event.kill();\n        }\n      });\n      const focusoutTimeout = value$4();\n      const onFocusOut = bind(container, 'focusout', event => {\n        const stopped = settings.triggerEvent('focusout', event);\n        if (stopped) {\n          event.kill();\n        }\n        focusoutTimeout.set(setTimeout(() => {\n          settings.triggerEvent(postBlur(), event);\n        }, 0));\n      });\n      const unbind = () => {\n        each$1(simpleEvents, e => {\n          e.unbind();\n        });\n        onKeydown.unbind();\n        onFocusIn.unbind();\n        onFocusOut.unbind();\n        onPaste.unbind();\n        pasteTimeout.on(clearTimeout);\n        focusoutTimeout.on(clearTimeout);\n      };\n      return { unbind };\n    };\n\n    const derive = (rawEvent, rawTarget) => {\n      const source = get$h(rawEvent, 'target').getOr(rawTarget);\n      return Cell(source);\n    };\n\n    const fromSource = (event, source) => {\n      const stopper = Cell(false);\n      const cutter = Cell(false);\n      const stop = () => {\n        stopper.set(true);\n      };\n      const cut = () => {\n        cutter.set(true);\n      };\n      return {\n        stop,\n        cut,\n        isStopped: stopper.get,\n        isCut: cutter.get,\n        event,\n        setSource: source.set,\n        getSource: source.get\n      };\n    };\n    const fromExternal = event => {\n      const stopper = Cell(false);\n      const stop = () => {\n        stopper.set(true);\n      };\n      return {\n        stop,\n        cut: noop,\n        isStopped: stopper.get,\n        isCut: never,\n        event,\n        setSource: die('Cannot set source of a broadcasted event'),\n        getSource: die('Cannot get source of a broadcasted event')\n      };\n    };\n\n    const adt$1 = Adt.generate([\n      { stopped: [] },\n      { resume: ['element'] },\n      { complete: [] }\n    ]);\n    const doTriggerHandler = (lookup, eventType, rawEvent, target, source, logger) => {\n      const handler = lookup(eventType, target);\n      const simulatedEvent = fromSource(rawEvent, source);\n      return handler.fold(() => {\n        logger.logEventNoHandlers(eventType, target);\n        return adt$1.complete();\n      }, handlerInfo => {\n        const descHandler = handlerInfo.descHandler;\n        const eventHandler = getCurried(descHandler);\n        eventHandler(simulatedEvent);\n        if (simulatedEvent.isStopped()) {\n          logger.logEventStopped(eventType, handlerInfo.element, descHandler.purpose);\n          return adt$1.stopped();\n        } else if (simulatedEvent.isCut()) {\n          logger.logEventCut(eventType, handlerInfo.element, descHandler.purpose);\n          return adt$1.complete();\n        } else {\n          return parent(handlerInfo.element).fold(() => {\n            logger.logNoParent(eventType, handlerInfo.element, descHandler.purpose);\n            return adt$1.complete();\n          }, parent => {\n            logger.logEventResponse(eventType, handlerInfo.element, descHandler.purpose);\n            return adt$1.resume(parent);\n          });\n        }\n      });\n    };\n    const doTriggerOnUntilStopped = (lookup, eventType, rawEvent, rawTarget, source, logger) => doTriggerHandler(lookup, eventType, rawEvent, rawTarget, source, logger).fold(always, parent => doTriggerOnUntilStopped(lookup, eventType, rawEvent, parent, source, logger), never);\n    const triggerHandler = (lookup, eventType, rawEvent, target, logger) => {\n      const source = derive(rawEvent, target);\n      return doTriggerHandler(lookup, eventType, rawEvent, target, source, logger);\n    };\n    const broadcast = (listeners, rawEvent, _logger) => {\n      const simulatedEvent = fromExternal(rawEvent);\n      each$1(listeners, listener => {\n        const descHandler = listener.descHandler;\n        const handler = getCurried(descHandler);\n        handler(simulatedEvent);\n      });\n      return simulatedEvent.isStopped();\n    };\n    const triggerUntilStopped = (lookup, eventType, rawEvent, logger) => triggerOnUntilStopped(lookup, eventType, rawEvent, rawEvent.target, logger);\n    const triggerOnUntilStopped = (lookup, eventType, rawEvent, rawTarget, logger) => {\n      const source = derive(rawEvent, rawTarget);\n      return doTriggerOnUntilStopped(lookup, eventType, rawEvent, rawTarget, source, logger);\n    };\n\n    const eventHandler = (element, descHandler) => ({\n      element,\n      descHandler\n    });\n    const broadcastHandler = (id, handler) => ({\n      id,\n      descHandler: handler\n    });\n    const EventRegistry = () => {\n      const registry = {};\n      const registerId = (extraArgs, id, events) => {\n        each(events, (v, k) => {\n          const handlers = registry[k] !== undefined ? registry[k] : {};\n          handlers[id] = curryArgs(v, extraArgs);\n          registry[k] = handlers;\n        });\n      };\n      const findHandler = (handlers, elem) => read(elem).bind(id => get$h(handlers, id)).map(descHandler => eventHandler(elem, descHandler));\n      const filterByType = type => get$h(registry, type).map(handlers => mapToArray(handlers, (f, id) => broadcastHandler(id, f))).getOr([]);\n      const find = (isAboveRoot, type, target) => get$h(registry, type).bind(handlers => closest$4(target, elem => findHandler(handlers, elem), isAboveRoot));\n      const unregisterId = id => {\n        each(registry, (handlersById, _eventName) => {\n          if (has$2(handlersById, id)) {\n            delete handlersById[id];\n          }\n        });\n      };\n      return {\n        registerId,\n        unregisterId,\n        filterByType,\n        find\n      };\n    };\n\n    const Registry = () => {\n      const events = EventRegistry();\n      const components = {};\n      const readOrTag = component => {\n        const elem = component.element;\n        return read(elem).getOrThunk(() => write('uid-', component.element));\n      };\n      const failOnDuplicate = (component, tagId) => {\n        const conflict = components[tagId];\n        if (conflict === component) {\n          unregister(component);\n        } else {\n          throw new Error('The tagId \"' + tagId + '\" is already used by: ' + element(conflict.element) + '\\nCannot use it for: ' + element(component.element) + '\\n' + 'The conflicting element is' + (inBody(conflict.element) ? ' ' : ' not ') + 'already in the DOM');\n        }\n      };\n      const register = component => {\n        const tagId = readOrTag(component);\n        if (hasNonNullableKey(components, tagId)) {\n          failOnDuplicate(component, tagId);\n        }\n        const extraArgs = [component];\n        events.registerId(extraArgs, tagId, component.events);\n        components[tagId] = component;\n      };\n      const unregister = component => {\n        read(component.element).each(tagId => {\n          delete components[tagId];\n          events.unregisterId(tagId);\n        });\n      };\n      const filter = type => events.filterByType(type);\n      const find = (isAboveRoot, type, target) => events.find(isAboveRoot, type, target);\n      const getById = id => get$h(components, id);\n      return {\n        find,\n        filter,\n        register,\n        unregister,\n        getById\n      };\n    };\n\n    const factory$j = detail => {\n      const {attributes, ...domWithoutAttributes} = detail.dom;\n      return {\n        uid: detail.uid,\n        dom: {\n          tag: 'div',\n          attributes: {\n            role: 'presentation',\n            ...attributes\n          },\n          ...domWithoutAttributes\n        },\n        components: detail.components,\n        behaviours: get$4(detail.containerBehaviours),\n        events: detail.events,\n        domModification: detail.domModification,\n        eventOrder: detail.eventOrder\n      };\n    };\n    const Container = single({\n      name: 'Container',\n      factory: factory$j,\n      configFields: [\n        defaulted('components', []),\n        field('containerBehaviours', []),\n        defaulted('events', {}),\n        defaulted('domModification', {}),\n        defaulted('eventOrder', {})\n      ]\n    });\n\n    const takeover = root => {\n      const isAboveRoot = el => parent(root.element).fold(always, parent => eq(el, parent));\n      const registry = Registry();\n      const lookup = (eventName, target) => registry.find(isAboveRoot, eventName, target);\n      const domEvents = setup$d(root.element, {\n        triggerEvent: (eventName, event) => {\n          return monitorEvent(eventName, event.target, logger => triggerUntilStopped(lookup, eventName, event, logger));\n        }\n      });\n      const systemApi = {\n        debugInfo: constant$1('real'),\n        triggerEvent: (eventName, target, data) => {\n          monitorEvent(eventName, target, logger => triggerOnUntilStopped(lookup, eventName, data, target, logger));\n        },\n        triggerFocus: (target, originator) => {\n          read(target).fold(() => {\n            focus$3(target);\n          }, _alloyId => {\n            monitorEvent(focus$4(), target, logger => {\n              triggerHandler(lookup, focus$4(), {\n                originator,\n                kill: noop,\n                prevent: noop,\n                target\n              }, target, logger);\n              return false;\n            });\n          });\n        },\n        triggerEscape: (comp, simulatedEvent) => {\n          systemApi.triggerEvent('keydown', comp.element, simulatedEvent.event);\n        },\n        getByUid: uid => {\n          return getByUid(uid);\n        },\n        getByDom: elem => {\n          return getByDom(elem);\n        },\n        build: build$1,\n        buildOrPatch: buildOrPatch,\n        addToGui: c => {\n          add(c);\n        },\n        removeFromGui: c => {\n          remove(c);\n        },\n        addToWorld: c => {\n          addToWorld(c);\n        },\n        removeFromWorld: c => {\n          removeFromWorld(c);\n        },\n        broadcast: message => {\n          broadcast$1(message);\n        },\n        broadcastOn: (channels, message) => {\n          broadcastOn(channels, message);\n        },\n        broadcastEvent: (eventName, event) => {\n          broadcastEvent(eventName, event);\n        },\n        isConnected: always\n      };\n      const addToWorld = component => {\n        component.connect(systemApi);\n        if (!isText(component.element)) {\n          registry.register(component);\n          each$1(component.components(), addToWorld);\n          systemApi.triggerEvent(systemInit(), component.element, { target: component.element });\n        }\n      };\n      const removeFromWorld = component => {\n        if (!isText(component.element)) {\n          each$1(component.components(), removeFromWorld);\n          registry.unregister(component);\n        }\n        component.disconnect();\n      };\n      const add = component => {\n        attach(root, component);\n      };\n      const remove = component => {\n        detach(component);\n      };\n      const destroy = () => {\n        domEvents.unbind();\n        remove$6(root.element);\n      };\n      const broadcastData = data => {\n        const receivers = registry.filter(receive());\n        each$1(receivers, receiver => {\n          const descHandler = receiver.descHandler;\n          const handler = getCurried(descHandler);\n          handler(data);\n        });\n      };\n      const broadcast$1 = message => {\n        broadcastData({\n          universal: true,\n          data: message\n        });\n      };\n      const broadcastOn = (channels, message) => {\n        broadcastData({\n          universal: false,\n          channels,\n          data: message\n        });\n      };\n      const broadcastEvent = (eventName, event) => {\n        const listeners = registry.filter(eventName);\n        return broadcast(listeners, event);\n      };\n      const getByUid = uid => registry.getById(uid).fold(() => Result.error(new Error('Could not find component with uid: \"' + uid + '\" in system.')), Result.value);\n      const getByDom = elem => {\n        const uid = read(elem).getOr('not found');\n        return getByUid(uid);\n      };\n      addToWorld(root);\n      return {\n        root,\n        element: root.element,\n        destroy,\n        add,\n        remove,\n        getByUid,\n        getByDom,\n        addToWorld,\n        removeFromWorld,\n        broadcast: broadcast$1,\n        broadcastOn,\n        broadcastEvent\n      };\n    };\n\n    const renderBar = (spec, backstage) => ({\n      dom: {\n        tag: 'div',\n        classes: [\n          'tox-bar',\n          'tox-form__controls-h-stack'\n        ]\n      },\n      components: map$2(spec.items, backstage.interpreter)\n    });\n\n    const schema$j = constant$1([\n      defaulted('prefix', 'form-field'),\n      field('fieldBehaviours', [\n        Composing,\n        Representing\n      ])\n    ]);\n    const parts$d = constant$1([\n      optional({\n        schema: [required$1('dom')],\n        name: 'label'\n      }),\n      optional({\n        factory: {\n          sketch: spec => {\n            return {\n              uid: spec.uid,\n              dom: {\n                tag: 'span',\n                styles: { display: 'none' },\n                attributes: { 'aria-hidden': 'true' },\n                innerHtml: spec.text\n              }\n            };\n          }\n        },\n        schema: [required$1('text')],\n        name: 'aria-descriptor'\n      }),\n      required({\n        factory: {\n          sketch: spec => {\n            const excludeFactory = exclude(spec, ['factory']);\n            return spec.factory.sketch(excludeFactory);\n          }\n        },\n        schema: [required$1('factory')],\n        name: 'field'\n      })\n    ]);\n\n    const factory$i = (detail, components, _spec, _externals) => {\n      const behaviours = augment(detail.fieldBehaviours, [\n        Composing.config({\n          find: container => {\n            return getPart(container, detail, 'field');\n          }\n        }),\n        Representing.config({\n          store: {\n            mode: 'manual',\n            getValue: field => {\n              return Composing.getCurrent(field).bind(Representing.getValue);\n            },\n            setValue: (field, value) => {\n              Composing.getCurrent(field).each(current => {\n                Representing.setValue(current, value);\n              });\n            }\n          }\n        })\n      ]);\n      const events = derive$2([runOnAttached((component, _simulatedEvent) => {\n          const ps = getParts(component, detail, [\n            'label',\n            'field',\n            'aria-descriptor'\n          ]);\n          ps.field().each(field => {\n            const id = generate$6(detail.prefix);\n            ps.label().each(label => {\n              set$9(label.element, 'for', id);\n              set$9(field.element, 'id', id);\n            });\n            ps['aria-descriptor']().each(descriptor => {\n              const descriptorId = generate$6(detail.prefix);\n              set$9(descriptor.element, 'id', descriptorId);\n              set$9(field.element, 'aria-describedby', descriptorId);\n            });\n          });\n        })]);\n      const apis = {\n        getField: container => getPart(container, detail, 'field'),\n        getLabel: container => getPart(container, detail, 'label')\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components,\n        behaviours,\n        events,\n        apis\n      };\n    };\n    const FormField = composite({\n      name: 'FormField',\n      configFields: schema$j(),\n      partFields: parts$d(),\n      factory: factory$i,\n      apis: {\n        getField: (apis, comp) => apis.getField(comp),\n        getLabel: (apis, comp) => apis.getLabel(comp)\n      }\n    });\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.html.Entities');\n\n    const renderFormFieldWith = (pLabel, pField, extraClasses, extraBehaviours) => {\n      const spec = renderFormFieldSpecWith(pLabel, pField, extraClasses, extraBehaviours);\n      return FormField.sketch(spec);\n    };\n    const renderFormField = (pLabel, pField) => renderFormFieldWith(pLabel, pField, [], []);\n    const renderFormFieldSpecWith = (pLabel, pField, extraClasses, extraBehaviours) => ({\n      dom: renderFormFieldDomWith(extraClasses),\n      components: pLabel.toArray().concat([pField]),\n      fieldBehaviours: derive$1(extraBehaviours)\n    });\n    const renderFormFieldDom = () => renderFormFieldDomWith([]);\n    const renderFormFieldDomWith = extraClasses => ({\n      tag: 'div',\n      classes: ['tox-form__group'].concat(extraClasses)\n    });\n    const renderLabel$3 = (label, providersBackstage) => FormField.parts.label({\n      dom: {\n        tag: 'label',\n        classes: ['tox-label']\n      },\n      components: [text$2(providersBackstage.translate(label))]\n    });\n\n    const formChangeEvent = generate$6('form-component-change');\n    const formCloseEvent = generate$6('form-close');\n    const formCancelEvent = generate$6('form-cancel');\n    const formActionEvent = generate$6('form-action');\n    const formSubmitEvent = generate$6('form-submit');\n    const formBlockEvent = generate$6('form-block');\n    const formUnblockEvent = generate$6('form-unblock');\n    const formTabChangeEvent = generate$6('form-tabchange');\n    const formResizeEvent = generate$6('form-resize');\n\n    const renderCollection = (spec, providersBackstage, initialData) => {\n      const pLabel = spec.label.map(label => renderLabel$3(label, providersBackstage));\n      const icons = providersBackstage.icons();\n      const getIcon = icon => {\n        var _a;\n        return (_a = icons[icon]) !== null && _a !== void 0 ? _a : icon;\n      };\n      const runOnItem = f => (comp, se) => {\n        closest$1(se.event.target, '[data-collection-item-value]').each(target => {\n          f(comp, se, target, get$g(target, 'data-collection-item-value'));\n        });\n      };\n      const setContents = (comp, items) => {\n        const htmlLines = map$2(items, item => {\n          const itemText = global$5.translate(item.text);\n          const textContent = spec.columns === 1 ? `<div class=\"tox-collection__item-label\">${ itemText }</div>` : '';\n          const iconContent = `<div class=\"tox-collection__item-icon\">${ getIcon(item.icon) }</div>`;\n          const mapItemName = {\n            '_': ' ',\n            ' - ': ' ',\n            '-': ' '\n          };\n          const ariaLabel = itemText.replace(/\\_| \\- |\\-/g, match => mapItemName[match]);\n          const disabledClass = providersBackstage.isDisabled() ? ' tox-collection__item--state-disabled' : '';\n          return `<div data-mce-tooltip=\"${ ariaLabel }\" class=\"tox-collection__item${ disabledClass }\" tabindex=\"-1\" data-collection-item-value=\"${ global$3.encodeAllRaw(item.value) }\" aria-label=\"${ ariaLabel }\">${ iconContent }${ textContent }</div>`;\n        });\n        const chunks = spec.columns !== 'auto' && spec.columns > 1 ? chunk$1(htmlLines, spec.columns) : [htmlLines];\n        const html = map$2(chunks, ch => `<div class=\"tox-collection__group\">${ ch.join('') }</div>`);\n        set$6(comp.element, html.join(''));\n      };\n      const onClick = runOnItem((comp, se, tgt, itemValue) => {\n        se.stop();\n        if (!providersBackstage.isDisabled()) {\n          emitWith(comp, formActionEvent, {\n            name: spec.name,\n            value: itemValue\n          });\n        }\n      });\n      const collectionEvents = [\n        run$1(mouseover(), runOnItem((comp, se, tgt) => {\n          focus$3(tgt);\n        })),\n        run$1(click(), onClick),\n        run$1(tap(), onClick),\n        run$1(focusin(), runOnItem((comp, se, tgt) => {\n          descendant(comp.element, '.' + activeClass).each(currentActive => {\n            remove$3(currentActive, activeClass);\n          });\n          add$2(tgt, activeClass);\n        })),\n        run$1(focusout(), runOnItem(comp => {\n          descendant(comp.element, '.' + activeClass).each(currentActive => {\n            remove$3(currentActive, activeClass);\n            blur$1(currentActive);\n          });\n        })),\n        runOnExecute$1(runOnItem((comp, se, tgt, itemValue) => {\n          emitWith(comp, formActionEvent, {\n            name: spec.name,\n            value: itemValue\n          });\n        }))\n      ];\n      const iterCollectionItems = (comp, applyAttributes) => map$2(descendants(comp.element, '.tox-collection__item'), applyAttributes);\n      const pField = FormField.parts.field({\n        dom: {\n          tag: 'div',\n          classes: ['tox-collection'].concat(spec.columns !== 1 ? ['tox-collection--grid'] : ['tox-collection--list'])\n        },\n        components: [],\n        factory: { sketch: identity },\n        behaviours: derive$1([\n          Disabling.config({\n            disabled: providersBackstage.isDisabled,\n            onDisabled: comp => {\n              iterCollectionItems(comp, childElm => {\n                add$2(childElm, 'tox-collection__item--state-disabled');\n                set$9(childElm, 'aria-disabled', true);\n              });\n            },\n            onEnabled: comp => {\n              iterCollectionItems(comp, childElm => {\n                remove$3(childElm, 'tox-collection__item--state-disabled');\n                remove$8(childElm, 'aria-disabled');\n              });\n            }\n          }),\n          receivingConfig(),\n          Replacing.config({}),\n          Tooltipping.config({\n            ...providersBackstage.tooltips.getConfig({\n              tooltipText: '',\n              onShow: comp => {\n                descendant(comp.element, '.' + activeClass + '[data-mce-tooltip]').each(current => {\n                  getOpt(current, 'data-mce-tooltip').each(text => {\n                    Tooltipping.setComponents(comp, providersBackstage.tooltips.getComponents({ tooltipText: text }));\n                  });\n                });\n              }\n            }),\n            mode: 'children-keyboard-focus',\n            anchor: comp => ({\n              type: 'node',\n              node: descendant(comp.element, '.' + activeClass).orThunk(() => first$1('.tox-collection__item')),\n              root: comp.element,\n              layouts: {\n                onLtr: constant$1([\n                  south$2,\n                  north$2,\n                  southeast$2,\n                  northeast$2,\n                  southwest$2,\n                  northwest$2\n                ]),\n                onRtl: constant$1([\n                  south$2,\n                  north$2,\n                  southeast$2,\n                  northeast$2,\n                  southwest$2,\n                  northwest$2\n                ])\n              },\n              bubble: nu$5(0, -2, {})\n            })\n          }),\n          Representing.config({\n            store: {\n              mode: 'memory',\n              initialValue: initialData.getOr([])\n            },\n            onSetValue: (comp, items) => {\n              setContents(comp, items);\n              if (spec.columns === 'auto') {\n                detectSize(comp, 5, 'tox-collection__item').each(({numRows, numColumns}) => {\n                  Keying.setGridSize(comp, numRows, numColumns);\n                });\n              }\n              emit(comp, formResizeEvent);\n            }\n          }),\n          Tabstopping.config({}),\n          Keying.config(deriveCollectionMovement(spec.columns, 'normal')),\n          config('collection-events', collectionEvents)\n        ]),\n        eventOrder: {\n          [execute$5()]: [\n            'disabling',\n            'alloy.base.behaviour',\n            'collection-events'\n          ],\n          [focusin()]: [\n            'collection-events',\n            'tooltipping'\n          ]\n        }\n      });\n      const extraClasses = ['tox-form__group--collection'];\n      return renderFormFieldWith(pLabel, pField, extraClasses, []);\n    };\n\n    const ariaElements = [\n      'input',\n      'textarea'\n    ];\n    const isAriaElement = elem => {\n      const name = name$3(elem);\n      return contains$2(ariaElements, name);\n    };\n    const markValid = (component, invalidConfig) => {\n      const elem = invalidConfig.getRoot(component).getOr(component.element);\n      remove$3(elem, invalidConfig.invalidClass);\n      invalidConfig.notify.each(notifyInfo => {\n        if (isAriaElement(component.element)) {\n          set$9(component.element, 'aria-invalid', false);\n        }\n        notifyInfo.getContainer(component).each(container => {\n          set$6(container, notifyInfo.validHtml);\n        });\n        notifyInfo.onValid(component);\n      });\n    };\n    const markInvalid = (component, invalidConfig, invalidState, text) => {\n      const elem = invalidConfig.getRoot(component).getOr(component.element);\n      add$2(elem, invalidConfig.invalidClass);\n      invalidConfig.notify.each(notifyInfo => {\n        if (isAriaElement(component.element)) {\n          set$9(component.element, 'aria-invalid', true);\n        }\n        notifyInfo.getContainer(component).each(container => {\n          set$6(container, text);\n        });\n        notifyInfo.onInvalid(component, text);\n      });\n    };\n    const query = (component, invalidConfig, _invalidState) => invalidConfig.validator.fold(() => Future.pure(Result.value(true)), validatorInfo => validatorInfo.validate(component));\n    const run = (component, invalidConfig, invalidState) => {\n      invalidConfig.notify.each(notifyInfo => {\n        notifyInfo.onValidate(component);\n      });\n      return query(component, invalidConfig).map(valid => {\n        if (component.getSystem().isConnected()) {\n          return valid.fold(err => {\n            markInvalid(component, invalidConfig, invalidState, err);\n            return Result.error(err);\n          }, v => {\n            markValid(component, invalidConfig);\n            return Result.value(v);\n          });\n        } else {\n          return Result.error('No longer in system');\n        }\n      });\n    };\n    const isInvalid = (component, invalidConfig) => {\n      const elem = invalidConfig.getRoot(component).getOr(component.element);\n      return has(elem, invalidConfig.invalidClass);\n    };\n\n    var InvalidateApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        markValid: markValid,\n        markInvalid: markInvalid,\n        query: query,\n        run: run,\n        isInvalid: isInvalid\n    });\n\n    const events$7 = (invalidConfig, invalidState) => invalidConfig.validator.map(validatorInfo => derive$2([run$1(validatorInfo.onEvent, component => {\n        run(component, invalidConfig, invalidState).get(identity);\n      })].concat(validatorInfo.validateOnLoad ? [runOnAttached(component => {\n        run(component, invalidConfig, invalidState).get(noop);\n      })] : []))).getOr({});\n\n    var ActiveInvalidate = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        events: events$7\n    });\n\n    var InvalidateSchema = [\n      required$1('invalidClass'),\n      defaulted('getRoot', Optional.none),\n      optionObjOf('notify', [\n        defaulted('aria', 'alert'),\n        defaulted('getContainer', Optional.none),\n        defaulted('validHtml', ''),\n        onHandler('onValid'),\n        onHandler('onInvalid'),\n        onHandler('onValidate')\n      ]),\n      optionObjOf('validator', [\n        required$1('validate'),\n        defaulted('onEvent', 'input'),\n        defaulted('validateOnLoad', true)\n      ])\n    ];\n\n    const Invalidating = create$4({\n      fields: InvalidateSchema,\n      name: 'invalidating',\n      active: ActiveInvalidate,\n      apis: InvalidateApis,\n      extra: {\n        validation: validator => {\n          return component => {\n            const v = Representing.getValue(component);\n            return Future.pure(validator(v));\n          };\n        }\n      }\n    });\n\n    const exhibit$1 = () => nu$8({\n      styles: {\n        '-webkit-user-select': 'none',\n        'user-select': 'none',\n        '-ms-user-select': 'none',\n        '-moz-user-select': '-moz-none'\n      },\n      attributes: { unselectable: 'on' }\n    });\n    const events$6 = () => derive$2([abort(selectstart(), always)]);\n\n    var ActiveUnselecting = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        events: events$6,\n        exhibit: exhibit$1\n    });\n\n    const Unselecting = create$4({\n      fields: [],\n      name: 'unselecting',\n      active: ActiveUnselecting\n    });\n\n    const renderPanelButton = (spec, sharedBackstage) => Dropdown.sketch({\n      dom: spec.dom,\n      components: spec.components,\n      toggleClass: 'mce-active',\n      dropdownBehaviours: derive$1([\n        DisablingConfigs.button(sharedBackstage.providers.isDisabled),\n        receivingConfig(),\n        Unselecting.config({}),\n        Tabstopping.config({})\n      ]),\n      layouts: spec.layouts,\n      sandboxClasses: ['tox-dialog__popups'],\n      lazySink: sharedBackstage.getSink,\n      fetch: comp => Future.nu(callback => spec.fetch(callback)).map(items => Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6('menu-value'), items, value => {\n        spec.onItemAction(comp, value);\n      }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, never, sharedBackstage.providers), { movement: deriveMenuMovement(spec.columns, spec.presets) })))),\n      parts: { menu: part(false, 1, spec.presets) }\n    });\n\n    const colorInputChangeEvent = generate$6('color-input-change');\n    const colorSwatchChangeEvent = generate$6('color-swatch-change');\n    const colorPickerCancelEvent = generate$6('color-picker-cancel');\n    const renderColorInput = (spec, sharedBackstage, colorInputBackstage, initialData) => {\n      const pField = FormField.parts.field({\n        factory: Input,\n        inputClasses: ['tox-textfield'],\n        data: initialData,\n        onSetValue: c => Invalidating.run(c).get(noop),\n        inputBehaviours: derive$1([\n          Disabling.config({ disabled: sharedBackstage.providers.isDisabled }),\n          receivingConfig(),\n          Tabstopping.config({}),\n          Invalidating.config({\n            invalidClass: 'tox-textbox-field-invalid',\n            getRoot: comp => parentElement(comp.element),\n            notify: {\n              onValid: comp => {\n                const val = Representing.getValue(comp);\n                emitWith(comp, colorInputChangeEvent, { color: val });\n              }\n            },\n            validator: {\n              validateOnLoad: false,\n              validate: input => {\n                const inputValue = Representing.getValue(input);\n                if (inputValue.length === 0) {\n                  return Future.pure(Result.value(true));\n                } else {\n                  const span = SugarElement.fromTag('span');\n                  set$8(span, 'background-color', inputValue);\n                  const res = getRaw(span, 'background-color').fold(() => Result.error('blah'), _ => Result.value(inputValue));\n                  return Future.pure(res);\n                }\n              }\n            }\n          })\n        ]),\n        selectOnFocus: false\n      });\n      const pLabel = spec.label.map(label => renderLabel$3(label, sharedBackstage.providers));\n      const emitSwatchChange = (colorBit, value) => {\n        emitWith(colorBit, colorSwatchChangeEvent, { value });\n      };\n      const onItemAction = (comp, value) => {\n        memColorButton.getOpt(comp).each(colorBit => {\n          if (value === 'custom') {\n            colorInputBackstage.colorPicker(valueOpt => {\n              valueOpt.fold(() => emit(colorBit, colorPickerCancelEvent), value => {\n                emitSwatchChange(colorBit, value);\n                addColor(spec.storageKey, value);\n              });\n            }, '#ffffff');\n          } else if (value === 'remove') {\n            emitSwatchChange(colorBit, '');\n          } else {\n            emitSwatchChange(colorBit, value);\n          }\n        });\n      };\n      const memColorButton = record(renderPanelButton({\n        dom: {\n          tag: 'span',\n          attributes: { 'aria-label': sharedBackstage.providers.translate('Color swatch') }\n        },\n        layouts: {\n          onRtl: () => [\n            southwest$2,\n            southeast$2,\n            south$2\n          ],\n          onLtr: () => [\n            southeast$2,\n            southwest$2,\n            south$2\n          ]\n        },\n        components: [],\n        fetch: getFetch$1(colorInputBackstage.getColors(spec.storageKey), spec.storageKey, colorInputBackstage.hasCustomColors()),\n        columns: colorInputBackstage.getColorCols(spec.storageKey),\n        presets: 'color',\n        onItemAction\n      }, sharedBackstage));\n      return FormField.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-form__group']\n        },\n        components: pLabel.toArray().concat([{\n            dom: {\n              tag: 'div',\n              classes: ['tox-color-input']\n            },\n            components: [\n              pField,\n              memColorButton.asSpec()\n            ]\n          }]),\n        fieldBehaviours: derive$1([config('form-field-events', [\n            run$1(colorInputChangeEvent, (comp, se) => {\n              memColorButton.getOpt(comp).each(colorButton => {\n                set$8(colorButton.element, 'background-color', se.event.color);\n              });\n              emitWith(comp, formChangeEvent, { name: spec.name });\n            }),\n            run$1(colorSwatchChangeEvent, (comp, se) => {\n              FormField.getField(comp).each(field => {\n                Representing.setValue(field, se.event.value);\n                Composing.getCurrent(comp).each(Focusing.focus);\n              });\n            }),\n            run$1(colorPickerCancelEvent, (comp, _se) => {\n              FormField.getField(comp).each(_field => {\n                Composing.getCurrent(comp).each(Focusing.focus);\n              });\n            })\n          ])])\n      });\n    };\n\n    const labelPart = optional({\n      schema: [required$1('dom')],\n      name: 'label'\n    });\n    const edgePart = name => optional({\n      name: '' + name + '-edge',\n      overrides: detail => {\n        const action = detail.model.manager.edgeActions[name];\n        return action.fold(() => ({}), a => ({\n          events: derive$2([\n            runActionExtra(touchstart(), (comp, se, d) => a(comp, d), [detail]),\n            runActionExtra(mousedown(), (comp, se, d) => a(comp, d), [detail]),\n            runActionExtra(mousemove(), (comp, se, det) => {\n              if (det.mouseIsDown.get()) {\n                a(comp, det);\n              }\n            }, [detail])\n          ])\n        }));\n      }\n    });\n    const tlEdgePart = edgePart('top-left');\n    const tedgePart = edgePart('top');\n    const trEdgePart = edgePart('top-right');\n    const redgePart = edgePart('right');\n    const brEdgePart = edgePart('bottom-right');\n    const bedgePart = edgePart('bottom');\n    const blEdgePart = edgePart('bottom-left');\n    const ledgePart = edgePart('left');\n    const thumbPart = required({\n      name: 'thumb',\n      defaults: constant$1({ dom: { styles: { position: 'absolute' } } }),\n      overrides: detail => {\n        return {\n          events: derive$2([\n            redirectToPart(touchstart(), detail, 'spectrum'),\n            redirectToPart(touchmove(), detail, 'spectrum'),\n            redirectToPart(touchend(), detail, 'spectrum'),\n            redirectToPart(mousedown(), detail, 'spectrum'),\n            redirectToPart(mousemove(), detail, 'spectrum'),\n            redirectToPart(mouseup(), detail, 'spectrum')\n          ])\n        };\n      }\n    });\n    const isShift = event => isShift$1(event.event);\n    const spectrumPart = required({\n      schema: [customField('mouseIsDown', () => Cell(false))],\n      name: 'spectrum',\n      overrides: detail => {\n        const modelDetail = detail.model;\n        const model = modelDetail.manager;\n        const setValueFrom = (component, simulatedEvent) => model.getValueFromEvent(simulatedEvent).map(value => model.setValueFrom(component, detail, value));\n        return {\n          behaviours: derive$1([\n            Keying.config({\n              mode: 'special',\n              onLeft: (spectrum, event) => model.onLeft(spectrum, detail, isShift(event)),\n              onRight: (spectrum, event) => model.onRight(spectrum, detail, isShift(event)),\n              onUp: (spectrum, event) => model.onUp(spectrum, detail, isShift(event)),\n              onDown: (spectrum, event) => model.onDown(spectrum, detail, isShift(event))\n            }),\n            Tabstopping.config({}),\n            Focusing.config({})\n          ]),\n          events: derive$2([\n            run$1(touchstart(), setValueFrom),\n            run$1(touchmove(), setValueFrom),\n            run$1(mousedown(), setValueFrom),\n            run$1(mousemove(), (spectrum, se) => {\n              if (detail.mouseIsDown.get()) {\n                setValueFrom(spectrum, se);\n              }\n            })\n          ])\n        };\n      }\n    });\n    var SliderParts = [\n      labelPart,\n      ledgePart,\n      redgePart,\n      tedgePart,\n      bedgePart,\n      tlEdgePart,\n      trEdgePart,\n      blEdgePart,\n      brEdgePart,\n      thumbPart,\n      spectrumPart\n    ];\n\n    const _sliderChangeEvent = 'slider.change.value';\n    const sliderChangeEvent = constant$1(_sliderChangeEvent);\n    const isTouchEvent$2 = evt => evt.type.indexOf('touch') !== -1;\n    const getEventSource = simulatedEvent => {\n      const evt = simulatedEvent.event.raw;\n      if (isTouchEvent$2(evt)) {\n        const touchEvent = evt;\n        return touchEvent.touches !== undefined && touchEvent.touches.length === 1 ? Optional.some(touchEvent.touches[0]).map(t => SugarPosition(t.clientX, t.clientY)) : Optional.none();\n      } else {\n        const mouseEvent = evt;\n        return mouseEvent.clientX !== undefined ? Optional.some(mouseEvent).map(me => SugarPosition(me.clientX, me.clientY)) : Optional.none();\n      }\n    };\n\n    const t = 'top', r = 'right', b = 'bottom', l = 'left';\n    const minX = detail => detail.model.minX;\n    const minY = detail => detail.model.minY;\n    const min1X = detail => detail.model.minX - 1;\n    const min1Y = detail => detail.model.minY - 1;\n    const maxX = detail => detail.model.maxX;\n    const maxY = detail => detail.model.maxY;\n    const max1X = detail => detail.model.maxX + 1;\n    const max1Y = detail => detail.model.maxY + 1;\n    const range = (detail, max, min) => max(detail) - min(detail);\n    const xRange = detail => range(detail, maxX, minX);\n    const yRange = detail => range(detail, maxY, minY);\n    const halfX = detail => xRange(detail) / 2;\n    const halfY = detail => yRange(detail) / 2;\n    const step = (detail, useMultiplier) => useMultiplier ? detail.stepSize * detail.speedMultiplier : detail.stepSize;\n    const snap = detail => detail.snapToGrid;\n    const snapStart = detail => detail.snapStart;\n    const rounded = detail => detail.rounded;\n    const hasEdge = (detail, edgeName) => detail[edgeName + '-edge'] !== undefined;\n    const hasLEdge = detail => hasEdge(detail, l);\n    const hasREdge = detail => hasEdge(detail, r);\n    const hasTEdge = detail => hasEdge(detail, t);\n    const hasBEdge = detail => hasEdge(detail, b);\n    const currentValue = detail => detail.model.value.get();\n\n    const xyValue = (x, y) => ({\n      x,\n      y\n    });\n    const fireSliderChange$3 = (component, value) => {\n      emitWith(component, sliderChangeEvent(), { value });\n    };\n    const setToTLEdgeXY = (edge, detail) => {\n      fireSliderChange$3(edge, xyValue(min1X(detail), min1Y(detail)));\n    };\n    const setToTEdge = (edge, detail) => {\n      fireSliderChange$3(edge, min1Y(detail));\n    };\n    const setToTEdgeXY = (edge, detail) => {\n      fireSliderChange$3(edge, xyValue(halfX(detail), min1Y(detail)));\n    };\n    const setToTREdgeXY = (edge, detail) => {\n      fireSliderChange$3(edge, xyValue(max1X(detail), min1Y(detail)));\n    };\n    const setToREdge = (edge, detail) => {\n      fireSliderChange$3(edge, max1X(detail));\n    };\n    const setToREdgeXY = (edge, detail) => {\n      fireSliderChange$3(edge, xyValue(max1X(detail), halfY(detail)));\n    };\n    const setToBREdgeXY = (edge, detail) => {\n      fireSliderChange$3(edge, xyValue(max1X(detail), max1Y(detail)));\n    };\n    const setToBEdge = (edge, detail) => {\n      fireSliderChange$3(edge, max1Y(detail));\n    };\n    const setToBEdgeXY = (edge, detail) => {\n      fireSliderChange$3(edge, xyValue(halfX(detail), max1Y(detail)));\n    };\n    const setToBLEdgeXY = (edge, detail) => {\n      fireSliderChange$3(edge, xyValue(min1X(detail), max1Y(detail)));\n    };\n    const setToLEdge = (edge, detail) => {\n      fireSliderChange$3(edge, min1X(detail));\n    };\n    const setToLEdgeXY = (edge, detail) => {\n      fireSliderChange$3(edge, xyValue(min1X(detail), halfY(detail)));\n    };\n\n    const reduceBy = (value, min, max, step) => {\n      if (value < min) {\n        return value;\n      } else if (value > max) {\n        return max;\n      } else if (value === min) {\n        return min - 1;\n      } else {\n        return Math.max(min, value - step);\n      }\n    };\n    const increaseBy = (value, min, max, step) => {\n      if (value > max) {\n        return value;\n      } else if (value < min) {\n        return min;\n      } else if (value === max) {\n        return max + 1;\n      } else {\n        return Math.min(max, value + step);\n      }\n    };\n    const capValue = (value, min, max) => Math.max(min, Math.min(max, value));\n    const snapValueOf = (value, min, max, step, snapStart) => snapStart.fold(() => {\n      const initValue = value - min;\n      const extraValue = Math.round(initValue / step) * step;\n      return capValue(min + extraValue, min - 1, max + 1);\n    }, start => {\n      const remainder = (value - start) % step;\n      const adjustment = Math.round(remainder / step);\n      const rawSteps = Math.floor((value - start) / step);\n      const maxSteps = Math.floor((max - start) / step);\n      const numSteps = Math.min(maxSteps, rawSteps + adjustment);\n      const r = start + numSteps * step;\n      return Math.max(start, r);\n    });\n    const findOffsetOf = (value, min, max) => Math.min(max, Math.max(value, min)) - min;\n    const findValueOf = args => {\n      const {min, max, range, value, step, snap, snapStart, rounded, hasMinEdge, hasMaxEdge, minBound, maxBound, screenRange} = args;\n      const capMin = hasMinEdge ? min - 1 : min;\n      const capMax = hasMaxEdge ? max + 1 : max;\n      if (value < minBound) {\n        return capMin;\n      } else if (value > maxBound) {\n        return capMax;\n      } else {\n        const offset = findOffsetOf(value, minBound, maxBound);\n        const newValue = capValue(offset / screenRange * range + min, capMin, capMax);\n        if (snap && newValue >= min && newValue <= max) {\n          return snapValueOf(newValue, min, max, step, snapStart);\n        } else if (rounded) {\n          return Math.round(newValue);\n        } else {\n          return newValue;\n        }\n      }\n    };\n    const findOffsetOfValue$2 = args => {\n      const {min, max, range, value, hasMinEdge, hasMaxEdge, maxBound, maxOffset, centerMinEdge, centerMaxEdge} = args;\n      if (value < min) {\n        return hasMinEdge ? 0 : centerMinEdge;\n      } else if (value > max) {\n        return hasMaxEdge ? maxBound : centerMaxEdge;\n      } else {\n        return (value - min) / range * maxOffset;\n      }\n    };\n\n    const top = 'top', right = 'right', bottom = 'bottom', left = 'left', width = 'width', height = 'height';\n    const getBounds = component => component.element.dom.getBoundingClientRect();\n    const getBoundsProperty = (bounds, property) => bounds[property];\n    const getMinXBounds = component => {\n      const bounds = getBounds(component);\n      return getBoundsProperty(bounds, left);\n    };\n    const getMaxXBounds = component => {\n      const bounds = getBounds(component);\n      return getBoundsProperty(bounds, right);\n    };\n    const getMinYBounds = component => {\n      const bounds = getBounds(component);\n      return getBoundsProperty(bounds, top);\n    };\n    const getMaxYBounds = component => {\n      const bounds = getBounds(component);\n      return getBoundsProperty(bounds, bottom);\n    };\n    const getXScreenRange = component => {\n      const bounds = getBounds(component);\n      return getBoundsProperty(bounds, width);\n    };\n    const getYScreenRange = component => {\n      const bounds = getBounds(component);\n      return getBoundsProperty(bounds, height);\n    };\n    const getCenterOffsetOf = (componentMinEdge, componentMaxEdge, spectrumMinEdge) => (componentMinEdge + componentMaxEdge) / 2 - spectrumMinEdge;\n    const getXCenterOffSetOf = (component, spectrum) => {\n      const componentBounds = getBounds(component);\n      const spectrumBounds = getBounds(spectrum);\n      const componentMinEdge = getBoundsProperty(componentBounds, left);\n      const componentMaxEdge = getBoundsProperty(componentBounds, right);\n      const spectrumMinEdge = getBoundsProperty(spectrumBounds, left);\n      return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);\n    };\n    const getYCenterOffSetOf = (component, spectrum) => {\n      const componentBounds = getBounds(component);\n      const spectrumBounds = getBounds(spectrum);\n      const componentMinEdge = getBoundsProperty(componentBounds, top);\n      const componentMaxEdge = getBoundsProperty(componentBounds, bottom);\n      const spectrumMinEdge = getBoundsProperty(spectrumBounds, top);\n      return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);\n    };\n\n    const fireSliderChange$2 = (spectrum, value) => {\n      emitWith(spectrum, sliderChangeEvent(), { value });\n    };\n    const findValueOfOffset$1 = (spectrum, detail, left) => {\n      const args = {\n        min: minX(detail),\n        max: maxX(detail),\n        range: xRange(detail),\n        value: left,\n        step: step(detail),\n        snap: snap(detail),\n        snapStart: snapStart(detail),\n        rounded: rounded(detail),\n        hasMinEdge: hasLEdge(detail),\n        hasMaxEdge: hasREdge(detail),\n        minBound: getMinXBounds(spectrum),\n        maxBound: getMaxXBounds(spectrum),\n        screenRange: getXScreenRange(spectrum)\n      };\n      return findValueOf(args);\n    };\n    const setValueFrom$2 = (spectrum, detail, value) => {\n      const xValue = findValueOfOffset$1(spectrum, detail, value);\n      const sliderVal = xValue;\n      fireSliderChange$2(spectrum, sliderVal);\n      return xValue;\n    };\n    const setToMin$2 = (spectrum, detail) => {\n      const min = minX(detail);\n      fireSliderChange$2(spectrum, min);\n    };\n    const setToMax$2 = (spectrum, detail) => {\n      const max = maxX(detail);\n      fireSliderChange$2(spectrum, max);\n    };\n    const moveBy$2 = (direction, spectrum, detail, useMultiplier) => {\n      const f = direction > 0 ? increaseBy : reduceBy;\n      const xValue = f(currentValue(detail), minX(detail), maxX(detail), step(detail, useMultiplier));\n      fireSliderChange$2(spectrum, xValue);\n      return Optional.some(xValue);\n    };\n    const handleMovement$2 = direction => (spectrum, detail, useMultiplier) => moveBy$2(direction, spectrum, detail, useMultiplier).map(always);\n    const getValueFromEvent$2 = simulatedEvent => {\n      const pos = getEventSource(simulatedEvent);\n      return pos.map(p => p.left);\n    };\n    const findOffsetOfValue$1 = (spectrum, detail, value, minEdge, maxEdge) => {\n      const minOffset = 0;\n      const maxOffset = getXScreenRange(spectrum);\n      const centerMinEdge = minEdge.bind(edge => Optional.some(getXCenterOffSetOf(edge, spectrum))).getOr(minOffset);\n      const centerMaxEdge = maxEdge.bind(edge => Optional.some(getXCenterOffSetOf(edge, spectrum))).getOr(maxOffset);\n      const args = {\n        min: minX(detail),\n        max: maxX(detail),\n        range: xRange(detail),\n        value,\n        hasMinEdge: hasLEdge(detail),\n        hasMaxEdge: hasREdge(detail),\n        minBound: getMinXBounds(spectrum),\n        minOffset,\n        maxBound: getMaxXBounds(spectrum),\n        maxOffset,\n        centerMinEdge,\n        centerMaxEdge\n      };\n      return findOffsetOfValue$2(args);\n    };\n    const findPositionOfValue$1 = (slider, spectrum, value, minEdge, maxEdge, detail) => {\n      const offset = findOffsetOfValue$1(spectrum, detail, value, minEdge, maxEdge);\n      return getMinXBounds(spectrum) - getMinXBounds(slider) + offset;\n    };\n    const setPositionFromValue$2 = (slider, thumb, detail, edges) => {\n      const value = currentValue(detail);\n      const pos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);\n      const thumbRadius = get$d(thumb.element) / 2;\n      set$8(thumb.element, 'left', pos - thumbRadius + 'px');\n    };\n    const onLeft$2 = handleMovement$2(-1);\n    const onRight$2 = handleMovement$2(1);\n    const onUp$2 = Optional.none;\n    const onDown$2 = Optional.none;\n    const edgeActions$2 = {\n      'top-left': Optional.none(),\n      'top': Optional.none(),\n      'top-right': Optional.none(),\n      'right': Optional.some(setToREdge),\n      'bottom-right': Optional.none(),\n      'bottom': Optional.none(),\n      'bottom-left': Optional.none(),\n      'left': Optional.some(setToLEdge)\n    };\n\n    var HorizontalModel = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        setValueFrom: setValueFrom$2,\n        setToMin: setToMin$2,\n        setToMax: setToMax$2,\n        findValueOfOffset: findValueOfOffset$1,\n        getValueFromEvent: getValueFromEvent$2,\n        findPositionOfValue: findPositionOfValue$1,\n        setPositionFromValue: setPositionFromValue$2,\n        onLeft: onLeft$2,\n        onRight: onRight$2,\n        onUp: onUp$2,\n        onDown: onDown$2,\n        edgeActions: edgeActions$2\n    });\n\n    const fireSliderChange$1 = (spectrum, value) => {\n      emitWith(spectrum, sliderChangeEvent(), { value });\n    };\n    const findValueOfOffset = (spectrum, detail, top) => {\n      const args = {\n        min: minY(detail),\n        max: maxY(detail),\n        range: yRange(detail),\n        value: top,\n        step: step(detail),\n        snap: snap(detail),\n        snapStart: snapStart(detail),\n        rounded: rounded(detail),\n        hasMinEdge: hasTEdge(detail),\n        hasMaxEdge: hasBEdge(detail),\n        minBound: getMinYBounds(spectrum),\n        maxBound: getMaxYBounds(spectrum),\n        screenRange: getYScreenRange(spectrum)\n      };\n      return findValueOf(args);\n    };\n    const setValueFrom$1 = (spectrum, detail, value) => {\n      const yValue = findValueOfOffset(spectrum, detail, value);\n      const sliderVal = yValue;\n      fireSliderChange$1(spectrum, sliderVal);\n      return yValue;\n    };\n    const setToMin$1 = (spectrum, detail) => {\n      const min = minY(detail);\n      fireSliderChange$1(spectrum, min);\n    };\n    const setToMax$1 = (spectrum, detail) => {\n      const max = maxY(detail);\n      fireSliderChange$1(spectrum, max);\n    };\n    const moveBy$1 = (direction, spectrum, detail, useMultiplier) => {\n      const f = direction > 0 ? increaseBy : reduceBy;\n      const yValue = f(currentValue(detail), minY(detail), maxY(detail), step(detail, useMultiplier));\n      fireSliderChange$1(spectrum, yValue);\n      return Optional.some(yValue);\n    };\n    const handleMovement$1 = direction => (spectrum, detail, useMultiplier) => moveBy$1(direction, spectrum, detail, useMultiplier).map(always);\n    const getValueFromEvent$1 = simulatedEvent => {\n      const pos = getEventSource(simulatedEvent);\n      return pos.map(p => {\n        return p.top;\n      });\n    };\n    const findOffsetOfValue = (spectrum, detail, value, minEdge, maxEdge) => {\n      const minOffset = 0;\n      const maxOffset = getYScreenRange(spectrum);\n      const centerMinEdge = minEdge.bind(edge => Optional.some(getYCenterOffSetOf(edge, spectrum))).getOr(minOffset);\n      const centerMaxEdge = maxEdge.bind(edge => Optional.some(getYCenterOffSetOf(edge, spectrum))).getOr(maxOffset);\n      const args = {\n        min: minY(detail),\n        max: maxY(detail),\n        range: yRange(detail),\n        value,\n        hasMinEdge: hasTEdge(detail),\n        hasMaxEdge: hasBEdge(detail),\n        minBound: getMinYBounds(spectrum),\n        minOffset,\n        maxBound: getMaxYBounds(spectrum),\n        maxOffset,\n        centerMinEdge,\n        centerMaxEdge\n      };\n      return findOffsetOfValue$2(args);\n    };\n    const findPositionOfValue = (slider, spectrum, value, minEdge, maxEdge, detail) => {\n      const offset = findOffsetOfValue(spectrum, detail, value, minEdge, maxEdge);\n      return getMinYBounds(spectrum) - getMinYBounds(slider) + offset;\n    };\n    const setPositionFromValue$1 = (slider, thumb, detail, edges) => {\n      const value = currentValue(detail);\n      const pos = findPositionOfValue(slider, edges.getSpectrum(slider), value, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);\n      const thumbRadius = get$e(thumb.element) / 2;\n      set$8(thumb.element, 'top', pos - thumbRadius + 'px');\n    };\n    const onLeft$1 = Optional.none;\n    const onRight$1 = Optional.none;\n    const onUp$1 = handleMovement$1(-1);\n    const onDown$1 = handleMovement$1(1);\n    const edgeActions$1 = {\n      'top-left': Optional.none(),\n      'top': Optional.some(setToTEdge),\n      'top-right': Optional.none(),\n      'right': Optional.none(),\n      'bottom-right': Optional.none(),\n      'bottom': Optional.some(setToBEdge),\n      'bottom-left': Optional.none(),\n      'left': Optional.none()\n    };\n\n    var VerticalModel = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        setValueFrom: setValueFrom$1,\n        setToMin: setToMin$1,\n        setToMax: setToMax$1,\n        findValueOfOffset: findValueOfOffset,\n        getValueFromEvent: getValueFromEvent$1,\n        findPositionOfValue: findPositionOfValue,\n        setPositionFromValue: setPositionFromValue$1,\n        onLeft: onLeft$1,\n        onRight: onRight$1,\n        onUp: onUp$1,\n        onDown: onDown$1,\n        edgeActions: edgeActions$1\n    });\n\n    const fireSliderChange = (spectrum, value) => {\n      emitWith(spectrum, sliderChangeEvent(), { value });\n    };\n    const sliderValue = (x, y) => ({\n      x,\n      y\n    });\n    const setValueFrom = (spectrum, detail, value) => {\n      const xValue = findValueOfOffset$1(spectrum, detail, value.left);\n      const yValue = findValueOfOffset(spectrum, detail, value.top);\n      const val = sliderValue(xValue, yValue);\n      fireSliderChange(spectrum, val);\n      return val;\n    };\n    const moveBy = (direction, isVerticalMovement, spectrum, detail, useMultiplier) => {\n      const f = direction > 0 ? increaseBy : reduceBy;\n      const xValue = isVerticalMovement ? currentValue(detail).x : f(currentValue(detail).x, minX(detail), maxX(detail), step(detail, useMultiplier));\n      const yValue = !isVerticalMovement ? currentValue(detail).y : f(currentValue(detail).y, minY(detail), maxY(detail), step(detail, useMultiplier));\n      fireSliderChange(spectrum, sliderValue(xValue, yValue));\n      return Optional.some(xValue);\n    };\n    const handleMovement = (direction, isVerticalMovement) => (spectrum, detail, useMultiplier) => moveBy(direction, isVerticalMovement, spectrum, detail, useMultiplier).map(always);\n    const setToMin = (spectrum, detail) => {\n      const mX = minX(detail);\n      const mY = minY(detail);\n      fireSliderChange(spectrum, sliderValue(mX, mY));\n    };\n    const setToMax = (spectrum, detail) => {\n      const mX = maxX(detail);\n      const mY = maxY(detail);\n      fireSliderChange(spectrum, sliderValue(mX, mY));\n    };\n    const getValueFromEvent = simulatedEvent => getEventSource(simulatedEvent);\n    const setPositionFromValue = (slider, thumb, detail, edges) => {\n      const value = currentValue(detail);\n      const xPos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value.x, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);\n      const yPos = findPositionOfValue(slider, edges.getSpectrum(slider), value.y, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);\n      const thumbXRadius = get$d(thumb.element) / 2;\n      const thumbYRadius = get$e(thumb.element) / 2;\n      set$8(thumb.element, 'left', xPos - thumbXRadius + 'px');\n      set$8(thumb.element, 'top', yPos - thumbYRadius + 'px');\n    };\n    const onLeft = handleMovement(-1, false);\n    const onRight = handleMovement(1, false);\n    const onUp = handleMovement(-1, true);\n    const onDown = handleMovement(1, true);\n    const edgeActions = {\n      'top-left': Optional.some(setToTLEdgeXY),\n      'top': Optional.some(setToTEdgeXY),\n      'top-right': Optional.some(setToTREdgeXY),\n      'right': Optional.some(setToREdgeXY),\n      'bottom-right': Optional.some(setToBREdgeXY),\n      'bottom': Optional.some(setToBEdgeXY),\n      'bottom-left': Optional.some(setToBLEdgeXY),\n      'left': Optional.some(setToLEdgeXY)\n    };\n\n    var TwoDModel = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        setValueFrom: setValueFrom,\n        setToMin: setToMin,\n        setToMax: setToMax,\n        getValueFromEvent: getValueFromEvent,\n        setPositionFromValue: setPositionFromValue,\n        onLeft: onLeft,\n        onRight: onRight,\n        onUp: onUp,\n        onDown: onDown,\n        edgeActions: edgeActions\n    });\n\n    const SliderSchema = [\n      defaulted('stepSize', 1),\n      defaulted('speedMultiplier', 10),\n      defaulted('onChange', noop),\n      defaulted('onChoose', noop),\n      defaulted('onInit', noop),\n      defaulted('onDragStart', noop),\n      defaulted('onDragEnd', noop),\n      defaulted('snapToGrid', false),\n      defaulted('rounded', true),\n      option$3('snapStart'),\n      requiredOf('model', choose$1('mode', {\n        x: [\n          defaulted('minX', 0),\n          defaulted('maxX', 100),\n          customField('value', spec => Cell(spec.mode.minX)),\n          required$1('getInitialValue'),\n          output$1('manager', HorizontalModel)\n        ],\n        y: [\n          defaulted('minY', 0),\n          defaulted('maxY', 100),\n          customField('value', spec => Cell(spec.mode.minY)),\n          required$1('getInitialValue'),\n          output$1('manager', VerticalModel)\n        ],\n        xy: [\n          defaulted('minX', 0),\n          defaulted('maxX', 100),\n          defaulted('minY', 0),\n          defaulted('maxY', 100),\n          customField('value', spec => Cell({\n            x: spec.mode.minX,\n            y: spec.mode.minY\n          })),\n          required$1('getInitialValue'),\n          output$1('manager', TwoDModel)\n        ]\n      })),\n      field('sliderBehaviours', [\n        Keying,\n        Representing\n      ]),\n      customField('mouseIsDown', () => Cell(false))\n    ];\n\n    const sketch$2 = (detail, components, _spec, _externals) => {\n      const getThumb = component => getPartOrDie(component, detail, 'thumb');\n      const getSpectrum = component => getPartOrDie(component, detail, 'spectrum');\n      const getLeftEdge = component => getPart(component, detail, 'left-edge');\n      const getRightEdge = component => getPart(component, detail, 'right-edge');\n      const getTopEdge = component => getPart(component, detail, 'top-edge');\n      const getBottomEdge = component => getPart(component, detail, 'bottom-edge');\n      const modelDetail = detail.model;\n      const model = modelDetail.manager;\n      const refresh = (slider, thumb) => {\n        model.setPositionFromValue(slider, thumb, detail, {\n          getLeftEdge,\n          getRightEdge,\n          getTopEdge,\n          getBottomEdge,\n          getSpectrum\n        });\n      };\n      const setValue = (slider, newValue) => {\n        modelDetail.value.set(newValue);\n        const thumb = getThumb(slider);\n        refresh(slider, thumb);\n      };\n      const changeValue = (slider, newValue) => {\n        setValue(slider, newValue);\n        const thumb = getThumb(slider);\n        detail.onChange(slider, thumb, newValue);\n        return Optional.some(true);\n      };\n      const resetToMin = slider => {\n        model.setToMin(slider, detail);\n      };\n      const resetToMax = slider => {\n        model.setToMax(slider, detail);\n      };\n      const choose = slider => {\n        const fireOnChoose = () => {\n          getPart(slider, detail, 'thumb').each(thumb => {\n            const value = modelDetail.value.get();\n            detail.onChoose(slider, thumb, value);\n          });\n        };\n        const wasDown = detail.mouseIsDown.get();\n        detail.mouseIsDown.set(false);\n        if (wasDown) {\n          fireOnChoose();\n        }\n      };\n      const onDragStart = (slider, simulatedEvent) => {\n        simulatedEvent.stop();\n        detail.mouseIsDown.set(true);\n        detail.onDragStart(slider, getThumb(slider));\n      };\n      const onDragEnd = (slider, simulatedEvent) => {\n        simulatedEvent.stop();\n        detail.onDragEnd(slider, getThumb(slider));\n        choose(slider);\n      };\n      const focusWidget = component => {\n        getPart(component, detail, 'spectrum').map(Keying.focusIn);\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components,\n        behaviours: augment(detail.sliderBehaviours, [\n          Keying.config({\n            mode: 'special',\n            focusIn: focusWidget\n          }),\n          Representing.config({\n            store: {\n              mode: 'manual',\n              getValue: _ => {\n                return modelDetail.value.get();\n              },\n              setValue\n            }\n          }),\n          Receiving.config({ channels: { [mouseReleased()]: { onReceive: choose } } })\n        ]),\n        events: derive$2([\n          run$1(sliderChangeEvent(), (slider, simulatedEvent) => {\n            changeValue(slider, simulatedEvent.event.value);\n          }),\n          runOnAttached((slider, _simulatedEvent) => {\n            const getInitial = modelDetail.getInitialValue();\n            modelDetail.value.set(getInitial);\n            const thumb = getThumb(slider);\n            refresh(slider, thumb);\n            const spectrum = getSpectrum(slider);\n            detail.onInit(slider, thumb, spectrum, modelDetail.value.get());\n          }),\n          run$1(touchstart(), onDragStart),\n          run$1(touchend(), onDragEnd),\n          run$1(mousedown(), (component, event) => {\n            focusWidget(component);\n            onDragStart(component, event);\n          }),\n          run$1(mouseup(), onDragEnd)\n        ]),\n        apis: {\n          resetToMin,\n          resetToMax,\n          setValue,\n          refresh\n        },\n        domModification: { styles: { position: 'relative' } }\n      };\n    };\n\n    const Slider = composite({\n      name: 'Slider',\n      configFields: SliderSchema,\n      partFields: SliderParts,\n      factory: sketch$2,\n      apis: {\n        setValue: (apis, slider, value) => {\n          apis.setValue(slider, value);\n        },\n        resetToMin: (apis, slider) => {\n          apis.resetToMin(slider);\n        },\n        resetToMax: (apis, slider) => {\n          apis.resetToMax(slider);\n        },\n        refresh: (apis, slider) => {\n          apis.refresh(slider);\n        }\n      }\n    });\n\n    const fieldsUpdate = generate$6('rgb-hex-update');\n    const sliderUpdate = generate$6('slider-update');\n    const paletteUpdate = generate$6('palette-update');\n\n    const sliderFactory = (translate, getClass) => {\n      const spectrum = Slider.parts.spectrum({\n        dom: {\n          tag: 'div',\n          classes: [getClass('hue-slider-spectrum')],\n          attributes: { role: 'presentation' }\n        }\n      });\n      const thumb = Slider.parts.thumb({\n        dom: {\n          tag: 'div',\n          classes: [getClass('hue-slider-thumb')],\n          attributes: { role: 'presentation' }\n        }\n      });\n      return Slider.sketch({\n        dom: {\n          tag: 'div',\n          classes: [getClass('hue-slider')],\n          attributes: {\n            'role': 'slider',\n            'aria-valuemin': 0,\n            'aria-valuemax': 360,\n            'aria-valuenow': 120\n          }\n        },\n        rounded: false,\n        model: {\n          mode: 'y',\n          getInitialValue: constant$1(0)\n        },\n        components: [\n          spectrum,\n          thumb\n        ],\n        sliderBehaviours: derive$1([Focusing.config({})]),\n        onChange: (slider, _thumb, value) => {\n          set$9(slider.element, 'aria-valuenow', Math.floor(360 - value * 3.6));\n          emitWith(slider, sliderUpdate, { value });\n        }\n      });\n    };\n\n    const owner$1 = 'form';\n    const schema$i = [field('formBehaviours', [Representing])];\n    const getPartName$1 = name => '<alloy.field.' + name + '>';\n    const sketch$1 = fSpec => {\n      const parts = (() => {\n        const record = [];\n        const field = (name, config) => {\n          record.push(name);\n          return generateOne$1(owner$1, getPartName$1(name), config);\n        };\n        return {\n          field,\n          record: constant$1(record)\n        };\n      })();\n      const spec = fSpec(parts);\n      const partNames = parts.record();\n      const fieldParts = map$2(partNames, n => required({\n        name: n,\n        pname: getPartName$1(n)\n      }));\n      return composite$1(owner$1, schema$i, fieldParts, make$4, spec);\n    };\n    const toResult = (o, e) => o.fold(() => Result.error(e), Result.value);\n    const make$4 = (detail, components) => ({\n      uid: detail.uid,\n      dom: detail.dom,\n      components,\n      behaviours: augment(detail.formBehaviours, [Representing.config({\n          store: {\n            mode: 'manual',\n            getValue: form => {\n              const resPs = getAllParts(form, detail);\n              return map$1(resPs, (resPThunk, pName) => resPThunk().bind(v => {\n                const opt = Composing.getCurrent(v);\n                return toResult(opt, new Error(`Cannot find a current component to extract the value from for form part '${ pName }': ` + element(v.element)));\n              }).map(Representing.getValue));\n            },\n            setValue: (form, values) => {\n              each(values, (newValue, key) => {\n                getPart(form, detail, key).each(wrapper => {\n                  Composing.getCurrent(wrapper).each(field => {\n                    Representing.setValue(field, newValue);\n                  });\n                });\n              });\n            }\n          }\n        })]),\n      apis: {\n        getField: (form, key) => {\n          return getPart(form, detail, key).bind(Composing.getCurrent);\n        }\n      }\n    });\n    const Form = {\n      getField: makeApi((apis, component, key) => apis.getField(component, key)),\n      sketch: sketch$1\n    };\n\n    const validInput = generate$6('valid-input');\n    const invalidInput = generate$6('invalid-input');\n    const validatingInput = generate$6('validating-input');\n    const translatePrefix = 'colorcustom.rgb.';\n    const rgbFormFactory = (translate, getClass, onValidHexx, onInvalidHexx) => {\n      const invalidation = (label, isValid) => Invalidating.config({\n        invalidClass: getClass('invalid'),\n        notify: {\n          onValidate: comp => {\n            emitWith(comp, validatingInput, { type: label });\n          },\n          onValid: comp => {\n            emitWith(comp, validInput, {\n              type: label,\n              value: Representing.getValue(comp)\n            });\n          },\n          onInvalid: comp => {\n            emitWith(comp, invalidInput, {\n              type: label,\n              value: Representing.getValue(comp)\n            });\n          }\n        },\n        validator: {\n          validate: comp => {\n            const value = Representing.getValue(comp);\n            const res = isValid(value) ? Result.value(true) : Result.error(translate('aria.input.invalid'));\n            return Future.pure(res);\n          },\n          validateOnLoad: false\n        }\n      });\n      const renderTextField = (isValid, name, label, description, data) => {\n        const helptext = translate(translatePrefix + 'range');\n        const pLabel = FormField.parts.label({\n          dom: {\n            tag: 'label',\n            attributes: { 'aria-label': description }\n          },\n          components: [text$2(label)]\n        });\n        const pField = FormField.parts.field({\n          data,\n          factory: Input,\n          inputAttributes: {\n            type: 'text',\n            ...name === 'hex' ? { 'aria-live': 'polite' } : {}\n          },\n          inputClasses: [getClass('textfield')],\n          inputBehaviours: derive$1([\n            invalidation(name, isValid),\n            Tabstopping.config({})\n          ]),\n          onSetValue: input => {\n            if (Invalidating.isInvalid(input)) {\n              const run = Invalidating.run(input);\n              run.get(noop);\n            }\n          }\n        });\n        const comps = [\n          pLabel,\n          pField\n        ];\n        const concats = name !== 'hex' ? [FormField.parts['aria-descriptor']({ text: helptext })] : [];\n        const components = comps.concat(concats);\n        return {\n          dom: {\n            tag: 'div',\n            attributes: { role: 'presentation' }\n          },\n          components\n        };\n      };\n      const copyRgbToHex = (form, rgba) => {\n        const hex = fromRgba(rgba);\n        Form.getField(form, 'hex').each(hexField => {\n          if (!Focusing.isFocused(hexField)) {\n            Representing.setValue(form, { hex: hex.value });\n          }\n        });\n        return hex;\n      };\n      const copyRgbToForm = (form, rgb) => {\n        const red = rgb.red;\n        const green = rgb.green;\n        const blue = rgb.blue;\n        Representing.setValue(form, {\n          red,\n          green,\n          blue\n        });\n      };\n      const memPreview = record({\n        dom: {\n          tag: 'div',\n          classes: [getClass('rgba-preview')],\n          styles: { 'background-color': 'white' },\n          attributes: { role: 'presentation' }\n        }\n      });\n      const updatePreview = (anyInSystem, hex) => {\n        memPreview.getOpt(anyInSystem).each(preview => {\n          set$8(preview.element, 'background-color', '#' + hex.value);\n        });\n      };\n      const factory = () => {\n        const state = {\n          red: Cell(Optional.some(255)),\n          green: Cell(Optional.some(255)),\n          blue: Cell(Optional.some(255)),\n          hex: Cell(Optional.some('ffffff'))\n        };\n        const copyHexToRgb = (form, hex) => {\n          const rgb = fromHex(hex);\n          copyRgbToForm(form, rgb);\n          setValueRgb(rgb);\n        };\n        const get = prop => state[prop].get();\n        const set = (prop, value) => {\n          state[prop].set(value);\n        };\n        const getValueRgb = () => get('red').bind(red => get('green').bind(green => get('blue').map(blue => rgbaColour(red, green, blue, 1))));\n        const setValueRgb = rgb => {\n          const red = rgb.red;\n          const green = rgb.green;\n          const blue = rgb.blue;\n          set('red', Optional.some(red));\n          set('green', Optional.some(green));\n          set('blue', Optional.some(blue));\n        };\n        const onInvalidInput = (form, simulatedEvent) => {\n          const data = simulatedEvent.event;\n          if (data.type !== 'hex') {\n            set(data.type, Optional.none());\n          } else {\n            onInvalidHexx(form);\n          }\n        };\n        const onValidHex = (form, value) => {\n          onValidHexx(form);\n          const hex = hexColour(value);\n          set('hex', Optional.some(hex.value));\n          const rgb = fromHex(hex);\n          copyRgbToForm(form, rgb);\n          setValueRgb(rgb);\n          emitWith(form, fieldsUpdate, { hex });\n          updatePreview(form, hex);\n        };\n        const onValidRgb = (form, prop, value) => {\n          const val = parseInt(value, 10);\n          set(prop, Optional.some(val));\n          getValueRgb().each(rgb => {\n            const hex = copyRgbToHex(form, rgb);\n            emitWith(form, fieldsUpdate, { hex });\n            updatePreview(form, hex);\n          });\n        };\n        const isHexInputEvent = data => data.type === 'hex';\n        const onValidInput = (form, simulatedEvent) => {\n          const data = simulatedEvent.event;\n          if (isHexInputEvent(data)) {\n            onValidHex(form, data.value);\n          } else {\n            onValidRgb(form, data.type, data.value);\n          }\n        };\n        const formPartStrings = key => ({\n          label: translate(translatePrefix + key + '.label'),\n          description: translate(translatePrefix + key + '.description')\n        });\n        const redStrings = formPartStrings('red');\n        const greenStrings = formPartStrings('green');\n        const blueStrings = formPartStrings('blue');\n        const hexStrings = formPartStrings('hex');\n        return deepMerge(Form.sketch(parts => ({\n          dom: {\n            tag: 'form',\n            classes: [getClass('rgb-form')],\n            attributes: { 'aria-label': translate('aria.color.picker') }\n          },\n          components: [\n            parts.field('red', FormField.sketch(renderTextField(isRgbaComponent, 'red', redStrings.label, redStrings.description, 255))),\n            parts.field('green', FormField.sketch(renderTextField(isRgbaComponent, 'green', greenStrings.label, greenStrings.description, 255))),\n            parts.field('blue', FormField.sketch(renderTextField(isRgbaComponent, 'blue', blueStrings.label, blueStrings.description, 255))),\n            parts.field('hex', FormField.sketch(renderTextField(isHexString, 'hex', hexStrings.label, hexStrings.description, 'ffffff'))),\n            memPreview.asSpec()\n          ],\n          formBehaviours: derive$1([\n            Invalidating.config({ invalidClass: getClass('form-invalid') }),\n            config('rgb-form-events', [\n              run$1(validInput, onValidInput),\n              run$1(invalidInput, onInvalidInput),\n              run$1(validatingInput, onInvalidInput)\n            ])\n          ])\n        })), {\n          apis: {\n            updateHex: (form, hex) => {\n              Representing.setValue(form, { hex: hex.value });\n              copyHexToRgb(form, hex);\n              updatePreview(form, hex);\n            }\n          }\n        });\n      };\n      const rgbFormSketcher = single({\n        factory,\n        name: 'RgbForm',\n        configFields: [],\n        apis: {\n          updateHex: (apis, form, hex) => {\n            apis.updateHex(form, hex);\n          }\n        },\n        extraApis: {}\n      });\n      return rgbFormSketcher;\n    };\n\n    const paletteFactory = (translate, getClass) => {\n      const spectrumPart = Slider.parts.spectrum({\n        dom: {\n          tag: 'canvas',\n          attributes: { role: 'presentation' },\n          classes: [getClass('sv-palette-spectrum')]\n        }\n      });\n      const thumbPart = Slider.parts.thumb({\n        dom: {\n          tag: 'div',\n          attributes: { role: 'presentation' },\n          classes: [getClass('sv-palette-thumb')],\n          innerHtml: `<div class=${ getClass('sv-palette-inner-thumb') } role=\"presentation\"></div>`\n        }\n      });\n      const setColour = (canvas, rgba) => {\n        const {width, height} = canvas;\n        const ctx = canvas.getContext('2d');\n        if (ctx === null) {\n          return;\n        }\n        ctx.fillStyle = rgba;\n        ctx.fillRect(0, 0, width, height);\n        const grdWhite = ctx.createLinearGradient(0, 0, width, 0);\n        grdWhite.addColorStop(0, 'rgba(255,255,255,1)');\n        grdWhite.addColorStop(1, 'rgba(255,255,255,0)');\n        ctx.fillStyle = grdWhite;\n        ctx.fillRect(0, 0, width, height);\n        const grdBlack = ctx.createLinearGradient(0, 0, 0, height);\n        grdBlack.addColorStop(0, 'rgba(0,0,0,0)');\n        grdBlack.addColorStop(1, 'rgba(0,0,0,1)');\n        ctx.fillStyle = grdBlack;\n        ctx.fillRect(0, 0, width, height);\n      };\n      const setPaletteHue = (slider, hue) => {\n        const canvas = slider.components()[0].element.dom;\n        const hsv = hsvColour(hue, 100, 100);\n        const rgba = fromHsv(hsv);\n        setColour(canvas, toString(rgba));\n      };\n      const setPaletteThumb = (slider, hex) => {\n        const hsv = fromRgb(fromHex(hex));\n        Slider.setValue(slider, {\n          x: hsv.saturation,\n          y: 100 - hsv.value\n        });\n        set$9(slider.element, 'aria-valuetext', translate([\n          'Saturation {0}%, Brightness {1}%',\n          hsv.saturation,\n          hsv.value\n        ]));\n      };\n      const factory = _detail => {\n        const getInitialValue = constant$1({\n          x: 0,\n          y: 0\n        });\n        const onChange = (slider, _thumb, value) => {\n          if (!isNumber(value)) {\n            set$9(slider.element, 'aria-valuetext', translate([\n              'Saturation {0}%, Brightness {1}%',\n              Math.floor(value.x),\n              Math.floor(100 - value.y)\n            ]));\n          }\n          emitWith(slider, paletteUpdate, { value });\n        };\n        const onInit = (_slider, _thumb, spectrum, _value) => {\n          setColour(spectrum.element.dom, toString(red));\n        };\n        const sliderBehaviours = derive$1([\n          Composing.config({ find: Optional.some }),\n          Focusing.config({})\n        ]);\n        return Slider.sketch({\n          dom: {\n            tag: 'div',\n            attributes: {\n              'role': 'slider',\n              'aria-valuetext': translate([\n                'Saturation {0}%, Brightness {1}%',\n                0,\n                0\n              ])\n            },\n            classes: [getClass('sv-palette')]\n          },\n          model: {\n            mode: 'xy',\n            getInitialValue\n          },\n          rounded: false,\n          components: [\n            spectrumPart,\n            thumbPart\n          ],\n          onChange,\n          onInit,\n          sliderBehaviours\n        });\n      };\n      const saturationBrightnessPaletteSketcher = single({\n        factory,\n        name: 'SaturationBrightnessPalette',\n        configFields: [],\n        apis: {\n          setHue: (_apis, slider, hue) => {\n            setPaletteHue(slider, hue);\n          },\n          setThumb: (_apis, slider, hex) => {\n            setPaletteThumb(slider, hex);\n          }\n        },\n        extraApis: {}\n      });\n      return saturationBrightnessPaletteSketcher;\n    };\n\n    const makeFactory = (translate, getClass) => {\n      const factory = detail => {\n        const rgbForm = rgbFormFactory(translate, getClass, detail.onValidHex, detail.onInvalidHex);\n        const sbPalette = paletteFactory(translate, getClass);\n        const hueSliderToDegrees = hue => (100 - hue) / 100 * 360;\n        const hueDegreesToSlider = hue => 100 - hue / 360 * 100;\n        const state = {\n          paletteRgba: Cell(red),\n          paletteHue: Cell(0)\n        };\n        const memSlider = record(sliderFactory(translate, getClass));\n        const memPalette = record(sbPalette.sketch({}));\n        const memRgb = record(rgbForm.sketch({}));\n        const updatePalette = (anyInSystem, _hex, hue) => {\n          memPalette.getOpt(anyInSystem).each(palette => {\n            sbPalette.setHue(palette, hue);\n          });\n        };\n        const updateFields = (anyInSystem, hex) => {\n          memRgb.getOpt(anyInSystem).each(form => {\n            rgbForm.updateHex(form, hex);\n          });\n        };\n        const updateSlider = (anyInSystem, _hex, hue) => {\n          memSlider.getOpt(anyInSystem).each(slider => {\n            Slider.setValue(slider, hueDegreesToSlider(hue));\n          });\n        };\n        const updatePaletteThumb = (anyInSystem, hex) => {\n          memPalette.getOpt(anyInSystem).each(palette => {\n            sbPalette.setThumb(palette, hex);\n          });\n        };\n        const updateState = (hex, hue) => {\n          const rgba = fromHex(hex);\n          state.paletteRgba.set(rgba);\n          state.paletteHue.set(hue);\n        };\n        const runUpdates = (anyInSystem, hex, hue, updates) => {\n          updateState(hex, hue);\n          each$1(updates, update => {\n            update(anyInSystem, hex, hue);\n          });\n        };\n        const onPaletteUpdate = () => {\n          const updates = [updateFields];\n          return (form, simulatedEvent) => {\n            const value = simulatedEvent.event.value;\n            const oldHue = state.paletteHue.get();\n            const newHsv = hsvColour(oldHue, value.x, 100 - value.y);\n            const newHex = hsvToHex(newHsv);\n            runUpdates(form, newHex, oldHue, updates);\n          };\n        };\n        const onSliderUpdate = () => {\n          const updates = [\n            updatePalette,\n            updateFields\n          ];\n          return (form, simulatedEvent) => {\n            const hue = hueSliderToDegrees(simulatedEvent.event.value);\n            const oldRgb = state.paletteRgba.get();\n            const oldHsv = fromRgb(oldRgb);\n            const newHsv = hsvColour(hue, oldHsv.saturation, oldHsv.value);\n            const newHex = hsvToHex(newHsv);\n            runUpdates(form, newHex, hue, updates);\n          };\n        };\n        const onFieldsUpdate = () => {\n          const updates = [\n            updatePalette,\n            updateSlider,\n            updatePaletteThumb\n          ];\n          return (form, simulatedEvent) => {\n            const hex = simulatedEvent.event.hex;\n            const hsv = hexToHsv(hex);\n            runUpdates(form, hex, hsv.hue, updates);\n          };\n        };\n        return {\n          uid: detail.uid,\n          dom: detail.dom,\n          components: [\n            memPalette.asSpec(),\n            memSlider.asSpec(),\n            memRgb.asSpec()\n          ],\n          behaviours: derive$1([\n            config('colour-picker-events', [\n              run$1(fieldsUpdate, onFieldsUpdate()),\n              run$1(paletteUpdate, onPaletteUpdate()),\n              run$1(sliderUpdate, onSliderUpdate())\n            ]),\n            Composing.config({ find: comp => memRgb.getOpt(comp) }),\n            Keying.config({ mode: 'acyclic' })\n          ])\n        };\n      };\n      const colourPickerSketcher = single({\n        name: 'ColourPicker',\n        configFields: [\n          required$1('dom'),\n          defaulted('onValidHex', noop),\n          defaulted('onInvalidHex', noop)\n        ],\n        factory\n      });\n      return colourPickerSketcher;\n    };\n\n    const self = () => Composing.config({ find: Optional.some });\n    const memento$1 = mem => Composing.config({ find: mem.getOpt });\n    const childAt = index => Composing.config({ find: comp => child$2(comp.element, index).bind(element => comp.getSystem().getByDom(element).toOptional()) });\n    const ComposingConfigs = {\n      self,\n      memento: memento$1,\n      childAt\n    };\n\n    const processors = objOf([\n      defaulted('preprocess', identity),\n      defaulted('postprocess', identity)\n    ]);\n    const memento = (mem, rawProcessors) => {\n      const ps = asRawOrDie$1('RepresentingConfigs.memento processors', processors, rawProcessors);\n      return Representing.config({\n        store: {\n          mode: 'manual',\n          getValue: comp => {\n            const other = mem.get(comp);\n            const rawValue = Representing.getValue(other);\n            return ps.postprocess(rawValue);\n          },\n          setValue: (comp, rawValue) => {\n            const newValue = ps.preprocess(rawValue);\n            const other = mem.get(comp);\n            Representing.setValue(other, newValue);\n          }\n        }\n      });\n    };\n    const withComp = (optInitialValue, getter, setter) => Representing.config({\n      store: {\n        mode: 'manual',\n        ...optInitialValue.map(initialValue => ({ initialValue })).getOr({}),\n        getValue: getter,\n        setValue: setter\n      }\n    });\n    const withElement = (initialValue, getter, setter) => withComp(initialValue, c => getter(c.element), (c, v) => setter(c.element, v));\n    const domHtml = optInitialValue => withElement(optInitialValue, get$8, set$6);\n    const memory = initialValue => Representing.config({\n      store: {\n        mode: 'memory',\n        initialValue\n      }\n    });\n\n    const english = {\n      'colorcustom.rgb.red.label': 'R',\n      'colorcustom.rgb.red.description': 'Red component',\n      'colorcustom.rgb.green.label': 'G',\n      'colorcustom.rgb.green.description': 'Green component',\n      'colorcustom.rgb.blue.label': 'B',\n      'colorcustom.rgb.blue.description': 'Blue component',\n      'colorcustom.rgb.hex.label': '#',\n      'colorcustom.rgb.hex.description': 'Hex color code',\n      'colorcustom.rgb.range': 'Range 0 to 255',\n      'aria.color.picker': 'Color Picker',\n      'aria.input.invalid': 'Invalid input'\n    };\n    const translate$1 = providerBackstage => key => {\n      if (isString(key)) {\n        return providerBackstage.translate(english[key]);\n      } else {\n        return providerBackstage.translate(key);\n      }\n    };\n    const renderColorPicker = (_spec, providerBackstage, initialData) => {\n      const getClass = key => 'tox-' + key;\n      const colourPickerFactory = makeFactory(translate$1(providerBackstage), getClass);\n      const onValidHex = form => {\n        emitWith(form, formActionEvent, {\n          name: 'hex-valid',\n          value: true\n        });\n      };\n      const onInvalidHex = form => {\n        emitWith(form, formActionEvent, {\n          name: 'hex-valid',\n          value: false\n        });\n      };\n      const memPicker = record(colourPickerFactory.sketch({\n        dom: {\n          tag: 'div',\n          classes: [getClass('color-picker-container')],\n          attributes: { role: 'presentation' }\n        },\n        onValidHex,\n        onInvalidHex\n      }));\n      return {\n        dom: { tag: 'div' },\n        components: [memPicker.asSpec()],\n        behaviours: derive$1([\n          withComp(initialData, comp => {\n            const picker = memPicker.get(comp);\n            const optRgbForm = Composing.getCurrent(picker);\n            const optHex = optRgbForm.bind(rgbForm => {\n              const formValues = Representing.getValue(rgbForm);\n              return formValues.hex;\n            });\n            return optHex.map(hex => '#' + removeLeading(hex, '#')).getOr('');\n          }, (comp, newValue) => {\n            const pattern = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/;\n            const valOpt = Optional.from(pattern.exec(newValue)).bind(matches => get$i(matches, 1));\n            const picker = memPicker.get(comp);\n            const optRgbForm = Composing.getCurrent(picker);\n            optRgbForm.fold(() => {\n              console.log('Can not find form');\n            }, rgbForm => {\n              Representing.setValue(rgbForm, { hex: valOpt.getOr('') });\n              Form.getField(rgbForm, 'hex').each(hexField => {\n                emit(hexField, input());\n              });\n            });\n          }),\n          ComposingConfigs.self()\n        ])\n      };\n    };\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.Resource');\n\n    const isOldCustomEditor = spec => has$2(spec, 'init');\n    const renderCustomEditor = spec => {\n      const editorApi = value$4();\n      const memReplaced = record({ dom: { tag: spec.tag } });\n      const initialValue = value$4();\n      const focusBehaviour = !isOldCustomEditor(spec) && spec.onFocus.isSome() ? [\n        Focusing.config({\n          onFocus: comp => {\n            spec.onFocus.each(onFocusFn => {\n              onFocusFn(comp.element.dom);\n            });\n          }\n        }),\n        Tabstopping.config({})\n      ] : [];\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-custom-editor']\n        },\n        behaviours: derive$1([\n          config('custom-editor-events', [runOnAttached(component => {\n              memReplaced.getOpt(component).each(ta => {\n                (isOldCustomEditor(spec) ? spec.init(ta.element.dom) : global$2.load(spec.scriptId, spec.scriptUrl).then(init => init(ta.element.dom, spec.settings))).then(ea => {\n                  initialValue.on(cvalue => {\n                    ea.setValue(cvalue);\n                  });\n                  initialValue.clear();\n                  editorApi.set(ea);\n                });\n              });\n            })]),\n          withComp(Optional.none(), () => editorApi.get().fold(() => initialValue.get().getOr(''), ed => ed.getValue()), (_component, value) => {\n            editorApi.get().fold(() => initialValue.set(value), ed => ed.setValue(value));\n          }),\n          ComposingConfigs.self()\n        ].concat(focusBehaviour)),\n        components: [memReplaced.asSpec()]\n      };\n    };\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    const filterByExtension = (files, providersBackstage) => {\n      const allowedImageFileTypes = global$1.explode(providersBackstage.getOption('images_file_types'));\n      const isFileInAllowedTypes = file => exists(allowedImageFileTypes, type => endsWith(file.name.toLowerCase(), `.${ type.toLowerCase() }`));\n      return filter$2(from(files), isFileInAllowedTypes);\n    };\n    const renderDropZone = (spec, providersBackstage, initialData) => {\n      const stopper = (_, se) => {\n        se.stop();\n      };\n      const sequence = actions => (comp, se) => {\n        each$1(actions, a => {\n          a(comp, se);\n        });\n      };\n      const onDrop = (comp, se) => {\n        var _a;\n        if (!Disabling.isDisabled(comp)) {\n          const transferEvent = se.event.raw;\n          handleFiles(comp, (_a = transferEvent.dataTransfer) === null || _a === void 0 ? void 0 : _a.files);\n        }\n      };\n      const onSelect = (component, simulatedEvent) => {\n        const input = simulatedEvent.event.raw.target;\n        handleFiles(component, input.files);\n      };\n      const handleFiles = (component, files) => {\n        if (files) {\n          Representing.setValue(component, filterByExtension(files, providersBackstage));\n          emitWith(component, formChangeEvent, { name: spec.name });\n        }\n      };\n      const memInput = record({\n        dom: {\n          tag: 'input',\n          attributes: {\n            type: 'file',\n            accept: 'image/*'\n          },\n          styles: { display: 'none' }\n        },\n        behaviours: derive$1([config('input-file-events', [\n            cutter(click()),\n            cutter(tap())\n          ])])\n      });\n      const renderField = s => ({\n        uid: s.uid,\n        dom: {\n          tag: 'div',\n          classes: ['tox-dropzone-container']\n        },\n        behaviours: derive$1([\n          memory(initialData.getOr([])),\n          ComposingConfigs.self(),\n          Disabling.config({}),\n          Toggling.config({\n            toggleClass: 'dragenter',\n            toggleOnExecute: false\n          }),\n          config('dropzone-events', [\n            run$1('dragenter', sequence([\n              stopper,\n              Toggling.toggle\n            ])),\n            run$1('dragleave', sequence([\n              stopper,\n              Toggling.toggle\n            ])),\n            run$1('dragover', stopper),\n            run$1('drop', sequence([\n              stopper,\n              onDrop\n            ])),\n            run$1(change(), onSelect)\n          ])\n        ]),\n        components: [{\n            dom: {\n              tag: 'div',\n              classes: ['tox-dropzone'],\n              styles: {}\n            },\n            components: [\n              {\n                dom: { tag: 'p' },\n                components: [text$2(providersBackstage.translate('Drop an image here'))]\n              },\n              Button.sketch({\n                dom: {\n                  tag: 'button',\n                  styles: { position: 'relative' },\n                  classes: [\n                    'tox-button',\n                    'tox-button--secondary'\n                  ]\n                },\n                components: [\n                  text$2(providersBackstage.translate('Browse for an image')),\n                  memInput.asSpec()\n                ],\n                action: comp => {\n                  const inputComp = memInput.get(comp);\n                  inputComp.element.dom.click();\n                },\n                buttonBehaviours: derive$1([\n                  Tabstopping.config({}),\n                  DisablingConfigs.button(providersBackstage.isDisabled),\n                  receivingConfig()\n                ])\n              })\n            ]\n          }]\n      });\n      const pLabel = spec.label.map(label => renderLabel$3(label, providersBackstage));\n      const pField = FormField.parts.field({ factory: { sketch: renderField } });\n      return renderFormFieldWith(pLabel, pField, ['tox-form__group--stretched'], []);\n    };\n\n    const renderGrid = (spec, backstage) => ({\n      dom: {\n        tag: 'div',\n        classes: [\n          'tox-form__grid',\n          `tox-form__grid--${ spec.columns }col`\n        ]\n      },\n      components: map$2(spec.items, backstage.interpreter)\n    });\n\n    const adaptable = (fn, rate) => {\n      let timer = null;\n      let args = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n          args = null;\n        }\n      };\n      const throttle = (...newArgs) => {\n        args = newArgs;\n        if (isNull(timer)) {\n          timer = setTimeout(() => {\n            const tempArgs = args;\n            timer = null;\n            args = null;\n            fn.apply(null, tempArgs);\n          }, rate);\n        }\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n    const first = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        if (isNull(timer)) {\n          timer = setTimeout(() => {\n            timer = null;\n            fn.apply(null, args);\n          }, rate);\n        }\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n    const last = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        cancel();\n        timer = setTimeout(() => {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n\n    const beforeObject = generate$6('alloy-fake-before-tabstop');\n    const afterObject = generate$6('alloy-fake-after-tabstop');\n    const craftWithClasses = classes => {\n      return {\n        dom: {\n          tag: 'div',\n          styles: {\n            width: '1px',\n            height: '1px',\n            outline: 'none'\n          },\n          attributes: { tabindex: '0' },\n          classes\n        },\n        behaviours: derive$1([\n          Focusing.config({ ignore: true }),\n          Tabstopping.config({})\n        ])\n      };\n    };\n    const craft = (containerClasses, spec) => {\n      return {\n        dom: {\n          tag: 'div',\n          classes: [\n            'tox-navobj',\n            ...containerClasses.getOr([])\n          ]\n        },\n        components: [\n          craftWithClasses([beforeObject]),\n          spec,\n          craftWithClasses([afterObject])\n        ],\n        behaviours: derive$1([ComposingConfigs.childAt(1)])\n      };\n    };\n    const triggerTab = (placeholder, shiftKey) => {\n      emitWith(placeholder, keydown(), {\n        raw: {\n          which: 9,\n          shiftKey\n        }\n      });\n    };\n    const onFocus = (container, targetComp) => {\n      const target = targetComp.element;\n      if (has(target, beforeObject)) {\n        triggerTab(container, true);\n      } else if (has(target, afterObject)) {\n        triggerTab(container, false);\n      }\n    };\n    const isPseudoStop = element => {\n      return closest(element, [\n        '.' + beforeObject,\n        '.' + afterObject\n      ].join(','), never);\n    };\n\n    const dialogChannel = generate$6('update-dialog');\n    const titleChannel = generate$6('update-title');\n    const bodyChannel = generate$6('update-body');\n    const footerChannel = generate$6('update-footer');\n    const bodySendMessageChannel = generate$6('body-send-message');\n    const dialogFocusShiftedChannel = generate$6('dialog-focus-shifted');\n\n    const browser = detect$1().browser;\n    const isSafari = browser.isSafari();\n    const isFirefox = browser.isFirefox();\n    const isSafariOrFirefox = isSafari || isFirefox;\n    const isChromium = browser.isChromium();\n    const isElementScrollAtBottom = ({scrollTop, scrollHeight, clientHeight}) => Math.ceil(scrollTop) + clientHeight >= scrollHeight;\n    const scrollToY = (win, y) => win.scrollTo(0, y === 'bottom' ? 99999999 : y);\n    const getScrollingElement = (doc, html) => {\n      const body = doc.body;\n      return Optional.from(!/^<!DOCTYPE (html|HTML)/.test(html) && (!isChromium && !isSafari || isNonNullable(body) && (body.scrollTop !== 0 || Math.abs(body.scrollHeight - body.clientHeight) > 1)) ? body : doc.documentElement);\n    };\n    const writeValue = (iframeElement, html, fallbackFn) => {\n      const iframe = iframeElement.dom;\n      Optional.from(iframe.contentDocument).fold(fallbackFn, doc => {\n        let lastScrollTop = 0;\n        const isScrollAtBottom = getScrollingElement(doc, html).map(el => {\n          lastScrollTop = el.scrollTop;\n          return el;\n        }).forall(isElementScrollAtBottom);\n        const scrollAfterWrite = () => {\n          const win = iframe.contentWindow;\n          if (isNonNullable(win)) {\n            if (isScrollAtBottom) {\n              scrollToY(win, 'bottom');\n            } else if (!isScrollAtBottom && isSafariOrFirefox && lastScrollTop !== 0) {\n              scrollToY(win, lastScrollTop);\n            }\n          }\n        };\n        if (isSafari) {\n          iframe.addEventListener('load', scrollAfterWrite, { once: true });\n        }\n        doc.open();\n        doc.write(html);\n        doc.close();\n        if (!isSafari) {\n          scrollAfterWrite();\n        }\n      });\n    };\n    const throttleInterval = someIf(isSafariOrFirefox, isSafari ? 500 : 200);\n    const writeValueThrottler = throttleInterval.map(interval => adaptable(writeValue, interval));\n    const getDynamicSource = (initialData, stream) => {\n      const cachedValue = Cell(initialData.getOr(''));\n      return {\n        getValue: _frameComponent => cachedValue.get(),\n        setValue: (frameComponent, html) => {\n          if (cachedValue.get() !== html) {\n            const iframeElement = frameComponent.element;\n            const setSrcdocValue = () => set$9(iframeElement, 'srcdoc', html);\n            if (stream) {\n              writeValueThrottler.fold(constant$1(writeValue), throttler => throttler.throttle)(iframeElement, html, setSrcdocValue);\n            } else {\n              setSrcdocValue();\n            }\n          }\n          cachedValue.set(html);\n        }\n      };\n    };\n    const renderIFrame = (spec, providersBackstage, initialData) => {\n      const baseClass = 'tox-dialog__iframe';\n      const opaqueClass = spec.transparent ? [] : [`${ baseClass }--opaque`];\n      const containerBorderedClass = spec.border ? [`tox-navobj-bordered`] : [];\n      const attributes = {\n        ...spec.label.map(title => ({ title })).getOr({}),\n        ...initialData.map(html => ({ srcdoc: html })).getOr({}),\n        ...spec.sandboxed ? { sandbox: 'allow-scripts allow-same-origin' } : {}\n      };\n      const sourcing = getDynamicSource(initialData, spec.streamContent);\n      const pLabel = spec.label.map(label => renderLabel$3(label, providersBackstage));\n      const factory = newSpec => craft(Optional.from(containerBorderedClass), {\n        uid: newSpec.uid,\n        dom: {\n          tag: 'iframe',\n          attributes,\n          classes: [\n            baseClass,\n            ...opaqueClass\n          ]\n        },\n        behaviours: derive$1([\n          Tabstopping.config({}),\n          Focusing.config({}),\n          withComp(initialData, sourcing.getValue, sourcing.setValue),\n          Receiving.config({\n            channels: {\n              [dialogFocusShiftedChannel]: {\n                onReceive: (comp, message) => {\n                  message.newFocus.each(newFocus => {\n                    parentElement(comp.element).each(parent => {\n                      const f = eq(comp.element, newFocus) ? add$2 : remove$3;\n                      f(parent, 'tox-navobj-bordered-focus');\n                    });\n                  });\n                }\n              }\n            }\n          })\n        ])\n      });\n      const pField = FormField.parts.field({ factory: { sketch: factory } });\n      return renderFormFieldWith(pLabel, pField, ['tox-form__group--stretched'], []);\n    };\n\n    const image = image => new Promise((resolve, reject) => {\n      const loaded = () => {\n        destroy();\n        resolve(image);\n      };\n      const listeners = [\n        bind(image, 'load', loaded),\n        bind(image, 'error', () => {\n          destroy();\n          reject('Unable to load data from image: ' + image.dom.src);\n        })\n      ];\n      const destroy = () => each$1(listeners, l => l.unbind());\n      if (image.dom.complete) {\n        loaded();\n      }\n    });\n\n    const calculateImagePosition = (panelWidth, panelHeight, imageWidth, imageHeight, zoom) => {\n      const width = imageWidth * zoom;\n      const height = imageHeight * zoom;\n      const left = Math.max(0, panelWidth / 2 - width / 2);\n      const top = Math.max(0, panelHeight / 2 - height / 2);\n      return {\n        left: left.toString() + 'px',\n        top: top.toString() + 'px',\n        width: width.toString() + 'px',\n        height: height.toString() + 'px'\n      };\n    };\n    const zoomToFit = (panel, width, height) => {\n      const panelW = get$d(panel);\n      const panelH = get$e(panel);\n      return Math.min(panelW / width, panelH / height, 1);\n    };\n    const renderImagePreview = (spec, initialData) => {\n      const cachedData = Cell(initialData.getOr({ url: '' }));\n      const memImage = record({\n        dom: {\n          tag: 'img',\n          classes: ['tox-imagepreview__image'],\n          attributes: initialData.map(data => ({ src: data.url })).getOr({})\n        }\n      });\n      const memContainer = record({\n        dom: {\n          tag: 'div',\n          classes: ['tox-imagepreview__container'],\n          attributes: { role: 'presentation' }\n        },\n        components: [memImage.asSpec()]\n      });\n      const setValue = (frameComponent, data) => {\n        const translatedData = { url: data.url };\n        data.zoom.each(z => translatedData.zoom = z);\n        data.cachedWidth.each(z => translatedData.cachedWidth = z);\n        data.cachedHeight.each(z => translatedData.cachedHeight = z);\n        cachedData.set(translatedData);\n        const applyFramePositioning = () => {\n          const {cachedWidth, cachedHeight, zoom} = translatedData;\n          if (!isUndefined(cachedWidth) && !isUndefined(cachedHeight)) {\n            if (isUndefined(zoom)) {\n              const z = zoomToFit(frameComponent.element, cachedWidth, cachedHeight);\n              translatedData.zoom = z;\n            }\n            const position = calculateImagePosition(get$d(frameComponent.element), get$e(frameComponent.element), cachedWidth, cachedHeight, translatedData.zoom);\n            memContainer.getOpt(frameComponent).each(container => {\n              setAll(container.element, position);\n            });\n          }\n        };\n        memImage.getOpt(frameComponent).each(imageComponent => {\n          const img = imageComponent.element;\n          if (data.url !== get$g(img, 'src')) {\n            set$9(img, 'src', data.url);\n            remove$3(frameComponent.element, 'tox-imagepreview__loaded');\n          }\n          applyFramePositioning();\n          image(img).then(img => {\n            if (frameComponent.getSystem().isConnected()) {\n              add$2(frameComponent.element, 'tox-imagepreview__loaded');\n              translatedData.cachedWidth = img.dom.naturalWidth;\n              translatedData.cachedHeight = img.dom.naturalHeight;\n              applyFramePositioning();\n            }\n          });\n        });\n      };\n      const styles = {};\n      spec.height.each(h => styles.height = h);\n      const fakeValidatedData = initialData.map(d => ({\n        url: d.url,\n        zoom: Optional.from(d.zoom),\n        cachedWidth: Optional.from(d.cachedWidth),\n        cachedHeight: Optional.from(d.cachedHeight)\n      }));\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-imagepreview'],\n          styles,\n          attributes: { role: 'presentation' }\n        },\n        components: [memContainer.asSpec()],\n        behaviours: derive$1([\n          ComposingConfigs.self(),\n          withComp(fakeValidatedData, () => cachedData.get(), setValue)\n        ])\n      };\n    };\n\n    const renderLabel$2 = (spec, backstageShared, getCompByName) => {\n      const baseClass = 'tox-label';\n      const centerClass = spec.align === 'center' ? [`${ baseClass }--center`] : [];\n      const endClass = spec.align === 'end' ? [`${ baseClass }--end`] : [];\n      const label = record({\n        dom: {\n          tag: 'label',\n          classes: [\n            baseClass,\n            ...centerClass,\n            ...endClass\n          ]\n        },\n        components: [text$2(backstageShared.providers.translate(spec.label))]\n      });\n      const comps = map$2(spec.items, backstageShared.interpreter);\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-form__group']\n        },\n        components: [\n          label.asSpec(),\n          ...comps\n        ],\n        behaviours: derive$1([\n          ComposingConfigs.self(),\n          Replacing.config({}),\n          domHtml(Optional.none()),\n          Keying.config({ mode: 'acyclic' }),\n          config('label', [runOnAttached(comp => {\n              spec.for.each(name => {\n                getCompByName(name).each(target => {\n                  label.getOpt(comp).each(labelComp => {\n                    var _a;\n                    const id = (_a = get$g(target.element, 'id')) !== null && _a !== void 0 ? _a : generate$6('form-field');\n                    set$9(target.element, 'id', id);\n                    set$9(labelComp.element, 'for', id);\n                  });\n                });\n              });\n            })])\n        ])\n      };\n    };\n\n    const internalToolbarButtonExecute = generate$6('toolbar.button.execute');\n    const onToolbarButtonExecute = info => runOnExecute$1((comp, _simulatedEvent) => {\n      runWithApi(info, comp)(itemApi => {\n        emitWith(comp, internalToolbarButtonExecute, { buttonApi: itemApi });\n        info.onAction(itemApi);\n      });\n    });\n    const commonButtonDisplayEvent = generate$6('common-button-display-events');\n    const toolbarButtonEventOrder = {\n      [execute$5()]: [\n        'disabling',\n        'alloy.base.behaviour',\n        'toggling',\n        'toolbar-button-events',\n        'tooltipping'\n      ],\n      [attachedToDom()]: [\n        'toolbar-button-events',\n        commonButtonDisplayEvent\n      ],\n      [detachedFromDom()]: [\n        'toolbar-button-events',\n        'dropdown-events',\n        'tooltipping'\n      ],\n      [mousedown()]: [\n        'focusing',\n        'alloy.base.behaviour',\n        commonButtonDisplayEvent\n      ]\n    };\n\n    const forceInitialSize = comp => set$8(comp.element, 'width', get$f(comp.element, 'width'));\n\n    const renderIcon$1 = (iconName, iconsProvider, behaviours) => render$3(iconName, {\n      tag: 'span',\n      classes: [\n        'tox-icon',\n        'tox-tbtn__icon-wrap'\n      ],\n      behaviours\n    }, iconsProvider);\n    const renderIconFromPack$1 = (iconName, iconsProvider) => renderIcon$1(iconName, iconsProvider, []);\n    const renderReplaceableIconFromPack = (iconName, iconsProvider) => renderIcon$1(iconName, iconsProvider, [Replacing.config({})]);\n    const renderLabel$1 = (text, prefix, providersBackstage) => ({\n      dom: {\n        tag: 'span',\n        classes: [`${ prefix }__select-label`]\n      },\n      components: [text$2(providersBackstage.translate(text))],\n      behaviours: derive$1([Replacing.config({})])\n    });\n\n    const updateMenuText = generate$6('update-menu-text');\n    const updateMenuIcon = generate$6('update-menu-icon');\n    const renderCommonDropdown = (spec, prefix, sharedBackstage, btnName) => {\n      const editorOffCell = Cell(noop);\n      const optMemDisplayText = spec.text.map(text => record(renderLabel$1(text, prefix, sharedBackstage.providers)));\n      const optMemDisplayIcon = spec.icon.map(iconName => record(renderReplaceableIconFromPack(iconName, sharedBackstage.providers.icons)));\n      const onLeftOrRightInMenu = (comp, se) => {\n        const dropdown = Representing.getValue(comp);\n        Focusing.focus(dropdown);\n        emitWith(dropdown, 'keydown', { raw: se.event.raw });\n        Dropdown.close(dropdown);\n        return Optional.some(true);\n      };\n      const role = spec.role.fold(() => ({}), role => ({ role }));\n      const listRole = Optional.from(spec.listRole).map(listRole => ({ listRole })).getOr({});\n      const ariaLabelAttribute = spec.ariaLabel.fold(() => ({}), ariaLabel => {\n        const translatedAriaLabel = sharedBackstage.providers.translate(ariaLabel);\n        return { 'aria-label': translatedAriaLabel };\n      });\n      const iconSpec = render$3('chevron-down', {\n        tag: 'div',\n        classes: [`${ prefix }__select-chevron`]\n      }, sharedBackstage.providers.icons);\n      const fixWidthBehaviourName = generate$6('common-button-display-events');\n      const customEventsName = 'dropdown-events';\n      const memDropdown = record(Dropdown.sketch({\n        ...spec.uid ? { uid: spec.uid } : {},\n        ...role,\n        ...listRole,\n        dom: {\n          tag: 'button',\n          classes: [\n            prefix,\n            `${ prefix }--select`\n          ].concat(map$2(spec.classes, c => `${ prefix }--${ c }`)),\n          attributes: {\n            ...ariaLabelAttribute,\n            ...isNonNullable(btnName) ? { 'data-mce-name': btnName } : {}\n          }\n        },\n        components: componentRenderPipeline([\n          optMemDisplayIcon.map(mem => mem.asSpec()),\n          optMemDisplayText.map(mem => mem.asSpec()),\n          Optional.some(iconSpec)\n        ]),\n        matchWidth: true,\n        useMinWidth: true,\n        onOpen: (anchor, dropdownComp, tmenuComp) => {\n          if (spec.searchable) {\n            focusSearchField(tmenuComp);\n          }\n        },\n        dropdownBehaviours: derive$1([\n          ...spec.dropdownBehaviours,\n          DisablingConfigs.button(() => spec.disabled || sharedBackstage.providers.isDisabled()),\n          receivingConfig(),\n          Unselecting.config({}),\n          Replacing.config({}),\n          ...spec.tooltip.map(t => Tooltipping.config(sharedBackstage.providers.tooltips.getConfig({ tooltipText: sharedBackstage.providers.translate(t) }))).toArray(),\n          config(customEventsName, [\n            onControlAttached(spec, editorOffCell),\n            onControlDetached(spec, editorOffCell)\n          ]),\n          config(fixWidthBehaviourName, [runOnAttached((comp, _se) => forceInitialSize(comp))]),\n          config('menubutton-update-display-text', [\n            run$1(updateMenuText, (comp, se) => {\n              optMemDisplayText.bind(mem => mem.getOpt(comp)).each(displayText => {\n                Replacing.set(displayText, [text$2(sharedBackstage.providers.translate(se.event.text))]);\n              });\n            }),\n            run$1(updateMenuIcon, (comp, se) => {\n              optMemDisplayIcon.bind(mem => mem.getOpt(comp)).each(displayIcon => {\n                Replacing.set(displayIcon, [renderReplaceableIconFromPack(se.event.icon, sharedBackstage.providers.icons)]);\n              });\n            })\n          ])\n        ]),\n        eventOrder: deepMerge(toolbarButtonEventOrder, {\n          [mousedown()]: [\n            'focusing',\n            'alloy.base.behaviour',\n            'item-type-events',\n            'normal-dropdown-events'\n          ],\n          [attachedToDom()]: [\n            'toolbar-button-events',\n            Tooltipping.name(),\n            customEventsName,\n            fixWidthBehaviourName\n          ]\n        }),\n        sandboxBehaviours: derive$1([\n          Keying.config({\n            mode: 'special',\n            onLeft: onLeftOrRightInMenu,\n            onRight: onLeftOrRightInMenu\n          }),\n          config('dropdown-sandbox-events', [\n            run$1(refetchTriggerEvent, (originalSandboxComp, se) => {\n              handleRefetchTrigger(originalSandboxComp);\n              se.stop();\n            }),\n            run$1(redirectMenuItemInteractionEvent, (sandboxComp, se) => {\n              handleRedirectToMenuItem(sandboxComp, se);\n              se.stop();\n            })\n          ])\n        ]),\n        lazySink: sharedBackstage.getSink,\n        toggleClass: `${ prefix }--active`,\n        parts: {\n          menu: {\n            ...part(false, spec.columns, spec.presets),\n            fakeFocus: spec.searchable,\n            ...spec.listRole === 'listbox' ? {} : {\n              onHighlightItem: updateAriaOnHighlight,\n              onCollapseMenu: (tmenuComp, itemCompCausingCollapse, nowActiveMenuComp) => {\n                Highlighting.getHighlighted(nowActiveMenuComp).each(itemComp => {\n                  updateAriaOnHighlight(tmenuComp, nowActiveMenuComp, itemComp);\n                });\n              },\n              onDehighlightItem: updateAriaOnDehighlight\n            }\n          }\n        },\n        getAnchorOverrides: () => {\n          return {\n            maxHeightFunction: (element, available) => {\n              anchored()(element, available - 10);\n            }\n          };\n        },\n        fetch: comp => Future.nu(curry(spec.fetch, comp))\n      }));\n      return memDropdown.asSpec();\n    };\n\n    const isMenuItemReference = item => isString(item);\n    const isSeparator$2 = item => item.type === 'separator';\n    const isExpandingMenuItem = item => has$2(item, 'getSubmenuItems');\n    const separator$2 = { type: 'separator' };\n    const unwrapReferences = (items, menuItems) => {\n      const realItems = foldl(items, (acc, item) => {\n        if (isMenuItemReference(item)) {\n          if (item === '') {\n            return acc;\n          } else if (item === '|') {\n            return acc.length > 0 && !isSeparator$2(acc[acc.length - 1]) ? acc.concat([separator$2]) : acc;\n          } else if (has$2(menuItems, item.toLowerCase())) {\n            return acc.concat([menuItems[item.toLowerCase()]]);\n          } else {\n            return acc;\n          }\n        } else {\n          return acc.concat([item]);\n        }\n      }, []);\n      if (realItems.length > 0 && isSeparator$2(realItems[realItems.length - 1])) {\n        realItems.pop();\n      }\n      return realItems;\n    };\n    const getFromExpandingItem = (item, menuItems) => {\n      const submenuItems = item.getSubmenuItems();\n      const rest = expand(submenuItems, menuItems);\n      const newMenus = deepMerge(rest.menus, { [item.value]: rest.items });\n      const newExpansions = deepMerge(rest.expansions, { [item.value]: item.value });\n      return {\n        item,\n        menus: newMenus,\n        expansions: newExpansions\n      };\n    };\n    const generateValueIfRequired = item => {\n      const itemValue = get$h(item, 'value').getOrThunk(() => generate$6('generated-menu-item'));\n      return deepMerge({ value: itemValue }, item);\n    };\n    const expand = (items, menuItems) => {\n      const realItems = unwrapReferences(isString(items) ? items.split(' ') : items, menuItems);\n      return foldr(realItems, (acc, item) => {\n        if (isExpandingMenuItem(item)) {\n          const itemWithValue = generateValueIfRequired(item);\n          const newData = getFromExpandingItem(itemWithValue, menuItems);\n          return {\n            menus: deepMerge(acc.menus, newData.menus),\n            items: [\n              newData.item,\n              ...acc.items\n            ],\n            expansions: deepMerge(acc.expansions, newData.expansions)\n          };\n        } else {\n          return {\n            ...acc,\n            items: [\n              item,\n              ...acc.items\n            ]\n          };\n        }\n      }, {\n        menus: {},\n        expansions: {},\n        items: []\n      });\n    };\n\n    const getSearchModeForField = settings => {\n      return settings.search.fold(() => ({ searchMode: 'no-search' }), searchSettings => ({\n        searchMode: 'search-with-field',\n        placeholder: searchSettings.placeholder\n      }));\n    };\n    const getSearchModeForResults = settings => {\n      return settings.search.fold(() => ({ searchMode: 'no-search' }), _ => ({ searchMode: 'search-with-results' }));\n    };\n    const build = (items, itemResponse, backstage, settings) => {\n      const primary = generate$6('primary-menu');\n      const data = expand(items, backstage.shared.providers.menuItems());\n      if (data.items.length === 0) {\n        return Optional.none();\n      }\n      const mainMenuSearchMode = getSearchModeForField(settings);\n      const mainMenu = createPartialMenu(primary, data.items, itemResponse, backstage, settings.isHorizontalMenu, mainMenuSearchMode);\n      const submenuSearchMode = getSearchModeForResults(settings);\n      const submenus = map$1(data.menus, (menuItems, menuName) => createPartialMenu(menuName, menuItems, itemResponse, backstage, false, submenuSearchMode));\n      const menus = deepMerge(submenus, wrap$1(primary, mainMenu));\n      return Optional.from(tieredMenu.tieredData(primary, menus, data.expansions));\n    };\n\n    const isSingleListItem = item => !has$2(item, 'items');\n    const dataAttribute = 'data-value';\n    const fetchItems = (dropdownComp, name, items, selectedValue, hasNestedItems) => map$2(items, item => {\n      if (!isSingleListItem(item)) {\n        return {\n          type: 'nestedmenuitem',\n          text: item.text,\n          getSubmenuItems: () => fetchItems(dropdownComp, name, item.items, selectedValue, hasNestedItems)\n        };\n      } else {\n        return {\n          type: 'togglemenuitem',\n          ...hasNestedItems ? {} : { role: 'option' },\n          text: item.text,\n          value: item.value,\n          active: item.value === selectedValue,\n          onAction: () => {\n            Representing.setValue(dropdownComp, item.value);\n            emitWith(dropdownComp, formChangeEvent, { name });\n            Focusing.focus(dropdownComp);\n          }\n        };\n      }\n    });\n    const findItemByValue = (items, value) => findMap(items, item => {\n      if (!isSingleListItem(item)) {\n        return findItemByValue(item.items, value);\n      } else {\n        return someIf(item.value === value, item);\n      }\n    });\n    const renderListBox = (spec, backstage, initialData) => {\n      const hasNestedItems = exists(spec.items, item => !isSingleListItem(item));\n      const providersBackstage = backstage.shared.providers;\n      const initialItem = initialData.bind(value => findItemByValue(spec.items, value)).orThunk(() => head(spec.items).filter(isSingleListItem));\n      const pLabel = spec.label.map(label => renderLabel$3(label, providersBackstage));\n      const pField = FormField.parts.field({\n        dom: {},\n        factory: {\n          sketch: sketchSpec => renderCommonDropdown({\n            uid: sketchSpec.uid,\n            text: initialItem.map(item => item.text),\n            icon: Optional.none(),\n            tooltip: Optional.none(),\n            role: someIf(!hasNestedItems, 'combobox'),\n            ...hasNestedItems ? {} : { listRole: 'listbox' },\n            ariaLabel: spec.label,\n            fetch: (comp, callback) => {\n              const items = fetchItems(comp, spec.name, spec.items, Representing.getValue(comp), hasNestedItems);\n              callback(build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {\n                isHorizontalMenu: false,\n                search: Optional.none()\n              }));\n            },\n            onSetup: constant$1(noop),\n            getApi: constant$1({}),\n            columns: 1,\n            presets: 'normal',\n            classes: [],\n            dropdownBehaviours: [\n              Tabstopping.config({}),\n              withComp(initialItem.map(item => item.value), comp => get$g(comp.element, dataAttribute), (comp, data) => {\n                findItemByValue(spec.items, data).each(item => {\n                  set$9(comp.element, dataAttribute, item.value);\n                  emitWith(comp, updateMenuText, { text: item.text });\n                });\n              })\n            ]\n          }, 'tox-listbox', backstage.shared)\n        }\n      });\n      const listBoxWrap = {\n        dom: {\n          tag: 'div',\n          classes: ['tox-listboxfield']\n        },\n        components: [pField]\n      };\n      return FormField.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-form__group']\n        },\n        components: flatten([\n          pLabel.toArray(),\n          [listBoxWrap]\n        ]),\n        fieldBehaviours: derive$1([Disabling.config({\n            disabled: constant$1(!spec.enabled),\n            onDisabled: comp => {\n              FormField.getField(comp).each(Disabling.disable);\n            },\n            onEnabled: comp => {\n              FormField.getField(comp).each(Disabling.enable);\n            }\n          })])\n      });\n    };\n\n    const renderPanel = (spec, backstage) => ({\n      dom: {\n        tag: 'div',\n        classes: spec.classes\n      },\n      components: map$2(spec.items, backstage.shared.interpreter)\n    });\n\n    const factory$h = (detail, _spec) => {\n      const options = map$2(detail.options, option => ({\n        dom: {\n          tag: 'option',\n          value: option.value,\n          innerHtml: option.text\n        }\n      }));\n      const initialValues = detail.data.map(v => wrap$1('initialValue', v)).getOr({});\n      return {\n        uid: detail.uid,\n        dom: {\n          tag: 'select',\n          classes: detail.selectClasses,\n          attributes: detail.selectAttributes\n        },\n        components: options,\n        behaviours: augment(detail.selectBehaviours, [\n          Focusing.config({}),\n          Representing.config({\n            store: {\n              mode: 'manual',\n              getValue: select => {\n                return get$7(select.element);\n              },\n              setValue: (select, newValue) => {\n                const firstOption = head(detail.options);\n                const found = find$5(detail.options, opt => opt.value === newValue);\n                if (found.isSome()) {\n                  set$5(select.element, newValue);\n                } else if (select.element.dom.selectedIndex === -1 && newValue === '') {\n                  firstOption.each(value => set$5(select.element, value.value));\n                }\n              },\n              ...initialValues\n            }\n          })\n        ])\n      };\n    };\n    const HtmlSelect = single({\n      name: 'HtmlSelect',\n      configFields: [\n        required$1('options'),\n        field('selectBehaviours', [\n          Focusing,\n          Representing\n        ]),\n        defaulted('selectClasses', []),\n        defaulted('selectAttributes', {}),\n        option$3('data')\n      ],\n      factory: factory$h\n    });\n\n    const renderSelectBox = (spec, providersBackstage, initialData) => {\n      const translatedOptions = map$2(spec.items, item => ({\n        text: providersBackstage.translate(item.text),\n        value: item.value\n      }));\n      const pLabel = spec.label.map(label => renderLabel$3(label, providersBackstage));\n      const pField = FormField.parts.field({\n        dom: {},\n        ...initialData.map(data => ({ data })).getOr({}),\n        selectAttributes: { size: spec.size },\n        options: translatedOptions,\n        factory: HtmlSelect,\n        selectBehaviours: derive$1([\n          Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() }),\n          Tabstopping.config({}),\n          config('selectbox-change', [run$1(change(), (component, _) => {\n              emitWith(component, formChangeEvent, { name: spec.name });\n            })])\n        ])\n      });\n      const chevron = spec.size > 1 ? Optional.none() : Optional.some(render$3('chevron-down', {\n        tag: 'div',\n        classes: ['tox-selectfield__icon-js']\n      }, providersBackstage.icons));\n      const selectWrap = {\n        dom: {\n          tag: 'div',\n          classes: ['tox-selectfield']\n        },\n        components: flatten([\n          [pField],\n          chevron.toArray()\n        ])\n      };\n      return FormField.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-form__group']\n        },\n        components: flatten([\n          pLabel.toArray(),\n          [selectWrap]\n        ]),\n        fieldBehaviours: derive$1([\n          Disabling.config({\n            disabled: () => !spec.enabled || providersBackstage.isDisabled(),\n            onDisabled: comp => {\n              FormField.getField(comp).each(Disabling.disable);\n            },\n            onEnabled: comp => {\n              FormField.getField(comp).each(Disabling.enable);\n            }\n          }),\n          receivingConfig()\n        ])\n      });\n    };\n\n    const schema$h = constant$1([\n      defaulted('field1Name', 'field1'),\n      defaulted('field2Name', 'field2'),\n      onStrictHandler('onLockedChange'),\n      markers$1(['lockClass']),\n      defaulted('locked', false),\n      SketchBehaviours.field('coupledFieldBehaviours', [\n        Composing,\n        Representing\n      ])\n    ]);\n    const getField = (comp, detail, partName) => getPart(comp, detail, partName).bind(Composing.getCurrent);\n    const coupledPart = (selfName, otherName) => required({\n      factory: FormField,\n      name: selfName,\n      overrides: detail => {\n        return {\n          fieldBehaviours: derive$1([config('coupled-input-behaviour', [run$1(input(), me => {\n                getField(me, detail, otherName).each(other => {\n                  getPart(me, detail, 'lock').each(lock => {\n                    if (Toggling.isOn(lock)) {\n                      detail.onLockedChange(me, other, lock);\n                    }\n                  });\n                });\n              })])])\n        };\n      }\n    });\n    const parts$c = constant$1([\n      coupledPart('field1', 'field2'),\n      coupledPart('field2', 'field1'),\n      required({\n        factory: Button,\n        schema: [required$1('dom')],\n        name: 'lock',\n        overrides: detail => {\n          return {\n            buttonBehaviours: derive$1([Toggling.config({\n                selected: detail.locked,\n                toggleClass: detail.markers.lockClass,\n                aria: { mode: 'pressed' }\n              })])\n          };\n        }\n      })\n    ]);\n\n    const factory$g = (detail, components, _spec, _externals) => ({\n      uid: detail.uid,\n      dom: detail.dom,\n      components,\n      behaviours: SketchBehaviours.augment(detail.coupledFieldBehaviours, [\n        Composing.config({ find: Optional.some }),\n        Representing.config({\n          store: {\n            mode: 'manual',\n            getValue: comp => {\n              const parts = getPartsOrDie(comp, detail, [\n                'field1',\n                'field2'\n              ]);\n              return {\n                [detail.field1Name]: Representing.getValue(parts.field1()),\n                [detail.field2Name]: Representing.getValue(parts.field2())\n              };\n            },\n            setValue: (comp, value) => {\n              const parts = getPartsOrDie(comp, detail, [\n                'field1',\n                'field2'\n              ]);\n              if (hasNonNullableKey(value, detail.field1Name)) {\n                Representing.setValue(parts.field1(), value[detail.field1Name]);\n              }\n              if (hasNonNullableKey(value, detail.field2Name)) {\n                Representing.setValue(parts.field2(), value[detail.field2Name]);\n              }\n            }\n          }\n        })\n      ]),\n      apis: {\n        getField1: component => getPart(component, detail, 'field1'),\n        getField2: component => getPart(component, detail, 'field2'),\n        getLock: component => getPart(component, detail, 'lock')\n      }\n    });\n    const FormCoupledInputs = composite({\n      name: 'FormCoupledInputs',\n      configFields: schema$h(),\n      partFields: parts$c(),\n      factory: factory$g,\n      apis: {\n        getField1: (apis, component) => apis.getField1(component),\n        getField2: (apis, component) => apis.getField2(component),\n        getLock: (apis, component) => apis.getLock(component)\n      }\n    });\n\n    const formatSize = size => {\n      const unitDec = {\n        '': 0,\n        'px': 0,\n        'pt': 1,\n        'mm': 1,\n        'pc': 2,\n        'ex': 2,\n        'em': 2,\n        'ch': 2,\n        'rem': 2,\n        'cm': 3,\n        'in': 4,\n        '%': 4\n      };\n      const maxDecimal = unit => unit in unitDec ? unitDec[unit] : 1;\n      let numText = size.value.toFixed(maxDecimal(size.unit));\n      if (numText.indexOf('.') !== -1) {\n        numText = numText.replace(/\\.?0*$/, '');\n      }\n      return numText + size.unit;\n    };\n    const parseSize = sizeText => {\n      const numPattern = /^\\s*(\\d+(?:\\.\\d+)?)\\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\\s*$/;\n      const match = numPattern.exec(sizeText);\n      if (match !== null) {\n        const value = parseFloat(match[1]);\n        const unit = match[2];\n        return Result.value({\n          value,\n          unit\n        });\n      } else {\n        return Result.error(sizeText);\n      }\n    };\n    const convertUnit = (size, unit) => {\n      const inInch = {\n        '': 96,\n        'px': 96,\n        'pt': 72,\n        'cm': 2.54,\n        'pc': 12,\n        'mm': 25.4,\n        'in': 1\n      };\n      const supported = u => has$2(inInch, u);\n      if (size.unit === unit) {\n        return Optional.some(size.value);\n      } else if (supported(size.unit) && supported(unit)) {\n        if (inInch[size.unit] === inInch[unit]) {\n          return Optional.some(size.value);\n        } else {\n          return Optional.some(size.value / inInch[size.unit] * inInch[unit]);\n        }\n      } else {\n        return Optional.none();\n      }\n    };\n    const noSizeConversion = _input => Optional.none();\n    const ratioSizeConversion = (scale, unit) => size => convertUnit(size, unit).map(value => ({\n      value: value * scale,\n      unit\n    }));\n    const makeRatioConverter = (currentFieldText, otherFieldText) => {\n      const cValue = parseSize(currentFieldText).toOptional();\n      const oValue = parseSize(otherFieldText).toOptional();\n      return lift2(cValue, oValue, (cSize, oSize) => convertUnit(cSize, oSize.unit).map(val => oSize.value / val).map(r => ratioSizeConversion(r, oSize.unit)).getOr(noSizeConversion)).getOr(noSizeConversion);\n    };\n\n    const renderSizeInput = (spec, providersBackstage) => {\n      let converter = noSizeConversion;\n      const ratioEvent = generate$6('ratio-event');\n      const makeIcon = iconName => render$3(iconName, {\n        tag: 'span',\n        classes: [\n          'tox-icon',\n          'tox-lock-icon__' + iconName\n        ]\n      }, providersBackstage.icons);\n      const label = spec.label.getOr('Constrain proportions');\n      const translatedLabel = providersBackstage.translate(label);\n      const pLock = FormCoupledInputs.parts.lock({\n        dom: {\n          tag: 'button',\n          classes: [\n            'tox-lock',\n            'tox-button',\n            'tox-button--naked',\n            'tox-button--icon'\n          ],\n          attributes: {\n            'aria-label': translatedLabel,\n            'data-mce-name': label\n          }\n        },\n        components: [\n          makeIcon('lock'),\n          makeIcon('unlock')\n        ],\n        buttonBehaviours: derive$1([\n          Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() }),\n          receivingConfig(),\n          Tabstopping.config({}),\n          Tooltipping.config(providersBackstage.tooltips.getConfig({ tooltipText: translatedLabel }))\n        ])\n      });\n      const formGroup = components => ({\n        dom: {\n          tag: 'div',\n          classes: ['tox-form__group']\n        },\n        components\n      });\n      const getFieldPart = isField1 => FormField.parts.field({\n        factory: Input,\n        inputClasses: ['tox-textfield'],\n        inputBehaviours: derive$1([\n          Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() }),\n          receivingConfig(),\n          Tabstopping.config({}),\n          config('size-input-events', [\n            run$1(focusin(), (component, _simulatedEvent) => {\n              emitWith(component, ratioEvent, { isField1 });\n            }),\n            run$1(change(), (component, _simulatedEvent) => {\n              emitWith(component, formChangeEvent, { name: spec.name });\n            })\n          ])\n        ]),\n        selectOnFocus: false\n      });\n      const getLabel = label => ({\n        dom: {\n          tag: 'label',\n          classes: ['tox-label']\n        },\n        components: [text$2(providersBackstage.translate(label))]\n      });\n      const widthField = FormCoupledInputs.parts.field1(formGroup([\n        FormField.parts.label(getLabel('Width')),\n        getFieldPart(true)\n      ]));\n      const heightField = FormCoupledInputs.parts.field2(formGroup([\n        FormField.parts.label(getLabel('Height')),\n        getFieldPart(false)\n      ]));\n      return FormCoupledInputs.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-form__group']\n        },\n        components: [{\n            dom: {\n              tag: 'div',\n              classes: ['tox-form__controls-h-stack']\n            },\n            components: [\n              widthField,\n              heightField,\n              formGroup([\n                getLabel(nbsp),\n                pLock\n              ])\n            ]\n          }],\n        field1Name: 'width',\n        field2Name: 'height',\n        locked: true,\n        markers: { lockClass: 'tox-locked' },\n        onLockedChange: (current, other, _lock) => {\n          parseSize(Representing.getValue(current)).each(size => {\n            converter(size).each(newSize => {\n              Representing.setValue(other, formatSize(newSize));\n            });\n          });\n        },\n        coupledFieldBehaviours: derive$1([\n          Disabling.config({\n            disabled: () => !spec.enabled || providersBackstage.isDisabled(),\n            onDisabled: comp => {\n              FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.disable);\n              FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.disable);\n              FormCoupledInputs.getLock(comp).each(Disabling.disable);\n            },\n            onEnabled: comp => {\n              FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.enable);\n              FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.enable);\n              FormCoupledInputs.getLock(comp).each(Disabling.enable);\n            }\n          }),\n          receivingConfig(),\n          config('size-input-events2', [run$1(ratioEvent, (component, simulatedEvent) => {\n              const isField1 = simulatedEvent.event.isField1;\n              const optCurrent = isField1 ? FormCoupledInputs.getField1(component) : FormCoupledInputs.getField2(component);\n              const optOther = isField1 ? FormCoupledInputs.getField2(component) : FormCoupledInputs.getField1(component);\n              const value1 = optCurrent.map(Representing.getValue).getOr('');\n              const value2 = optOther.map(Representing.getValue).getOr('');\n              converter = makeRatioConverter(value1, value2);\n            })])\n        ])\n      });\n    };\n\n    const renderSlider = (spec, providerBackstage, initialData) => {\n      const labelPart = Slider.parts.label({\n        dom: {\n          tag: 'label',\n          classes: ['tox-label']\n        },\n        components: [text$2(providerBackstage.translate(spec.label))]\n      });\n      const spectrum = Slider.parts.spectrum({\n        dom: {\n          tag: 'div',\n          classes: ['tox-slider__rail'],\n          attributes: { role: 'presentation' }\n        }\n      });\n      const thumb = Slider.parts.thumb({\n        dom: {\n          tag: 'div',\n          classes: ['tox-slider__handle'],\n          attributes: { role: 'presentation' }\n        }\n      });\n      return Slider.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-slider'],\n          attributes: { role: 'presentation' }\n        },\n        model: {\n          mode: 'x',\n          minX: spec.min,\n          maxX: spec.max,\n          getInitialValue: constant$1(initialData.getOrThunk(() => (Math.abs(spec.max) - Math.abs(spec.min)) / 2))\n        },\n        components: [\n          labelPart,\n          spectrum,\n          thumb\n        ],\n        sliderBehaviours: derive$1([\n          ComposingConfigs.self(),\n          Focusing.config({})\n        ]),\n        onChoose: (component, thumb, value) => {\n          emitWith(component, formChangeEvent, {\n            name: spec.name,\n            value\n          });\n        },\n        onChange: (component, thumb, value) => {\n          emitWith(component, formChangeEvent, {\n            name: spec.name,\n            value\n          });\n        }\n      });\n    };\n\n    const renderTable = (spec, providersBackstage) => {\n      const renderTh = text => ({\n        dom: {\n          tag: 'th',\n          innerHtml: providersBackstage.translate(text)\n        }\n      });\n      const renderHeader = header => ({\n        dom: { tag: 'thead' },\n        components: [{\n            dom: { tag: 'tr' },\n            components: map$2(header, renderTh)\n          }]\n      });\n      const renderTd = text => ({\n        dom: {\n          tag: 'td',\n          innerHtml: providersBackstage.translate(text)\n        }\n      });\n      const renderTr = row => ({\n        dom: { tag: 'tr' },\n        components: map$2(row, renderTd)\n      });\n      const renderRows = rows => ({\n        dom: { tag: 'tbody' },\n        components: map$2(rows, renderTr)\n      });\n      return {\n        dom: {\n          tag: 'table',\n          classes: ['tox-dialog__table']\n        },\n        components: [\n          renderHeader(spec.header),\n          renderRows(spec.cells)\n        ],\n        behaviours: derive$1([\n          Tabstopping.config({}),\n          Focusing.config({})\n        ])\n      };\n    };\n\n    const renderTextField = (spec, providersBackstage) => {\n      const pLabel = spec.label.map(label => renderLabel$3(label, providersBackstage));\n      const baseInputBehaviours = [\n        Disabling.config({ disabled: () => spec.disabled || providersBackstage.isDisabled() }),\n        receivingConfig(),\n        Keying.config({\n          mode: 'execution',\n          useEnter: spec.multiline !== true,\n          useControlEnter: spec.multiline === true,\n          execute: comp => {\n            emit(comp, formSubmitEvent);\n            return Optional.some(true);\n          }\n        }),\n        config('textfield-change', [\n          run$1(input(), (component, _) => {\n            emitWith(component, formChangeEvent, { name: spec.name });\n          }),\n          run$1(postPaste(), (component, _) => {\n            emitWith(component, formChangeEvent, { name: spec.name });\n          })\n        ]),\n        Tabstopping.config({})\n      ];\n      const validatingBehaviours = spec.validation.map(vl => Invalidating.config({\n        getRoot: input => {\n          return parentElement(input.element);\n        },\n        invalidClass: 'tox-invalid',\n        validator: {\n          validate: input => {\n            const v = Representing.getValue(input);\n            const result = vl.validator(v);\n            return Future.pure(result === true ? Result.value(v) : Result.error(result));\n          },\n          validateOnLoad: vl.validateOnLoad\n        }\n      })).toArray();\n      const placeholder = spec.placeholder.fold(constant$1({}), p => ({ placeholder: providersBackstage.translate(p) }));\n      const inputMode = spec.inputMode.fold(constant$1({}), mode => ({ inputmode: mode }));\n      const inputAttributes = {\n        ...placeholder,\n        ...inputMode\n      };\n      const pField = FormField.parts.field({\n        tag: spec.multiline === true ? 'textarea' : 'input',\n        ...spec.data.map(data => ({ data })).getOr({}),\n        inputAttributes,\n        inputClasses: [spec.classname],\n        inputBehaviours: derive$1(flatten([\n          baseInputBehaviours,\n          validatingBehaviours\n        ])),\n        selectOnFocus: false,\n        factory: Input\n      });\n      const pTextField = spec.multiline ? {\n        dom: {\n          tag: 'div',\n          classes: ['tox-textarea-wrap']\n        },\n        components: [pField]\n      } : pField;\n      const extraClasses = spec.flex ? ['tox-form__group--stretched'] : [];\n      const extraClasses2 = extraClasses.concat(spec.maximized ? ['tox-form-group--maximize'] : []);\n      const extraBehaviours = [\n        Disabling.config({\n          disabled: () => spec.disabled || providersBackstage.isDisabled(),\n          onDisabled: comp => {\n            FormField.getField(comp).each(Disabling.disable);\n          },\n          onEnabled: comp => {\n            FormField.getField(comp).each(Disabling.enable);\n          }\n        }),\n        receivingConfig()\n      ];\n      return renderFormFieldWith(pLabel, pTextField, extraClasses2, extraBehaviours);\n    };\n    const renderInput = (spec, providersBackstage, initialData) => renderTextField({\n      name: spec.name,\n      multiline: false,\n      label: spec.label,\n      inputMode: spec.inputMode,\n      placeholder: spec.placeholder,\n      flex: false,\n      disabled: !spec.enabled,\n      classname: 'tox-textfield',\n      validation: Optional.none(),\n      maximized: spec.maximized,\n      data: initialData\n    }, providersBackstage);\n    const renderTextarea = (spec, providersBackstage, initialData) => renderTextField({\n      name: spec.name,\n      multiline: true,\n      label: spec.label,\n      inputMode: Optional.none(),\n      placeholder: spec.placeholder,\n      flex: true,\n      disabled: !spec.enabled,\n      classname: 'tox-textarea',\n      validation: Optional.none(),\n      maximized: spec.maximized,\n      data: initialData\n    }, providersBackstage);\n\n    const getAnimationRoot = (component, slideConfig) => slideConfig.getAnimationRoot.fold(() => component.element, get => get(component));\n\n    const getDimensionProperty = slideConfig => slideConfig.dimension.property;\n    const getDimension = (slideConfig, elem) => slideConfig.dimension.getDimension(elem);\n    const disableTransitions = (component, slideConfig) => {\n      const root = getAnimationRoot(component, slideConfig);\n      remove$2(root, [\n        slideConfig.shrinkingClass,\n        slideConfig.growingClass\n      ]);\n    };\n    const setShrunk = (component, slideConfig) => {\n      remove$3(component.element, slideConfig.openClass);\n      add$2(component.element, slideConfig.closedClass);\n      set$8(component.element, getDimensionProperty(slideConfig), '0px');\n      reflow(component.element);\n    };\n    const setGrown = (component, slideConfig) => {\n      remove$3(component.element, slideConfig.closedClass);\n      add$2(component.element, slideConfig.openClass);\n      remove$7(component.element, getDimensionProperty(slideConfig));\n    };\n    const doImmediateShrink = (component, slideConfig, slideState, _calculatedSize) => {\n      slideState.setCollapsed();\n      set$8(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));\n      disableTransitions(component, slideConfig);\n      setShrunk(component, slideConfig);\n      slideConfig.onStartShrink(component);\n      slideConfig.onShrunk(component);\n    };\n    const doStartShrink = (component, slideConfig, slideState, calculatedSize) => {\n      const size = calculatedSize.getOrThunk(() => getDimension(slideConfig, component.element));\n      slideState.setCollapsed();\n      set$8(component.element, getDimensionProperty(slideConfig), size);\n      reflow(component.element);\n      const root = getAnimationRoot(component, slideConfig);\n      remove$3(root, slideConfig.growingClass);\n      add$2(root, slideConfig.shrinkingClass);\n      setShrunk(component, slideConfig);\n      slideConfig.onStartShrink(component);\n    };\n    const doStartSmartShrink = (component, slideConfig, slideState) => {\n      const size = getDimension(slideConfig, component.element);\n      const shrinker = size === '0px' ? doImmediateShrink : doStartShrink;\n      shrinker(component, slideConfig, slideState, Optional.some(size));\n    };\n    const doStartGrow = (component, slideConfig, slideState) => {\n      const root = getAnimationRoot(component, slideConfig);\n      const wasShrinking = has(root, slideConfig.shrinkingClass);\n      const beforeSize = getDimension(slideConfig, component.element);\n      setGrown(component, slideConfig);\n      const fullSize = getDimension(slideConfig, component.element);\n      const startPartialGrow = () => {\n        set$8(component.element, getDimensionProperty(slideConfig), beforeSize);\n        reflow(component.element);\n      };\n      const startCompleteGrow = () => {\n        setShrunk(component, slideConfig);\n      };\n      const setStartSize = wasShrinking ? startPartialGrow : startCompleteGrow;\n      setStartSize();\n      remove$3(root, slideConfig.shrinkingClass);\n      add$2(root, slideConfig.growingClass);\n      setGrown(component, slideConfig);\n      set$8(component.element, getDimensionProperty(slideConfig), fullSize);\n      slideState.setExpanded();\n      slideConfig.onStartGrow(component);\n    };\n    const refresh$3 = (component, slideConfig, slideState) => {\n      if (slideState.isExpanded()) {\n        remove$7(component.element, getDimensionProperty(slideConfig));\n        const fullSize = getDimension(slideConfig, component.element);\n        set$8(component.element, getDimensionProperty(slideConfig), fullSize);\n      }\n    };\n    const grow = (component, slideConfig, slideState) => {\n      if (!slideState.isExpanded()) {\n        doStartGrow(component, slideConfig, slideState);\n      }\n    };\n    const shrink = (component, slideConfig, slideState) => {\n      if (slideState.isExpanded()) {\n        doStartSmartShrink(component, slideConfig, slideState);\n      }\n    };\n    const immediateShrink = (component, slideConfig, slideState) => {\n      if (slideState.isExpanded()) {\n        doImmediateShrink(component, slideConfig, slideState);\n      }\n    };\n    const hasGrown = (component, slideConfig, slideState) => slideState.isExpanded();\n    const hasShrunk = (component, slideConfig, slideState) => slideState.isCollapsed();\n    const isGrowing = (component, slideConfig, _slideState) => {\n      const root = getAnimationRoot(component, slideConfig);\n      return has(root, slideConfig.growingClass) === true;\n    };\n    const isShrinking = (component, slideConfig, _slideState) => {\n      const root = getAnimationRoot(component, slideConfig);\n      return has(root, slideConfig.shrinkingClass) === true;\n    };\n    const isTransitioning = (component, slideConfig, slideState) => isGrowing(component, slideConfig) || isShrinking(component, slideConfig);\n    const toggleGrow = (component, slideConfig, slideState) => {\n      const f = slideState.isExpanded() ? doStartSmartShrink : doStartGrow;\n      f(component, slideConfig, slideState);\n    };\n    const immediateGrow = (component, slideConfig, slideState) => {\n      if (!slideState.isExpanded()) {\n        setGrown(component, slideConfig);\n        set$8(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));\n        disableTransitions(component, slideConfig);\n        slideState.setExpanded();\n        slideConfig.onStartGrow(component);\n        slideConfig.onGrown(component);\n      }\n    };\n\n    var SlidingApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        refresh: refresh$3,\n        grow: grow,\n        shrink: shrink,\n        immediateShrink: immediateShrink,\n        hasGrown: hasGrown,\n        hasShrunk: hasShrunk,\n        isGrowing: isGrowing,\n        isShrinking: isShrinking,\n        isTransitioning: isTransitioning,\n        toggleGrow: toggleGrow,\n        disableTransitions: disableTransitions,\n        immediateGrow: immediateGrow\n    });\n\n    const exhibit = (base, slideConfig, _slideState) => {\n      const expanded = slideConfig.expanded;\n      return expanded ? nu$8({\n        classes: [slideConfig.openClass],\n        styles: {}\n      }) : nu$8({\n        classes: [slideConfig.closedClass],\n        styles: wrap$1(slideConfig.dimension.property, '0px')\n      });\n    };\n    const events$5 = (slideConfig, slideState) => derive$2([runOnSource(transitionend(), (component, simulatedEvent) => {\n        const raw = simulatedEvent.event.raw;\n        if (raw.propertyName === slideConfig.dimension.property) {\n          disableTransitions(component, slideConfig);\n          if (slideState.isExpanded()) {\n            remove$7(component.element, slideConfig.dimension.property);\n          }\n          const notify = slideState.isExpanded() ? slideConfig.onGrown : slideConfig.onShrunk;\n          notify(component);\n        }\n      })]);\n\n    var ActiveSliding = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        exhibit: exhibit,\n        events: events$5\n    });\n\n    var SlidingSchema = [\n      required$1('closedClass'),\n      required$1('openClass'),\n      required$1('shrinkingClass'),\n      required$1('growingClass'),\n      option$3('getAnimationRoot'),\n      onHandler('onShrunk'),\n      onHandler('onStartShrink'),\n      onHandler('onGrown'),\n      onHandler('onStartGrow'),\n      defaulted('expanded', false),\n      requiredOf('dimension', choose$1('property', {\n        width: [\n          output$1('property', 'width'),\n          output$1('getDimension', elem => get$d(elem) + 'px')\n        ],\n        height: [\n          output$1('property', 'height'),\n          output$1('getDimension', elem => get$e(elem) + 'px')\n        ]\n      }))\n    ];\n\n    const init$8 = spec => {\n      const state = Cell(spec.expanded);\n      const readState = () => 'expanded: ' + state.get();\n      return nu$7({\n        isExpanded: () => state.get() === true,\n        isCollapsed: () => state.get() === false,\n        setCollapsed: curry(state.set, false),\n        setExpanded: curry(state.set, true),\n        readState\n      });\n    };\n\n    var SlidingState = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        init: init$8\n    });\n\n    const Sliding = create$4({\n      fields: SlidingSchema,\n      name: 'sliding',\n      active: ActiveSliding,\n      apis: SlidingApis,\n      state: SlidingState\n    });\n\n    const getMenuButtonApi = component => ({\n      isEnabled: () => !Disabling.isDisabled(component),\n      setEnabled: state => Disabling.set(component, !state),\n      setActive: state => {\n        const elm = component.element;\n        if (state) {\n          add$2(elm, 'tox-tbtn--enabled');\n          set$9(elm, 'aria-pressed', true);\n        } else {\n          remove$3(elm, 'tox-tbtn--enabled');\n          remove$8(elm, 'aria-pressed');\n        }\n      },\n      isActive: () => has(component.element, 'tox-tbtn--enabled'),\n      setText: text => {\n        emitWith(component, updateMenuText, { text });\n      },\n      setIcon: icon => emitWith(component, updateMenuIcon, { icon })\n    });\n    const renderMenuButton = (spec, prefix, backstage, role, tabstopping = true, btnName) => {\n      return renderCommonDropdown({\n        text: spec.text,\n        icon: spec.icon,\n        tooltip: spec.tooltip,\n        ariaLabel: spec.tooltip,\n        searchable: spec.search.isSome(),\n        role,\n        fetch: (dropdownComp, callback) => {\n          const fetchContext = { pattern: spec.search.isSome() ? getSearchPattern(dropdownComp) : '' };\n          spec.fetch(items => {\n            callback(build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {\n              isHorizontalMenu: false,\n              search: spec.search\n            }));\n          }, fetchContext, getMenuButtonApi(dropdownComp));\n        },\n        onSetup: spec.onSetup,\n        getApi: getMenuButtonApi,\n        columns: 1,\n        presets: 'normal',\n        classes: [],\n        dropdownBehaviours: [...tabstopping ? [Tabstopping.config({})] : []]\n      }, prefix, backstage.shared, btnName);\n    };\n    const getFetch = (items, getButton, backstage) => {\n      const getMenuItemAction = item => api => {\n        const newValue = !api.isActive();\n        api.setActive(newValue);\n        item.storage.set(newValue);\n        backstage.shared.getSink().each(sink => {\n          getButton().getOpt(sink).each(orig => {\n            focus$3(orig.element);\n            emitWith(orig, formActionEvent, {\n              name: item.name,\n              value: item.storage.get()\n            });\n          });\n        });\n      };\n      const getMenuItemSetup = item => api => {\n        api.setActive(item.storage.get());\n      };\n      return success => {\n        success(map$2(items, item => {\n          const text = item.text.fold(() => ({}), text => ({ text }));\n          return {\n            type: item.type,\n            active: false,\n            ...text,\n            onAction: getMenuItemAction(item),\n            onSetup: getMenuItemSetup(item)\n          };\n        }));\n      };\n    };\n\n    const renderLabel = text => ({\n      dom: {\n        tag: 'span',\n        classes: ['tox-tree__label'],\n        attributes: { 'aria-label': text }\n      },\n      components: [text$2(text)]\n    });\n    const leafLabelEventsId = generate$6('leaf-label-event-id');\n    const renderLeafLabel = ({leaf, onLeafAction, visible, treeId, selectedId, backstage}) => {\n      const internalMenuButton = leaf.menu.map(btn => renderMenuButton(btn, 'tox-mbtn', backstage, Optional.none(), visible));\n      const components = [renderLabel(leaf.title)];\n      internalMenuButton.each(btn => components.push(btn));\n      return Button.sketch({\n        dom: {\n          tag: 'div',\n          classes: [\n            'tox-tree--leaf__label',\n            'tox-trbtn'\n          ].concat(visible ? ['tox-tree--leaf__label--visible'] : [])\n        },\n        components,\n        role: 'treeitem',\n        action: button => {\n          onLeafAction(leaf.id);\n          button.getSystem().broadcastOn([`update-active-item-${ treeId }`], { value: leaf.id });\n        },\n        eventOrder: {\n          [keydown()]: [\n            leafLabelEventsId,\n            'keying'\n          ]\n        },\n        buttonBehaviours: derive$1([\n          ...visible ? [Tabstopping.config({})] : [],\n          Toggling.config({\n            toggleClass: 'tox-trbtn--enabled',\n            toggleOnExecute: false,\n            aria: { mode: 'selected' }\n          }),\n          Receiving.config({\n            channels: {\n              [`update-active-item-${ treeId }`]: {\n                onReceive: (comp, message) => {\n                  (message.value === leaf.id ? Toggling.on : Toggling.off)(comp);\n                }\n              }\n            }\n          }),\n          config(leafLabelEventsId, [\n            runOnAttached((comp, _se) => {\n              selectedId.each(id => {\n                const toggle = id === leaf.id ? Toggling.on : Toggling.off;\n                toggle(comp);\n              });\n            }),\n            run$1(keydown(), (comp, se) => {\n              const isLeftArrowKey = se.event.raw.code === 'ArrowLeft';\n              const isRightArrowKey = se.event.raw.code === 'ArrowRight';\n              if (isLeftArrowKey) {\n                ancestor(comp.element, '.tox-tree--directory').each(dirElement => {\n                  comp.getSystem().getByDom(dirElement).each(dirComp => {\n                    child(dirElement, '.tox-tree--directory__label').each(dirLabelElement => {\n                      dirComp.getSystem().getByDom(dirLabelElement).each(Focusing.focus);\n                    });\n                  });\n                });\n                se.stop();\n              } else if (isRightArrowKey) {\n                se.stop();\n              }\n            })\n          ])\n        ])\n      });\n    };\n    const renderIcon = (iconName, iconsProvider, behaviours) => render$3(iconName, {\n      tag: 'span',\n      classes: [\n        'tox-tree__icon-wrap',\n        'tox-icon'\n      ],\n      behaviours\n    }, iconsProvider);\n    const renderIconFromPack = (iconName, iconsProvider) => renderIcon(iconName, iconsProvider, []);\n    const directoryLabelEventsId = generate$6('directory-label-event-id');\n    const renderDirectoryLabel = ({directory, visible, noChildren, backstage}) => {\n      const internalMenuButton = directory.menu.map(btn => renderMenuButton(btn, 'tox-mbtn', backstage, Optional.none()));\n      const components = [\n        {\n          dom: {\n            tag: 'div',\n            classes: ['tox-chevron']\n          },\n          components: [renderIconFromPack('chevron-right', backstage.shared.providers.icons)]\n        },\n        renderLabel(directory.title)\n      ];\n      internalMenuButton.each(btn => {\n        components.push(btn);\n      });\n      const toggleExpandChildren = button => {\n        ancestor(button.element, '.tox-tree--directory').each(directoryEle => {\n          button.getSystem().getByDom(directoryEle).each(directoryComp => {\n            const willExpand = !Toggling.isOn(directoryComp);\n            Toggling.toggle(directoryComp);\n            emitWith(button, 'expand-tree-node', {\n              expanded: willExpand,\n              node: directory.id\n            });\n          });\n        });\n      };\n      return Button.sketch({\n        dom: {\n          tag: 'div',\n          classes: [\n            'tox-tree--directory__label',\n            'tox-trbtn'\n          ].concat(visible ? ['tox-tree--directory__label--visible'] : [])\n        },\n        components,\n        action: toggleExpandChildren,\n        eventOrder: {\n          [keydown()]: [\n            directoryLabelEventsId,\n            'keying'\n          ]\n        },\n        buttonBehaviours: derive$1([\n          ...visible ? [Tabstopping.config({})] : [],\n          config(directoryLabelEventsId, [run$1(keydown(), (comp, se) => {\n              const isRightArrowKey = se.event.raw.code === 'ArrowRight';\n              const isLeftArrowKey = se.event.raw.code === 'ArrowLeft';\n              if (isRightArrowKey && noChildren) {\n                se.stop();\n              }\n              if (isRightArrowKey || isLeftArrowKey) {\n                ancestor(comp.element, '.tox-tree--directory').each(directoryEle => {\n                  comp.getSystem().getByDom(directoryEle).each(directoryComp => {\n                    if (!Toggling.isOn(directoryComp) && isRightArrowKey || Toggling.isOn(directoryComp) && isLeftArrowKey) {\n                      toggleExpandChildren(comp);\n                      se.stop();\n                    } else if (isLeftArrowKey && !Toggling.isOn(directoryComp)) {\n                      ancestor(directoryComp.element, '.tox-tree--directory').each(parentDirElement => {\n                        child(parentDirElement, '.tox-tree--directory__label').each(parentDirLabelElement => {\n                          directoryComp.getSystem().getByDom(parentDirLabelElement).each(Focusing.focus);\n                        });\n                      });\n                      se.stop();\n                    }\n                  });\n                });\n              }\n            })])\n        ])\n      });\n    };\n    const renderDirectoryChildren = ({children, onLeafAction, visible, treeId, expandedIds, selectedId, backstage}) => {\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-tree--directory__children']\n        },\n        components: children.map(item => {\n          return item.type === 'leaf' ? renderLeafLabel({\n            leaf: item,\n            selectedId,\n            onLeafAction,\n            visible,\n            treeId,\n            backstage\n          }) : renderDirectory({\n            directory: item,\n            expandedIds,\n            selectedId,\n            onLeafAction,\n            labelTabstopping: visible,\n            treeId,\n            backstage\n          });\n        }),\n        behaviours: derive$1([\n          Sliding.config({\n            dimension: { property: 'height' },\n            closedClass: 'tox-tree--directory__children--closed',\n            openClass: 'tox-tree--directory__children--open',\n            growingClass: 'tox-tree--directory__children--growing',\n            shrinkingClass: 'tox-tree--directory__children--shrinking',\n            expanded: visible\n          }),\n          Replacing.config({})\n        ])\n      };\n    };\n    const directoryEventsId = generate$6('directory-event-id');\n    const renderDirectory = ({directory, onLeafAction, labelTabstopping, treeId, backstage, expandedIds, selectedId}) => {\n      const {children} = directory;\n      const expandedIdsCell = Cell(expandedIds);\n      const computedChildrenComponents = visible => children.map(item => {\n        return item.type === 'leaf' ? renderLeafLabel({\n          leaf: item,\n          selectedId,\n          onLeafAction,\n          visible,\n          treeId,\n          backstage\n        }) : renderDirectory({\n          directory: item,\n          expandedIds: expandedIdsCell.get(),\n          selectedId,\n          onLeafAction,\n          labelTabstopping: visible,\n          treeId,\n          backstage\n        });\n      });\n      const childrenVisible = expandedIds.includes(directory.id);\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-tree--directory'],\n          attributes: { role: 'treeitem' }\n        },\n        components: [\n          renderDirectoryLabel({\n            directory,\n            visible: labelTabstopping,\n            noChildren: directory.children.length === 0,\n            backstage\n          }),\n          renderDirectoryChildren({\n            children,\n            expandedIds,\n            selectedId,\n            onLeafAction,\n            visible: childrenVisible,\n            treeId,\n            backstage\n          })\n        ],\n        behaviours: derive$1([\n          config(directoryEventsId, [\n            runOnAttached((comp, _se) => {\n              Toggling.set(comp, childrenVisible);\n            }),\n            run$1('expand-tree-node', (_cmp, se) => {\n              const {expanded, node} = se.event;\n              expandedIdsCell.set(expanded ? [\n                ...expandedIdsCell.get(),\n                node\n              ] : expandedIdsCell.get().filter(id => id !== node));\n            })\n          ]),\n          Toggling.config({\n            ...directory.children.length > 0 ? { aria: { mode: 'expanded' } } : {},\n            toggleClass: 'tox-tree--directory--expanded',\n            onToggled: (comp, childrenVisible) => {\n              const childrenComp = comp.components()[1];\n              const newChildren = computedChildrenComponents(childrenVisible);\n              if (childrenVisible) {\n                Sliding.grow(childrenComp);\n              } else {\n                Sliding.shrink(childrenComp);\n              }\n              Replacing.set(childrenComp, newChildren);\n            }\n          })\n        ])\n      };\n    };\n    const treeEventsId = generate$6('tree-event-id');\n    const renderTree = (spec, backstage) => {\n      const onLeafAction = spec.onLeafAction.getOr(noop);\n      const onToggleExpand = spec.onToggleExpand.getOr(noop);\n      const defaultExpandedIds = spec.defaultExpandedIds;\n      const expandedIds = Cell(defaultExpandedIds);\n      const selectedIdCell = Cell(spec.defaultSelectedId);\n      const treeId = generate$6('tree-id');\n      const children = (selectedId, expandedIds) => spec.items.map(item => {\n        return item.type === 'leaf' ? renderLeafLabel({\n          leaf: item,\n          selectedId,\n          onLeafAction,\n          visible: true,\n          treeId,\n          backstage\n        }) : renderDirectory({\n          directory: item,\n          selectedId,\n          onLeafAction,\n          expandedIds,\n          labelTabstopping: true,\n          treeId,\n          backstage\n        });\n      });\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-tree'],\n          attributes: { role: 'tree' }\n        },\n        components: children(selectedIdCell.get(), expandedIds.get()),\n        behaviours: derive$1([\n          Keying.config({\n            mode: 'flow',\n            selector: '.tox-tree--leaf__label--visible, .tox-tree--directory__label--visible',\n            cycles: false\n          }),\n          config(treeEventsId, [run$1('expand-tree-node', (_cmp, se) => {\n              const {expanded, node} = se.event;\n              expandedIds.set(expanded ? [\n                ...expandedIds.get(),\n                node\n              ] : expandedIds.get().filter(id => id !== node));\n              onToggleExpand(expandedIds.get(), {\n                expanded,\n                node\n              });\n            })]),\n          Receiving.config({\n            channels: {\n              [`update-active-item-${ treeId }`]: {\n                onReceive: (comp, message) => {\n                  selectedIdCell.set(Optional.some(message.value));\n                  Replacing.set(comp, children(Optional.some(message.value), expandedIds.get()));\n                }\n              }\n            }\n          }),\n          Replacing.config({})\n        ])\n      };\n    };\n\n    const events$4 = (streamConfig, streamState) => {\n      const streams = streamConfig.stream.streams;\n      const processor = streams.setup(streamConfig, streamState);\n      return derive$2([\n        run$1(streamConfig.event, processor),\n        runOnDetached(() => streamState.cancel())\n      ].concat(streamConfig.cancelEvent.map(e => [run$1(e, () => streamState.cancel())]).getOr([])));\n    };\n\n    var ActiveStreaming = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        events: events$4\n    });\n\n    const throttle = _config => {\n      const state = Cell(null);\n      const readState = () => ({ timer: state.get() !== null ? 'set' : 'unset' });\n      const setTimer = t => {\n        state.set(t);\n      };\n      const cancel = () => {\n        const t = state.get();\n        if (t !== null) {\n          t.cancel();\n        }\n      };\n      return nu$7({\n        readState,\n        setTimer,\n        cancel\n      });\n    };\n    const init$7 = spec => spec.stream.streams.state(spec);\n\n    var StreamingState = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        throttle: throttle,\n        init: init$7\n    });\n\n    const setup$c = (streamInfo, streamState) => {\n      const sInfo = streamInfo.stream;\n      const throttler = last(streamInfo.onStream, sInfo.delay);\n      streamState.setTimer(throttler);\n      return (component, simulatedEvent) => {\n        throttler.throttle(component, simulatedEvent);\n        if (sInfo.stopEvent) {\n          simulatedEvent.stop();\n        }\n      };\n    };\n    var StreamingSchema = [\n      requiredOf('stream', choose$1('mode', {\n        throttle: [\n          required$1('delay'),\n          defaulted('stopEvent', true),\n          output$1('streams', {\n            setup: setup$c,\n            state: throttle\n          })\n        ]\n      })),\n      defaulted('event', 'input'),\n      option$3('cancelEvent'),\n      onStrictHandler('onStream')\n    ];\n\n    const Streaming = create$4({\n      fields: StreamingSchema,\n      name: 'streaming',\n      active: ActiveStreaming,\n      state: StreamingState\n    });\n\n    const setValueFromItem = (model, input, item) => {\n      const itemData = Representing.getValue(item);\n      Representing.setValue(input, itemData);\n      setCursorAtEnd(input);\n    };\n    const setSelectionOn = (input, f) => {\n      const el = input.element;\n      const value = get$7(el);\n      const node = el.dom;\n      if (get$g(el, 'type') !== 'number') {\n        f(node, value);\n      }\n    };\n    const setCursorAtEnd = input => {\n      setSelectionOn(input, (node, value) => node.setSelectionRange(value.length, value.length));\n    };\n    const setSelectionToEnd = (input, startOffset) => {\n      setSelectionOn(input, (node, value) => node.setSelectionRange(startOffset, value.length));\n    };\n    const attemptSelectOver = (model, input, item) => {\n      if (!model.selectsOver) {\n        return Optional.none();\n      } else {\n        const currentValue = Representing.getValue(input);\n        const inputDisplay = model.getDisplayText(currentValue);\n        const itemValue = Representing.getValue(item);\n        const itemDisplay = model.getDisplayText(itemValue);\n        return itemDisplay.indexOf(inputDisplay) === 0 ? Optional.some(() => {\n          setValueFromItem(model, input, item);\n          setSelectionToEnd(input, inputDisplay.length);\n        }) : Optional.none();\n      }\n    };\n\n    const itemExecute = constant$1('alloy.typeahead.itemexecute');\n\n    const make$3 = (detail, components, spec, externals) => {\n      const navigateList = (comp, simulatedEvent, highlighter) => {\n        detail.previewing.set(false);\n        const sandbox = Coupling.getCoupled(comp, 'sandbox');\n        if (Sandboxing.isOpen(sandbox)) {\n          Composing.getCurrent(sandbox).each(menu => {\n            Highlighting.getHighlighted(menu).fold(() => {\n              highlighter(menu);\n            }, () => {\n              dispatchEvent(sandbox, menu.element, 'keydown', simulatedEvent);\n            });\n          });\n        } else {\n          const onOpenSync = sandbox => {\n            Composing.getCurrent(sandbox).each(highlighter);\n          };\n          open(detail, mapFetch(comp), comp, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop);\n        }\n      };\n      const focusBehaviours$1 = focusBehaviours(detail);\n      const mapFetch = comp => tdata => tdata.map(data => {\n        const menus = values(data.menus);\n        const items = bind$3(menus, menu => filter$2(menu.items, item => item.type === 'item'));\n        const repState = Representing.getState(comp);\n        repState.update(map$2(items, item => item.data));\n        return data;\n      });\n      const getActiveMenu = sandboxComp => Composing.getCurrent(sandboxComp);\n      const typeaheadCustomEvents = 'typeaheadevents';\n      const behaviours = [\n        Focusing.config({}),\n        Representing.config({\n          onSetValue: detail.onSetValue,\n          store: {\n            mode: 'dataset',\n            getDataKey: comp => get$7(comp.element),\n            getFallbackEntry: itemString => ({\n              value: itemString,\n              meta: {}\n            }),\n            setValue: (comp, data) => {\n              set$5(comp.element, detail.model.getDisplayText(data));\n            },\n            ...detail.initialData.map(d => wrap$1('initialValue', d)).getOr({})\n          }\n        }),\n        Streaming.config({\n          stream: {\n            mode: 'throttle',\n            delay: detail.responseTime,\n            stopEvent: false\n          },\n          onStream: (component, _simulatedEvent) => {\n            const sandbox = Coupling.getCoupled(component, 'sandbox');\n            const focusInInput = Focusing.isFocused(component);\n            if (focusInInput) {\n              if (get$7(component.element).length >= detail.minChars) {\n                const previousValue = getActiveMenu(sandbox).bind(activeMenu => Highlighting.getHighlighted(activeMenu).map(Representing.getValue));\n                detail.previewing.set(true);\n                const onOpenSync = _sandbox => {\n                  getActiveMenu(sandbox).each(activeMenu => {\n                    previousValue.fold(() => {\n                      if (detail.model.selectsOver) {\n                        Highlighting.highlightFirst(activeMenu);\n                      }\n                    }, pv => {\n                      Highlighting.highlightBy(activeMenu, item => {\n                        const itemData = Representing.getValue(item);\n                        return itemData.value === pv.value;\n                      });\n                      Highlighting.getHighlighted(activeMenu).orThunk(() => {\n                        Highlighting.highlightFirst(activeMenu);\n                        return Optional.none();\n                      });\n                    });\n                  });\n                };\n                open(detail, mapFetch(component), component, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightJustMenu).get(noop);\n              }\n            }\n          },\n          cancelEvent: typeaheadCancel()\n        }),\n        Keying.config({\n          mode: 'special',\n          onDown: (comp, simulatedEvent) => {\n            navigateList(comp, simulatedEvent, Highlighting.highlightFirst);\n            return Optional.some(true);\n          },\n          onEscape: comp => {\n            const sandbox = Coupling.getCoupled(comp, 'sandbox');\n            if (Sandboxing.isOpen(sandbox)) {\n              Sandboxing.close(sandbox);\n              return Optional.some(true);\n            }\n            return Optional.none();\n          },\n          onUp: (comp, simulatedEvent) => {\n            navigateList(comp, simulatedEvent, Highlighting.highlightLast);\n            return Optional.some(true);\n          },\n          onEnter: comp => {\n            const sandbox = Coupling.getCoupled(comp, 'sandbox');\n            const sandboxIsOpen = Sandboxing.isOpen(sandbox);\n            if (sandboxIsOpen && !detail.previewing.get()) {\n              return getActiveMenu(sandbox).bind(activeMenu => Highlighting.getHighlighted(activeMenu)).map(item => {\n                emitWith(comp, itemExecute(), { item });\n                return true;\n              });\n            } else {\n              const currentValue = Representing.getValue(comp);\n              emit(comp, typeaheadCancel());\n              detail.onExecute(sandbox, comp, currentValue);\n              if (sandboxIsOpen) {\n                Sandboxing.close(sandbox);\n              }\n              return Optional.some(true);\n            }\n          }\n        }),\n        Toggling.config({\n          toggleClass: detail.markers.openClass,\n          aria: { mode: 'expanded' }\n        }),\n        Coupling.config({\n          others: {\n            sandbox: hotspot => {\n              return makeSandbox$1(detail, hotspot, {\n                onOpen: () => Toggling.on(hotspot),\n                onClose: () => {\n                  detail.lazyTypeaheadComp.get().each(input => remove$8(input.element, 'aria-activedescendant'));\n                  Toggling.off(hotspot);\n                }\n              });\n            }\n          }\n        }),\n        config(typeaheadCustomEvents, [\n          runOnAttached(typeaheadComp => {\n            detail.lazyTypeaheadComp.set(Optional.some(typeaheadComp));\n          }),\n          runOnDetached(_typeaheadComp => {\n            detail.lazyTypeaheadComp.set(Optional.none());\n          }),\n          runOnExecute$1(comp => {\n            const onOpenSync = noop;\n            togglePopup(detail, mapFetch(comp), comp, externals, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop);\n          }),\n          run$1(itemExecute(), (comp, se) => {\n            const sandbox = Coupling.getCoupled(comp, 'sandbox');\n            setValueFromItem(detail.model, comp, se.event.item);\n            emit(comp, typeaheadCancel());\n            detail.onItemExecute(comp, sandbox, se.event.item, Representing.getValue(comp));\n            Sandboxing.close(sandbox);\n            setCursorAtEnd(comp);\n          })\n        ].concat(detail.dismissOnBlur ? [run$1(postBlur(), typeahead => {\n            const sandbox = Coupling.getCoupled(typeahead, 'sandbox');\n            if (search(sandbox.element).isNone()) {\n              Sandboxing.close(sandbox);\n            }\n          })] : []))\n      ];\n      const eventOrder = {\n        [detachedFromDom()]: [\n          Representing.name(),\n          Streaming.name(),\n          typeaheadCustomEvents\n        ],\n        ...detail.eventOrder\n      };\n      return {\n        uid: detail.uid,\n        dom: dom(deepMerge(detail, {\n          inputAttributes: {\n            'role': 'combobox',\n            'aria-autocomplete': 'list',\n            'aria-haspopup': 'true'\n          }\n        })),\n        behaviours: {\n          ...focusBehaviours$1,\n          ...augment(detail.typeaheadBehaviours, behaviours)\n        },\n        eventOrder\n      };\n    };\n\n    const schema$g = constant$1([\n      option$3('lazySink'),\n      required$1('fetch'),\n      defaulted('minChars', 5),\n      defaulted('responseTime', 1000),\n      onHandler('onOpen'),\n      defaulted('getHotspot', Optional.some),\n      defaulted('getAnchorOverrides', constant$1({})),\n      defaulted('layouts', Optional.none()),\n      defaulted('eventOrder', {}),\n      defaultedObjOf('model', {}, [\n        defaulted('getDisplayText', itemData => itemData.meta !== undefined && itemData.meta.text !== undefined ? itemData.meta.text : itemData.value),\n        defaulted('selectsOver', true),\n        defaulted('populateFromBrowse', true)\n      ]),\n      onHandler('onSetValue'),\n      onKeyboardHandler('onExecute'),\n      onHandler('onItemExecute'),\n      defaulted('inputClasses', []),\n      defaulted('inputAttributes', {}),\n      defaulted('inputStyles', {}),\n      defaulted('matchWidth', true),\n      defaulted('useMinWidth', false),\n      defaulted('dismissOnBlur', true),\n      markers$1(['openClass']),\n      option$3('initialData'),\n      option$3('listRole'),\n      field('typeaheadBehaviours', [\n        Focusing,\n        Representing,\n        Streaming,\n        Keying,\n        Toggling,\n        Coupling\n      ]),\n      customField('lazyTypeaheadComp', () => Cell(Optional.none)),\n      customField('previewing', () => Cell(true))\n    ].concat(schema$l()).concat(sandboxFields()));\n    const parts$b = constant$1([external({\n        schema: [tieredMenuMarkers()],\n        name: 'menu',\n        overrides: detail => {\n          return {\n            fakeFocus: true,\n            onHighlightItem: (_tmenu, menu, item) => {\n              if (!detail.previewing.get()) {\n                detail.lazyTypeaheadComp.get().each(input => {\n                  if (detail.model.populateFromBrowse) {\n                    setValueFromItem(detail.model, input, item);\n                  }\n                  getOpt(item.element, 'id').each(id => set$9(input.element, 'aria-activedescendant', id));\n                });\n              } else {\n                detail.lazyTypeaheadComp.get().each(input => {\n                  attemptSelectOver(detail.model, input, item).fold(() => {\n                    if (detail.model.selectsOver) {\n                      Highlighting.dehighlight(menu, item);\n                      detail.previewing.set(true);\n                    } else {\n                      detail.previewing.set(false);\n                    }\n                  }, selectOverTextInInput => {\n                    selectOverTextInInput();\n                    detail.previewing.set(false);\n                  });\n                });\n              }\n            },\n            onExecute: (_menu, item) => {\n              return detail.lazyTypeaheadComp.get().map(typeahead => {\n                emitWith(typeahead, itemExecute(), { item });\n                return true;\n              });\n            },\n            onHover: (menu, item) => {\n              detail.previewing.set(false);\n              detail.lazyTypeaheadComp.get().each(input => {\n                if (detail.model.populateFromBrowse) {\n                  setValueFromItem(detail.model, input, item);\n                }\n              });\n            }\n          };\n        }\n      })]);\n\n    const Typeahead = composite({\n      name: 'Typeahead',\n      configFields: schema$g(),\n      partFields: parts$b(),\n      factory: make$3\n    });\n\n    const wrap = delegate => {\n      const toCached = () => {\n        return wrap(delegate.toCached());\n      };\n      const bindFuture = f => {\n        return wrap(delegate.bind(resA => resA.fold(err => Future.pure(Result.error(err)), a => f(a))));\n      };\n      const bindResult = f => {\n        return wrap(delegate.map(resA => resA.bind(f)));\n      };\n      const mapResult = f => {\n        return wrap(delegate.map(resA => resA.map(f)));\n      };\n      const mapError = f => {\n        return wrap(delegate.map(resA => resA.mapError(f)));\n      };\n      const foldResult = (whenError, whenValue) => {\n        return delegate.map(res => res.fold(whenError, whenValue));\n      };\n      const withTimeout = (timeout, errorThunk) => {\n        return wrap(Future.nu(callback => {\n          let timedOut = false;\n          const timer = setTimeout(() => {\n            timedOut = true;\n            callback(Result.error(errorThunk()));\n          }, timeout);\n          delegate.get(result => {\n            if (!timedOut) {\n              clearTimeout(timer);\n              callback(result);\n            }\n          });\n        }));\n      };\n      return {\n        ...delegate,\n        toCached,\n        bindFuture,\n        bindResult,\n        mapResult,\n        mapError,\n        foldResult,\n        withTimeout\n      };\n    };\n    const nu$1 = worker => {\n      return wrap(Future.nu(worker));\n    };\n    const value = value => {\n      return wrap(Future.pure(Result.value(value)));\n    };\n    const error = error => {\n      return wrap(Future.pure(Result.error(error)));\n    };\n    const fromResult = result => {\n      return wrap(Future.pure(result));\n    };\n    const fromFuture = future => {\n      return wrap(future.map(Result.value));\n    };\n    const fromPromise = promise => {\n      return nu$1(completer => {\n        promise.then(value => {\n          completer(Result.value(value));\n        }, error => {\n          completer(Result.error(error));\n        });\n      });\n    };\n    const FutureResult = {\n      nu: nu$1,\n      wrap,\n      pure: value,\n      value,\n      error,\n      fromResult,\n      fromFuture,\n      fromPromise\n    };\n\n    const renderCommonSpec = (spec, actionOpt, extraBehaviours = [], dom, components, tooltip, providersBackstage) => {\n      const action = actionOpt.fold(() => ({}), action => ({ action }));\n      const common = {\n        buttonBehaviours: derive$1([\n          DisablingConfigs.button(() => !spec.enabled || providersBackstage.isDisabled()),\n          receivingConfig(),\n          Tabstopping.config({}),\n          ...tooltip.map(t => Tooltipping.config(providersBackstage.tooltips.getConfig({ tooltipText: providersBackstage.translate(t) }))).toArray(),\n          config('button press', [\n            preventDefault('click'),\n            preventDefault('mousedown')\n          ])\n        ].concat(extraBehaviours)),\n        eventOrder: {\n          click: [\n            'button press',\n            'alloy.base.behaviour'\n          ],\n          mousedown: [\n            'button press',\n            'alloy.base.behaviour'\n          ]\n        },\n        ...action\n      };\n      const domFinal = deepMerge(common, { dom });\n      return deepMerge(domFinal, { components });\n    };\n    const renderIconButtonSpec = (spec, action, providersBackstage, extraBehaviours = [], btnName) => {\n      const tooltipAttributes = spec.tooltip.map(tooltip => ({ 'aria-label': providersBackstage.translate(tooltip) })).getOr({});\n      const dom = {\n        tag: 'button',\n        classes: ['tox-tbtn'],\n        attributes: {\n          ...tooltipAttributes,\n          'data-mce-name': btnName\n        }\n      };\n      const icon = spec.icon.map(iconName => renderIconFromPack$1(iconName, providersBackstage.icons));\n      const components = componentRenderPipeline([icon]);\n      return renderCommonSpec(spec, action, extraBehaviours, dom, components, spec.tooltip, providersBackstage);\n    };\n    const calculateClassesFromButtonType = buttonType => {\n      switch (buttonType) {\n      case 'primary':\n        return ['tox-button'];\n      case 'toolbar':\n        return ['tox-tbtn'];\n      case 'secondary':\n      default:\n        return [\n          'tox-button',\n          'tox-button--secondary'\n        ];\n      }\n    };\n    const renderButtonSpec = (spec, action, providersBackstage, extraBehaviours = [], extraClasses = []) => {\n      const translatedText = providersBackstage.translate(spec.text);\n      const icon = spec.icon.map(iconName => renderIconFromPack$1(iconName, providersBackstage.icons));\n      const components = [icon.getOrThunk(() => text$2(translatedText))];\n      const buttonType = spec.buttonType.getOr(!spec.primary && !spec.borderless ? 'secondary' : 'primary');\n      const baseClasses = calculateClassesFromButtonType(buttonType);\n      const classes = [\n        ...baseClasses,\n        ...icon.isSome() ? ['tox-button--icon'] : [],\n        ...spec.borderless ? ['tox-button--naked'] : [],\n        ...extraClasses\n      ];\n      const dom = {\n        tag: 'button',\n        classes,\n        attributes: {\n          'aria-label': translatedText,\n          'data-mce-name': spec.text\n        }\n      };\n      const optTooltip = spec.icon.map(constant$1(translatedText));\n      return renderCommonSpec(spec, action, extraBehaviours, dom, components, optTooltip, providersBackstage);\n    };\n    const renderButton$1 = (spec, action, providersBackstage, extraBehaviours = [], extraClasses = []) => {\n      const buttonSpec = renderButtonSpec(spec, Optional.some(action), providersBackstage, extraBehaviours, extraClasses);\n      return Button.sketch(buttonSpec);\n    };\n    const getAction = (name, buttonType) => comp => {\n      if (buttonType === 'custom') {\n        emitWith(comp, formActionEvent, {\n          name,\n          value: {}\n        });\n      } else if (buttonType === 'submit') {\n        emit(comp, formSubmitEvent);\n      } else if (buttonType === 'cancel') {\n        emit(comp, formCancelEvent);\n      } else {\n        console.error('Unknown button type: ', buttonType);\n      }\n    };\n    const isMenuFooterButtonSpec = (spec, buttonType) => buttonType === 'menu';\n    const isNormalFooterButtonSpec = (spec, buttonType) => buttonType === 'custom' || buttonType === 'cancel' || buttonType === 'submit';\n    const isToggleButtonSpec = (spec, buttonType) => buttonType === 'togglebutton';\n    const renderToggleButton = (spec, providers, btnName) => {\n      var _a, _b;\n      const optMemIcon = spec.icon.map(memIcon => renderReplaceableIconFromPack(memIcon, providers.icons)).map(record);\n      const action = comp => {\n        emitWith(comp, formActionEvent, {\n          name: spec.name,\n          value: {\n            setIcon: newIcon => {\n              optMemIcon.map(memIcon => memIcon.getOpt(comp).each(displayIcon => {\n                Replacing.set(displayIcon, [renderReplaceableIconFromPack(newIcon, providers.icons)]);\n              }));\n            }\n          }\n        });\n      };\n      const buttonType = spec.buttonType.getOr(!spec.primary ? 'secondary' : 'primary');\n      const buttonSpec = {\n        ...spec,\n        name: (_a = spec.name) !== null && _a !== void 0 ? _a : '',\n        primary: buttonType === 'primary',\n        tooltip: spec.tooltip,\n        enabled: (_b = spec.enabled) !== null && _b !== void 0 ? _b : false,\n        borderless: false\n      };\n      const tooltipAttributes = buttonSpec.tooltip.or(spec.text).map(tooltip => ({ 'aria-label': providers.translate(tooltip) })).getOr({});\n      const buttonTypeClasses = calculateClassesFromButtonType(buttonType !== null && buttonType !== void 0 ? buttonType : 'secondary');\n      const showIconAndText = spec.icon.isSome() && spec.text.isSome();\n      const dom = {\n        tag: 'button',\n        classes: [\n          ...buttonTypeClasses.concat(spec.icon.isSome() ? ['tox-button--icon'] : []),\n          ...spec.active ? ['tox-button--enabled'] : [],\n          ...showIconAndText ? ['tox-button--icon-and-text'] : []\n        ],\n        attributes: {\n          ...tooltipAttributes,\n          ...isNonNullable(btnName) ? { 'data-mce-name': btnName } : {}\n        }\n      };\n      const extraBehaviours = [];\n      const translatedText = providers.translate(spec.text.getOr(''));\n      const translatedTextComponed = text$2(translatedText);\n      const iconComp = componentRenderPipeline([optMemIcon.map(memIcon => memIcon.asSpec())]);\n      const components = [\n        ...iconComp,\n        ...spec.text.isSome() ? [translatedTextComponed] : []\n      ];\n      const iconButtonSpec = renderCommonSpec(buttonSpec, Optional.some(action), extraBehaviours, dom, components, spec.tooltip, providers);\n      return Button.sketch(iconButtonSpec);\n    };\n    const renderFooterButton = (spec, buttonType, backstage) => {\n      if (isMenuFooterButtonSpec(spec, buttonType)) {\n        const getButton = () => memButton;\n        const menuButtonSpec = spec;\n        const fixedSpec = {\n          ...spec,\n          type: 'menubutton',\n          search: Optional.none(),\n          onSetup: api => {\n            api.setEnabled(spec.enabled);\n            return noop;\n          },\n          fetch: getFetch(menuButtonSpec.items, getButton, backstage)\n        };\n        const memButton = record(renderMenuButton(fixedSpec, 'tox-tbtn', backstage, Optional.none(), true, spec.text.or(spec.tooltip).getOrUndefined()));\n        return memButton.asSpec();\n      } else if (isNormalFooterButtonSpec(spec, buttonType)) {\n        const action = getAction(spec.name, buttonType);\n        const buttonSpec = {\n          ...spec,\n          borderless: false\n        };\n        return renderButton$1(buttonSpec, action, backstage.shared.providers, []);\n      } else if (isToggleButtonSpec(spec, buttonType)) {\n        return renderToggleButton(spec, backstage.shared.providers, spec.text.or(spec.tooltip).getOrUndefined());\n      } else {\n        console.error('Unknown footer button type: ', buttonType);\n        throw new Error('Unknown footer button type');\n      }\n    };\n    const renderDialogButton = (spec, providersBackstage) => {\n      const action = getAction(spec.name, 'custom');\n      return renderFormField(Optional.none(), FormField.parts.field({\n        factory: Button,\n        ...renderButtonSpec(spec, Optional.some(action), providersBackstage, [\n          memory(''),\n          ComposingConfigs.self()\n        ])\n      }));\n    };\n\n    const separator$1 = { type: 'separator' };\n    const toMenuItem = target => ({\n      type: 'menuitem',\n      value: target.url,\n      text: target.title,\n      meta: { attach: target.attach },\n      onAction: noop\n    });\n    const staticMenuItem = (title, url) => ({\n      type: 'menuitem',\n      value: url,\n      text: title,\n      meta: { attach: undefined },\n      onAction: noop\n    });\n    const toMenuItems = targets => map$2(targets, toMenuItem);\n    const filterLinkTargets = (type, targets) => filter$2(targets, target => target.type === type);\n    const filteredTargets = (type, targets) => toMenuItems(filterLinkTargets(type, targets));\n    const headerTargets = linkInfo => filteredTargets('header', linkInfo.targets);\n    const anchorTargets = linkInfo => filteredTargets('anchor', linkInfo.targets);\n    const anchorTargetTop = linkInfo => Optional.from(linkInfo.anchorTop).map(url => staticMenuItem('<top>', url)).toArray();\n    const anchorTargetBottom = linkInfo => Optional.from(linkInfo.anchorBottom).map(url => staticMenuItem('<bottom>', url)).toArray();\n    const historyTargets = history => map$2(history, url => staticMenuItem(url, url));\n    const joinMenuLists = items => {\n      return foldl(items, (a, b) => {\n        const bothEmpty = a.length === 0 || b.length === 0;\n        return bothEmpty ? a.concat(b) : a.concat(separator$1, b);\n      }, []);\n    };\n    const filterByQuery = (term, menuItems) => {\n      const lowerCaseTerm = term.toLowerCase();\n      return filter$2(menuItems, item => {\n        var _a;\n        const text = item.meta !== undefined && item.meta.text !== undefined ? item.meta.text : item.text;\n        const value = (_a = item.value) !== null && _a !== void 0 ? _a : '';\n        return contains$1(text.toLowerCase(), lowerCaseTerm) || contains$1(value.toLowerCase(), lowerCaseTerm);\n      });\n    };\n\n    const getItems = (fileType, input, urlBackstage) => {\n      var _a, _b;\n      const urlInputValue = Representing.getValue(input);\n      const term = (_b = (_a = urlInputValue === null || urlInputValue === void 0 ? void 0 : urlInputValue.meta) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : urlInputValue.value;\n      const info = urlBackstage.getLinkInformation();\n      return info.fold(() => [], linkInfo => {\n        const history = filterByQuery(term, historyTargets(urlBackstage.getHistory(fileType)));\n        return fileType === 'file' ? joinMenuLists([\n          history,\n          filterByQuery(term, headerTargets(linkInfo)),\n          filterByQuery(term, flatten([\n            anchorTargetTop(linkInfo),\n            anchorTargets(linkInfo),\n            anchorTargetBottom(linkInfo)\n          ]))\n        ]) : history;\n      });\n    };\n    const errorId = generate$6('aria-invalid');\n    const renderUrlInput = (spec, backstage, urlBackstage, initialData) => {\n      const providersBackstage = backstage.shared.providers;\n      const updateHistory = component => {\n        const urlEntry = Representing.getValue(component);\n        urlBackstage.addToHistory(urlEntry.value, spec.filetype);\n      };\n      const typeaheadSpec = {\n        ...initialData.map(initialData => ({ initialData })).getOr({}),\n        dismissOnBlur: true,\n        inputClasses: ['tox-textfield'],\n        sandboxClasses: ['tox-dialog__popups'],\n        inputAttributes: {\n          'aria-errormessage': errorId,\n          'type': 'url'\n        },\n        minChars: 0,\n        responseTime: 0,\n        fetch: input => {\n          const items = getItems(spec.filetype, input, urlBackstage);\n          const tdata = build(items, ItemResponse$1.BUBBLE_TO_SANDBOX, backstage, {\n            isHorizontalMenu: false,\n            search: Optional.none()\n          });\n          return Future.pure(tdata);\n        },\n        getHotspot: comp => memUrlBox.getOpt(comp),\n        onSetValue: (comp, _newValue) => {\n          if (comp.hasConfigured(Invalidating)) {\n            Invalidating.run(comp).get(noop);\n          }\n        },\n        typeaheadBehaviours: derive$1([\n          ...urlBackstage.getValidationHandler().map(handler => Invalidating.config({\n            getRoot: comp => parentElement(comp.element),\n            invalidClass: 'tox-control-wrap--status-invalid',\n            notify: {\n              onInvalid: (comp, err) => {\n                memInvalidIcon.getOpt(comp).each(invalidComp => {\n                  set$9(invalidComp.element, 'title', providersBackstage.translate(err));\n                });\n              }\n            },\n            validator: {\n              validate: input => {\n                const urlEntry = Representing.getValue(input);\n                return FutureResult.nu(completer => {\n                  handler({\n                    type: spec.filetype,\n                    url: urlEntry.value\n                  }, validation => {\n                    if (validation.status === 'invalid') {\n                      const err = Result.error(validation.message);\n                      completer(err);\n                    } else {\n                      const val = Result.value(validation.message);\n                      completer(val);\n                    }\n                  });\n                });\n              },\n              validateOnLoad: false\n            }\n          })).toArray(),\n          Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() }),\n          Tabstopping.config({}),\n          config('urlinput-events', [\n            run$1(input(), comp => {\n              const currentValue = get$7(comp.element);\n              const trimmedValue = currentValue.trim();\n              if (trimmedValue !== currentValue) {\n                set$5(comp.element, trimmedValue);\n              }\n              if (spec.filetype === 'file') {\n                emitWith(comp, formChangeEvent, { name: spec.name });\n              }\n            }),\n            run$1(change(), comp => {\n              emitWith(comp, formChangeEvent, { name: spec.name });\n              updateHistory(comp);\n            }),\n            run$1(postPaste(), comp => {\n              emitWith(comp, formChangeEvent, { name: spec.name });\n              updateHistory(comp);\n            })\n          ])\n        ]),\n        eventOrder: {\n          [input()]: [\n            'streaming',\n            'urlinput-events',\n            'invalidating'\n          ]\n        },\n        model: {\n          getDisplayText: itemData => itemData.value,\n          selectsOver: false,\n          populateFromBrowse: false\n        },\n        markers: { openClass: 'tox-textfield--popup-open' },\n        lazySink: backstage.shared.getSink,\n        parts: { menu: part(false, 1, 'normal') },\n        onExecute: (_menu, component, _entry) => {\n          emitWith(component, formSubmitEvent, {});\n        },\n        onItemExecute: (typeahead, _sandbox, _item, _value) => {\n          updateHistory(typeahead);\n          emitWith(typeahead, formChangeEvent, { name: spec.name });\n        }\n      };\n      const pField = FormField.parts.field({\n        ...typeaheadSpec,\n        factory: Typeahead\n      });\n      const pLabel = spec.label.map(label => renderLabel$3(label, providersBackstage));\n      const makeIcon = (name, errId, icon = name, label = name) => render$3(icon, {\n        tag: 'div',\n        classes: [\n          'tox-icon',\n          'tox-control-wrap__status-icon-' + name\n        ],\n        attributes: {\n          'title': providersBackstage.translate(label),\n          'aria-live': 'polite',\n          ...errId.fold(() => ({}), id => ({ id }))\n        }\n      }, providersBackstage.icons);\n      const memInvalidIcon = record(makeIcon('invalid', Optional.some(errorId), 'warning'));\n      const memStatus = record({\n        dom: {\n          tag: 'div',\n          classes: ['tox-control-wrap__status-icon-wrap']\n        },\n        components: [memInvalidIcon.asSpec()]\n      });\n      const optUrlPicker = urlBackstage.getUrlPicker(spec.filetype);\n      const browseUrlEvent = generate$6('browser.url.event');\n      const memUrlBox = record({\n        dom: {\n          tag: 'div',\n          classes: ['tox-control-wrap']\n        },\n        components: [\n          pField,\n          memStatus.asSpec()\n        ],\n        behaviours: derive$1([Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() })])\n      });\n      const memUrlPickerButton = record(renderButton$1({\n        name: spec.name,\n        icon: Optional.some('browse'),\n        text: spec.picker_text.or(spec.label).getOr(''),\n        enabled: spec.enabled,\n        primary: false,\n        buttonType: Optional.none(),\n        borderless: true\n      }, component => emit(component, browseUrlEvent), providersBackstage, [], ['tox-browse-url']));\n      const controlHWrapper = () => ({\n        dom: {\n          tag: 'div',\n          classes: ['tox-form__controls-h-stack']\n        },\n        components: flatten([\n          [memUrlBox.asSpec()],\n          optUrlPicker.map(() => memUrlPickerButton.asSpec()).toArray()\n        ])\n      });\n      const openUrlPicker = comp => {\n        Composing.getCurrent(comp).each(field => {\n          const componentData = Representing.getValue(field);\n          const urlData = {\n            fieldname: spec.name,\n            ...componentData\n          };\n          optUrlPicker.each(picker => {\n            picker(urlData).get(chosenData => {\n              Representing.setValue(field, chosenData);\n              emitWith(comp, formChangeEvent, { name: spec.name });\n            });\n          });\n        });\n      };\n      return FormField.sketch({\n        dom: renderFormFieldDom(),\n        components: pLabel.toArray().concat([controlHWrapper()]),\n        fieldBehaviours: derive$1([\n          Disabling.config({\n            disabled: () => !spec.enabled || providersBackstage.isDisabled(),\n            onDisabled: comp => {\n              FormField.getField(comp).each(Disabling.disable);\n              memUrlPickerButton.getOpt(comp).each(Disabling.disable);\n            },\n            onEnabled: comp => {\n              FormField.getField(comp).each(Disabling.enable);\n              memUrlPickerButton.getOpt(comp).each(Disabling.enable);\n            }\n          }),\n          receivingConfig(),\n          config('url-input-events', [run$1(browseUrlEvent, openUrlPicker)])\n        ])\n      });\n    };\n\n    const renderAlertBanner = (spec, providersBackstage) => {\n      const icon = get$3(spec.icon, providersBackstage.icons);\n      return Container.sketch({\n        dom: {\n          tag: 'div',\n          attributes: { role: 'alert' },\n          classes: [\n            'tox-notification',\n            'tox-notification--in',\n            `tox-notification--${ spec.level }`\n          ]\n        },\n        components: [\n          {\n            dom: {\n              tag: 'div',\n              classes: ['tox-notification__icon'],\n              innerHtml: !spec.url ? icon : undefined\n            },\n            components: spec.url ? [Button.sketch({\n                dom: {\n                  tag: 'button',\n                  classes: [\n                    'tox-button',\n                    'tox-button--naked',\n                    'tox-button--icon'\n                  ],\n                  innerHtml: icon,\n                  attributes: { title: providersBackstage.translate(spec.iconTooltip) }\n                },\n                action: comp => emitWith(comp, formActionEvent, {\n                  name: 'alert-banner',\n                  value: spec.url\n                }),\n                buttonBehaviours: derive$1([addFocusableBehaviour()])\n              })] : undefined\n          },\n          {\n            dom: {\n              tag: 'div',\n              classes: ['tox-notification__body'],\n              innerHtml: providersBackstage.translate(spec.text)\n            }\n          }\n        ]\n      });\n    };\n\n    const set$1 = (element, status) => {\n      element.dom.checked = status;\n    };\n    const get$2 = element => element.dom.checked;\n\n    const renderCheckbox = (spec, providerBackstage, initialData) => {\n      const toggleCheckboxHandler = comp => {\n        comp.element.dom.click();\n        return Optional.some(true);\n      };\n      const pField = FormField.parts.field({\n        factory: { sketch: identity },\n        dom: {\n          tag: 'input',\n          classes: ['tox-checkbox__input'],\n          attributes: { type: 'checkbox' }\n        },\n        behaviours: derive$1([\n          ComposingConfigs.self(),\n          Disabling.config({\n            disabled: () => !spec.enabled || providerBackstage.isDisabled(),\n            onDisabled: component => {\n              parentElement(component.element).each(element => add$2(element, 'tox-checkbox--disabled'));\n            },\n            onEnabled: component => {\n              parentElement(component.element).each(element => remove$3(element, 'tox-checkbox--disabled'));\n            }\n          }),\n          Tabstopping.config({}),\n          Focusing.config({}),\n          withElement(initialData, get$2, set$1),\n          Keying.config({\n            mode: 'special',\n            onEnter: toggleCheckboxHandler,\n            onSpace: toggleCheckboxHandler,\n            stopSpaceKeyup: true\n          }),\n          config('checkbox-events', [run$1(change(), (component, _) => {\n              emitWith(component, formChangeEvent, { name: spec.name });\n            })])\n        ])\n      });\n      const pLabel = FormField.parts.label({\n        dom: {\n          tag: 'span',\n          classes: ['tox-checkbox__label']\n        },\n        components: [text$2(providerBackstage.translate(spec.label))],\n        behaviours: derive$1([Unselecting.config({})])\n      });\n      const makeIcon = className => {\n        const iconName = className === 'checked' ? 'selected' : 'unselected';\n        return render$3(iconName, {\n          tag: 'span',\n          classes: [\n            'tox-icon',\n            'tox-checkbox-icon__' + className\n          ]\n        }, providerBackstage.icons);\n      };\n      const memIcons = record({\n        dom: {\n          tag: 'div',\n          classes: ['tox-checkbox__icons']\n        },\n        components: [\n          makeIcon('checked'),\n          makeIcon('unchecked')\n        ]\n      });\n      return FormField.sketch({\n        dom: {\n          tag: 'label',\n          classes: ['tox-checkbox']\n        },\n        components: [\n          pField,\n          memIcons.asSpec(),\n          pLabel\n        ],\n        fieldBehaviours: derive$1([\n          Disabling.config({ disabled: () => !spec.enabled || providerBackstage.isDisabled() }),\n          receivingConfig()\n        ])\n      });\n    };\n\n    const renderHtmlPanel = (spec, providersBackstage) => {\n      const classes = [\n        'tox-form__group',\n        ...spec.stretched ? ['tox-form__group--stretched'] : []\n      ];\n      const init = config('htmlpanel', [runOnAttached(comp => {\n          spec.onInit(comp.element.dom);\n        })]);\n      if (spec.presets === 'presentation') {\n        return Container.sketch({\n          dom: {\n            tag: 'div',\n            classes,\n            innerHtml: spec.html\n          },\n          containerBehaviours: derive$1([\n            Tooltipping.config({\n              ...providersBackstage.tooltips.getConfig({\n                tooltipText: '',\n                onShow: comp => {\n                  descendant(comp.element, '[data-mce-tooltip]:hover').orThunk(() => search(comp.element)).each(current => {\n                    getOpt(current, 'data-mce-tooltip').each(text => {\n                      Tooltipping.setComponents(comp, providersBackstage.tooltips.getComponents({ tooltipText: text }));\n                    });\n                  });\n                }\n              }),\n              mode: 'children-normal',\n              anchor: comp => ({\n                type: 'node',\n                node: descendant(comp.element, '[data-mce-tooltip]:hover').orThunk(() => search(comp.element).filter(current => getOpt(current, 'data-mce-tooltip').isSome())),\n                root: comp.element,\n                layouts: {\n                  onLtr: constant$1([\n                    south$2,\n                    north$2,\n                    southeast$2,\n                    northeast$2,\n                    southwest$2,\n                    northwest$2\n                  ]),\n                  onRtl: constant$1([\n                    south$2,\n                    north$2,\n                    southeast$2,\n                    northeast$2,\n                    southwest$2,\n                    northwest$2\n                  ])\n                },\n                bubble: nu$5(0, -2, {})\n              })\n            }),\n            init\n          ])\n        });\n      } else {\n        return Container.sketch({\n          dom: {\n            tag: 'div',\n            classes,\n            innerHtml: spec.html,\n            attributes: { role: 'document' }\n          },\n          containerBehaviours: derive$1([\n            Tabstopping.config({}),\n            Focusing.config({}),\n            init\n          ])\n        });\n      }\n    };\n\n    const make$2 = render => {\n      return (parts, spec, dialogData, backstage, getCompByName) => get$h(spec, 'name').fold(() => render(spec, backstage, Optional.none(), getCompByName), fieldName => parts.field(fieldName, render(spec, backstage, get$h(dialogData, fieldName), getCompByName)));\n    };\n    const makeIframe = render => (parts, spec, dialogData, backstage, getCompByName) => {\n      const iframeSpec = deepMerge(spec, { source: 'dynamic' });\n      return make$2(render)(parts, iframeSpec, dialogData, backstage, getCompByName);\n    };\n    const factories = {\n      bar: make$2((spec, backstage) => renderBar(spec, backstage.shared)),\n      collection: make$2((spec, backstage, data) => renderCollection(spec, backstage.shared.providers, data)),\n      alertbanner: make$2((spec, backstage) => renderAlertBanner(spec, backstage.shared.providers)),\n      input: make$2((spec, backstage, data) => renderInput(spec, backstage.shared.providers, data)),\n      textarea: make$2((spec, backstage, data) => renderTextarea(spec, backstage.shared.providers, data)),\n      label: make$2((spec, backstage, _data, getCompByName) => renderLabel$2(spec, backstage.shared, getCompByName)),\n      iframe: makeIframe((spec, backstage, data) => renderIFrame(spec, backstage.shared.providers, data)),\n      button: make$2((spec, backstage) => renderDialogButton(spec, backstage.shared.providers)),\n      checkbox: make$2((spec, backstage, data) => renderCheckbox(spec, backstage.shared.providers, data)),\n      colorinput: make$2((spec, backstage, data) => renderColorInput(spec, backstage.shared, backstage.colorinput, data)),\n      colorpicker: make$2((spec, backstage, data) => renderColorPicker(spec, backstage.shared.providers, data)),\n      dropzone: make$2((spec, backstage, data) => renderDropZone(spec, backstage.shared.providers, data)),\n      grid: make$2((spec, backstage) => renderGrid(spec, backstage.shared)),\n      listbox: make$2((spec, backstage, data) => renderListBox(spec, backstage, data)),\n      selectbox: make$2((spec, backstage, data) => renderSelectBox(spec, backstage.shared.providers, data)),\n      sizeinput: make$2((spec, backstage) => renderSizeInput(spec, backstage.shared.providers)),\n      slider: make$2((spec, backstage, data) => renderSlider(spec, backstage.shared.providers, data)),\n      urlinput: make$2((spec, backstage, data) => renderUrlInput(spec, backstage, backstage.urlinput, data)),\n      customeditor: make$2(renderCustomEditor),\n      htmlpanel: make$2((spec, backstage) => renderHtmlPanel(spec, backstage.shared.providers)),\n      imagepreview: make$2((spec, _, data) => renderImagePreview(spec, data)),\n      table: make$2((spec, backstage) => renderTable(spec, backstage.shared.providers)),\n      tree: make$2((spec, backstage) => renderTree(spec, backstage)),\n      panel: make$2((spec, backstage) => renderPanel(spec, backstage))\n    };\n    const noFormParts = {\n      field: (_name, spec) => spec,\n      record: constant$1([])\n    };\n    const interpretInForm = (parts, spec, dialogData, oldBackstage, getCompByName) => {\n      const newBackstage = deepMerge(oldBackstage, { shared: { interpreter: childSpec => interpretParts(parts, childSpec, dialogData, newBackstage, getCompByName) } });\n      return interpretParts(parts, spec, dialogData, newBackstage, getCompByName);\n    };\n    const interpretParts = (parts, spec, dialogData, backstage, getCompByName) => get$h(factories, spec.type).fold(() => {\n      console.error(`Unknown factory type \"${ spec.type }\", defaulting to container: `, spec);\n      return spec;\n    }, factory => factory(parts, spec, dialogData, backstage, getCompByName));\n    const interpretWithoutForm = (spec, dialogData, backstage, getCompByName) => interpretParts(noFormParts, spec, dialogData, backstage, getCompByName);\n\n    const labelPrefix = 'layout-inset';\n    const westEdgeX = anchor => anchor.x;\n    const middleX = (anchor, element) => anchor.x + anchor.width / 2 - element.width / 2;\n    const eastEdgeX = (anchor, element) => anchor.x + anchor.width - element.width;\n    const northY = anchor => anchor.y;\n    const southY = (anchor, element) => anchor.y + anchor.height - element.height;\n    const centreY = (anchor, element) => anchor.y + anchor.height / 2 - element.height / 2;\n    const southwest = (anchor, element, bubbles) => nu$6(eastEdgeX(anchor, element), southY(anchor, element), bubbles.insetSouthwest(), northwest$3(), 'southwest', boundsRestriction(anchor, {\n      right: 0,\n      bottom: 3\n    }), labelPrefix);\n    const southeast = (anchor, element, bubbles) => nu$6(westEdgeX(anchor), southY(anchor, element), bubbles.insetSoutheast(), northeast$3(), 'southeast', boundsRestriction(anchor, {\n      left: 1,\n      bottom: 3\n    }), labelPrefix);\n    const northwest = (anchor, element, bubbles) => nu$6(eastEdgeX(anchor, element), northY(anchor), bubbles.insetNorthwest(), southwest$3(), 'northwest', boundsRestriction(anchor, {\n      right: 0,\n      top: 2\n    }), labelPrefix);\n    const northeast = (anchor, element, bubbles) => nu$6(westEdgeX(anchor), northY(anchor), bubbles.insetNortheast(), southeast$3(), 'northeast', boundsRestriction(anchor, {\n      left: 1,\n      top: 2\n    }), labelPrefix);\n    const north = (anchor, element, bubbles) => nu$6(middleX(anchor, element), northY(anchor), bubbles.insetNorth(), south$3(), 'north', boundsRestriction(anchor, { top: 2 }), labelPrefix);\n    const south = (anchor, element, bubbles) => nu$6(middleX(anchor, element), southY(anchor, element), bubbles.insetSouth(), north$3(), 'south', boundsRestriction(anchor, { bottom: 3 }), labelPrefix);\n    const east = (anchor, element, bubbles) => nu$6(eastEdgeX(anchor, element), centreY(anchor, element), bubbles.insetEast(), west$3(), 'east', boundsRestriction(anchor, { right: 0 }), labelPrefix);\n    const west = (anchor, element, bubbles) => nu$6(westEdgeX(anchor), centreY(anchor, element), bubbles.insetWest(), east$3(), 'west', boundsRestriction(anchor, { left: 1 }), labelPrefix);\n    const lookupPreserveLayout = lastPlacement => {\n      switch (lastPlacement) {\n      case 'north':\n        return north;\n      case 'northeast':\n        return northeast;\n      case 'northwest':\n        return northwest;\n      case 'south':\n        return south;\n      case 'southeast':\n        return southeast;\n      case 'southwest':\n        return southwest;\n      case 'east':\n        return east;\n      case 'west':\n        return west;\n      }\n    };\n    const preserve = (anchor, element, bubbles, placee, bounds) => {\n      const layout = getPlacement(placee).map(lookupPreserveLayout).getOr(north);\n      return layout(anchor, element, bubbles, placee, bounds);\n    };\n    const lookupFlippedLayout = lastPlacement => {\n      switch (lastPlacement) {\n      case 'north':\n        return south;\n      case 'northeast':\n        return southeast;\n      case 'northwest':\n        return southwest;\n      case 'south':\n        return north;\n      case 'southeast':\n        return northeast;\n      case 'southwest':\n        return northwest;\n      case 'east':\n        return west;\n      case 'west':\n        return east;\n      }\n    };\n    const flip = (anchor, element, bubbles, placee, bounds) => {\n      const layout = getPlacement(placee).map(lookupFlippedLayout).getOr(north);\n      return layout(anchor, element, bubbles, placee, bounds);\n    };\n\n    const bubbleAlignments$2 = {\n      valignCentre: [],\n      alignCentre: [],\n      alignLeft: [],\n      alignRight: [],\n      right: [],\n      left: [],\n      bottom: [],\n      top: []\n    };\n    const getInlineDialogAnchor = (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) => {\n      const bubbleSize = 12;\n      const overrides = { maxHeightFunction: expandable$1() };\n      const editableAreaAnchor = () => ({\n        type: 'node',\n        root: getContentContainer(getRootNode(contentAreaElement())),\n        node: Optional.from(contentAreaElement()),\n        bubble: nu$5(bubbleSize, bubbleSize, bubbleAlignments$2),\n        layouts: {\n          onRtl: () => [northeast],\n          onLtr: () => [northwest]\n        },\n        overrides\n      });\n      const standardAnchor = () => ({\n        type: 'hotspot',\n        hotspot: lazyAnchorbar(),\n        bubble: nu$5(-bubbleSize, bubbleSize, bubbleAlignments$2),\n        layouts: {\n          onRtl: () => [\n            southeast$2,\n            southwest$2,\n            south$2\n          ],\n          onLtr: () => [\n            southwest$2,\n            southeast$2,\n            south$2\n          ]\n        },\n        overrides\n      });\n      return () => lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();\n    };\n    const getInlineBottomDialogAnchor = (inline, contentAreaElement, lazyBottomAnchorBar, lazyUseEditableAreaAnchor) => {\n      const bubbleSize = 12;\n      const overrides = { maxHeightFunction: expandable$1() };\n      const editableAreaAnchor = () => ({\n        type: 'node',\n        root: getContentContainer(getRootNode(contentAreaElement())),\n        node: Optional.from(contentAreaElement()),\n        bubble: nu$5(bubbleSize, bubbleSize, bubbleAlignments$2),\n        layouts: {\n          onRtl: () => [north],\n          onLtr: () => [north]\n        },\n        overrides\n      });\n      const standardAnchor = () => inline ? {\n        type: 'node',\n        root: getContentContainer(getRootNode(contentAreaElement())),\n        node: Optional.from(contentAreaElement()),\n        bubble: nu$5(0, -getOuter$2(contentAreaElement()), bubbleAlignments$2),\n        layouts: {\n          onRtl: () => [north$2],\n          onLtr: () => [north$2]\n        },\n        overrides\n      } : {\n        type: 'hotspot',\n        hotspot: lazyBottomAnchorBar(),\n        bubble: nu$5(0, 0, bubbleAlignments$2),\n        layouts: {\n          onRtl: () => [north$2],\n          onLtr: () => [north$2]\n        },\n        overrides\n      };\n      return () => lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();\n    };\n    const getBannerAnchor = (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) => {\n      const editableAreaAnchor = () => ({\n        type: 'node',\n        root: getContentContainer(getRootNode(contentAreaElement())),\n        node: Optional.from(contentAreaElement()),\n        layouts: {\n          onRtl: () => [north],\n          onLtr: () => [north]\n        }\n      });\n      const standardAnchor = () => ({\n        type: 'hotspot',\n        hotspot: lazyAnchorbar(),\n        layouts: {\n          onRtl: () => [south$2],\n          onLtr: () => [south$2]\n        }\n      });\n      return () => lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();\n    };\n    const getCursorAnchor = (editor, bodyElement) => () => ({\n      type: 'selection',\n      root: bodyElement(),\n      getSelection: () => {\n        const rng = editor.selection.getRng();\n        const selectedCells = editor.model.table.getSelectedCells();\n        if (selectedCells.length > 1) {\n          const firstCell = selectedCells[0];\n          const lastCell = selectedCells[selectedCells.length - 1];\n          const selectionTableCellRange = {\n            firstCell: SugarElement.fromDom(firstCell),\n            lastCell: SugarElement.fromDom(lastCell)\n          };\n          return Optional.some(selectionTableCellRange);\n        }\n        return Optional.some(SimSelection.range(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n      }\n    });\n    const getNodeAnchor$1 = bodyElement => element => ({\n      type: 'node',\n      root: bodyElement(),\n      node: element\n    });\n    const getAnchors = (editor, lazyAnchorbar, lazyBottomAnchorBar, isToolbarTop) => {\n      const useFixedToolbarContainer = useFixedContainer(editor);\n      const bodyElement = () => SugarElement.fromDom(editor.getBody());\n      const contentAreaElement = () => SugarElement.fromDom(editor.getContentAreaContainer());\n      const lazyUseEditableAreaAnchor = () => useFixedToolbarContainer || !isToolbarTop();\n      return {\n        inlineDialog: getInlineDialogAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),\n        inlineBottomDialog: getInlineBottomDialogAnchor(editor.inline, contentAreaElement, lazyBottomAnchorBar, lazyUseEditableAreaAnchor),\n        banner: getBannerAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),\n        cursor: getCursorAnchor(editor, bodyElement),\n        node: getNodeAnchor$1(bodyElement)\n      };\n    };\n\n    const colorPicker = editor => (callback, value) => {\n      const dialog = colorPickerDialog(editor);\n      dialog(callback, value);\n    };\n    const hasCustomColors = editor => () => hasCustomColors$1(editor);\n    const getColors = editor => id => getColors$2(editor, id);\n    const getColorCols = editor => id => getColorCols$1(editor, id);\n    const ColorInputBackstage = editor => ({\n      colorPicker: colorPicker(editor),\n      hasCustomColors: hasCustomColors(editor),\n      getColors: getColors(editor),\n      getColorCols: getColorCols(editor)\n    });\n\n    const isDraggableModal = editor => () => isDraggableModal$1(editor);\n    const DialogBackstage = editor => ({ isDraggableModal: isDraggableModal(editor) });\n\n    const HeaderBackstage = editor => {\n      const mode = Cell(isToolbarLocationBottom(editor) ? 'bottom' : 'top');\n      return {\n        isPositionedAtTop: () => mode.get() === 'top',\n        getDockingMode: mode.get,\n        setDockingMode: mode.set\n      };\n    };\n\n    const isNestedFormat = format => hasNonNullableKey(format, 'items');\n    const isFormatReference = format => hasNonNullableKey(format, 'format');\n    const defaultStyleFormats = [\n      {\n        title: 'Headings',\n        items: [\n          {\n            title: 'Heading 1',\n            format: 'h1'\n          },\n          {\n            title: 'Heading 2',\n            format: 'h2'\n          },\n          {\n            title: 'Heading 3',\n            format: 'h3'\n          },\n          {\n            title: 'Heading 4',\n            format: 'h4'\n          },\n          {\n            title: 'Heading 5',\n            format: 'h5'\n          },\n          {\n            title: 'Heading 6',\n            format: 'h6'\n          }\n        ]\n      },\n      {\n        title: 'Inline',\n        items: [\n          {\n            title: 'Bold',\n            format: 'bold'\n          },\n          {\n            title: 'Italic',\n            format: 'italic'\n          },\n          {\n            title: 'Underline',\n            format: 'underline'\n          },\n          {\n            title: 'Strikethrough',\n            format: 'strikethrough'\n          },\n          {\n            title: 'Superscript',\n            format: 'superscript'\n          },\n          {\n            title: 'Subscript',\n            format: 'subscript'\n          },\n          {\n            title: 'Code',\n            format: 'code'\n          }\n        ]\n      },\n      {\n        title: 'Blocks',\n        items: [\n          {\n            title: 'Paragraph',\n            format: 'p'\n          },\n          {\n            title: 'Blockquote',\n            format: 'blockquote'\n          },\n          {\n            title: 'Div',\n            format: 'div'\n          },\n          {\n            title: 'Pre',\n            format: 'pre'\n          }\n        ]\n      },\n      {\n        title: 'Align',\n        items: [\n          {\n            title: 'Left',\n            format: 'alignleft'\n          },\n          {\n            title: 'Center',\n            format: 'aligncenter'\n          },\n          {\n            title: 'Right',\n            format: 'alignright'\n          },\n          {\n            title: 'Justify',\n            format: 'alignjustify'\n          }\n        ]\n      }\n    ];\n    const isNestedFormats = format => has$2(format, 'items');\n    const isBlockFormat = format => has$2(format, 'block');\n    const isInlineFormat = format => has$2(format, 'inline');\n    const isSelectorFormat = format => has$2(format, 'selector');\n    const mapFormats = userFormats => foldl(userFormats, (acc, fmt) => {\n      if (isNestedFormats(fmt)) {\n        const result = mapFormats(fmt.items);\n        return {\n          customFormats: acc.customFormats.concat(result.customFormats),\n          formats: acc.formats.concat([{\n              title: fmt.title,\n              items: result.formats\n            }])\n        };\n      } else if (isInlineFormat(fmt) || isBlockFormat(fmt) || isSelectorFormat(fmt)) {\n        const formatName = isString(fmt.name) ? fmt.name : fmt.title.toLowerCase();\n        const formatNameWithPrefix = `custom-${ formatName }`;\n        return {\n          customFormats: acc.customFormats.concat([{\n              name: formatNameWithPrefix,\n              format: fmt\n            }]),\n          formats: acc.formats.concat([{\n              title: fmt.title,\n              format: formatNameWithPrefix,\n              icon: fmt.icon\n            }])\n        };\n      } else {\n        return {\n          ...acc,\n          formats: acc.formats.concat(fmt)\n        };\n      }\n    }, {\n      customFormats: [],\n      formats: []\n    });\n    const registerCustomFormats = (editor, userFormats) => {\n      const result = mapFormats(userFormats);\n      const registerFormats = customFormats => {\n        each$1(customFormats, fmt => {\n          if (!editor.formatter.has(fmt.name)) {\n            editor.formatter.register(fmt.name, fmt.format);\n          }\n        });\n      };\n      if (editor.formatter) {\n        registerFormats(result.customFormats);\n      } else {\n        editor.on('init', () => {\n          registerFormats(result.customFormats);\n        });\n      }\n      return result.formats;\n    };\n    const getStyleFormats = editor => getUserStyleFormats(editor).map(userFormats => {\n      const registeredUserFormats = registerCustomFormats(editor, userFormats);\n      return shouldMergeStyleFormats(editor) ? defaultStyleFormats.concat(registeredUserFormats) : registeredUserFormats;\n    }).getOr(defaultStyleFormats);\n\n    const isSeparator$1 = format => {\n      const keys$1 = keys(format);\n      return keys$1.length === 1 && contains$2(keys$1, 'title');\n    };\n    const processBasic = (item, isSelectedFor, getPreviewFor) => ({\n      ...item,\n      type: 'formatter',\n      isSelected: isSelectedFor(item.format),\n      getStylePreview: getPreviewFor(item.format)\n    });\n    const register$a = (editor, formats, isSelectedFor, getPreviewFor) => {\n      const enrichSupported = item => processBasic(item, isSelectedFor, getPreviewFor);\n      const enrichMenu = item => {\n        const newItems = doEnrich(item.items);\n        return {\n          ...item,\n          type: 'submenu',\n          getStyleItems: constant$1(newItems)\n        };\n      };\n      const enrichCustom = item => {\n        const formatName = isString(item.name) ? item.name : generate$6(item.title);\n        const formatNameWithPrefix = `custom-${ formatName }`;\n        const newItem = {\n          ...item,\n          type: 'formatter',\n          format: formatNameWithPrefix,\n          isSelected: isSelectedFor(formatNameWithPrefix),\n          getStylePreview: getPreviewFor(formatNameWithPrefix)\n        };\n        editor.formatter.register(formatName, newItem);\n        return newItem;\n      };\n      const doEnrich = items => map$2(items, item => {\n        if (isNestedFormat(item)) {\n          return enrichMenu(item);\n        } else if (isFormatReference(item)) {\n          return enrichSupported(item);\n        } else if (isSeparator$1(item)) {\n          return {\n            ...item,\n            type: 'separator'\n          };\n        } else {\n          return enrichCustom(item);\n        }\n      });\n      return doEnrich(formats);\n    };\n\n    const init$6 = editor => {\n      const isSelectedFor = format => () => editor.formatter.match(format);\n      const getPreviewFor = format => () => {\n        const fmt = editor.formatter.get(format);\n        return fmt !== undefined ? Optional.some({\n          tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',\n          styles: editor.dom.parseStyle(editor.formatter.getCssText(format))\n        }) : Optional.none();\n      };\n      const settingsFormats = Cell([]);\n      const eventsFormats = Cell([]);\n      const replaceSettings = Cell(false);\n      editor.on('PreInit', _e => {\n        const formats = getStyleFormats(editor);\n        const enriched = register$a(editor, formats, isSelectedFor, getPreviewFor);\n        settingsFormats.set(enriched);\n      });\n      editor.on('addStyleModifications', e => {\n        const modifications = register$a(editor, e.items, isSelectedFor, getPreviewFor);\n        eventsFormats.set(modifications);\n        replaceSettings.set(e.replace);\n      });\n      const getData = () => {\n        const fromSettings = replaceSettings.get() ? [] : settingsFormats.get();\n        const fromEvents = eventsFormats.get();\n        return fromSettings.concat(fromEvents);\n      };\n      return { getData };\n    };\n\n    const TooltipsBackstage = getSink => {\n      const tooltipDelay = 300;\n      const intervalDelay = tooltipDelay * 0.2;\n      let numActiveTooltips = 0;\n      const alreadyShowingTooltips = () => numActiveTooltips > 0;\n      const getComponents = spec => {\n        return [{\n            dom: {\n              tag: 'div',\n              classes: ['tox-tooltip__body']\n            },\n            components: [text$2(spec.tooltipText)]\n          }];\n      };\n      const getConfig = spec => {\n        return {\n          delayForShow: () => alreadyShowingTooltips() ? intervalDelay : tooltipDelay,\n          delayForHide: constant$1(tooltipDelay),\n          exclusive: true,\n          lazySink: getSink,\n          tooltipDom: {\n            tag: 'div',\n            classes: [\n              'tox-tooltip',\n              'tox-tooltip--up'\n            ]\n          },\n          tooltipComponents: getComponents(spec),\n          onShow: (comp, tooltip) => {\n            numActiveTooltips++;\n            if (spec.onShow) {\n              spec.onShow(comp, tooltip);\n            }\n          },\n          onHide: (comp, tooltip) => {\n            numActiveTooltips--;\n            if (spec.onHide) {\n              spec.onHide(comp, tooltip);\n            }\n          }\n        };\n      };\n      return {\n        getConfig,\n        getComponents\n      };\n    };\n\n    const isElement = node => isNonNullable(node) && node.nodeType === 1;\n    const trim = global$1.trim;\n    const hasContentEditableState = value => {\n      return node => {\n        if (isElement(node)) {\n          if (node.contentEditable === value) {\n            return true;\n          }\n          if (node.getAttribute('data-mce-contenteditable') === value) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const isContentEditableTrue = hasContentEditableState('true');\n    const isContentEditableFalse = hasContentEditableState('false');\n    const create = (type, title, url, level, attach) => ({\n      type,\n      title,\n      url,\n      level,\n      attach\n    });\n    const isChildOfContentEditableTrue = node => {\n      let tempNode = node;\n      while (tempNode = tempNode.parentNode) {\n        const value = tempNode.contentEditable;\n        if (value && value !== 'inherit') {\n          return isContentEditableTrue(tempNode);\n        }\n      }\n      return false;\n    };\n    const select = (selector, root) => {\n      return map$2(descendants(SugarElement.fromDom(root), selector), element => {\n        return element.dom;\n      });\n    };\n    const getElementText = elm => {\n      return elm.innerText || elm.textContent;\n    };\n    const getOrGenerateId = elm => {\n      return elm.id ? elm.id : generate$6('h');\n    };\n    const isAnchor = elm => {\n      return elm && elm.nodeName === 'A' && (elm.id || elm.name) !== undefined;\n    };\n    const isValidAnchor = elm => {\n      return isAnchor(elm) && isEditable(elm);\n    };\n    const isHeader = elm => {\n      return elm && /^(H[1-6])$/.test(elm.nodeName);\n    };\n    const isEditable = elm => {\n      return isChildOfContentEditableTrue(elm) && !isContentEditableFalse(elm);\n    };\n    const isValidHeader = elm => {\n      return isHeader(elm) && isEditable(elm);\n    };\n    const getLevel = elm => {\n      return isHeader(elm) ? parseInt(elm.nodeName.substr(1), 10) : 0;\n    };\n    const headerTarget = elm => {\n      var _a;\n      const headerId = getOrGenerateId(elm);\n      const attach = () => {\n        elm.id = headerId;\n      };\n      return create('header', (_a = getElementText(elm)) !== null && _a !== void 0 ? _a : '', '#' + headerId, getLevel(elm), attach);\n    };\n    const anchorTarget = elm => {\n      const anchorId = elm.id || elm.name;\n      const anchorText = getElementText(elm);\n      return create('anchor', anchorText ? anchorText : '#' + anchorId, '#' + anchorId, 0, noop);\n    };\n    const getHeaderTargets = elms => {\n      return map$2(filter$2(elms, isValidHeader), headerTarget);\n    };\n    const getAnchorTargets = elms => {\n      return map$2(filter$2(elms, isValidAnchor), anchorTarget);\n    };\n    const getTargetElements = elm => {\n      const elms = select('h1,h2,h3,h4,h5,h6,a:not([href])', elm);\n      return elms;\n    };\n    const hasTitle = target => {\n      return trim(target.title).length > 0;\n    };\n    const find = elm => {\n      const elms = getTargetElements(elm);\n      return filter$2(getHeaderTargets(elms).concat(getAnchorTargets(elms)), hasTitle);\n    };\n    const LinkTargets = { find };\n\n    const STORAGE_KEY = 'tinymce-url-history';\n    const HISTORY_LENGTH = 5;\n    const isHttpUrl = url => isString(url) && /^https?/.test(url);\n    const isArrayOfUrl = a => isArray(a) && a.length <= HISTORY_LENGTH && forall(a, isHttpUrl);\n    const isRecordOfUrlArray = r => isObject(r) && find$4(r, value => !isArrayOfUrl(value)).isNone();\n    const getAllHistory = () => {\n      const unparsedHistory = global$4.getItem(STORAGE_KEY);\n      if (unparsedHistory === null) {\n        return {};\n      }\n      let history;\n      try {\n        history = JSON.parse(unparsedHistory);\n      } catch (e) {\n        if (e instanceof SyntaxError) {\n          console.log('Local storage ' + STORAGE_KEY + ' was not valid JSON', e);\n          return {};\n        }\n        throw e;\n      }\n      if (!isRecordOfUrlArray(history)) {\n        console.log('Local storage ' + STORAGE_KEY + ' was not valid format', history);\n        return {};\n      }\n      return history;\n    };\n    const setAllHistory = history => {\n      if (!isRecordOfUrlArray(history)) {\n        throw new Error('Bad format for history:\\n' + JSON.stringify(history));\n      }\n      global$4.setItem(STORAGE_KEY, JSON.stringify(history));\n    };\n    const getHistory = fileType => {\n      const history = getAllHistory();\n      return get$h(history, fileType).getOr([]);\n    };\n    const addToHistory = (url, fileType) => {\n      if (!isHttpUrl(url)) {\n        return;\n      }\n      const history = getAllHistory();\n      const items = get$h(history, fileType).getOr([]);\n      const itemsWithoutUrl = filter$2(items, item => item !== url);\n      history[fileType] = [url].concat(itemsWithoutUrl).slice(0, HISTORY_LENGTH);\n      setAllHistory(history);\n    };\n\n    const isTruthy = value => !!value;\n    const makeMap = value => map$1(global$1.makeMap(value, /[, ]/), isTruthy);\n    const getPicker = editor => Optional.from(getFilePickerCallback(editor));\n    const getPickerTypes = editor => {\n      const optFileTypes = Optional.from(getFilePickerTypes(editor)).filter(isTruthy).map(makeMap);\n      return getPicker(editor).fold(never, _picker => optFileTypes.fold(always, types => keys(types).length > 0 ? types : false));\n    };\n    const getPickerSetting = (editor, filetype) => {\n      const pickerTypes = getPickerTypes(editor);\n      if (isBoolean(pickerTypes)) {\n        return pickerTypes ? getPicker(editor) : Optional.none();\n      } else {\n        return pickerTypes[filetype] ? getPicker(editor) : Optional.none();\n      }\n    };\n    const getUrlPicker = (editor, filetype) => getPickerSetting(editor, filetype).map(picker => entry => Future.nu(completer => {\n      const handler = (value, meta) => {\n        if (!isString(value)) {\n          throw new Error('Expected value to be string');\n        }\n        if (meta !== undefined && !isObject(meta)) {\n          throw new Error('Expected meta to be a object');\n        }\n        const r = {\n          value,\n          meta\n        };\n        completer(r);\n      };\n      const meta = {\n        filetype,\n        fieldname: entry.fieldname,\n        ...Optional.from(entry.meta).getOr({})\n      };\n      picker.call(editor, handler, entry.value, meta);\n    }));\n    const getTextSetting = value => Optional.from(value).filter(isString).getOrUndefined();\n    const getLinkInformation = editor => {\n      if (!useTypeaheadUrls(editor)) {\n        return Optional.none();\n      }\n      return Optional.some({\n        targets: LinkTargets.find(editor.getBody()),\n        anchorTop: getTextSetting(getAnchorTop(editor)),\n        anchorBottom: getTextSetting(getAnchorBottom(editor))\n      });\n    };\n    const getValidationHandler = editor => Optional.from(getFilePickerValidatorHandler(editor));\n    const UrlInputBackstage = editor => ({\n      getHistory,\n      addToHistory,\n      getLinkInformation: () => getLinkInformation(editor),\n      getValidationHandler: () => getValidationHandler(editor),\n      getUrlPicker: filetype => getUrlPicker(editor, filetype)\n    });\n\n    const init$5 = (lazySinks, editor, lazyAnchorbar, lazyBottomAnchorBar) => {\n      const contextMenuState = Cell(false);\n      const toolbar = HeaderBackstage(editor);\n      const providers = {\n        icons: () => editor.ui.registry.getAll().icons,\n        menuItems: () => editor.ui.registry.getAll().menuItems,\n        translate: global$5.translate,\n        isDisabled: () => editor.mode.isReadOnly() || !editor.ui.isEnabled(),\n        getOption: editor.options.get,\n        tooltips: TooltipsBackstage(lazySinks.dialog)\n      };\n      const urlinput = UrlInputBackstage(editor);\n      const styles = init$6(editor);\n      const colorinput = ColorInputBackstage(editor);\n      const dialogSettings = DialogBackstage(editor);\n      const isContextMenuOpen = () => contextMenuState.get();\n      const setContextMenuState = state => contextMenuState.set(state);\n      const commonBackstage = {\n        shared: {\n          providers,\n          anchors: getAnchors(editor, lazyAnchorbar, lazyBottomAnchorBar, toolbar.isPositionedAtTop),\n          header: toolbar\n        },\n        urlinput,\n        styles,\n        colorinput,\n        dialog: dialogSettings,\n        isContextMenuOpen,\n        setContextMenuState\n      };\n      const getCompByName = _name => Optional.none();\n      const popupBackstage = {\n        ...commonBackstage,\n        shared: {\n          ...commonBackstage.shared,\n          interpreter: s => interpretWithoutForm(s, {}, popupBackstage, getCompByName),\n          getSink: lazySinks.popup\n        }\n      };\n      const dialogBackstage = {\n        ...commonBackstage,\n        shared: {\n          ...commonBackstage.shared,\n          interpreter: s => interpretWithoutForm(s, {}, dialogBackstage, getCompByName),\n          getSink: lazySinks.dialog\n        }\n      };\n      return {\n        popup: popupBackstage,\n        dialog: dialogBackstage\n      };\n    };\n\n    const setup$b = (editor, mothership, uiMotherships) => {\n      const broadcastEvent = (name, evt) => {\n        each$1([\n          mothership,\n          ...uiMotherships\n        ], m => {\n          m.broadcastEvent(name, evt);\n        });\n      };\n      const broadcastOn = (channel, message) => {\n        each$1([\n          mothership,\n          ...uiMotherships\n        ], m => {\n          m.broadcastOn([channel], message);\n        });\n      };\n      const fireDismissPopups = evt => broadcastOn(dismissPopups(), { target: evt.target });\n      const doc = getDocument();\n      const onTouchstart = bind(doc, 'touchstart', fireDismissPopups);\n      const onTouchmove = bind(doc, 'touchmove', evt => broadcastEvent(documentTouchmove(), evt));\n      const onTouchend = bind(doc, 'touchend', evt => broadcastEvent(documentTouchend(), evt));\n      const onMousedown = bind(doc, 'mousedown', fireDismissPopups);\n      const onMouseup = bind(doc, 'mouseup', evt => {\n        if (evt.raw.button === 0) {\n          broadcastOn(mouseReleased(), { target: evt.target });\n        }\n      });\n      const onContentClick = raw => broadcastOn(dismissPopups(), { target: SugarElement.fromDom(raw.target) });\n      const onContentMouseup = raw => {\n        if (raw.button === 0) {\n          broadcastOn(mouseReleased(), { target: SugarElement.fromDom(raw.target) });\n        }\n      };\n      const onContentMousedown = () => {\n        each$1(editor.editorManager.get(), loopEditor => {\n          if (editor !== loopEditor) {\n            loopEditor.dispatch('DismissPopups', { relatedTarget: editor });\n          }\n        });\n      };\n      const onWindowScroll = evt => broadcastEvent(windowScroll(), fromRawEvent(evt));\n      const onWindowResize = evt => {\n        broadcastOn(repositionPopups(), {});\n        broadcastEvent(windowResize(), fromRawEvent(evt));\n      };\n      const dos = getRootNode(SugarElement.fromDom(editor.getElement()));\n      const onElementScroll = capture(dos, 'scroll', evt => {\n        requestAnimationFrame(() => {\n          const c = editor.getContainer();\n          if (c !== undefined && c !== null) {\n            const optScrollingContext = detectWhenSplitUiMode(editor, mothership.element);\n            const scrollers = optScrollingContext.map(sc => [\n              sc.element,\n              ...sc.others\n            ]).getOr([]);\n            if (exists(scrollers, s => eq(s, evt.target))) {\n              editor.dispatch('ElementScroll', { target: evt.target.dom });\n              broadcastEvent(externalElementScroll(), evt);\n            }\n          }\n        });\n      });\n      const onEditorResize = () => broadcastOn(repositionPopups(), {});\n      const onEditorProgress = evt => {\n        if (evt.state) {\n          broadcastOn(dismissPopups(), { target: SugarElement.fromDom(editor.getContainer()) });\n        }\n      };\n      const onDismissPopups = event => {\n        broadcastOn(dismissPopups(), { target: SugarElement.fromDom(event.relatedTarget.getContainer()) });\n      };\n      const onFocusIn = event => editor.dispatch('focusin', event);\n      const onFocusOut = event => editor.dispatch('focusout', event);\n      editor.on('PostRender', () => {\n        editor.on('click', onContentClick);\n        editor.on('tap', onContentClick);\n        editor.on('mouseup', onContentMouseup);\n        editor.on('mousedown', onContentMousedown);\n        editor.on('ScrollWindow', onWindowScroll);\n        editor.on('ResizeWindow', onWindowResize);\n        editor.on('ResizeEditor', onEditorResize);\n        editor.on('AfterProgressState', onEditorProgress);\n        editor.on('DismissPopups', onDismissPopups);\n        each$1([\n          mothership,\n          ...uiMotherships\n        ], gui => {\n          gui.element.dom.addEventListener('focusin', onFocusIn);\n          gui.element.dom.addEventListener('focusout', onFocusOut);\n        });\n      });\n      editor.on('remove', () => {\n        editor.off('click', onContentClick);\n        editor.off('tap', onContentClick);\n        editor.off('mouseup', onContentMouseup);\n        editor.off('mousedown', onContentMousedown);\n        editor.off('ScrollWindow', onWindowScroll);\n        editor.off('ResizeWindow', onWindowResize);\n        editor.off('ResizeEditor', onEditorResize);\n        editor.off('AfterProgressState', onEditorProgress);\n        editor.off('DismissPopups', onDismissPopups);\n        each$1([\n          mothership,\n          ...uiMotherships\n        ], gui => {\n          gui.element.dom.removeEventListener('focusin', onFocusIn);\n          gui.element.dom.removeEventListener('focusout', onFocusOut);\n        });\n        onMousedown.unbind();\n        onTouchstart.unbind();\n        onTouchmove.unbind();\n        onTouchend.unbind();\n        onMouseup.unbind();\n        onElementScroll.unbind();\n      });\n      editor.on('detach', () => {\n        each$1([\n          mothership,\n          ...uiMotherships\n        ], detachSystem);\n        each$1([\n          mothership,\n          ...uiMotherships\n        ], m => m.destroy());\n      });\n    };\n\n    const parts$a = AlloyParts;\n    const partType = PartType;\n\n    const schema$f = constant$1([\n      defaulted('shell', false),\n      required$1('makeItem'),\n      defaulted('setupItem', noop),\n      SketchBehaviours.field('listBehaviours', [Replacing])\n    ]);\n    const customListDetail = () => ({ behaviours: derive$1([Replacing.config({})]) });\n    const itemsPart = optional({\n      name: 'items',\n      overrides: customListDetail\n    });\n    const parts$9 = constant$1([itemsPart]);\n    const name = constant$1('CustomList');\n\n    const factory$f = (detail, components, _spec, _external) => {\n      const setItems = (list, items) => {\n        getListContainer(list).fold(() => {\n          console.error('Custom List was defined to not be a shell, but no item container was specified in components');\n          throw new Error('Custom List was defined to not be a shell, but no item container was specified in components');\n        }, container => {\n          const itemComps = Replacing.contents(container);\n          const numListsRequired = items.length;\n          const numListsToAdd = numListsRequired - itemComps.length;\n          const itemsToAdd = numListsToAdd > 0 ? range$2(numListsToAdd, () => detail.makeItem()) : [];\n          const itemsToRemove = itemComps.slice(numListsRequired);\n          each$1(itemsToRemove, item => Replacing.remove(container, item));\n          each$1(itemsToAdd, item => Replacing.append(container, item));\n          const builtLists = Replacing.contents(container);\n          each$1(builtLists, (item, i) => {\n            detail.setupItem(list, item, items[i], i);\n          });\n        });\n      };\n      const extra = detail.shell ? {\n        behaviours: [Replacing.config({})],\n        components: []\n      } : {\n        behaviours: [],\n        components\n      };\n      const getListContainer = component => detail.shell ? Optional.some(component) : getPart(component, detail, 'items');\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components: extra.components,\n        behaviours: augment(detail.listBehaviours, extra.behaviours),\n        apis: { setItems }\n      };\n    };\n    const CustomList = composite({\n      name: name(),\n      configFields: schema$f(),\n      partFields: parts$9(),\n      factory: factory$f,\n      apis: {\n        setItems: (apis, list, items) => {\n          apis.setItems(list, items);\n        }\n      }\n    });\n\n    const schema$e = constant$1([\n      required$1('dom'),\n      defaulted('shell', true),\n      field('toolbarBehaviours', [Replacing])\n    ]);\n    const enhanceGroups = () => ({ behaviours: derive$1([Replacing.config({})]) });\n    const parts$8 = constant$1([optional({\n        name: 'groups',\n        overrides: enhanceGroups\n      })]);\n\n    const factory$e = (detail, components, _spec, _externals) => {\n      const setGroups = (toolbar, groups) => {\n        getGroupContainer(toolbar).fold(() => {\n          console.error('Toolbar was defined to not be a shell, but no groups container was specified in components');\n          throw new Error('Toolbar was defined to not be a shell, but no groups container was specified in components');\n        }, container => {\n          Replacing.set(container, groups);\n        });\n      };\n      const getGroupContainer = component => detail.shell ? Optional.some(component) : getPart(component, detail, 'groups');\n      const extra = detail.shell ? {\n        behaviours: [Replacing.config({})],\n        components: []\n      } : {\n        behaviours: [],\n        components\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components: extra.components,\n        behaviours: augment(detail.toolbarBehaviours, extra.behaviours),\n        apis: {\n          setGroups,\n          refresh: noop\n        },\n        domModification: { attributes: { role: 'group' } }\n      };\n    };\n    const Toolbar = composite({\n      name: 'Toolbar',\n      configFields: schema$e(),\n      partFields: parts$8(),\n      factory: factory$e,\n      apis: {\n        setGroups: (apis, toolbar, groups) => {\n          apis.setGroups(toolbar, groups);\n        }\n      }\n    });\n\n    const setup$a = noop;\n    const isDocked$1 = never;\n    const getBehaviours$1 = constant$1([]);\n\n    var StaticHeader = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        setup: setup$a,\n        isDocked: isDocked$1,\n        getBehaviours: getBehaviours$1\n    });\n\n    const toolbarHeightChange = constant$1(generate$6('toolbar-height-change'));\n\n    const visibility = {\n      fadeInClass: 'tox-editor-dock-fadein',\n      fadeOutClass: 'tox-editor-dock-fadeout',\n      transitionClass: 'tox-editor-dock-transition'\n    };\n    const editorStickyOnClass = 'tox-tinymce--toolbar-sticky-on';\n    const editorStickyOffClass = 'tox-tinymce--toolbar-sticky-off';\n    const scrollFromBehindHeader = (e, containerHeader) => {\n      const doc = owner$4(containerHeader);\n      const win = defaultView(containerHeader);\n      const viewHeight = win.dom.innerHeight;\n      const scrollPos = get$c(doc);\n      const markerElement = SugarElement.fromDom(e.elm);\n      const markerPos = absolute$2(markerElement);\n      const markerHeight = get$e(markerElement);\n      const markerTop = markerPos.y;\n      const markerBottom = markerTop + markerHeight;\n      const editorHeaderPos = absolute$3(containerHeader);\n      const editorHeaderHeight = get$e(containerHeader);\n      const editorHeaderTop = editorHeaderPos.top;\n      const editorHeaderBottom = editorHeaderTop + editorHeaderHeight;\n      const editorHeaderDockedAtTop = Math.abs(editorHeaderTop - scrollPos.top) < 2;\n      const editorHeaderDockedAtBottom = Math.abs(editorHeaderBottom - (scrollPos.top + viewHeight)) < 2;\n      if (editorHeaderDockedAtTop && markerTop < editorHeaderBottom) {\n        to(scrollPos.left, markerTop - editorHeaderHeight, doc);\n      } else if (editorHeaderDockedAtBottom && markerBottom > editorHeaderTop) {\n        const y = markerTop - viewHeight + markerHeight + editorHeaderHeight;\n        to(scrollPos.left, y, doc);\n      }\n    };\n    const isDockedMode = (header, mode) => contains$2(Docking.getModes(header), mode);\n    const updateIframeContentFlow = header => {\n      const getOccupiedHeight = elm => getOuter$2(elm) + (parseInt(get$f(elm, 'margin-top'), 10) || 0) + (parseInt(get$f(elm, 'margin-bottom'), 10) || 0);\n      const elm = header.element;\n      parentElement(elm).each(parentElem => {\n        const padding = 'padding-' + Docking.getModes(header)[0];\n        if (Docking.isDocked(header)) {\n          const parentWidth = get$d(parentElem);\n          set$8(elm, 'width', parentWidth + 'px');\n          set$8(parentElem, padding, getOccupiedHeight(elm) + 'px');\n        } else {\n          remove$7(elm, 'width');\n          remove$7(parentElem, padding);\n        }\n      });\n    };\n    const updateSinkVisibility = (sinkElem, visible) => {\n      if (visible) {\n        remove$3(sinkElem, visibility.fadeOutClass);\n        add$1(sinkElem, [\n          visibility.transitionClass,\n          visibility.fadeInClass\n        ]);\n      } else {\n        remove$3(sinkElem, visibility.fadeInClass);\n        add$1(sinkElem, [\n          visibility.fadeOutClass,\n          visibility.transitionClass\n        ]);\n      }\n    };\n    const updateEditorClasses = (editor, docked) => {\n      const editorContainer = SugarElement.fromDom(editor.getContainer());\n      if (docked) {\n        add$2(editorContainer, editorStickyOnClass);\n        remove$3(editorContainer, editorStickyOffClass);\n      } else {\n        add$2(editorContainer, editorStickyOffClass);\n        remove$3(editorContainer, editorStickyOnClass);\n      }\n    };\n    const restoreFocus = (headerElem, focusedElem) => {\n      const ownerDoc = owner$4(focusedElem);\n      active$1(ownerDoc).filter(activeElm => !eq(focusedElem, activeElm)).filter(activeElm => eq(activeElm, SugarElement.fromDom(ownerDoc.dom.body)) || contains(headerElem, activeElm)).each(() => focus$3(focusedElem));\n    };\n    const findFocusedElem = (rootElm, lazySink) => search(rootElm).orThunk(() => lazySink().toOptional().bind(sink => search(sink.element)));\n    const setup$9 = (editor, sharedBackstage, lazyHeader) => {\n      if (!editor.inline) {\n        if (!sharedBackstage.header.isPositionedAtTop()) {\n          editor.on('ResizeEditor', () => {\n            lazyHeader().each(Docking.reset);\n          });\n        }\n        editor.on('ResizeWindow ResizeEditor', () => {\n          lazyHeader().each(updateIframeContentFlow);\n        });\n        editor.on('SkinLoaded', () => {\n          lazyHeader().each(comp => {\n            Docking.isDocked(comp) ? Docking.reset(comp) : Docking.refresh(comp);\n          });\n        });\n        editor.on('FullscreenStateChanged', () => {\n          lazyHeader().each(Docking.reset);\n        });\n      }\n      editor.on('AfterScrollIntoView', e => {\n        lazyHeader().each(header => {\n          Docking.refresh(header);\n          const headerElem = header.element;\n          if (isVisible(headerElem)) {\n            scrollFromBehindHeader(e, headerElem);\n          }\n        });\n      });\n      editor.on('PostRender', () => {\n        updateEditorClasses(editor, false);\n      });\n    };\n    const isDocked = lazyHeader => lazyHeader().map(Docking.isDocked).getOr(false);\n    const getIframeBehaviours = () => [Receiving.config({ channels: { [toolbarHeightChange()]: { onReceive: updateIframeContentFlow } } })];\n    const getBehaviours = (editor, sharedBackstage) => {\n      const focusedElm = value$4();\n      const lazySink = sharedBackstage.getSink;\n      const runOnSinkElement = f => {\n        lazySink().each(sink => f(sink.element));\n      };\n      const onDockingSwitch = comp => {\n        if (!editor.inline) {\n          updateIframeContentFlow(comp);\n        }\n        updateEditorClasses(editor, Docking.isDocked(comp));\n        comp.getSystem().broadcastOn([repositionPopups()], {});\n        lazySink().each(sink => sink.getSystem().broadcastOn([repositionPopups()], {}));\n      };\n      const additionalBehaviours = editor.inline ? [] : getIframeBehaviours();\n      return [\n        Focusing.config({}),\n        Docking.config({\n          contextual: {\n            lazyContext: comp => {\n              const headerHeight = getOuter$2(comp.element);\n              const container = editor.inline ? editor.getContentAreaContainer() : editor.getContainer();\n              return Optional.from(container).map(c => {\n                const box = box$1(SugarElement.fromDom(c));\n                const optScrollingContext = detectWhenSplitUiMode(editor, comp.element);\n                return optScrollingContext.fold(() => {\n                  const boxHeight = box.height - headerHeight;\n                  const topBound = box.y + (isDockedMode(comp, 'top') ? 0 : headerHeight);\n                  return bounds(box.x, topBound, box.width, boxHeight);\n                }, scrollEnv => {\n                  const constrainedBounds = constrain(box, getBoundsFrom(scrollEnv));\n                  const constrainedBoundsY = isDockedMode(comp, 'top') ? constrainedBounds.y : constrainedBounds.y + headerHeight;\n                  return bounds(constrainedBounds.x, constrainedBoundsY, constrainedBounds.width, constrainedBounds.height - headerHeight);\n                });\n              });\n            },\n            onShow: () => {\n              runOnSinkElement(elem => updateSinkVisibility(elem, true));\n            },\n            onShown: comp => {\n              runOnSinkElement(elem => remove$2(elem, [\n                visibility.transitionClass,\n                visibility.fadeInClass\n              ]));\n              focusedElm.get().each(elem => {\n                restoreFocus(comp.element, elem);\n                focusedElm.clear();\n              });\n            },\n            onHide: comp => {\n              findFocusedElem(comp.element, lazySink).fold(focusedElm.clear, focusedElm.set);\n              runOnSinkElement(elem => updateSinkVisibility(elem, false));\n            },\n            onHidden: () => {\n              runOnSinkElement(elem => remove$2(elem, [visibility.transitionClass]));\n            },\n            ...visibility\n          },\n          lazyViewport: comp => {\n            const optScrollingContext = detectWhenSplitUiMode(editor, comp.element);\n            return optScrollingContext.fold(() => {\n              const boundsWithoutOffset = win();\n              const offset = getStickyToolbarOffset(editor);\n              const top = boundsWithoutOffset.y + (isDockedMode(comp, 'top') ? offset : 0);\n              const height = boundsWithoutOffset.height - (isDockedMode(comp, 'bottom') ? offset : 0);\n              return {\n                bounds: bounds(boundsWithoutOffset.x, top, boundsWithoutOffset.width, height),\n                optScrollEnv: Optional.none()\n              };\n            }, sc => {\n              const combinedBounds = getBoundsFrom(sc);\n              return {\n                bounds: combinedBounds,\n                optScrollEnv: Optional.some({\n                  currentScrollTop: sc.element.dom.scrollTop,\n                  scrollElmTop: absolute$3(sc.element).top\n                })\n              };\n            });\n          },\n          modes: [sharedBackstage.header.getDockingMode()],\n          onDocked: onDockingSwitch,\n          onUndocked: onDockingSwitch\n        }),\n        ...additionalBehaviours\n      ];\n    };\n\n    var StickyHeader = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        setup: setup$9,\n        isDocked: isDocked,\n        getBehaviours: getBehaviours\n    });\n\n    const renderHeader = spec => {\n      const editor = spec.editor;\n      const getBehaviours$2 = spec.sticky ? getBehaviours : getBehaviours$1;\n      return {\n        uid: spec.uid,\n        dom: spec.dom,\n        components: spec.components,\n        behaviours: derive$1(getBehaviours$2(editor, spec.sharedBackstage))\n      };\n    };\n\n    const groupToolbarButtonSchema = objOf([\n      type,\n      requiredOf('items', oneOf([\n        arrOfObj([\n          name$1,\n          requiredArrayOf('items', string)\n        ]),\n        string\n      ]))\n    ].concat(baseToolbarButtonFields));\n    const createGroupToolbarButton = spec => asRaw('GroupToolbarButton', groupToolbarButtonSchema, spec);\n\n    const baseMenuButtonFields = [\n      optionString('text'),\n      optionString('tooltip'),\n      optionString('icon'),\n      defaultedOf('search', false, oneOf([\n        boolean,\n        objOf([optionString('placeholder')])\n      ], x => {\n        if (isBoolean(x)) {\n          return x ? Optional.some({ placeholder: Optional.none() }) : Optional.none();\n        } else {\n          return Optional.some(x);\n        }\n      })),\n      requiredFunction('fetch'),\n      defaultedFunction('onSetup', () => noop)\n    ];\n\n    const MenuButtonSchema = objOf([\n      type,\n      ...baseMenuButtonFields\n    ]);\n    const createMenuButton = spec => asRaw('menubutton', MenuButtonSchema, spec);\n\n    const splitButtonSchema = objOf([\n      type,\n      optionalTooltip,\n      optionalIcon,\n      optionalText,\n      optionalSelect,\n      fetch$1,\n      onSetup,\n      defaultedStringEnum('presets', 'normal', [\n        'normal',\n        'color',\n        'listpreview'\n      ]),\n      defaultedColumns(1),\n      onAction,\n      onItemAction\n    ]);\n    const createSplitButton = spec => asRaw('SplitButton', splitButtonSchema, spec);\n\n    const factory$d = (detail, spec) => {\n      const setMenus = (comp, menus) => {\n        const newMenus = map$2(menus, m => {\n          const buttonSpec = {\n            type: 'menubutton',\n            text: m.text,\n            fetch: callback => {\n              callback(m.getItems());\n            }\n          };\n          const internal = createMenuButton(buttonSpec).mapError(errInfo => formatError(errInfo)).getOrDie();\n          return renderMenuButton(internal, 'tox-mbtn', spec.backstage, Optional.some('menuitem'));\n        });\n        Replacing.set(comp, newMenus);\n      };\n      const apis = {\n        focus: Keying.focusIn,\n        setMenus\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components: [],\n        behaviours: derive$1([\n          Replacing.config({}),\n          config('menubar-events', [\n            runOnAttached(component => {\n              detail.onSetup(component);\n            }),\n            run$1(mouseover(), (comp, se) => {\n              descendant(comp.element, '.' + 'tox-mbtn--active').each(activeButton => {\n                closest$1(se.event.target, '.' + 'tox-mbtn').each(hoveredButton => {\n                  if (!eq(activeButton, hoveredButton)) {\n                    comp.getSystem().getByDom(activeButton).each(activeComp => {\n                      comp.getSystem().getByDom(hoveredButton).each(hoveredComp => {\n                        Dropdown.expand(hoveredComp);\n                        Dropdown.close(activeComp);\n                        Focusing.focus(hoveredComp);\n                      });\n                    });\n                  }\n                });\n              });\n            }),\n            run$1(focusShifted(), (comp, se) => {\n              se.event.prevFocus.bind(prev => comp.getSystem().getByDom(prev).toOptional()).each(prev => {\n                se.event.newFocus.bind(nu => comp.getSystem().getByDom(nu).toOptional()).each(nu => {\n                  if (Dropdown.isOpen(prev)) {\n                    Dropdown.expand(nu);\n                    Dropdown.close(prev);\n                  }\n                });\n              });\n            })\n          ]),\n          Keying.config({\n            mode: 'flow',\n            selector: '.' + 'tox-mbtn',\n            onEscape: comp => {\n              detail.onEscape(comp);\n              return Optional.some(true);\n            }\n          }),\n          Tabstopping.config({})\n        ]),\n        apis,\n        domModification: { attributes: { role: 'menubar' } }\n      };\n    };\n    var SilverMenubar = single({\n      factory: factory$d,\n      name: 'silver.Menubar',\n      configFields: [\n        required$1('dom'),\n        required$1('uid'),\n        required$1('onEscape'),\n        required$1('backstage'),\n        defaulted('onSetup', noop)\n      ],\n      apis: {\n        focus: (apis, comp) => {\n          apis.focus(comp);\n        },\n        setMenus: (apis, comp, menus) => {\n          apis.setMenus(comp, menus);\n        }\n      }\n    });\n\n    const promotionMessage = '\\u26A1\\ufe0fUpgrade';\n    const promotionLink = 'https://www.tiny.cloud/tinymce-self-hosted-premium-features/?utm_campaign=self_hosted_upgrade_promo&utm_source=tiny&utm_medium=referral';\n    const renderPromotion = spec => {\n      return {\n        uid: spec.uid,\n        dom: spec.dom,\n        components: [{\n            dom: {\n              tag: 'a',\n              attributes: {\n                'href': promotionLink,\n                'rel': 'noopener',\n                'target': '_blank',\n                'aria-hidden': 'true'\n              },\n              classes: ['tox-promotion-link'],\n              innerHtml: promotionMessage\n            }\n          }]\n      };\n    };\n\n    const owner = 'container';\n    const schema$d = [field('slotBehaviours', [])];\n    const getPartName = name => '<alloy.field.' + name + '>';\n    const sketch = sSpec => {\n      const parts = (() => {\n        const record = [];\n        const slot = (name, config) => {\n          record.push(name);\n          return generateOne$1(owner, getPartName(name), config);\n        };\n        return {\n          slot,\n          record: constant$1(record)\n        };\n      })();\n      const spec = sSpec(parts);\n      const partNames = parts.record();\n      const fieldParts = map$2(partNames, n => required({\n        name: n,\n        pname: getPartName(n)\n      }));\n      return composite$1(owner, schema$d, fieldParts, make$1, spec);\n    };\n    const make$1 = (detail, components) => {\n      const getSlotNames = _ => getAllPartNames(detail);\n      const getSlot = (container, key) => getPart(container, detail, key);\n      const onSlot = (f, def) => (container, key) => getPart(container, detail, key).map(slot => f(slot, key)).getOr(def);\n      const onSlots = f => (container, keys) => {\n        each$1(keys, key => f(container, key));\n      };\n      const doShowing = (comp, _key) => get$g(comp.element, 'aria-hidden') !== 'true';\n      const doShow = (comp, key) => {\n        if (!doShowing(comp)) {\n          const element = comp.element;\n          remove$7(element, 'display');\n          remove$8(element, 'aria-hidden');\n          emitWith(comp, slotVisibility(), {\n            name: key,\n            visible: true\n          });\n        }\n      };\n      const doHide = (comp, key) => {\n        if (doShowing(comp)) {\n          const element = comp.element;\n          set$8(element, 'display', 'none');\n          set$9(element, 'aria-hidden', 'true');\n          emitWith(comp, slotVisibility(), {\n            name: key,\n            visible: false\n          });\n        }\n      };\n      const isShowing = onSlot(doShowing, false);\n      const hideSlot = onSlot(doHide);\n      const hideSlots = onSlots(hideSlot);\n      const hideAllSlots = container => hideSlots(container, getSlotNames());\n      const showSlot = onSlot(doShow);\n      const apis = {\n        getSlotNames,\n        getSlot,\n        isShowing,\n        hideSlot,\n        hideAllSlots,\n        showSlot\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components,\n        behaviours: get$4(detail.slotBehaviours),\n        apis\n      };\n    };\n    const slotApis = map$1({\n      getSlotNames: (apis, c) => apis.getSlotNames(c),\n      getSlot: (apis, c, key) => apis.getSlot(c, key),\n      isShowing: (apis, c, key) => apis.isShowing(c, key),\n      hideSlot: (apis, c, key) => apis.hideSlot(c, key),\n      hideAllSlots: (apis, c) => apis.hideAllSlots(c),\n      showSlot: (apis, c, key) => apis.showSlot(c, key)\n    }, value => makeApi(value));\n    const SlotContainer = {\n      ...slotApis,\n      ...{ sketch }\n    };\n\n    const sidebarSchema = objOf([\n      optionalIcon,\n      optionalTooltip,\n      defaultedFunction('onShow', noop),\n      defaultedFunction('onHide', noop),\n      onSetup\n    ]);\n    const createSidebar = spec => asRaw('sidebar', sidebarSchema, spec);\n\n    const setup$8 = editor => {\n      const {sidebars} = editor.ui.registry.getAll();\n      each$1(keys(sidebars), name => {\n        const spec = sidebars[name];\n        const isActive = () => is$1(Optional.from(editor.queryCommandValue('ToggleSidebar')), name);\n        editor.ui.registry.addToggleButton(name, {\n          icon: spec.icon,\n          tooltip: spec.tooltip,\n          onAction: buttonApi => {\n            editor.execCommand('ToggleSidebar', false, name);\n            buttonApi.setActive(isActive());\n          },\n          onSetup: buttonApi => {\n            buttonApi.setActive(isActive());\n            const handleToggle = () => buttonApi.setActive(isActive());\n            editor.on('ToggleSidebar', handleToggle);\n            return () => {\n              editor.off('ToggleSidebar', handleToggle);\n            };\n          }\n        });\n      });\n    };\n    const getApi = comp => ({ element: () => comp.element.dom });\n    const makePanels = (parts, panelConfigs) => {\n      const specs = map$2(keys(panelConfigs), name => {\n        const spec = panelConfigs[name];\n        const bridged = getOrDie(createSidebar(spec));\n        return {\n          name,\n          getApi,\n          onSetup: bridged.onSetup,\n          onShow: bridged.onShow,\n          onHide: bridged.onHide\n        };\n      });\n      return map$2(specs, spec => {\n        const editorOffCell = Cell(noop);\n        return parts.slot(spec.name, {\n          dom: {\n            tag: 'div',\n            classes: ['tox-sidebar__pane']\n          },\n          behaviours: SimpleBehaviours.unnamedEvents([\n            onControlAttached(spec, editorOffCell),\n            onControlDetached(spec, editorOffCell),\n            run$1(slotVisibility(), (sidepanel, se) => {\n              const data = se.event;\n              const optSidePanelSpec = find$5(specs, config => config.name === data.name);\n              optSidePanelSpec.each(sidePanelSpec => {\n                const handler = data.visible ? sidePanelSpec.onShow : sidePanelSpec.onHide;\n                handler(sidePanelSpec.getApi(sidepanel));\n              });\n            })\n          ])\n        });\n      });\n    };\n    const makeSidebar = panelConfigs => SlotContainer.sketch(parts => ({\n      dom: {\n        tag: 'div',\n        classes: ['tox-sidebar__pane-container']\n      },\n      components: makePanels(parts, panelConfigs),\n      slotBehaviours: SimpleBehaviours.unnamedEvents([runOnAttached(slotContainer => SlotContainer.hideAllSlots(slotContainer))])\n    }));\n    const setSidebar = (sidebar, panelConfigs, showSidebar) => {\n      const optSlider = Composing.getCurrent(sidebar);\n      optSlider.each(slider => {\n        Replacing.set(slider, [makeSidebar(panelConfigs)]);\n        const configKey = showSidebar === null || showSidebar === void 0 ? void 0 : showSidebar.toLowerCase();\n        if (isString(configKey) && has$2(panelConfigs, configKey)) {\n          Composing.getCurrent(slider).each(slotContainer => {\n            SlotContainer.showSlot(slotContainer, configKey);\n            Sliding.immediateGrow(slider);\n            remove$7(slider.element, 'width');\n            updateSidebarRoleOnToggle(sidebar.element, 'region');\n          });\n        }\n      });\n    };\n    const updateSidebarRoleOnToggle = (sidebar, sidebarState) => {\n      set$9(sidebar, 'role', sidebarState);\n    };\n    const toggleSidebar = (sidebar, name) => {\n      const optSlider = Composing.getCurrent(sidebar);\n      optSlider.each(slider => {\n        const optSlotContainer = Composing.getCurrent(slider);\n        optSlotContainer.each(slotContainer => {\n          if (Sliding.hasGrown(slider)) {\n            if (SlotContainer.isShowing(slotContainer, name)) {\n              Sliding.shrink(slider);\n              updateSidebarRoleOnToggle(sidebar.element, 'presentation');\n            } else {\n              SlotContainer.hideAllSlots(slotContainer);\n              SlotContainer.showSlot(slotContainer, name);\n              updateSidebarRoleOnToggle(sidebar.element, 'region');\n            }\n          } else {\n            SlotContainer.hideAllSlots(slotContainer);\n            SlotContainer.showSlot(slotContainer, name);\n            Sliding.grow(slider);\n            updateSidebarRoleOnToggle(sidebar.element, 'region');\n          }\n        });\n      });\n    };\n    const whichSidebar = sidebar => {\n      const optSlider = Composing.getCurrent(sidebar);\n      return optSlider.bind(slider => {\n        const sidebarOpen = Sliding.isGrowing(slider) || Sliding.hasGrown(slider);\n        if (sidebarOpen) {\n          const optSlotContainer = Composing.getCurrent(slider);\n          return optSlotContainer.bind(slotContainer => find$5(SlotContainer.getSlotNames(slotContainer), name => SlotContainer.isShowing(slotContainer, name)));\n        } else {\n          return Optional.none();\n        }\n      });\n    };\n    const fixSize = generate$6('FixSizeEvent');\n    const autoSize = generate$6('AutoSizeEvent');\n    const renderSidebar = spec => ({\n      uid: spec.uid,\n      dom: {\n        tag: 'div',\n        classes: ['tox-sidebar'],\n        attributes: { role: 'presentation' }\n      },\n      components: [{\n          dom: {\n            tag: 'div',\n            classes: ['tox-sidebar__slider']\n          },\n          components: [],\n          behaviours: derive$1([\n            Tabstopping.config({}),\n            Focusing.config({}),\n            Sliding.config({\n              dimension: { property: 'width' },\n              closedClass: 'tox-sidebar--sliding-closed',\n              openClass: 'tox-sidebar--sliding-open',\n              shrinkingClass: 'tox-sidebar--sliding-shrinking',\n              growingClass: 'tox-sidebar--sliding-growing',\n              onShrunk: slider => {\n                const optSlotContainer = Composing.getCurrent(slider);\n                optSlotContainer.each(SlotContainer.hideAllSlots);\n                emit(slider, autoSize);\n              },\n              onGrown: slider => {\n                emit(slider, autoSize);\n              },\n              onStartGrow: slider => {\n                emitWith(slider, fixSize, { width: getRaw(slider.element, 'width').getOr('') });\n              },\n              onStartShrink: slider => {\n                emitWith(slider, fixSize, { width: get$d(slider.element) + 'px' });\n              }\n            }),\n            Replacing.config({}),\n            Composing.config({\n              find: comp => {\n                const children = Replacing.contents(comp);\n                return head(children);\n              }\n            })\n          ])\n        }],\n      behaviours: derive$1([\n        ComposingConfigs.childAt(0),\n        config('sidebar-sliding-events', [\n          run$1(fixSize, (comp, se) => {\n            set$8(comp.element, 'width', se.event.width);\n          }),\n          run$1(autoSize, (comp, _se) => {\n            remove$7(comp.element, 'width');\n          })\n        ])\n      ])\n    });\n\n    const block = (component, config, state, getBusySpec) => {\n      set$9(component.element, 'aria-busy', true);\n      const root = config.getRoot(component).getOr(component);\n      const blockerBehaviours = derive$1([\n        Keying.config({\n          mode: 'special',\n          onTab: () => Optional.some(true),\n          onShiftTab: () => Optional.some(true)\n        }),\n        Focusing.config({})\n      ]);\n      const blockSpec = getBusySpec(root, blockerBehaviours);\n      const blocker = root.getSystem().build(blockSpec);\n      Replacing.append(root, premade(blocker));\n      if (blocker.hasConfigured(Keying) && config.focus) {\n        Keying.focusIn(blocker);\n      }\n      if (!state.isBlocked()) {\n        config.onBlock(component);\n      }\n      state.blockWith(() => Replacing.remove(root, blocker));\n    };\n    const unblock = (component, config, state) => {\n      remove$8(component.element, 'aria-busy');\n      if (state.isBlocked()) {\n        config.onUnblock(component);\n      }\n      state.clear();\n    };\n    const isBlocked = (component, blockingConfig, blockingState) => blockingState.isBlocked();\n\n    var BlockingApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        block: block,\n        unblock: unblock,\n        isBlocked: isBlocked\n    });\n\n    var BlockingSchema = [\n      defaultedFunction('getRoot', Optional.none),\n      defaultedBoolean('focus', true),\n      onHandler('onBlock'),\n      onHandler('onUnblock')\n    ];\n\n    const init$4 = () => {\n      const blocker = destroyable();\n      const blockWith = destroy => {\n        blocker.set({ destroy });\n      };\n      return nu$7({\n        readState: blocker.isSet,\n        blockWith,\n        clear: blocker.clear,\n        isBlocked: blocker.isSet\n      });\n    };\n\n    var BlockingState = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        init: init$4\n    });\n\n    const Blocking = create$4({\n      fields: BlockingSchema,\n      name: 'blocking',\n      apis: BlockingApis,\n      state: BlockingState\n    });\n\n    const getBusySpec$1 = providerBackstage => (_root, _behaviours) => ({\n      dom: {\n        tag: 'div',\n        attributes: {\n          'aria-label': providerBackstage.translate('Loading...'),\n          'tabindex': '0'\n        },\n        classes: ['tox-throbber__busy-spinner']\n      },\n      components: [{ dom: fromHtml('<div class=\"tox-spinner\"><div></div><div></div><div></div></div>') }]\n    });\n    const focusBusyComponent = throbber => Composing.getCurrent(throbber).each(comp => focus$3(comp.element, true));\n    const toggleEditorTabIndex = (editor, state) => {\n      const tabIndexAttr = 'tabindex';\n      const dataTabIndexAttr = `data-mce-${ tabIndexAttr }`;\n      Optional.from(editor.iframeElement).map(SugarElement.fromDom).each(iframe => {\n        if (state) {\n          getOpt(iframe, tabIndexAttr).each(tabIndex => set$9(iframe, dataTabIndexAttr, tabIndex));\n          set$9(iframe, tabIndexAttr, -1);\n        } else {\n          remove$8(iframe, tabIndexAttr);\n          getOpt(iframe, dataTabIndexAttr).each(tabIndex => {\n            set$9(iframe, tabIndexAttr, tabIndex);\n            remove$8(iframe, dataTabIndexAttr);\n          });\n        }\n      });\n    };\n    const toggleThrobber = (editor, comp, state, providerBackstage) => {\n      const element = comp.element;\n      toggleEditorTabIndex(editor, state);\n      if (state) {\n        Blocking.block(comp, getBusySpec$1(providerBackstage));\n        remove$7(element, 'display');\n        remove$8(element, 'aria-hidden');\n        if (editor.hasFocus()) {\n          focusBusyComponent(comp);\n        }\n      } else {\n        const throbberFocus = Composing.getCurrent(comp).exists(busyComp => hasFocus(busyComp.element));\n        Blocking.unblock(comp);\n        set$8(element, 'display', 'none');\n        set$9(element, 'aria-hidden', 'true');\n        if (throbberFocus) {\n          editor.focus();\n        }\n      }\n    };\n    const renderThrobber = spec => ({\n      uid: spec.uid,\n      dom: {\n        tag: 'div',\n        attributes: { 'aria-hidden': 'true' },\n        classes: ['tox-throbber'],\n        styles: { display: 'none' }\n      },\n      behaviours: derive$1([\n        Replacing.config({}),\n        Blocking.config({ focus: false }),\n        Composing.config({ find: comp => head(comp.components()) })\n      ]),\n      components: []\n    });\n    const isFocusEvent = event => event.type === 'focusin';\n    const isPasteBinTarget = event => {\n      if (isFocusEvent(event)) {\n        const node = event.composed ? head(event.composedPath()) : Optional.from(event.target);\n        return node.map(SugarElement.fromDom).filter(isElement$1).exists(targetElm => has(targetElm, 'mce-pastebin'));\n      } else {\n        return false;\n      }\n    };\n    const setup$7 = (editor, lazyThrobber, sharedBackstage) => {\n      const throbberState = Cell(false);\n      const timer = value$4();\n      const stealFocus = e => {\n        if (throbberState.get() && !isPasteBinTarget(e)) {\n          e.preventDefault();\n          focusBusyComponent(lazyThrobber());\n          editor.editorManager.setActive(editor);\n        }\n      };\n      if (!editor.inline) {\n        editor.on('PreInit', () => {\n          editor.dom.bind(editor.getWin(), 'focusin', stealFocus);\n          editor.on('BeforeExecCommand', e => {\n            if (e.command.toLowerCase() === 'mcefocus' && e.value !== true) {\n              stealFocus(e);\n            }\n          });\n        });\n      }\n      const toggle = state => {\n        if (state !== throbberState.get()) {\n          throbberState.set(state);\n          toggleThrobber(editor, lazyThrobber(), state, sharedBackstage.providers);\n          fireAfterProgressState(editor, state);\n        }\n      };\n      editor.on('ProgressState', e => {\n        timer.on(clearTimeout);\n        if (isNumber(e.time)) {\n          const timerId = global$9.setEditorTimeout(editor, () => toggle(e.state), e.time);\n          timer.set(timerId);\n        } else {\n          toggle(e.state);\n          timer.clear();\n        }\n      });\n    };\n\n    const generate$1 = (xs, f) => {\n      const init = {\n        len: 0,\n        list: []\n      };\n      const r = foldl(xs, (b, a) => {\n        const value = f(a, b.len);\n        return value.fold(constant$1(b), v => ({\n          len: v.finish,\n          list: b.list.concat([v])\n        }));\n      }, init);\n      return r.list;\n    };\n\n    const output = (within, extra, withinWidth) => ({\n      within,\n      extra,\n      withinWidth\n    });\n    const apportion = (units, total, len) => {\n      const parray = generate$1(units, (unit, current) => {\n        const width = len(unit);\n        return Optional.some({\n          element: unit,\n          start: current,\n          finish: current + width,\n          width\n        });\n      });\n      const within = filter$2(parray, unit => unit.finish <= total);\n      const withinWidth = foldr(within, (acc, el) => acc + el.width, 0);\n      const extra = parray.slice(within.length);\n      return {\n        within,\n        extra,\n        withinWidth\n      };\n    };\n    const toUnit = parray => map$2(parray, unit => unit.element);\n    const fitLast = (within, extra, withinWidth) => {\n      const fits = toUnit(within.concat(extra));\n      return output(fits, [], withinWidth);\n    };\n    const overflow = (within, extra, overflower, withinWidth) => {\n      const fits = toUnit(within).concat([overflower]);\n      return output(fits, toUnit(extra), withinWidth);\n    };\n    const fitAll = (within, extra, withinWidth) => output(toUnit(within), [], withinWidth);\n    const tryFit = (total, units, len) => {\n      const divide = apportion(units, total, len);\n      return divide.extra.length === 0 ? Optional.some(divide) : Optional.none();\n    };\n    const partition = (total, units, len, overflower) => {\n      const divide = tryFit(total, units, len).getOrThunk(() => apportion(units, total - len(overflower), len));\n      const within = divide.within;\n      const extra = divide.extra;\n      const withinWidth = divide.withinWidth;\n      if (extra.length === 1 && extra[0].width <= len(overflower)) {\n        return fitLast(within, extra, withinWidth);\n      } else if (extra.length >= 1) {\n        return overflow(within, extra, overflower, withinWidth);\n      } else {\n        return fitAll(within, extra, withinWidth);\n      }\n    };\n\n    const setGroups$1 = (toolbar, storedGroups) => {\n      const bGroups = map$2(storedGroups, g => premade(g));\n      Toolbar.setGroups(toolbar, bGroups);\n    };\n    const findFocusedComp = comps => findMap(comps, comp => search(comp.element).bind(focusedElm => comp.getSystem().getByDom(focusedElm).toOptional()));\n    const refresh$2 = (toolbar, detail, setOverflow) => {\n      const builtGroups = detail.builtGroups.get();\n      if (builtGroups.length === 0) {\n        return;\n      }\n      const primary = getPartOrDie(toolbar, detail, 'primary');\n      const overflowGroup = Coupling.getCoupled(toolbar, 'overflowGroup');\n      set$8(primary.element, 'visibility', 'hidden');\n      const groups = builtGroups.concat([overflowGroup]);\n      const focusedComp = findFocusedComp(groups);\n      setOverflow([]);\n      setGroups$1(primary, groups);\n      const availableWidth = get$d(primary.element);\n      const overflows = partition(availableWidth, detail.builtGroups.get(), comp => Math.ceil(comp.element.dom.getBoundingClientRect().width), overflowGroup);\n      if (overflows.extra.length === 0) {\n        Replacing.remove(primary, overflowGroup);\n        setOverflow([]);\n      } else {\n        setGroups$1(primary, overflows.within);\n        setOverflow(overflows.extra);\n      }\n      remove$7(primary.element, 'visibility');\n      reflow(primary.element);\n      focusedComp.each(Focusing.focus);\n    };\n\n    const schema$c = constant$1([\n      field('splitToolbarBehaviours', [Coupling]),\n      customField('builtGroups', () => Cell([]))\n    ]);\n\n    const schema$b = constant$1([\n      markers$1(['overflowToggledClass']),\n      optionFunction('getOverflowBounds'),\n      required$1('lazySink'),\n      customField('overflowGroups', () => Cell([])),\n      onHandler('onOpened'),\n      onHandler('onClosed')\n    ].concat(schema$c()));\n    const parts$7 = constant$1([\n      required({\n        factory: Toolbar,\n        schema: schema$e(),\n        name: 'primary'\n      }),\n      external({\n        schema: schema$e(),\n        name: 'overflow'\n      }),\n      external({ name: 'overflow-button' }),\n      external({ name: 'overflow-group' })\n    ]);\n\n    const expandable = constant$1((element, available) => {\n      setMax(element, Math.floor(available));\n    });\n\n    const schema$a = constant$1([\n      markers$1(['toggledClass']),\n      required$1('lazySink'),\n      requiredFunction('fetch'),\n      optionFunction('getBounds'),\n      optionObjOf('fireDismissalEventInstead', [defaulted('event', dismissRequested())]),\n      schema$y(),\n      onHandler('onToggled')\n    ]);\n    const parts$6 = constant$1([\n      external({\n        name: 'button',\n        overrides: detail => ({\n          dom: { attributes: { 'aria-haspopup': 'true' } },\n          buttonBehaviours: derive$1([Toggling.config({\n              toggleClass: detail.markers.toggledClass,\n              aria: { mode: 'expanded' },\n              toggleOnExecute: false,\n              onToggled: detail.onToggled\n            })])\n        })\n      }),\n      external({\n        factory: Toolbar,\n        schema: schema$e(),\n        name: 'toolbar',\n        overrides: detail => {\n          return {\n            toolbarBehaviours: derive$1([Keying.config({\n                mode: 'cyclic',\n                onEscape: comp => {\n                  getPart(comp, detail, 'button').each(Focusing.focus);\n                  return Optional.none();\n                }\n              })])\n          };\n        }\n      })\n    ]);\n\n    const shouldSkipFocus = value$4();\n    const toggleWithoutFocusing = (button, externals) => {\n      shouldSkipFocus.set(true);\n      toggle(button, externals);\n      shouldSkipFocus.clear();\n    };\n    const toggle = (button, externals) => {\n      const toolbarSandbox = Coupling.getCoupled(button, 'toolbarSandbox');\n      if (Sandboxing.isOpen(toolbarSandbox)) {\n        Sandboxing.close(toolbarSandbox);\n      } else {\n        Sandboxing.open(toolbarSandbox, externals.toolbar());\n      }\n    };\n    const position = (button, toolbar, detail, layouts) => {\n      const bounds = detail.getBounds.map(bounder => bounder());\n      const sink = detail.lazySink(button).getOrDie();\n      Positioning.positionWithinBounds(sink, toolbar, {\n        anchor: {\n          type: 'hotspot',\n          hotspot: button,\n          layouts,\n          overrides: { maxWidthFunction: expandable() }\n        }\n      }, bounds);\n    };\n    const setGroups = (button, toolbar, detail, layouts, groups) => {\n      Toolbar.setGroups(toolbar, groups);\n      position(button, toolbar, detail, layouts);\n      Toggling.on(button);\n    };\n    const makeSandbox = (button, spec, detail) => {\n      const ariaControls = manager();\n      const onOpen = (sandbox, toolbar) => {\n        const skipFocus = shouldSkipFocus.get().getOr(false);\n        detail.fetch().get(groups => {\n          setGroups(button, toolbar, detail, spec.layouts, groups);\n          ariaControls.link(button.element);\n          if (!skipFocus) {\n            Keying.focusIn(toolbar);\n          }\n        });\n      };\n      const onClose = () => {\n        Toggling.off(button);\n        if (!shouldSkipFocus.get().getOr(false)) {\n          Focusing.focus(button);\n        }\n        ariaControls.unlink(button.element);\n      };\n      return {\n        dom: {\n          tag: 'div',\n          attributes: { id: ariaControls.id }\n        },\n        behaviours: derive$1([\n          Keying.config({\n            mode: 'special',\n            onEscape: comp => {\n              Sandboxing.close(comp);\n              return Optional.some(true);\n            }\n          }),\n          Sandboxing.config({\n            onOpen,\n            onClose,\n            isPartOf: (container, data, queryElem) => {\n              return isPartOf$1(data, queryElem) || isPartOf$1(button, queryElem);\n            },\n            getAttachPoint: () => {\n              return detail.lazySink(button).getOrDie();\n            }\n          }),\n          Receiving.config({\n            channels: {\n              ...receivingChannel$1({\n                isExtraPart: never,\n                ...detail.fireDismissalEventInstead.map(fe => ({ fireEventInstead: { event: fe.event } })).getOr({})\n              }),\n              ...receivingChannel({\n                doReposition: () => {\n                  Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each(toolbar => {\n                    position(button, toolbar, detail, spec.layouts);\n                  });\n                }\n              })\n            }\n          })\n        ])\n      };\n    };\n    const factory$c = (detail, components, spec, externals) => ({\n      ...Button.sketch({\n        ...externals.button(),\n        action: button => {\n          toggle(button, externals);\n        },\n        buttonBehaviours: SketchBehaviours.augment({ dump: externals.button().buttonBehaviours }, [Coupling.config({\n            others: {\n              toolbarSandbox: button => {\n                return makeSandbox(button, spec, detail);\n              }\n            }\n          })])\n      }),\n      apis: {\n        setGroups: (button, groups) => {\n          Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each(toolbar => {\n            setGroups(button, toolbar, detail, spec.layouts, groups);\n          });\n        },\n        reposition: button => {\n          Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each(toolbar => {\n            position(button, toolbar, detail, spec.layouts);\n          });\n        },\n        toggle: button => {\n          toggle(button, externals);\n        },\n        toggleWithoutFocusing: button => {\n          toggleWithoutFocusing(button, externals);\n        },\n        getToolbar: button => {\n          return Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox'));\n        },\n        isOpen: button => {\n          return Sandboxing.isOpen(Coupling.getCoupled(button, 'toolbarSandbox'));\n        }\n      }\n    });\n    const FloatingToolbarButton = composite({\n      name: 'FloatingToolbarButton',\n      factory: factory$c,\n      configFields: schema$a(),\n      partFields: parts$6(),\n      apis: {\n        setGroups: (apis, button, groups) => {\n          apis.setGroups(button, groups);\n        },\n        reposition: (apis, button) => {\n          apis.reposition(button);\n        },\n        toggle: (apis, button) => {\n          apis.toggle(button);\n        },\n        toggleWithoutFocusing: (apis, button) => {\n          apis.toggleWithoutFocusing(button);\n        },\n        getToolbar: (apis, button) => apis.getToolbar(button),\n        isOpen: (apis, button) => apis.isOpen(button)\n      }\n    });\n\n    const schema$9 = constant$1([\n      required$1('items'),\n      markers$1(['itemSelector']),\n      field('tgroupBehaviours', [Keying])\n    ]);\n    const parts$5 = constant$1([group({\n        name: 'items',\n        unit: 'item'\n      })]);\n\n    const factory$b = (detail, components, _spec, _externals) => ({\n      uid: detail.uid,\n      dom: detail.dom,\n      components,\n      behaviours: augment(detail.tgroupBehaviours, [Keying.config({\n          mode: 'flow',\n          selector: detail.markers.itemSelector\n        })]),\n      domModification: { attributes: { role: 'toolbar' } }\n    });\n    const ToolbarGroup = composite({\n      name: 'ToolbarGroup',\n      configFields: schema$9(),\n      partFields: parts$5(),\n      factory: factory$b\n    });\n\n    const buildGroups = comps => map$2(comps, g => premade(g));\n    const refresh$1 = (toolbar, memFloatingToolbarButton, detail) => {\n      refresh$2(toolbar, detail, overflowGroups => {\n        detail.overflowGroups.set(overflowGroups);\n        memFloatingToolbarButton.getOpt(toolbar).each(floatingToolbarButton => {\n          FloatingToolbarButton.setGroups(floatingToolbarButton, buildGroups(overflowGroups));\n        });\n      });\n    };\n    const factory$a = (detail, components, spec, externals) => {\n      const memFloatingToolbarButton = record(FloatingToolbarButton.sketch({\n        fetch: () => Future.nu(resolve => {\n          resolve(buildGroups(detail.overflowGroups.get()));\n        }),\n        layouts: {\n          onLtr: () => [\n            southwest$2,\n            southeast$2\n          ],\n          onRtl: () => [\n            southeast$2,\n            southwest$2\n          ],\n          onBottomLtr: () => [\n            northwest$2,\n            northeast$2\n          ],\n          onBottomRtl: () => [\n            northeast$2,\n            northwest$2\n          ]\n        },\n        getBounds: spec.getOverflowBounds,\n        lazySink: detail.lazySink,\n        fireDismissalEventInstead: {},\n        markers: { toggledClass: detail.markers.overflowToggledClass },\n        parts: {\n          button: externals['overflow-button'](),\n          toolbar: externals.overflow()\n        },\n        onToggled: (comp, state) => detail[state ? 'onOpened' : 'onClosed'](comp)\n      }));\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components,\n        behaviours: augment(detail.splitToolbarBehaviours, [Coupling.config({\n            others: {\n              overflowGroup: () => {\n                return ToolbarGroup.sketch({\n                  ...externals['overflow-group'](),\n                  items: [memFloatingToolbarButton.asSpec()]\n                });\n              }\n            }\n          })]),\n        apis: {\n          setGroups: (toolbar, groups) => {\n            detail.builtGroups.set(map$2(groups, toolbar.getSystem().build));\n            refresh$1(toolbar, memFloatingToolbarButton, detail);\n          },\n          refresh: toolbar => refresh$1(toolbar, memFloatingToolbarButton, detail),\n          toggle: toolbar => {\n            memFloatingToolbarButton.getOpt(toolbar).each(floatingToolbarButton => {\n              FloatingToolbarButton.toggle(floatingToolbarButton);\n            });\n          },\n          toggleWithoutFocusing: toolbar => {\n            memFloatingToolbarButton.getOpt(toolbar).each(FloatingToolbarButton.toggleWithoutFocusing);\n          },\n          isOpen: toolbar => memFloatingToolbarButton.getOpt(toolbar).map(FloatingToolbarButton.isOpen).getOr(false),\n          reposition: toolbar => {\n            memFloatingToolbarButton.getOpt(toolbar).each(floatingToolbarButton => {\n              FloatingToolbarButton.reposition(floatingToolbarButton);\n            });\n          },\n          getOverflow: toolbar => memFloatingToolbarButton.getOpt(toolbar).bind(FloatingToolbarButton.getToolbar)\n        },\n        domModification: { attributes: { role: 'group' } }\n      };\n    };\n    const SplitFloatingToolbar = composite({\n      name: 'SplitFloatingToolbar',\n      configFields: schema$b(),\n      partFields: parts$7(),\n      factory: factory$a,\n      apis: {\n        setGroups: (apis, toolbar, groups) => {\n          apis.setGroups(toolbar, groups);\n        },\n        refresh: (apis, toolbar) => {\n          apis.refresh(toolbar);\n        },\n        reposition: (apis, toolbar) => {\n          apis.reposition(toolbar);\n        },\n        toggle: (apis, toolbar) => {\n          apis.toggle(toolbar);\n        },\n        toggleWithoutFocusing: (apis, toolbar) => {\n          apis.toggle(toolbar);\n        },\n        isOpen: (apis, toolbar) => apis.isOpen(toolbar),\n        getOverflow: (apis, toolbar) => apis.getOverflow(toolbar)\n      }\n    });\n\n    const schema$8 = constant$1([\n      markers$1([\n        'closedClass',\n        'openClass',\n        'shrinkingClass',\n        'growingClass',\n        'overflowToggledClass'\n      ]),\n      onHandler('onOpened'),\n      onHandler('onClosed')\n    ].concat(schema$c()));\n    const parts$4 = constant$1([\n      required({\n        factory: Toolbar,\n        schema: schema$e(),\n        name: 'primary'\n      }),\n      required({\n        factory: Toolbar,\n        schema: schema$e(),\n        name: 'overflow',\n        overrides: detail => {\n          return {\n            toolbarBehaviours: derive$1([\n              Sliding.config({\n                dimension: { property: 'height' },\n                closedClass: detail.markers.closedClass,\n                openClass: detail.markers.openClass,\n                shrinkingClass: detail.markers.shrinkingClass,\n                growingClass: detail.markers.growingClass,\n                onShrunk: comp => {\n                  getPart(comp, detail, 'overflow-button').each(button => {\n                    Toggling.off(button);\n                  });\n                  detail.onClosed(comp);\n                },\n                onGrown: comp => {\n                  detail.onOpened(comp);\n                },\n                onStartGrow: comp => {\n                  getPart(comp, detail, 'overflow-button').each(Toggling.on);\n                }\n              }),\n              Keying.config({\n                mode: 'acyclic',\n                onEscape: comp => {\n                  getPart(comp, detail, 'overflow-button').each(Focusing.focus);\n                  return Optional.some(true);\n                }\n              })\n            ])\n          };\n        }\n      }),\n      external({\n        name: 'overflow-button',\n        overrides: detail => ({\n          buttonBehaviours: derive$1([Toggling.config({\n              toggleClass: detail.markers.overflowToggledClass,\n              aria: { mode: 'expanded' },\n              toggleOnExecute: false\n            })])\n        })\n      }),\n      external({ name: 'overflow-group' })\n    ]);\n\n    const isOpen = (toolbar, detail) => getPart(toolbar, detail, 'overflow').map(Sliding.hasGrown).getOr(false);\n    const toggleToolbar = (toolbar, detail, skipFocus) => {\n      getPart(toolbar, detail, 'overflow-button').each(oveflowButton => {\n        getPart(toolbar, detail, 'overflow').each(overf => {\n          refresh(toolbar, detail);\n          if (Sliding.hasShrunk(overf)) {\n            const fn = detail.onOpened;\n            detail.onOpened = comp => {\n              if (!skipFocus) {\n                Keying.focusIn(overf);\n              }\n              fn(comp);\n              detail.onOpened = fn;\n            };\n          } else {\n            const fn = detail.onClosed;\n            detail.onClosed = comp => {\n              if (!skipFocus) {\n                Focusing.focus(oveflowButton);\n              }\n              fn(comp);\n              detail.onClosed = fn;\n            };\n          }\n          Sliding.toggleGrow(overf);\n        });\n      });\n    };\n    const refresh = (toolbar, detail) => {\n      getPart(toolbar, detail, 'overflow').each(overflow => {\n        refresh$2(toolbar, detail, groups => {\n          const builtGroups = map$2(groups, g => premade(g));\n          Toolbar.setGroups(overflow, builtGroups);\n        });\n        getPart(toolbar, detail, 'overflow-button').each(button => {\n          if (Sliding.hasGrown(overflow)) {\n            Toggling.on(button);\n          }\n        });\n        Sliding.refresh(overflow);\n      });\n    };\n    const factory$9 = (detail, components, spec, externals) => {\n      const toolbarToggleEvent = 'alloy.toolbar.toggle';\n      const doSetGroups = (toolbar, groups) => {\n        const built = map$2(groups, toolbar.getSystem().build);\n        detail.builtGroups.set(built);\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components,\n        behaviours: augment(detail.splitToolbarBehaviours, [\n          Coupling.config({\n            others: {\n              overflowGroup: toolbar => {\n                return ToolbarGroup.sketch({\n                  ...externals['overflow-group'](),\n                  items: [Button.sketch({\n                      ...externals['overflow-button'](),\n                      action: _button => {\n                        emit(toolbar, toolbarToggleEvent);\n                      }\n                    })]\n                });\n              }\n            }\n          }),\n          config('toolbar-toggle-events', [run$1(toolbarToggleEvent, toolbar => {\n              toggleToolbar(toolbar, detail, false);\n            })])\n        ]),\n        apis: {\n          setGroups: (toolbar, groups) => {\n            doSetGroups(toolbar, groups);\n            refresh(toolbar, detail);\n          },\n          refresh: toolbar => refresh(toolbar, detail),\n          toggle: toolbar => {\n            toggleToolbar(toolbar, detail, false);\n          },\n          toggleWithoutFocusing: toolbar => {\n            toggleToolbar(toolbar, detail, true);\n          },\n          isOpen: toolbar => isOpen(toolbar, detail)\n        },\n        domModification: { attributes: { role: 'group' } }\n      };\n    };\n    const SplitSlidingToolbar = composite({\n      name: 'SplitSlidingToolbar',\n      configFields: schema$8(),\n      partFields: parts$4(),\n      factory: factory$9,\n      apis: {\n        setGroups: (apis, toolbar, groups) => {\n          apis.setGroups(toolbar, groups);\n        },\n        refresh: (apis, toolbar) => {\n          apis.refresh(toolbar);\n        },\n        toggle: (apis, toolbar) => {\n          apis.toggle(toolbar);\n        },\n        isOpen: (apis, toolbar) => apis.isOpen(toolbar)\n      }\n    });\n\n    const renderToolbarGroupCommon = toolbarGroup => {\n      const attributes = toolbarGroup.title.fold(() => ({}), title => ({ attributes: { title } }));\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-toolbar__group'],\n          ...attributes\n        },\n        components: [ToolbarGroup.parts.items({})],\n        items: toolbarGroup.items,\n        markers: { itemSelector: '*:not(.tox-split-button) > .tox-tbtn:not([disabled]), ' + '.tox-split-button:not([disabled]), ' + '.tox-toolbar-nav-js:not([disabled]), ' + '.tox-number-input:not([disabled])' },\n        tgroupBehaviours: derive$1([\n          Tabstopping.config({}),\n          Focusing.config({})\n        ])\n      };\n    };\n    const renderToolbarGroup = toolbarGroup => ToolbarGroup.sketch(renderToolbarGroupCommon(toolbarGroup));\n    const getToolbarBehaviours = (toolbarSpec, modeName) => {\n      const onAttached = runOnAttached(component => {\n        const groups = map$2(toolbarSpec.initGroups, renderToolbarGroup);\n        Toolbar.setGroups(component, groups);\n      });\n      return derive$1([\n        DisablingConfigs.toolbarButton(toolbarSpec.providers.isDisabled),\n        receivingConfig(),\n        Keying.config({\n          mode: modeName,\n          onEscape: toolbarSpec.onEscape,\n          selector: '.tox-toolbar__group'\n        }),\n        config('toolbar-events', [onAttached])\n      ]);\n    };\n    const renderMoreToolbarCommon = toolbarSpec => {\n      const modeName = toolbarSpec.cyclicKeying ? 'cyclic' : 'acyclic';\n      return {\n        uid: toolbarSpec.uid,\n        dom: {\n          tag: 'div',\n          classes: ['tox-toolbar-overlord']\n        },\n        parts: {\n          'overflow-group': renderToolbarGroupCommon({\n            title: Optional.none(),\n            items: []\n          }),\n          'overflow-button': renderIconButtonSpec({\n            name: 'more',\n            icon: Optional.some('more-drawer'),\n            enabled: true,\n            tooltip: Optional.some('Reveal or hide additional toolbar items'),\n            primary: false,\n            buttonType: Optional.none(),\n            borderless: false\n          }, Optional.none(), toolbarSpec.providers, [], 'overflow-button')\n        },\n        splitToolbarBehaviours: getToolbarBehaviours(toolbarSpec, modeName)\n      };\n    };\n    const renderFloatingMoreToolbar = toolbarSpec => {\n      const baseSpec = renderMoreToolbarCommon(toolbarSpec);\n      const overflowXOffset = 4;\n      const primary = SplitFloatingToolbar.parts.primary({\n        dom: {\n          tag: 'div',\n          classes: ['tox-toolbar__primary']\n        }\n      });\n      return SplitFloatingToolbar.sketch({\n        ...baseSpec,\n        lazySink: toolbarSpec.getSink,\n        getOverflowBounds: () => {\n          const headerElem = toolbarSpec.moreDrawerData.lazyHeader().element;\n          const headerBounds = absolute$2(headerElem);\n          const docElem = documentElement(headerElem);\n          const docBounds = absolute$2(docElem);\n          const height = Math.max(docElem.dom.scrollHeight, docBounds.height);\n          return bounds(headerBounds.x + overflowXOffset, docBounds.y, headerBounds.width - overflowXOffset * 2, height);\n        },\n        parts: {\n          ...baseSpec.parts,\n          overflow: {\n            dom: {\n              tag: 'div',\n              classes: ['tox-toolbar__overflow'],\n              attributes: toolbarSpec.attributes\n            }\n          }\n        },\n        components: [primary],\n        markers: { overflowToggledClass: 'tox-tbtn--enabled' },\n        onOpened: comp => toolbarSpec.onToggled(comp, true),\n        onClosed: comp => toolbarSpec.onToggled(comp, false)\n      });\n    };\n    const renderSlidingMoreToolbar = toolbarSpec => {\n      const primary = SplitSlidingToolbar.parts.primary({\n        dom: {\n          tag: 'div',\n          classes: ['tox-toolbar__primary']\n        }\n      });\n      const overflow = SplitSlidingToolbar.parts.overflow({\n        dom: {\n          tag: 'div',\n          classes: ['tox-toolbar__overflow']\n        }\n      });\n      const baseSpec = renderMoreToolbarCommon(toolbarSpec);\n      return SplitSlidingToolbar.sketch({\n        ...baseSpec,\n        components: [\n          primary,\n          overflow\n        ],\n        markers: {\n          openClass: 'tox-toolbar__overflow--open',\n          closedClass: 'tox-toolbar__overflow--closed',\n          growingClass: 'tox-toolbar__overflow--growing',\n          shrinkingClass: 'tox-toolbar__overflow--shrinking',\n          overflowToggledClass: 'tox-tbtn--enabled'\n        },\n        onOpened: comp => {\n          comp.getSystem().broadcastOn([toolbarHeightChange()], { type: 'opened' });\n          toolbarSpec.onToggled(comp, true);\n        },\n        onClosed: comp => {\n          comp.getSystem().broadcastOn([toolbarHeightChange()], { type: 'closed' });\n          toolbarSpec.onToggled(comp, false);\n        }\n      });\n    };\n    const renderToolbar = toolbarSpec => {\n      const modeName = toolbarSpec.cyclicKeying ? 'cyclic' : 'acyclic';\n      return Toolbar.sketch({\n        uid: toolbarSpec.uid,\n        dom: {\n          tag: 'div',\n          classes: ['tox-toolbar'].concat(toolbarSpec.type === ToolbarMode$1.scrolling ? ['tox-toolbar--scrolling'] : [])\n        },\n        components: [Toolbar.parts.groups({})],\n        toolbarBehaviours: getToolbarBehaviours(toolbarSpec, modeName)\n      });\n    };\n\n    const baseButtonFields = [\n      optionalText,\n      optionalIcon,\n      optionString('tooltip'),\n      defaultedStringEnum('buttonType', 'secondary', [\n        'primary',\n        'secondary'\n      ]),\n      defaultedBoolean('borderless', false),\n      requiredFunction('onAction')\n    ];\n    const normalButtonFields = [\n      ...baseButtonFields,\n      text,\n      requiredStringEnum('type', ['button'])\n    ];\n    const toggleButtonFields = [\n      ...baseButtonFields,\n      defaultedBoolean('active', false),\n      requiredStringEnum('type', ['togglebutton'])\n    ];\n    const schemaWithoutGroupButton = {\n      button: normalButtonFields,\n      togglebutton: toggleButtonFields\n    };\n    const groupFields = [\n      requiredStringEnum('type', ['group']),\n      defaultedArrayOf('buttons', [], choose$1('type', schemaWithoutGroupButton))\n    ];\n    const viewButtonSchema = choose$1('type', {\n      ...schemaWithoutGroupButton,\n      group: groupFields\n    });\n\n    const viewSchema = objOf([\n      defaultedArrayOf('buttons', [], viewButtonSchema),\n      requiredFunction('onShow'),\n      requiredFunction('onHide')\n    ]);\n    const createView = spec => asRaw('view', viewSchema, spec);\n\n    const renderButton = (spec, providers) => {\n      var _a, _b;\n      const isToggleButton = spec.type === 'togglebutton';\n      const optMemIcon = spec.icon.map(memIcon => renderReplaceableIconFromPack(memIcon, providers.icons)).map(record);\n      const getAction = () => comp => {\n        const setIcon = newIcon => {\n          optMemIcon.map(memIcon => memIcon.getOpt(comp).each(displayIcon => {\n            Replacing.set(displayIcon, [renderReplaceableIconFromPack(newIcon, providers.icons)]);\n          }));\n        };\n        const setActive = state => {\n          const elm = comp.element;\n          if (state) {\n            add$2(elm, 'tox-button--enabled');\n            set$9(elm, 'aria-pressed', true);\n          } else {\n            remove$3(elm, 'tox-button--enabled');\n            remove$8(elm, 'aria-pressed');\n          }\n        };\n        const isActive = () => has(comp.element, 'tox-button--enabled');\n        if (isToggleButton) {\n          return spec.onAction({\n            setIcon,\n            setActive,\n            isActive\n          });\n        }\n        if (spec.type === 'button') {\n          return spec.onAction({ setIcon });\n        }\n      };\n      const action = getAction();\n      const buttonSpec = {\n        ...spec,\n        name: isToggleButton ? spec.text.getOr(spec.icon.getOr('')) : (_a = spec.text) !== null && _a !== void 0 ? _a : spec.icon.getOr(''),\n        primary: spec.buttonType === 'primary',\n        buttonType: Optional.from(spec.buttonType),\n        tooltip: spec.tooltip,\n        icon: spec.icon,\n        enabled: true,\n        borderless: spec.borderless\n      };\n      const buttonTypeClasses = calculateClassesFromButtonType((_b = spec.buttonType) !== null && _b !== void 0 ? _b : 'secondary');\n      const optTranslatedText = isToggleButton ? spec.text.map(providers.translate) : Optional.some(providers.translate(spec.text));\n      const optTranslatedTextComponed = optTranslatedText.map(text$2);\n      const ariaLabelAttributes = buttonSpec.tooltip.or(optTranslatedText).map(al => ({ 'aria-label': providers.translate(al) })).getOr({});\n      const optIconSpec = optMemIcon.map(memIcon => memIcon.asSpec());\n      const components = componentRenderPipeline([\n        optIconSpec,\n        optTranslatedTextComponed\n      ]);\n      const hasIconAndText = spec.icon.isSome() && optTranslatedTextComponed.isSome();\n      const dom = {\n        tag: 'button',\n        classes: buttonTypeClasses.concat(...spec.icon.isSome() && !hasIconAndText ? ['tox-button--icon'] : []).concat(...hasIconAndText ? ['tox-button--icon-and-text'] : []).concat(...spec.borderless ? ['tox-button--naked'] : []).concat(...spec.type === 'togglebutton' && spec.active ? ['tox-button--enabled'] : []),\n        attributes: ariaLabelAttributes\n      };\n      const extraBehaviours = [];\n      const iconButtonSpec = renderCommonSpec(buttonSpec, Optional.some(action), extraBehaviours, dom, components, spec.tooltip, providers);\n      return Button.sketch(iconButtonSpec);\n    };\n\n    const renderViewButton = (spec, providers) => renderButton(spec, providers);\n    const renderButtonsGroup = (spec, providers) => {\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-view__toolbar__group']\n        },\n        components: map$2(spec.buttons, button => renderViewButton(button, providers))\n      };\n    };\n    const deviceDetection = detect$1().deviceType;\n    const isPhone = deviceDetection.isPhone();\n    const isTablet = deviceDetection.isTablet();\n    const renderViewHeader = spec => {\n      let hasGroups = false;\n      const endButtons = map$2(spec.buttons, btnspec => {\n        if (btnspec.type === 'group') {\n          hasGroups = true;\n          return renderButtonsGroup(btnspec, spec.providers);\n        } else {\n          return renderViewButton(btnspec, spec.providers);\n        }\n      });\n      return {\n        uid: spec.uid,\n        dom: {\n          tag: 'div',\n          classes: [\n            !hasGroups ? 'tox-view__header' : 'tox-view__toolbar',\n            ...isPhone || isTablet ? [\n              'tox-view--mobile',\n              'tox-view--scrolling'\n            ] : []\n          ]\n        },\n        behaviours: derive$1([\n          Focusing.config({}),\n          Keying.config({\n            mode: 'flow',\n            selector: 'button, .tox-button',\n            focusInside: FocusInsideModes.OnEnterOrSpaceMode\n          })\n        ]),\n        components: hasGroups ? endButtons : [\n          Container.sketch({\n            dom: {\n              tag: 'div',\n              classes: ['tox-view__header-start']\n            },\n            components: []\n          }),\n          Container.sketch({\n            dom: {\n              tag: 'div',\n              classes: ['tox-view__header-end']\n            },\n            components: endButtons\n          })\n        ]\n      };\n    };\n    const renderViewPane = spec => {\n      return {\n        uid: spec.uid,\n        behaviours: derive$1([\n          Focusing.config({}),\n          Tabstopping.config({})\n        ]),\n        dom: {\n          tag: 'div',\n          classes: ['tox-view__pane']\n        }\n      };\n    };\n    const factory$8 = (detail, components, _spec, _externals) => {\n      const apis = {\n        getPane: comp => parts$a.getPart(comp, detail, 'pane'),\n        getOnShow: _comp => detail.viewConfig.onShow,\n        getOnHide: _comp => detail.viewConfig.onHide\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components,\n        behaviours: derive$1([\n          Focusing.config({}),\n          Keying.config({\n            mode: 'cyclic',\n            focusInside: FocusInsideModes.OnEnterOrSpaceMode\n          })\n        ]),\n        apis\n      };\n    };\n    var View = composite({\n      name: 'silver.View',\n      configFields: [required$1('viewConfig')],\n      partFields: [\n        optional({\n          factory: { sketch: renderViewHeader },\n          schema: [\n            required$1('buttons'),\n            required$1('providers')\n          ],\n          name: 'header'\n        }),\n        optional({\n          factory: { sketch: renderViewPane },\n          schema: [],\n          name: 'pane'\n        })\n      ],\n      factory: factory$8,\n      apis: {\n        getPane: (apis, comp) => apis.getPane(comp),\n        getOnShow: (apis, comp) => apis.getOnShow(comp),\n        getOnHide: (apis, comp) => apis.getOnHide(comp)\n      }\n    });\n\n    const makeViews = (parts, viewConfigs, providers) => {\n      return mapToArray(viewConfigs, (config, name) => {\n        const internalViewConfig = getOrDie(createView(config));\n        return parts.slot(name, View.sketch({\n          dom: {\n            tag: 'div',\n            classes: ['tox-view']\n          },\n          viewConfig: internalViewConfig,\n          components: [\n            ...internalViewConfig.buttons.length > 0 ? [View.parts.header({\n                buttons: internalViewConfig.buttons,\n                providers\n              })] : [],\n            View.parts.pane({})\n          ]\n        }));\n      });\n    };\n    const makeSlotContainer = (viewConfigs, providers) => SlotContainer.sketch(parts => ({\n      dom: {\n        tag: 'div',\n        classes: ['tox-view-wrap__slot-container']\n      },\n      components: makeViews(parts, viewConfigs, providers),\n      slotBehaviours: SimpleBehaviours.unnamedEvents([runOnAttached(slotContainer => SlotContainer.hideAllSlots(slotContainer))])\n    }));\n    const getCurrentName = slotContainer => {\n      return find$5(SlotContainer.getSlotNames(slotContainer), name => SlotContainer.isShowing(slotContainer, name));\n    };\n    const hideContainer = comp => {\n      const element = comp.element;\n      set$8(element, 'display', 'none');\n      set$9(element, 'aria-hidden', 'true');\n    };\n    const showContainer = comp => {\n      const element = comp.element;\n      remove$7(element, 'display');\n      remove$8(element, 'aria-hidden');\n    };\n    const makeViewInstanceApi = slot => ({ getContainer: constant$1(slot) });\n    const runOnPaneWithInstanceApi = (slotContainer, name, get) => {\n      SlotContainer.getSlot(slotContainer, name).each(view => {\n        View.getPane(view).each(pane => {\n          const onCallback = get(view);\n          onCallback(makeViewInstanceApi(pane.element.dom));\n        });\n      });\n    };\n    const runOnShow = (slotContainer, name) => runOnPaneWithInstanceApi(slotContainer, name, View.getOnShow);\n    const runOnHide = (slotContainer, name) => runOnPaneWithInstanceApi(slotContainer, name, View.getOnHide);\n    const factory$7 = (detail, spec) => {\n      const setViews = (comp, viewConfigs) => {\n        Replacing.set(comp, [makeSlotContainer(viewConfigs, spec.backstage.shared.providers)]);\n      };\n      const whichView = comp => {\n        return Composing.getCurrent(comp).bind(getCurrentName);\n      };\n      const toggleView = (comp, showMainView, hideMainView, name) => {\n        return Composing.getCurrent(comp).exists(slotContainer => {\n          const optCurrentSlotName = getCurrentName(slotContainer);\n          const isTogglingCurrentView = optCurrentSlotName.exists(current => name === current);\n          const exists = SlotContainer.getSlot(slotContainer, name).isSome();\n          if (exists) {\n            SlotContainer.hideAllSlots(slotContainer);\n            if (!isTogglingCurrentView) {\n              hideMainView();\n              showContainer(comp);\n              SlotContainer.showSlot(slotContainer, name);\n              runOnShow(slotContainer, name);\n            } else {\n              hideContainer(comp);\n              showMainView();\n            }\n            optCurrentSlotName.each(prevName => runOnHide(slotContainer, prevName));\n          }\n          return exists;\n        });\n      };\n      const apis = {\n        setViews,\n        whichView,\n        toggleView\n      };\n      return {\n        uid: detail.uid,\n        dom: {\n          tag: 'div',\n          classes: ['tox-view-wrap'],\n          attributes: { 'aria-hidden': 'true' },\n          styles: { display: 'none' }\n        },\n        components: [],\n        behaviours: derive$1([\n          Replacing.config({}),\n          Composing.config({\n            find: comp => {\n              const children = Replacing.contents(comp);\n              return head(children);\n            }\n          })\n        ]),\n        apis\n      };\n    };\n    var ViewWrapper = single({\n      factory: factory$7,\n      name: 'silver.ViewWrapper',\n      configFields: [required$1('backstage')],\n      apis: {\n        setViews: (apis, comp, views) => apis.setViews(comp, views),\n        toggleView: (apis, comp, outerContainer, editorCont, name) => apis.toggleView(comp, outerContainer, editorCont, name),\n        whichView: (apis, comp) => apis.whichView(comp)\n      }\n    });\n\n    const factory$6 = (detail, components, _spec) => {\n      let toolbarDrawerOpenState = false;\n      const toggleStatusbar = editorContainer => {\n        sibling(editorContainer, '.tox-statusbar').each(statusBar => {\n          if (get$f(statusBar, 'display') === 'none' && get$g(statusBar, 'aria-hidden') === 'true') {\n            remove$7(statusBar, 'display');\n            remove$8(statusBar, 'aria-hidden');\n          } else {\n            set$8(statusBar, 'display', 'none');\n            set$9(statusBar, 'aria-hidden', 'true');\n          }\n        });\n      };\n      const apis = {\n        getSocket: comp => {\n          return parts$a.getPart(comp, detail, 'socket');\n        },\n        setSidebar: (comp, panelConfigs, showSidebar) => {\n          parts$a.getPart(comp, detail, 'sidebar').each(sidebar => setSidebar(sidebar, panelConfigs, showSidebar));\n        },\n        toggleSidebar: (comp, name) => {\n          parts$a.getPart(comp, detail, 'sidebar').each(sidebar => toggleSidebar(sidebar, name));\n        },\n        whichSidebar: comp => {\n          return parts$a.getPart(comp, detail, 'sidebar').bind(whichSidebar).getOrNull();\n        },\n        getHeader: comp => {\n          return parts$a.getPart(comp, detail, 'header');\n        },\n        getToolbar: comp => {\n          return parts$a.getPart(comp, detail, 'toolbar');\n        },\n        setToolbar: (comp, groups) => {\n          parts$a.getPart(comp, detail, 'toolbar').each(toolbar => {\n            const renderedGroups = map$2(groups, renderToolbarGroup);\n            toolbar.getApis().setGroups(toolbar, renderedGroups);\n          });\n        },\n        setToolbars: (comp, toolbars) => {\n          parts$a.getPart(comp, detail, 'multiple-toolbar').each(mToolbar => {\n            const renderedToolbars = map$2(toolbars, g => map$2(g, renderToolbarGroup));\n            CustomList.setItems(mToolbar, renderedToolbars);\n          });\n        },\n        refreshToolbar: comp => {\n          const toolbar = parts$a.getPart(comp, detail, 'toolbar');\n          toolbar.each(toolbar => toolbar.getApis().refresh(toolbar));\n        },\n        toggleToolbarDrawer: comp => {\n          parts$a.getPart(comp, detail, 'toolbar').each(toolbar => {\n            mapFrom(toolbar.getApis().toggle, toggle => toggle(toolbar));\n          });\n        },\n        toggleToolbarDrawerWithoutFocusing: comp => {\n          parts$a.getPart(comp, detail, 'toolbar').each(toolbar => {\n            mapFrom(toolbar.getApis().toggleWithoutFocusing, toggleWithoutFocusing => toggleWithoutFocusing(toolbar));\n          });\n        },\n        isToolbarDrawerToggled: comp => {\n          return parts$a.getPart(comp, detail, 'toolbar').bind(toolbar => Optional.from(toolbar.getApis().isOpen).map(isOpen => isOpen(toolbar))).getOr(false);\n        },\n        getThrobber: comp => {\n          return parts$a.getPart(comp, detail, 'throbber');\n        },\n        focusToolbar: comp => {\n          const optToolbar = parts$a.getPart(comp, detail, 'toolbar').orThunk(() => parts$a.getPart(comp, detail, 'multiple-toolbar'));\n          optToolbar.each(toolbar => {\n            Keying.focusIn(toolbar);\n          });\n        },\n        setMenubar: (comp, menus) => {\n          parts$a.getPart(comp, detail, 'menubar').each(menubar => {\n            SilverMenubar.setMenus(menubar, menus);\n          });\n        },\n        focusMenubar: comp => {\n          parts$a.getPart(comp, detail, 'menubar').each(menubar => {\n            SilverMenubar.focus(menubar);\n          });\n        },\n        setViews: (comp, viewConfigs) => {\n          parts$a.getPart(comp, detail, 'viewWrapper').each(wrapper => {\n            ViewWrapper.setViews(wrapper, viewConfigs);\n          });\n        },\n        toggleView: (comp, name) => {\n          return parts$a.getPart(comp, detail, 'viewWrapper').exists(wrapper => ViewWrapper.toggleView(wrapper, () => apis.showMainView(comp), () => apis.hideMainView(comp), name));\n        },\n        whichView: comp => {\n          return parts$a.getPart(comp, detail, 'viewWrapper').bind(ViewWrapper.whichView).getOrNull();\n        },\n        hideMainView: comp => {\n          toolbarDrawerOpenState = apis.isToolbarDrawerToggled(comp);\n          if (toolbarDrawerOpenState) {\n            apis.toggleToolbarDrawer(comp);\n          }\n          parts$a.getPart(comp, detail, 'editorContainer').each(editorContainer => {\n            const element = editorContainer.element;\n            toggleStatusbar(element);\n            set$8(element, 'display', 'none');\n            set$9(element, 'aria-hidden', 'true');\n          });\n        },\n        showMainView: comp => {\n          if (toolbarDrawerOpenState) {\n            apis.toggleToolbarDrawer(comp);\n          }\n          parts$a.getPart(comp, detail, 'editorContainer').each(editorContainer => {\n            const element = editorContainer.element;\n            toggleStatusbar(element);\n            remove$7(element, 'display');\n            remove$8(element, 'aria-hidden');\n          });\n        }\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components,\n        apis,\n        behaviours: detail.behaviours\n      };\n    };\n    const partMenubar = partType.optional({\n      factory: SilverMenubar,\n      name: 'menubar',\n      schema: [required$1('backstage')]\n    });\n    const toolbarFactory = spec => {\n      if (spec.type === ToolbarMode$1.sliding) {\n        return renderSlidingMoreToolbar;\n      } else if (spec.type === ToolbarMode$1.floating) {\n        return renderFloatingMoreToolbar;\n      } else {\n        return renderToolbar;\n      }\n    };\n    const partMultipleToolbar = partType.optional({\n      factory: {\n        sketch: spec => CustomList.sketch({\n          uid: spec.uid,\n          dom: spec.dom,\n          listBehaviours: derive$1([Keying.config({\n              mode: 'acyclic',\n              selector: '.tox-toolbar'\n            })]),\n          makeItem: () => renderToolbar({\n            type: spec.type,\n            uid: generate$6('multiple-toolbar-item'),\n            cyclicKeying: false,\n            initGroups: [],\n            providers: spec.providers,\n            onEscape: () => {\n              spec.onEscape();\n              return Optional.some(true);\n            }\n          }),\n          setupItem: (_mToolbar, tc, data, _index) => {\n            Toolbar.setGroups(tc, data);\n          },\n          shell: true\n        })\n      },\n      name: 'multiple-toolbar',\n      schema: [\n        required$1('dom'),\n        required$1('onEscape')\n      ]\n    });\n    const partToolbar = partType.optional({\n      factory: {\n        sketch: spec => {\n          const renderer = toolbarFactory(spec);\n          const toolbarSpec = {\n            type: spec.type,\n            uid: spec.uid,\n            onEscape: () => {\n              spec.onEscape();\n              return Optional.some(true);\n            },\n            onToggled: (_comp, state) => spec.onToolbarToggled(state),\n            cyclicKeying: false,\n            initGroups: [],\n            getSink: spec.getSink,\n            providers: spec.providers,\n            moreDrawerData: {\n              lazyToolbar: spec.lazyToolbar,\n              lazyMoreButton: spec.lazyMoreButton,\n              lazyHeader: spec.lazyHeader\n            },\n            attributes: spec.attributes\n          };\n          return renderer(toolbarSpec);\n        }\n      },\n      name: 'toolbar',\n      schema: [\n        required$1('dom'),\n        required$1('onEscape'),\n        required$1('getSink')\n      ]\n    });\n    const partHeader = partType.optional({\n      factory: { sketch: renderHeader },\n      name: 'header',\n      schema: [required$1('dom')]\n    });\n    const partPromotion = partType.optional({\n      factory: { sketch: renderPromotion },\n      name: 'promotion',\n      schema: [required$1('dom')]\n    });\n    const partSocket = partType.optional({\n      name: 'socket',\n      schema: [required$1('dom')]\n    });\n    const partSidebar = partType.optional({\n      factory: { sketch: renderSidebar },\n      name: 'sidebar',\n      schema: [required$1('dom')]\n    });\n    const partThrobber = partType.optional({\n      factory: { sketch: renderThrobber },\n      name: 'throbber',\n      schema: [required$1('dom')]\n    });\n    const partViewWrapper = partType.optional({\n      factory: ViewWrapper,\n      name: 'viewWrapper',\n      schema: [required$1('backstage')]\n    });\n    const renderEditorContainer = spec => ({\n      uid: spec.uid,\n      dom: {\n        tag: 'div',\n        classes: ['tox-editor-container']\n      },\n      components: spec.components\n    });\n    const partEditorContainer = partType.optional({\n      factory: { sketch: renderEditorContainer },\n      name: 'editorContainer',\n      schema: []\n    });\n    var OuterContainer = composite({\n      name: 'OuterContainer',\n      factory: factory$6,\n      configFields: [\n        required$1('dom'),\n        required$1('behaviours')\n      ],\n      partFields: [\n        partHeader,\n        partMenubar,\n        partToolbar,\n        partMultipleToolbar,\n        partSocket,\n        partSidebar,\n        partPromotion,\n        partThrobber,\n        partViewWrapper,\n        partEditorContainer\n      ],\n      apis: {\n        getSocket: (apis, comp) => {\n          return apis.getSocket(comp);\n        },\n        setSidebar: (apis, comp, panelConfigs, showSidebar) => {\n          apis.setSidebar(comp, panelConfigs, showSidebar);\n        },\n        toggleSidebar: (apis, comp, name) => {\n          apis.toggleSidebar(comp, name);\n        },\n        whichSidebar: (apis, comp) => {\n          return apis.whichSidebar(comp);\n        },\n        getHeader: (apis, comp) => {\n          return apis.getHeader(comp);\n        },\n        getToolbar: (apis, comp) => {\n          return apis.getToolbar(comp);\n        },\n        setToolbar: (apis, comp, groups) => {\n          apis.setToolbar(comp, groups);\n        },\n        setToolbars: (apis, comp, toolbars) => {\n          apis.setToolbars(comp, toolbars);\n        },\n        refreshToolbar: (apis, comp) => {\n          return apis.refreshToolbar(comp);\n        },\n        toggleToolbarDrawer: (apis, comp) => {\n          apis.toggleToolbarDrawer(comp);\n        },\n        toggleToolbarDrawerWithoutFocusing: (apis, comp) => {\n          apis.toggleToolbarDrawerWithoutFocusing(comp);\n        },\n        isToolbarDrawerToggled: (apis, comp) => {\n          return apis.isToolbarDrawerToggled(comp);\n        },\n        getThrobber: (apis, comp) => {\n          return apis.getThrobber(comp);\n        },\n        setMenubar: (apis, comp, menus) => {\n          apis.setMenubar(comp, menus);\n        },\n        focusMenubar: (apis, comp) => {\n          apis.focusMenubar(comp);\n        },\n        focusToolbar: (apis, comp) => {\n          apis.focusToolbar(comp);\n        },\n        setViews: (apis, comp, views) => {\n          apis.setViews(comp, views);\n        },\n        toggleView: (apis, comp, name) => {\n          return apis.toggleView(comp, name);\n        },\n        whichView: (apis, comp) => {\n          return apis.whichView(comp);\n        }\n      }\n    });\n\n    const defaultMenubar = 'file edit view insert format tools table help';\n    const defaultMenus = {\n      file: {\n        title: 'File',\n        items: 'newdocument restoredraft | preview | importword exportpdf exportword | export print | deleteallconversations'\n      },\n      edit: {\n        title: 'Edit',\n        items: 'undo redo | cut copy paste pastetext | selectall | searchreplace'\n      },\n      view: {\n        title: 'View',\n        items: 'code revisionhistory | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments'\n      },\n      insert: {\n        title: 'Insert',\n        items: 'image link media addcomment pageembed inserttemplate codesample inserttable accordion math | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents footnotes | mergetags | insertdatetime'\n      },\n      format: {\n        title: 'Format',\n        items: 'bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat'\n      },\n      tools: {\n        title: 'Tools',\n        items: 'aidialog aishortcuts | spellchecker spellcheckerlanguage | autocorrect capitalization | a11ycheck code typography wordcount addtemplate'\n      },\n      table: {\n        title: 'Table',\n        items: 'inserttable | cell row column | advtablesort | tableprops deletetable'\n      },\n      help: {\n        title: 'Help',\n        items: 'help'\n      }\n    };\n    const make = (menu, registry, editor) => {\n      const removedMenuItems = getRemovedMenuItems(editor).split(/[ ,]/);\n      return {\n        text: menu.title,\n        getItems: () => bind$3(menu.items, i => {\n          const itemName = i.toLowerCase();\n          if (itemName.trim().length === 0) {\n            return [];\n          } else if (exists(removedMenuItems, removedMenuItem => removedMenuItem === itemName)) {\n            return [];\n          } else if (itemName === 'separator' || itemName === '|') {\n            return [{ type: 'separator' }];\n          } else if (registry.menuItems[itemName]) {\n            return [registry.menuItems[itemName]];\n          } else {\n            return [];\n          }\n        })\n      };\n    };\n    const parseItemsString = items => {\n      return items.split(' ');\n    };\n    const identifyMenus = (editor, registry) => {\n      const rawMenuData = {\n        ...defaultMenus,\n        ...registry.menus\n      };\n      const userDefinedMenus = keys(registry.menus).length > 0;\n      const menubar = registry.menubar === undefined || registry.menubar === true ? parseItemsString(defaultMenubar) : parseItemsString(registry.menubar === false ? '' : registry.menubar);\n      const validMenus = filter$2(menubar, menuName => {\n        const isDefaultMenu = has$2(defaultMenus, menuName);\n        if (userDefinedMenus) {\n          return isDefaultMenu || get$h(registry.menus, menuName).exists(menu => has$2(menu, 'items'));\n        } else {\n          return isDefaultMenu;\n        }\n      });\n      const menus = map$2(validMenus, menuName => {\n        const menuData = rawMenuData[menuName];\n        return make({\n          title: menuData.title,\n          items: parseItemsString(menuData.items)\n        }, registry, editor);\n      });\n      return filter$2(menus, menu => {\n        const isNotSeparator = item => isString(item) || item.type !== 'separator';\n        return menu.getItems().length > 0 && exists(menu.getItems(), isNotSeparator);\n      });\n    };\n\n    const fireSkinLoaded = editor => {\n      const done = () => {\n        editor._skinLoaded = true;\n        fireSkinLoaded$1(editor);\n      };\n      return () => {\n        if (editor.initialized) {\n          done();\n        } else {\n          editor.on('init', done);\n        }\n      };\n    };\n    const fireSkinLoadError = (editor, err) => () => fireSkinLoadError$1(editor, { message: err });\n\n    const loadStylesheet = (editor, stylesheetUrl, styleSheetLoader) => {\n      editor.on('remove', () => styleSheetLoader.unload(stylesheetUrl));\n      return styleSheetLoader.load(stylesheetUrl);\n    };\n    const loadRawCss = (editor, key, css, styleSheetLoader) => {\n      editor.on('remove', () => styleSheetLoader.unloadRawCss(key));\n      return styleSheetLoader.loadRawCss(key, css);\n    };\n    const loadUiSkins = async (editor, skinUrl) => {\n      const skinResourceIdentifier = getSkinUrlOption(editor).getOr('default');\n      const skinUiCss = 'ui/' + skinResourceIdentifier + '/skin.css';\n      const css = tinymce.Resource.get(skinUiCss);\n      if (isString(css)) {\n        loadRawCss(editor, skinUiCss, css, editor.ui.styleSheetLoader);\n      } else {\n        const suffix = editor.editorManager.suffix;\n        const skinUiCss = skinUrl + `/skin${ suffix }.css`;\n        return loadStylesheet(editor, skinUiCss, editor.ui.styleSheetLoader);\n      }\n    };\n    const loadShadowDomUiSkins = async (editor, skinUrl) => {\n      const isInShadowRoot$1 = isInShadowRoot(SugarElement.fromDom(editor.getElement()));\n      if (isInShadowRoot$1) {\n        const skinResourceIdentifier = getSkinUrlOption(editor).getOr('default');\n        const shadowDomSkinCss = 'ui/' + skinResourceIdentifier + '/skin.shadowdom.css';\n        const css = tinymce.Resource.get(shadowDomSkinCss);\n        if (isString(css)) {\n          loadRawCss(editor, shadowDomSkinCss, css, global$8.DOM.styleSheetLoader);\n        } else {\n          const suffix = editor.editorManager.suffix;\n          const shadowDomSkinCss = skinUrl + `/skin.shadowdom${ suffix }.css`;\n          return loadStylesheet(editor, shadowDomSkinCss, global$8.DOM.styleSheetLoader);\n        }\n      }\n    };\n    const loadUrlSkin = async (isInline, editor) => {\n      const unbundled = () => {\n        const skinResourceIdentifier = getSkinUrl(editor);\n        const suffix = editor.editorManager.suffix;\n        if (skinResourceIdentifier) {\n          editor.contentCSS.push(skinResourceIdentifier + (isInline ? '/content.inline' : '/content') + `${ suffix }.css`);\n        }\n      };\n      getSkinUrlOption(editor).fold(unbundled, skinUrl => {\n        const skinContentCss = 'ui/' + skinUrl + (isInline ? '/content.inline' : '/content') + '.css';\n        const css = tinymce.Resource.get(skinContentCss);\n        if (isString(css)) {\n          loadRawCss(editor, skinContentCss, css, editor.ui.styleSheetLoader);\n        } else {\n          unbundled();\n        }\n      });\n      const skinUrl = getSkinUrl(editor);\n      if (!isSkinDisabled(editor) && isString(skinUrl)) {\n        return Promise.all([\n          loadUiSkins(editor, skinUrl),\n          loadShadowDomUiSkins(editor, skinUrl)\n        ]).then();\n      }\n    };\n    const loadSkin = (isInline, editor) => {\n      return loadUrlSkin(isInline, editor).then(fireSkinLoaded(editor), fireSkinLoadError(editor, 'Skin could not be loaded'));\n    };\n    const iframe = curry(loadSkin, false);\n    const inline = curry(loadSkin, true);\n\n    const makeTooltipText = (editor, labelWithPlaceholder, value) => isEmpty(value) ? editor.translate(labelWithPlaceholder) : editor.translate([\n      labelWithPlaceholder,\n      editor.translate(value)\n    ]);\n\n    const generateSelectItems = (backstage, spec) => {\n      const generateItem = (rawItem, response, invalid, value) => {\n        const translatedText = backstage.shared.providers.translate(rawItem.title);\n        if (rawItem.type === 'separator') {\n          return Optional.some({\n            type: 'separator',\n            text: translatedText\n          });\n        } else if (rawItem.type === 'submenu') {\n          const items = bind$3(rawItem.getStyleItems(), si => validate(si, response, value));\n          if (response === 0 && items.length <= 0) {\n            return Optional.none();\n          } else {\n            return Optional.some({\n              type: 'nestedmenuitem',\n              text: translatedText,\n              enabled: items.length > 0,\n              getSubmenuItems: () => bind$3(rawItem.getStyleItems(), si => validate(si, response, value))\n            });\n          }\n        } else {\n          return Optional.some({\n            type: 'togglemenuitem',\n            text: translatedText,\n            icon: rawItem.icon,\n            active: rawItem.isSelected(value),\n            enabled: !invalid,\n            onAction: spec.onAction(rawItem),\n            ...rawItem.getStylePreview().fold(() => ({}), preview => ({ meta: { style: preview } }))\n          });\n        }\n      };\n      const validate = (item, response, value) => {\n        const invalid = item.type === 'formatter' && spec.isInvalid(item);\n        if (response === 0) {\n          return invalid ? [] : generateItem(item, response, false, value).toArray();\n        } else {\n          return generateItem(item, response, invalid, value).toArray();\n        }\n      };\n      const validateItems = preItems => {\n        const value = spec.getCurrentValue();\n        const response = spec.shouldHide ? 0 : 1;\n        return bind$3(preItems, item => validate(item, response, value));\n      };\n      const getFetch = (backstage, getStyleItems) => (comp, callback) => {\n        const preItems = getStyleItems();\n        const items = validateItems(preItems);\n        const menu = build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {\n          isHorizontalMenu: false,\n          search: Optional.none()\n        });\n        callback(menu);\n      };\n      return {\n        validateItems,\n        getFetch\n      };\n    };\n    const createMenuItems = (backstage, spec) => {\n      const dataset = spec.dataset;\n      const getStyleItems = dataset.type === 'basic' ? () => map$2(dataset.data, d => processBasic(d, spec.isSelectedFor, spec.getPreviewFor)) : dataset.getData;\n      return {\n        items: generateSelectItems(backstage, spec),\n        getStyleItems\n      };\n    };\n    const createSelectButton = (editor, backstage, spec, getTooltip, textUpdateEventName, btnName) => {\n      const {items, getStyleItems} = createMenuItems(backstage, spec);\n      const tooltipString = Cell(spec.tooltip);\n      const getApi = comp => ({\n        getComponent: constant$1(comp),\n        setTooltip: tooltip => {\n          const translatedTooltip = backstage.shared.providers.translate(tooltip);\n          set$9(comp.element, 'aria-label', translatedTooltip);\n          tooltipString.set(tooltip);\n        }\n      });\n      const onSetup = api => {\n        const handler = e => api.setTooltip(makeTooltipText(editor, getTooltip(e.value), e.value));\n        editor.on(textUpdateEventName, handler);\n        return composeUnbinders(onSetupEvent(editor, 'NodeChange', api => {\n          const comp = api.getComponent();\n          spec.updateText(comp);\n          Disabling.set(api.getComponent(), !editor.selection.isEditable());\n        })(api), () => editor.off(textUpdateEventName, handler));\n      };\n      return renderCommonDropdown({\n        text: spec.icon.isSome() ? Optional.none() : spec.text,\n        icon: spec.icon,\n        ariaLabel: Optional.some(spec.tooltip),\n        tooltip: Optional.none(),\n        role: Optional.none(),\n        fetch: items.getFetch(backstage, getStyleItems),\n        onSetup,\n        getApi,\n        columns: 1,\n        presets: 'normal',\n        classes: spec.icon.isSome() ? [] : ['bespoke'],\n        dropdownBehaviours: [Tooltipping.config({\n            ...backstage.shared.providers.tooltips.getConfig({\n              tooltipText: backstage.shared.providers.translate(spec.tooltip),\n              onShow: comp => {\n                if (spec.tooltip !== tooltipString.get()) {\n                  const translatedTooltip = backstage.shared.providers.translate(tooltipString.get());\n                  Tooltipping.setComponents(comp, backstage.shared.providers.tooltips.getComponents({ tooltipText: translatedTooltip }));\n                }\n              }\n            })\n          })]\n      }, 'tox-tbtn', backstage.shared, btnName);\n    };\n\n    const process = rawFormats => map$2(rawFormats, item => {\n      let title = item, format = item;\n      const values = item.split('=');\n      if (values.length > 1) {\n        title = values[0];\n        format = values[1];\n      }\n      return {\n        title,\n        format\n      };\n    });\n    const buildBasicStaticDataset = data => ({\n      type: 'basic',\n      data\n    });\n    var Delimiter;\n    (function (Delimiter) {\n      Delimiter[Delimiter['SemiColon'] = 0] = 'SemiColon';\n      Delimiter[Delimiter['Space'] = 1] = 'Space';\n    }(Delimiter || (Delimiter = {})));\n    const split = (rawFormats, delimiter) => {\n      if (delimiter === Delimiter.SemiColon) {\n        return rawFormats.replace(/;$/, '').split(';');\n      } else {\n        return rawFormats.split(' ');\n      }\n    };\n    const buildBasicSettingsDataset = (editor, settingName, delimiter) => {\n      const rawFormats = editor.options.get(settingName);\n      const data = process(split(rawFormats, delimiter));\n      return {\n        type: 'basic',\n        data\n      };\n    };\n\n    const menuTitle$4 = 'Align';\n    const getTooltipPlaceholder$4 = constant$1('Alignment {0}');\n    const fallbackAlignment = 'left';\n    const alignMenuItems = [\n      {\n        title: 'Left',\n        icon: 'align-left',\n        format: 'alignleft',\n        command: 'JustifyLeft'\n      },\n      {\n        title: 'Center',\n        icon: 'align-center',\n        format: 'aligncenter',\n        command: 'JustifyCenter'\n      },\n      {\n        title: 'Right',\n        icon: 'align-right',\n        format: 'alignright',\n        command: 'JustifyRight'\n      },\n      {\n        title: 'Justify',\n        icon: 'align-justify',\n        format: 'alignjustify',\n        command: 'JustifyFull'\n      }\n    ];\n    const getSpec$4 = editor => {\n      const getMatchingValue = () => find$5(alignMenuItems, item => editor.formatter.match(item.format));\n      const isSelectedFor = format => () => editor.formatter.match(format);\n      const getPreviewFor = _format => Optional.none;\n      const updateSelectMenuIcon = comp => {\n        const match = getMatchingValue();\n        const alignment = match.fold(constant$1(fallbackAlignment), item => item.title.toLowerCase());\n        emitWith(comp, updateMenuIcon, { icon: `align-${ alignment }` });\n        fireAlignTextUpdate(editor, { value: alignment });\n      };\n      const dataset = buildBasicStaticDataset(alignMenuItems);\n      const onAction = rawItem => () => find$5(alignMenuItems, item => item.format === rawItem.format).each(item => editor.execCommand(item.command));\n      return {\n        tooltip: makeTooltipText(editor, getTooltipPlaceholder$4(), fallbackAlignment),\n        text: Optional.none(),\n        icon: Optional.some('align-left'),\n        isSelectedFor,\n        getCurrentValue: Optional.none,\n        getPreviewFor,\n        onAction,\n        updateText: updateSelectMenuIcon,\n        dataset,\n        shouldHide: false,\n        isInvalid: item => !editor.formatter.canApply(item.format)\n      };\n    };\n    const createAlignButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$4(editor), getTooltipPlaceholder$4, 'AlignTextUpdate', 'align');\n    const createAlignMenu = (editor, backstage) => {\n      const menuItems = createMenuItems(backstage, getSpec$4(editor));\n      editor.ui.registry.addNestedMenuItem('align', {\n        text: backstage.shared.providers.translate(menuTitle$4),\n        onSetup: onSetupEditableToggle(editor),\n        getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())\n      });\n    };\n\n    const findNearest = (editor, getStyles) => {\n      const styles = getStyles();\n      const formats = map$2(styles, style => style.format);\n      return Optional.from(editor.formatter.closest(formats)).bind(fmt => find$5(styles, data => data.format === fmt));\n    };\n\n    const menuTitle$3 = 'Blocks';\n    const getTooltipPlaceholder$3 = constant$1('Block {0}');\n    const fallbackFormat = 'Paragraph';\n    const getSpec$3 = editor => {\n      const isSelectedFor = format => () => editor.formatter.match(format);\n      const getPreviewFor = format => () => {\n        const fmt = editor.formatter.get(format);\n        if (fmt) {\n          return Optional.some({\n            tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',\n            styles: editor.dom.parseStyle(editor.formatter.getCssText(format))\n          });\n        } else {\n          return Optional.none();\n        }\n      };\n      const updateSelectMenuText = comp => {\n        const detectedFormat = findNearest(editor, () => dataset.data);\n        const text = detectedFormat.fold(constant$1(fallbackFormat), fmt => fmt.title);\n        emitWith(comp, updateMenuText, { text });\n        fireBlocksTextUpdate(editor, { value: text });\n      };\n      const dataset = buildBasicSettingsDataset(editor, 'block_formats', Delimiter.SemiColon);\n      return {\n        tooltip: makeTooltipText(editor, getTooltipPlaceholder$3(), fallbackFormat),\n        text: Optional.some(fallbackFormat),\n        icon: Optional.none(),\n        isSelectedFor,\n        getCurrentValue: Optional.none,\n        getPreviewFor,\n        onAction: onActionToggleFormat$1(editor),\n        updateText: updateSelectMenuText,\n        dataset,\n        shouldHide: false,\n        isInvalid: item => !editor.formatter.canApply(item.format)\n      };\n    };\n    const createBlocksButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$3(editor), getTooltipPlaceholder$3, 'BlocksTextUpdate', 'blocks');\n    const createBlocksMenu = (editor, backstage) => {\n      const menuItems = createMenuItems(backstage, getSpec$3(editor));\n      editor.ui.registry.addNestedMenuItem('blocks', {\n        text: menuTitle$3,\n        onSetup: onSetupEditableToggle(editor),\n        getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())\n      });\n    };\n\n    const menuTitle$2 = 'Fonts';\n    const getTooltipPlaceholder$2 = constant$1('Font {0}');\n    const systemFont = 'System Font';\n    const systemStackFonts = [\n      '-apple-system',\n      'Segoe UI',\n      'Roboto',\n      'Helvetica Neue',\n      'sans-serif'\n    ];\n    const splitFonts = fontFamily => {\n      const fonts = fontFamily.split(/\\s*,\\s*/);\n      return map$2(fonts, font => font.replace(/^['\"]+|['\"]+$/g, ''));\n    };\n    const matchesStack = (fonts, stack) => stack.length > 0 && forall(stack, font => fonts.indexOf(font.toLowerCase()) > -1);\n    const isSystemFontStack = (fontFamily, userStack) => {\n      if (fontFamily.indexOf('-apple-system') === 0 || userStack.length > 0) {\n        const fonts = splitFonts(fontFamily.toLowerCase());\n        return matchesStack(fonts, systemStackFonts) || matchesStack(fonts, userStack);\n      } else {\n        return false;\n      }\n    };\n    const getSpec$2 = editor => {\n      const getMatchingValue = () => {\n        const getFirstFont = fontFamily => fontFamily ? splitFonts(fontFamily)[0] : '';\n        const fontFamily = editor.queryCommandValue('FontName');\n        const items = dataset.data;\n        const font = fontFamily ? fontFamily.toLowerCase() : '';\n        const userStack = getDefaultFontStack(editor);\n        const matchOpt = find$5(items, item => {\n          const format = item.format;\n          return format.toLowerCase() === font || getFirstFont(format).toLowerCase() === getFirstFont(font).toLowerCase();\n        }).orThunk(() => {\n          return someIf(isSystemFontStack(font, userStack), {\n            title: systemFont,\n            format: font\n          });\n        });\n        return {\n          matchOpt,\n          font: fontFamily\n        };\n      };\n      const isSelectedFor = item => valueOpt => valueOpt.exists(value => value.format === item);\n      const getCurrentValue = () => {\n        const {matchOpt} = getMatchingValue();\n        return matchOpt;\n      };\n      const getPreviewFor = item => () => Optional.some({\n        tag: 'div',\n        styles: item.indexOf('dings') === -1 ? { 'font-family': item } : {}\n      });\n      const onAction = rawItem => () => {\n        editor.undoManager.transact(() => {\n          editor.focus();\n          editor.execCommand('FontName', false, rawItem.format);\n        });\n      };\n      const updateSelectMenuText = comp => {\n        const {matchOpt, font} = getMatchingValue();\n        const text = matchOpt.fold(constant$1(font), item => item.title);\n        emitWith(comp, updateMenuText, { text });\n        fireFontFamilyTextUpdate(editor, { value: text });\n      };\n      const dataset = buildBasicSettingsDataset(editor, 'font_family_formats', Delimiter.SemiColon);\n      return {\n        tooltip: makeTooltipText(editor, getTooltipPlaceholder$2(), systemFont),\n        text: Optional.some(systemFont),\n        icon: Optional.none(),\n        isSelectedFor,\n        getCurrentValue,\n        getPreviewFor,\n        onAction,\n        updateText: updateSelectMenuText,\n        dataset,\n        shouldHide: false,\n        isInvalid: never\n      };\n    };\n    const createFontFamilyButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$2(editor), getTooltipPlaceholder$2, 'FontFamilyTextUpdate', 'fontfamily');\n    const createFontFamilyMenu = (editor, backstage) => {\n      const menuItems = createMenuItems(backstage, getSpec$2(editor));\n      editor.ui.registry.addNestedMenuItem('fontfamily', {\n        text: backstage.shared.providers.translate(menuTitle$2),\n        onSetup: onSetupEditableToggle(editor),\n        getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())\n      });\n    };\n\n    const units = {\n      unsupportedLength: [\n        'em',\n        'ex',\n        'cap',\n        'ch',\n        'ic',\n        'rem',\n        'lh',\n        'rlh',\n        'vw',\n        'vh',\n        'vi',\n        'vb',\n        'vmin',\n        'vmax',\n        'cm',\n        'mm',\n        'Q',\n        'in',\n        'pc',\n        'pt',\n        'px'\n      ],\n      fixed: [\n        'px',\n        'pt'\n      ],\n      relative: ['%'],\n      empty: ['']\n    };\n    const pattern = (() => {\n      const decimalDigits = '[0-9]+';\n      const signedInteger = '[+-]?' + decimalDigits;\n      const exponentPart = '[eE]' + signedInteger;\n      const dot = '\\\\.';\n      const opt = input => `(?:${ input })?`;\n      const unsignedDecimalLiteral = [\n        'Infinity',\n        decimalDigits + dot + opt(decimalDigits) + opt(exponentPart),\n        dot + decimalDigits + opt(exponentPart),\n        decimalDigits + opt(exponentPart)\n      ].join('|');\n      const float = `[+-]?(?:${ unsignedDecimalLiteral })`;\n      return new RegExp(`^(${ float })(.*)$`);\n    })();\n    const isUnit = (unit, accepted) => exists(accepted, acc => exists(units[acc], check => unit === check));\n    const parse = (input, accepted) => {\n      const match = Optional.from(pattern.exec(input));\n      return match.bind(array => {\n        const value = Number(array[1]);\n        const unitRaw = array[2];\n        if (isUnit(unitRaw, accepted)) {\n          return Optional.some({\n            value,\n            unit: unitRaw\n          });\n        } else {\n          return Optional.none();\n        }\n      });\n    };\n    const normalise = (input, accepted) => parse(input, accepted).map(({value, unit}) => value + unit);\n\n    const Keys = {\n      tab: constant$1(9),\n      escape: constant$1(27),\n      enter: constant$1(13),\n      backspace: constant$1(8),\n      delete: constant$1(46),\n      left: constant$1(37),\n      up: constant$1(38),\n      right: constant$1(39),\n      down: constant$1(40),\n      space: constant$1(32),\n      home: constant$1(36),\n      end: constant$1(35),\n      pageUp: constant$1(33),\n      pageDown: constant$1(34)\n    };\n\n    const createBespokeNumberInput = (editor, backstage, spec, btnName) => {\n      let currentComp = Optional.none();\n      const getValueFromCurrentComp = comp => comp.map(alloyComp => Representing.getValue(alloyComp)).getOr('');\n      const onSetup = onSetupEvent(editor, 'NodeChange SwitchMode', api => {\n        const comp = api.getComponent();\n        currentComp = Optional.some(comp);\n        spec.updateInputValue(comp);\n        Disabling.set(comp, !editor.selection.isEditable());\n      });\n      const getApi = comp => ({ getComponent: constant$1(comp) });\n      const editorOffCell = Cell(noop);\n      const customEvents = generate$6('custom-number-input-events');\n      const changeValue = (f, fromInput, focusBack) => {\n        const text = getValueFromCurrentComp(currentComp);\n        const newValue = spec.getNewValue(text, f);\n        const lenghtDelta = text.length - `${ newValue }`.length;\n        const oldStart = currentComp.map(comp => comp.element.dom.selectionStart - lenghtDelta);\n        const oldEnd = currentComp.map(comp => comp.element.dom.selectionEnd - lenghtDelta);\n        spec.onAction(newValue, focusBack);\n        currentComp.each(comp => {\n          Representing.setValue(comp, newValue);\n          if (fromInput) {\n            oldStart.each(oldStart => comp.element.dom.selectionStart = oldStart);\n            oldEnd.each(oldEnd => comp.element.dom.selectionEnd = oldEnd);\n          }\n        });\n      };\n      const decrease = (fromInput, focusBack) => changeValue((n, s) => n - s, fromInput, focusBack);\n      const increase = (fromInput, focusBack) => changeValue((n, s) => n + s, fromInput, focusBack);\n      const goToParent = comp => parentElement(comp.element).fold(Optional.none, parent => {\n        focus$3(parent);\n        return Optional.some(true);\n      });\n      const focusInput = comp => {\n        if (hasFocus(comp.element)) {\n          firstChild(comp.element).each(input => focus$3(input));\n          return Optional.some(true);\n        } else {\n          return Optional.none();\n        }\n      };\n      const makeStepperButton = (action, title, tooltip, classes) => {\n        const editorOffCellStepButton = Cell(noop);\n        const translatedTooltip = backstage.shared.providers.translate(tooltip);\n        const altExecuting = generate$6('altExecuting');\n        const onSetup = onSetupEvent(editor, 'NodeChange SwitchMode', api => {\n          Disabling.set(api.getComponent(), !editor.selection.isEditable());\n        });\n        const onClick = comp => {\n          if (!Disabling.isDisabled(comp)) {\n            action(true);\n          }\n        };\n        return Button.sketch({\n          dom: {\n            tag: 'button',\n            attributes: {\n              'aria-label': translatedTooltip,\n              'data-mce-name': title\n            },\n            classes: classes.concat(title)\n          },\n          components: [renderIconFromPack$1(title, backstage.shared.providers.icons)],\n          buttonBehaviours: derive$1([\n            Disabling.config({}),\n            Tooltipping.config(backstage.shared.providers.tooltips.getConfig({ tooltipText: translatedTooltip })),\n            config(altExecuting, [\n              onControlAttached({\n                onSetup,\n                getApi\n              }, editorOffCellStepButton),\n              onControlDetached({ getApi }, editorOffCellStepButton),\n              run$1(keydown(), (comp, se) => {\n                if (se.event.raw.keyCode === Keys.space() || se.event.raw.keyCode === Keys.enter()) {\n                  if (!Disabling.isDisabled(comp)) {\n                    action(false);\n                  }\n                }\n              }),\n              run$1(click(), onClick),\n              run$1(touchend(), onClick)\n            ])\n          ]),\n          eventOrder: {\n            [keydown()]: [\n              altExecuting,\n              'keying'\n            ],\n            [click()]: [\n              altExecuting,\n              'alloy.base.behaviour'\n            ],\n            [touchend()]: [\n              altExecuting,\n              'alloy.base.behaviour'\n            ],\n            [attachedToDom()]: [\n              'alloy.base.behaviour',\n              altExecuting,\n              'tooltipping'\n            ],\n            [detachedFromDom()]: [\n              altExecuting,\n              'tooltipping'\n            ]\n          }\n        });\n      };\n      const memMinus = record(makeStepperButton(focusBack => decrease(false, focusBack), 'minus', 'Decrease font size', []));\n      const memPlus = record(makeStepperButton(focusBack => increase(false, focusBack), 'plus', 'Increase font size', []));\n      const memInput = record({\n        dom: {\n          tag: 'div',\n          classes: ['tox-input-wrapper']\n        },\n        components: [Input.sketch({\n            inputBehaviours: derive$1([\n              Disabling.config({}),\n              config(customEvents, [\n                onControlAttached({\n                  onSetup,\n                  getApi\n                }, editorOffCell),\n                onControlDetached({ getApi }, editorOffCell)\n              ]),\n              config('input-update-display-text', [\n                run$1(updateMenuText, (comp, se) => {\n                  Representing.setValue(comp, se.event.text);\n                }),\n                run$1(focusout(), comp => {\n                  spec.onAction(Representing.getValue(comp));\n                }),\n                run$1(change(), comp => {\n                  spec.onAction(Representing.getValue(comp));\n                })\n              ]),\n              Keying.config({\n                mode: 'special',\n                onEnter: _comp => {\n                  changeValue(identity, true, true);\n                  return Optional.some(true);\n                },\n                onEscape: goToParent,\n                onUp: _comp => {\n                  increase(true, false);\n                  return Optional.some(true);\n                },\n                onDown: _comp => {\n                  decrease(true, false);\n                  return Optional.some(true);\n                },\n                onLeft: (_comp, se) => {\n                  se.cut();\n                  return Optional.none();\n                },\n                onRight: (_comp, se) => {\n                  se.cut();\n                  return Optional.none();\n                }\n              })\n            ])\n          })],\n        behaviours: derive$1([\n          Focusing.config({}),\n          Keying.config({\n            mode: 'special',\n            onEnter: focusInput,\n            onSpace: focusInput,\n            onEscape: goToParent\n          }),\n          config('input-wrapper-events', [run$1(mouseover(), comp => {\n              each$1([\n                memMinus,\n                memPlus\n              ], button => {\n                const buttonNode = SugarElement.fromDom(button.get(comp).element.dom);\n                if (hasFocus(buttonNode)) {\n                  blur$1(buttonNode);\n                }\n              });\n            })])\n        ])\n      });\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-number-input'],\n          attributes: { ...isNonNullable(btnName) ? { 'data-mce-name': btnName } : {} }\n        },\n        components: [\n          memMinus.asSpec(),\n          memInput.asSpec(),\n          memPlus.asSpec()\n        ],\n        behaviours: derive$1([\n          Focusing.config({}),\n          Keying.config({\n            mode: 'flow',\n            focusInside: FocusInsideModes.OnEnterOrSpaceMode,\n            cycles: false,\n            selector: 'button, .tox-input-wrapper',\n            onEscape: wrapperComp => {\n              if (hasFocus(wrapperComp.element)) {\n                return Optional.none();\n              } else {\n                focus$3(wrapperComp.element);\n                return Optional.some(true);\n              }\n            }\n          })\n        ])\n      };\n    };\n\n    const menuTitle$1 = 'Font sizes';\n    const getTooltipPlaceholder$1 = constant$1('Font size {0}');\n    const fallbackFontSize = '12pt';\n    const legacyFontSizes = {\n      '8pt': '1',\n      '10pt': '2',\n      '12pt': '3',\n      '14pt': '4',\n      '18pt': '5',\n      '24pt': '6',\n      '36pt': '7'\n    };\n    const keywordFontSizes = {\n      'xx-small': '7pt',\n      'x-small': '8pt',\n      'small': '10pt',\n      'medium': '12pt',\n      'large': '14pt',\n      'x-large': '18pt',\n      'xx-large': '24pt'\n    };\n    const round = (number, precision) => {\n      const factor = Math.pow(10, precision);\n      return Math.round(number * factor) / factor;\n    };\n    const toPt = (fontSize, precision) => {\n      if (/[0-9.]+px$/.test(fontSize)) {\n        return round(parseInt(fontSize, 10) * 72 / 96, precision || 0) + 'pt';\n      } else {\n        return get$h(keywordFontSizes, fontSize).getOr(fontSize);\n      }\n    };\n    const toLegacy = fontSize => get$h(legacyFontSizes, fontSize).getOr('');\n    const getSpec$1 = editor => {\n      const getMatchingValue = () => {\n        let matchOpt = Optional.none();\n        const items = dataset.data;\n        const fontSize = editor.queryCommandValue('FontSize');\n        if (fontSize) {\n          for (let precision = 3; matchOpt.isNone() && precision >= 0; precision--) {\n            const pt = toPt(fontSize, precision);\n            const legacy = toLegacy(pt);\n            matchOpt = find$5(items, item => item.format === fontSize || item.format === pt || item.format === legacy);\n          }\n        }\n        return {\n          matchOpt,\n          size: fontSize\n        };\n      };\n      const isSelectedFor = item => valueOpt => valueOpt.exists(value => value.format === item);\n      const getCurrentValue = () => {\n        const {matchOpt} = getMatchingValue();\n        return matchOpt;\n      };\n      const getPreviewFor = constant$1(Optional.none);\n      const onAction = rawItem => () => {\n        editor.undoManager.transact(() => {\n          editor.focus();\n          editor.execCommand('FontSize', false, rawItem.format);\n        });\n      };\n      const updateSelectMenuText = comp => {\n        const {matchOpt, size} = getMatchingValue();\n        const text = matchOpt.fold(constant$1(size), match => match.title);\n        emitWith(comp, updateMenuText, { text });\n        fireFontSizeTextUpdate(editor, { value: text });\n      };\n      const dataset = buildBasicSettingsDataset(editor, 'font_size_formats', Delimiter.Space);\n      return {\n        tooltip: makeTooltipText(editor, getTooltipPlaceholder$1(), fallbackFontSize),\n        text: Optional.some(fallbackFontSize),\n        icon: Optional.none(),\n        isSelectedFor,\n        getPreviewFor,\n        getCurrentValue,\n        onAction,\n        updateText: updateSelectMenuText,\n        dataset,\n        shouldHide: false,\n        isInvalid: never\n      };\n    };\n    const createFontSizeButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$1(editor), getTooltipPlaceholder$1, 'FontSizeTextUpdate', 'fontsize');\n    const getConfigFromUnit = unit => {\n      var _a;\n      const baseConfig = { step: 1 };\n      const configs = {\n        em: { step: 0.1 },\n        cm: { step: 0.1 },\n        in: { step: 0.1 },\n        pc: { step: 0.1 },\n        ch: { step: 0.1 },\n        rem: { step: 0.1 }\n      };\n      return (_a = configs[unit]) !== null && _a !== void 0 ? _a : baseConfig;\n    };\n    const defaultValue = 16;\n    const isValidValue = value => value >= 0;\n    const getNumberInputSpec = editor => {\n      const getCurrentValue = () => editor.queryCommandValue('FontSize');\n      const updateInputValue = comp => emitWith(comp, updateMenuText, { text: getCurrentValue() });\n      return {\n        updateInputValue,\n        onAction: (format, focusBack) => editor.execCommand('FontSize', false, format, { skip_focus: !focusBack }),\n        getNewValue: (text, updateFunction) => {\n          parse(text, [\n            'unsupportedLength',\n            'empty'\n          ]);\n          const currentValue = getCurrentValue();\n          const parsedText = parse(text, [\n            'unsupportedLength',\n            'empty'\n          ]).or(parse(currentValue, [\n            'unsupportedLength',\n            'empty'\n          ]));\n          const value = parsedText.map(res => res.value).getOr(defaultValue);\n          const defaultUnit = getFontSizeInputDefaultUnit(editor);\n          const unit = parsedText.map(res => res.unit).filter(u => u !== '').getOr(defaultUnit);\n          const newValue = updateFunction(value, getConfigFromUnit(unit).step);\n          const res = `${ isValidValue(newValue) ? newValue : value }${ unit }`;\n          if (res !== currentValue) {\n            fireFontSizeInputTextUpdate(editor, { value: res });\n          }\n          return res;\n        }\n      };\n    };\n    const createFontSizeInputButton = (editor, backstage) => createBespokeNumberInput(editor, backstage, getNumberInputSpec(editor), 'fontsizeinput');\n    const createFontSizeMenu = (editor, backstage) => {\n      const menuItems = createMenuItems(backstage, getSpec$1(editor));\n      editor.ui.registry.addNestedMenuItem('fontsize', {\n        text: menuTitle$1,\n        onSetup: onSetupEditableToggle(editor),\n        getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())\n      });\n    };\n\n    const menuTitle = 'Formats';\n    const getTooltipPlaceholder = value => isEmpty(value) ? 'Formats' : 'Format {0}';\n    const getSpec = (editor, dataset) => {\n      const fallbackFormat = 'Formats';\n      const isSelectedFor = format => () => editor.formatter.match(format);\n      const getPreviewFor = format => () => {\n        const fmt = editor.formatter.get(format);\n        return fmt !== undefined ? Optional.some({\n          tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',\n          styles: editor.dom.parseStyle(editor.formatter.getCssText(format))\n        }) : Optional.none();\n      };\n      const updateSelectMenuText = comp => {\n        const getFormatItems = fmt => {\n          if (isNestedFormat(fmt)) {\n            return bind$3(fmt.items, getFormatItems);\n          } else if (isFormatReference(fmt)) {\n            return [{\n                title: fmt.title,\n                format: fmt.format\n              }];\n          } else {\n            return [];\n          }\n        };\n        const flattenedItems = bind$3(getStyleFormats(editor), getFormatItems);\n        const detectedFormat = findNearest(editor, constant$1(flattenedItems));\n        const text = detectedFormat.fold(constant$1({\n          title: fallbackFormat,\n          tooltipLabel: ''\n        }), fmt => ({\n          title: fmt.title,\n          tooltipLabel: fmt.title\n        }));\n        emitWith(comp, updateMenuText, { text: text.title });\n        fireStylesTextUpdate(editor, { value: text.tooltipLabel });\n      };\n      return {\n        tooltip: makeTooltipText(editor, getTooltipPlaceholder(''), ''),\n        text: Optional.some(fallbackFormat),\n        icon: Optional.none(),\n        isSelectedFor,\n        getCurrentValue: Optional.none,\n        getPreviewFor,\n        onAction: onActionToggleFormat$1(editor),\n        updateText: updateSelectMenuText,\n        shouldHide: shouldAutoHideStyleFormats(editor),\n        isInvalid: item => !editor.formatter.canApply(item.format),\n        dataset\n      };\n    };\n    const createStylesButton = (editor, backstage) => {\n      const dataset = {\n        type: 'advanced',\n        ...backstage.styles\n      };\n      return createSelectButton(editor, backstage, getSpec(editor, dataset), getTooltipPlaceholder, 'StylesTextUpdate', 'styles');\n    };\n    const createStylesMenu = (editor, backstage) => {\n      const dataset = {\n        type: 'advanced',\n        ...backstage.styles\n      };\n      const menuItems = createMenuItems(backstage, getSpec(editor, dataset));\n      editor.ui.registry.addNestedMenuItem('styles', {\n        text: menuTitle,\n        onSetup: onSetupEditableToggle(editor),\n        getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())\n      });\n    };\n\n    const schema$7 = constant$1([\n      required$1('toggleClass'),\n      required$1('fetch'),\n      onStrictHandler('onExecute'),\n      defaulted('getHotspot', Optional.some),\n      defaulted('getAnchorOverrides', constant$1({})),\n      schema$y(),\n      onStrictHandler('onItemExecute'),\n      option$3('lazySink'),\n      required$1('dom'),\n      onHandler('onOpen'),\n      field('splitDropdownBehaviours', [\n        Coupling,\n        Keying,\n        Focusing\n      ]),\n      defaulted('matchWidth', false),\n      defaulted('useMinWidth', false),\n      defaulted('eventOrder', {}),\n      option$3('role'),\n      option$3('listRole')\n    ].concat(sandboxFields()));\n    const arrowPart = required({\n      factory: Button,\n      schema: [required$1('dom')],\n      name: 'arrow',\n      defaults: () => {\n        return { buttonBehaviours: derive$1([Focusing.revoke()]) };\n      },\n      overrides: detail => {\n        return {\n          dom: {\n            tag: 'span',\n            attributes: { role: 'presentation' }\n          },\n          action: arrow => {\n            arrow.getSystem().getByUid(detail.uid).each(emitExecute);\n          },\n          buttonBehaviours: derive$1([Toggling.config({\n              toggleOnExecute: false,\n              toggleClass: detail.toggleClass\n            })])\n        };\n      }\n    });\n    const buttonPart = required({\n      factory: Button,\n      schema: [required$1('dom')],\n      name: 'button',\n      defaults: () => {\n        return { buttonBehaviours: derive$1([Focusing.revoke()]) };\n      },\n      overrides: detail => {\n        return {\n          dom: {\n            tag: 'span',\n            attributes: { role: 'presentation' }\n          },\n          action: btn => {\n            btn.getSystem().getByUid(detail.uid).each(splitDropdown => {\n              detail.onExecute(splitDropdown, btn);\n            });\n          }\n        };\n      }\n    });\n    const parts$3 = constant$1([\n      arrowPart,\n      buttonPart,\n      optional({\n        factory: {\n          sketch: spec => {\n            return {\n              uid: spec.uid,\n              dom: {\n                tag: 'span',\n                styles: { display: 'none' },\n                attributes: { 'aria-hidden': 'true' },\n                innerHtml: spec.text\n              }\n            };\n          }\n        },\n        schema: [required$1('text')],\n        name: 'aria-descriptor'\n      }),\n      external({\n        schema: [tieredMenuMarkers()],\n        name: 'menu',\n        defaults: detail => {\n          return {\n            onExecute: (tmenu, item) => {\n              tmenu.getSystem().getByUid(detail.uid).each(splitDropdown => {\n                detail.onItemExecute(splitDropdown, tmenu, item);\n              });\n            }\n          };\n        }\n      }),\n      partType$1()\n    ]);\n\n    const factory$5 = (detail, components, spec, externals) => {\n      const switchToMenu = sandbox => {\n        Composing.getCurrent(sandbox).each(current => {\n          Highlighting.highlightFirst(current);\n          Keying.focusIn(current);\n        });\n      };\n      const action = component => {\n        const onOpenSync = switchToMenu;\n        togglePopup(detail, identity, component, externals, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop);\n      };\n      const openMenu = comp => {\n        action(comp);\n        return Optional.some(true);\n      };\n      const executeOnButton = comp => {\n        const button = getPartOrDie(comp, detail, 'button');\n        emitExecute(button);\n        return Optional.some(true);\n      };\n      const buttonEvents = {\n        ...derive$2([runOnAttached((component, _simulatedEvent) => {\n            const ariaDescriptor = getPart(component, detail, 'aria-descriptor');\n            ariaDescriptor.each(descriptor => {\n              const descriptorId = generate$6('aria');\n              set$9(descriptor.element, 'id', descriptorId);\n              set$9(component.element, 'aria-describedby', descriptorId);\n            });\n          })]),\n        ...events$9(Optional.some(action))\n      };\n      const apis = {\n        repositionMenus: comp => {\n          if (Toggling.isOn(comp)) {\n            repositionMenus(comp);\n          }\n        }\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components,\n        apis,\n        eventOrder: {\n          ...detail.eventOrder,\n          [execute$5()]: [\n            'disabling',\n            'toggling',\n            'alloy.base.behaviour'\n          ]\n        },\n        events: buttonEvents,\n        behaviours: augment(detail.splitDropdownBehaviours, [\n          Coupling.config({\n            others: {\n              sandbox: hotspot => {\n                const arrow = getPartOrDie(hotspot, detail, 'arrow');\n                const extras = {\n                  onOpen: () => {\n                    Toggling.on(arrow);\n                    Toggling.on(hotspot);\n                  },\n                  onClose: () => {\n                    Toggling.off(arrow);\n                    Toggling.off(hotspot);\n                  }\n                };\n                return makeSandbox$1(detail, hotspot, extras);\n              }\n            }\n          }),\n          Keying.config({\n            mode: 'special',\n            onSpace: executeOnButton,\n            onEnter: executeOnButton,\n            onDown: openMenu\n          }),\n          Focusing.config({}),\n          Toggling.config({\n            toggleOnExecute: false,\n            aria: { mode: 'expanded' }\n          })\n        ]),\n        domModification: {\n          attributes: {\n            'role': detail.role.getOr('button'),\n            'aria-haspopup': true\n          }\n        }\n      };\n    };\n    const SplitDropdown = composite({\n      name: 'SplitDropdown',\n      configFields: schema$7(),\n      partFields: parts$3(),\n      factory: factory$5,\n      apis: { repositionMenus: (apis, comp) => apis.repositionMenus(comp) }\n    });\n\n    const getButtonApi = component => ({\n      isEnabled: () => !Disabling.isDisabled(component),\n      setEnabled: state => Disabling.set(component, !state),\n      setText: text => emitWith(component, updateMenuText, { text }),\n      setIcon: icon => emitWith(component, updateMenuIcon, { icon })\n    });\n    const getToggleApi = component => ({\n      setActive: state => {\n        Toggling.set(component, state);\n      },\n      isActive: () => Toggling.isOn(component),\n      isEnabled: () => !Disabling.isDisabled(component),\n      setEnabled: state => Disabling.set(component, !state),\n      setText: text => emitWith(component, updateMenuText, { text }),\n      setIcon: icon => emitWith(component, updateMenuIcon, { icon })\n    });\n    const getTooltipAttributes = (tooltip, providersBackstage) => tooltip.map(tooltip => ({ 'aria-label': providersBackstage.translate(tooltip) })).getOr({});\n    const focusButtonEvent = generate$6('focus-button');\n    const renderCommonStructure = (optIcon, optText, tooltip, behaviours, providersBackstage, btnName) => {\n      const optMemDisplayText = optText.map(text => record(renderLabel$1(text, 'tox-tbtn', providersBackstage)));\n      const optMemDisplayIcon = optIcon.map(icon => record(renderReplaceableIconFromPack(icon, providersBackstage.icons)));\n      return {\n        dom: {\n          tag: 'button',\n          classes: ['tox-tbtn'].concat(optText.isSome() ? ['tox-tbtn--select'] : []),\n          attributes: {\n            ...getTooltipAttributes(tooltip, providersBackstage),\n            ...isNonNullable(btnName) ? { 'data-mce-name': btnName } : {}\n          }\n        },\n        components: componentRenderPipeline([\n          optMemDisplayIcon.map(mem => mem.asSpec()),\n          optMemDisplayText.map(mem => mem.asSpec())\n        ]),\n        eventOrder: {\n          [mousedown()]: [\n            'focusing',\n            'alloy.base.behaviour',\n            commonButtonDisplayEvent\n          ],\n          [attachedToDom()]: [\n            commonButtonDisplayEvent,\n            'toolbar-group-button-events'\n          ]\n        },\n        buttonBehaviours: derive$1([\n          DisablingConfigs.toolbarButton(providersBackstage.isDisabled),\n          receivingConfig(),\n          config(commonButtonDisplayEvent, [\n            runOnAttached((comp, _se) => forceInitialSize(comp)),\n            run$1(updateMenuText, (comp, se) => {\n              optMemDisplayText.bind(mem => mem.getOpt(comp)).each(displayText => {\n                Replacing.set(displayText, [text$2(providersBackstage.translate(se.event.text))]);\n              });\n            }),\n            run$1(updateMenuIcon, (comp, se) => {\n              optMemDisplayIcon.bind(mem => mem.getOpt(comp)).each(displayIcon => {\n                Replacing.set(displayIcon, [renderReplaceableIconFromPack(se.event.icon, providersBackstage.icons)]);\n              });\n            }),\n            run$1(mousedown(), (button, se) => {\n              se.event.prevent();\n              emit(button, focusButtonEvent);\n            })\n          ])\n        ].concat(behaviours.getOr([])))\n      };\n    };\n    const renderFloatingToolbarButton = (spec, backstage, identifyButtons, attributes, btnName) => {\n      const sharedBackstage = backstage.shared;\n      const editorOffCell = Cell(noop);\n      const specialisation = {\n        toolbarButtonBehaviours: [],\n        getApi: getButtonApi,\n        onSetup: spec.onSetup\n      };\n      const behaviours = [config('toolbar-group-button-events', [\n          onControlAttached(specialisation, editorOffCell),\n          onControlDetached(specialisation, editorOffCell)\n        ])];\n      return FloatingToolbarButton.sketch({\n        lazySink: sharedBackstage.getSink,\n        fetch: () => Future.nu(resolve => {\n          resolve(map$2(identifyButtons(spec.items), renderToolbarGroup));\n        }),\n        markers: { toggledClass: 'tox-tbtn--enabled' },\n        parts: {\n          button: renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.some(behaviours), sharedBackstage.providers, btnName),\n          toolbar: {\n            dom: {\n              tag: 'div',\n              classes: ['tox-toolbar__overflow'],\n              attributes\n            }\n          }\n        }\n      });\n    };\n    const renderCommonToolbarButton = (spec, specialisation, providersBackstage, btnName) => {\n      var _d;\n      const editorOffCell = Cell(noop);\n      const structure = renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.none(), providersBackstage, btnName);\n      return Button.sketch({\n        dom: structure.dom,\n        components: structure.components,\n        eventOrder: toolbarButtonEventOrder,\n        buttonBehaviours: {\n          ...derive$1([\n            config('toolbar-button-events', [\n              onToolbarButtonExecute({\n                onAction: spec.onAction,\n                getApi: specialisation.getApi\n              }),\n              onControlAttached(specialisation, editorOffCell),\n              onControlDetached(specialisation, editorOffCell)\n            ]),\n            ...spec.tooltip.map(t => Tooltipping.config(providersBackstage.tooltips.getConfig({ tooltipText: providersBackstage.translate(t) + spec.shortcut.map(shortcut => ` (${ convertText(shortcut) })`).getOr('') }))).toArray(),\n            DisablingConfigs.toolbarButton(() => !spec.enabled || providersBackstage.isDisabled()),\n            receivingConfig()\n          ].concat(specialisation.toolbarButtonBehaviours)),\n          [commonButtonDisplayEvent]: (_d = structure.buttonBehaviours) === null || _d === void 0 ? void 0 : _d[commonButtonDisplayEvent]\n        }\n      });\n    };\n    const renderToolbarButton = (spec, providersBackstage, btnName) => renderToolbarButtonWith(spec, providersBackstage, [], btnName);\n    const renderToolbarButtonWith = (spec, providersBackstage, bonusEvents, btnName) => renderCommonToolbarButton(spec, {\n      toolbarButtonBehaviours: bonusEvents.length > 0 ? [config('toolbarButtonWith', bonusEvents)] : [],\n      getApi: getButtonApi,\n      onSetup: spec.onSetup\n    }, providersBackstage, btnName);\n    const renderToolbarToggleButton = (spec, providersBackstage, btnName) => renderToolbarToggleButtonWith(spec, providersBackstage, [], btnName);\n    const renderToolbarToggleButtonWith = (spec, providersBackstage, bonusEvents, btnName) => renderCommonToolbarButton(spec, {\n      toolbarButtonBehaviours: [\n        Replacing.config({}),\n        Toggling.config({\n          toggleClass: 'tox-tbtn--enabled',\n          aria: { mode: 'pressed' },\n          toggleOnExecute: false\n        })\n      ].concat(bonusEvents.length > 0 ? [config('toolbarToggleButtonWith', bonusEvents)] : []),\n      getApi: getToggleApi,\n      onSetup: spec.onSetup\n    }, providersBackstage, btnName);\n    const fetchChoices = (getApi, spec, providersBackstage) => comp => Future.nu(callback => spec.fetch(callback)).map(items => Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6('menu-value'), items, value => {\n      spec.onItemAction(getApi(comp), value);\n    }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(never), providersBackstage), {\n      movement: deriveMenuMovement(spec.columns, spec.presets),\n      menuBehaviours: SimpleBehaviours.unnamedEvents(spec.columns !== 'auto' ? [] : [runOnAttached((comp, _se) => {\n          detectSize(comp, 4, classForPreset(spec.presets)).each(({numRows, numColumns}) => {\n            Keying.setGridSize(comp, numRows, numColumns);\n          });\n        })])\n    }))));\n    const renderSplitButton = (spec, sharedBackstage, btnName) => {\n      const tooltipString = Cell(spec.tooltip.getOr(''));\n      const getApi = comp => ({\n        isEnabled: () => !Disabling.isDisabled(comp),\n        setEnabled: state => Disabling.set(comp, !state),\n        setIconFill: (id, value) => {\n          descendant(comp.element, `svg path[class=\"${ id }\"], rect[class=\"${ id }\"]`).each(underlinePath => {\n            set$9(underlinePath, 'fill', value);\n          });\n        },\n        setActive: state => {\n          set$9(comp.element, 'aria-pressed', state);\n          descendant(comp.element, 'span').each(button => {\n            comp.getSystem().getByDom(button).each(buttonComp => Toggling.set(buttonComp, state));\n          });\n        },\n        isActive: () => descendant(comp.element, 'span').exists(button => comp.getSystem().getByDom(button).exists(Toggling.isOn)),\n        setText: text => descendant(comp.element, 'span').each(button => comp.getSystem().getByDom(button).each(buttonComp => emitWith(buttonComp, updateMenuText, { text }))),\n        setIcon: icon => descendant(comp.element, 'span').each(button => comp.getSystem().getByDom(button).each(buttonComp => emitWith(buttonComp, updateMenuIcon, { icon }))),\n        setTooltip: tooltip => {\n          const translatedTooltip = sharedBackstage.providers.translate(tooltip);\n          set$9(comp.element, 'aria-label', translatedTooltip);\n          tooltipString.set(tooltip);\n        }\n      });\n      const editorOffCell = Cell(noop);\n      const specialisation = {\n        getApi,\n        onSetup: spec.onSetup\n      };\n      return SplitDropdown.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-split-button'],\n          attributes: {\n            'aria-pressed': false,\n            ...getTooltipAttributes(spec.tooltip, sharedBackstage.providers),\n            ...isNonNullable(btnName) ? { 'data-mce-name': btnName } : {}\n          }\n        },\n        onExecute: button => {\n          const api = getApi(button);\n          if (api.isEnabled()) {\n            spec.onAction(api);\n          }\n        },\n        onItemExecute: (_a, _b, _c) => {\n        },\n        splitDropdownBehaviours: derive$1([\n          DisablingConfigs.splitButton(sharedBackstage.providers.isDisabled),\n          receivingConfig(),\n          config('split-dropdown-events', [\n            runOnAttached((comp, _se) => forceInitialSize(comp)),\n            run$1(focusButtonEvent, Focusing.focus),\n            onControlAttached(specialisation, editorOffCell),\n            onControlDetached(specialisation, editorOffCell)\n          ]),\n          Unselecting.config({}),\n          ...spec.tooltip.map(tooltip => {\n            return Tooltipping.config({\n              ...sharedBackstage.providers.tooltips.getConfig({\n                tooltipText: sharedBackstage.providers.translate(tooltip),\n                onShow: comp => {\n                  if (tooltipString.get() !== tooltip) {\n                    const translatedTooltip = sharedBackstage.providers.translate(tooltipString.get());\n                    Tooltipping.setComponents(comp, sharedBackstage.providers.tooltips.getComponents({ tooltipText: translatedTooltip }));\n                  }\n                }\n              })\n            });\n          }).toArray()\n        ]),\n        eventOrder: {\n          [attachedToDom()]: [\n            'alloy.base.behaviour',\n            'split-dropdown-events',\n            'tooltipping'\n          ],\n          [detachedFromDom()]: [\n            'split-dropdown-events',\n            'tooltipping'\n          ]\n        },\n        toggleClass: 'tox-tbtn--enabled',\n        lazySink: sharedBackstage.getSink,\n        fetch: fetchChoices(getApi, spec, sharedBackstage.providers),\n        parts: { menu: part(false, spec.columns, spec.presets) },\n        components: [\n          SplitDropdown.parts.button(renderCommonStructure(spec.icon, spec.text, Optional.none(), Optional.some([Toggling.config({\n              toggleClass: 'tox-tbtn--enabled',\n              toggleOnExecute: false\n            })]), sharedBackstage.providers)),\n          SplitDropdown.parts.arrow({\n            dom: {\n              tag: 'button',\n              classes: [\n                'tox-tbtn',\n                'tox-split-button__chevron'\n              ],\n              innerHtml: get$3('chevron-down', sharedBackstage.providers.icons)\n            },\n            buttonBehaviours: derive$1([\n              DisablingConfigs.splitButton(sharedBackstage.providers.isDisabled),\n              receivingConfig(),\n              addFocusableBehaviour()\n            ])\n          }),\n          SplitDropdown.parts['aria-descriptor']({ text: sharedBackstage.providers.translate('To open the popup, press Shift+Enter') })\n        ]\n      });\n    };\n\n    const defaultToolbar = [\n      {\n        name: 'history',\n        items: [\n          'undo',\n          'redo'\n        ]\n      },\n      {\n        name: 'ai',\n        items: [\n          'aidialog',\n          'aishortcuts'\n        ]\n      },\n      {\n        name: 'styles',\n        items: ['styles']\n      },\n      {\n        name: 'formatting',\n        items: [\n          'bold',\n          'italic'\n        ]\n      },\n      {\n        name: 'alignment',\n        items: [\n          'alignleft',\n          'aligncenter',\n          'alignright',\n          'alignjustify'\n        ]\n      },\n      {\n        name: 'indentation',\n        items: [\n          'outdent',\n          'indent'\n        ]\n      },\n      {\n        name: 'permanent pen',\n        items: ['permanentpen']\n      },\n      {\n        name: 'comments',\n        items: ['addcomment']\n      }\n    ];\n    const renderFromBridge = (bridgeBuilder, render) => (spec, backstage, editor, btnName) => {\n      const internal = bridgeBuilder(spec).mapError(errInfo => formatError(errInfo)).getOrDie();\n      return render(internal, backstage, editor, btnName);\n    };\n    const types = {\n      button: renderFromBridge(createToolbarButton, (s, backstage, _, btnName) => renderToolbarButton(s, backstage.shared.providers, btnName)),\n      togglebutton: renderFromBridge(createToggleButton, (s, backstage, _, btnName) => renderToolbarToggleButton(s, backstage.shared.providers, btnName)),\n      menubutton: renderFromBridge(createMenuButton, (s, backstage, _, btnName) => renderMenuButton(s, 'tox-tbtn', backstage, Optional.none(), false, btnName)),\n      splitbutton: renderFromBridge(createSplitButton, (s, backstage, _, btnName) => renderSplitButton(s, backstage.shared, btnName)),\n      grouptoolbarbutton: renderFromBridge(createGroupToolbarButton, (s, backstage, editor, btnName) => {\n        const buttons = editor.ui.registry.getAll().buttons;\n        const identify = toolbar => identifyButtons(editor, {\n          buttons,\n          toolbar,\n          allowToolbarGroups: false\n        }, backstage, Optional.none());\n        const attributes = { [Attribute]: backstage.shared.header.isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop };\n        switch (getToolbarMode(editor)) {\n        case ToolbarMode$1.floating:\n          return renderFloatingToolbarButton(s, backstage, identify, attributes, btnName);\n        default:\n          throw new Error('Toolbar groups are only supported when using floating toolbar mode');\n        }\n      })\n    };\n    const extractFrom = (spec, backstage, editor, btnName) => get$h(types, spec.type).fold(() => {\n      console.error('skipping button defined by', spec);\n      return Optional.none();\n    }, render => Optional.some(render(spec, backstage, editor, btnName)));\n    const bespokeButtons = {\n      styles: createStylesButton,\n      fontsize: createFontSizeButton,\n      fontsizeinput: createFontSizeInputButton,\n      fontfamily: createFontFamilyButton,\n      blocks: createBlocksButton,\n      align: createAlignButton\n    };\n    const removeUnusedDefaults = buttons => {\n      const filteredItemGroups = map$2(defaultToolbar, group => {\n        const items = filter$2(group.items, subItem => has$2(buttons, subItem) || has$2(bespokeButtons, subItem));\n        return {\n          name: group.name,\n          items\n        };\n      });\n      return filter$2(filteredItemGroups, group => group.items.length > 0);\n    };\n    const convertStringToolbar = strToolbar => {\n      const groupsStrings = strToolbar.split('|');\n      return map$2(groupsStrings, g => ({ items: g.trim().split(' ') }));\n    };\n    const isToolbarGroupSettingArray = toolbar => isArrayOf(toolbar, t => has$2(t, 'name') && has$2(t, 'items'));\n    const createToolbar = toolbarConfig => {\n      const toolbar = toolbarConfig.toolbar;\n      const buttons = toolbarConfig.buttons;\n      if (toolbar === false) {\n        return [];\n      } else if (toolbar === undefined || toolbar === true) {\n        return removeUnusedDefaults(buttons);\n      } else if (isString(toolbar)) {\n        return convertStringToolbar(toolbar);\n      } else if (isToolbarGroupSettingArray(toolbar)) {\n        return toolbar;\n      } else {\n        console.error('Toolbar type should be string, string[], boolean or ToolbarGroup[]');\n        return [];\n      }\n    };\n    const lookupButton = (editor, buttons, toolbarItem, allowToolbarGroups, backstage, prefixes) => get$h(buttons, toolbarItem.toLowerCase()).orThunk(() => prefixes.bind(ps => findMap(ps, prefix => get$h(buttons, prefix + toolbarItem.toLowerCase())))).fold(() => get$h(bespokeButtons, toolbarItem.toLowerCase()).map(r => r(editor, backstage)), spec => {\n      if (spec.type === 'grouptoolbarbutton' && !allowToolbarGroups) {\n        console.warn(`Ignoring the '${ toolbarItem }' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.`);\n        return Optional.none();\n      } else {\n        return extractFrom(spec, backstage, editor, toolbarItem.toLowerCase());\n      }\n    });\n    const identifyButtons = (editor, toolbarConfig, backstage, prefixes) => {\n      const toolbarGroups = createToolbar(toolbarConfig);\n      const groups = map$2(toolbarGroups, group => {\n        const items = bind$3(group.items, toolbarItem => {\n          return toolbarItem.trim().length === 0 ? [] : lookupButton(editor, toolbarConfig.buttons, toolbarItem, toolbarConfig.allowToolbarGroups, backstage, prefixes).toArray();\n        });\n        return {\n          title: Optional.from(editor.translate(group.name)),\n          items\n        };\n      });\n      return filter$2(groups, group => group.items.length > 0);\n    };\n\n    const setToolbar = (editor, uiRefs, rawUiConfig, backstage) => {\n      const outerContainer = uiRefs.mainUi.outerContainer;\n      const toolbarConfig = rawUiConfig.toolbar;\n      const toolbarButtonsConfig = rawUiConfig.buttons;\n      if (isArrayOf(toolbarConfig, isString)) {\n        const toolbars = toolbarConfig.map(t => {\n          const config = {\n            toolbar: t,\n            buttons: toolbarButtonsConfig,\n            allowToolbarGroups: rawUiConfig.allowToolbarGroups\n          };\n          return identifyButtons(editor, config, backstage, Optional.none());\n        });\n        OuterContainer.setToolbars(outerContainer, toolbars);\n      } else {\n        OuterContainer.setToolbar(outerContainer, identifyButtons(editor, rawUiConfig, backstage, Optional.none()));\n      }\n    };\n\n    const detection = detect$1();\n    const isiOS12 = detection.os.isiOS() && detection.os.version.major <= 12;\n    const setupEvents$1 = (editor, uiRefs) => {\n      const {uiMotherships} = uiRefs;\n      const dom = editor.dom;\n      let contentWindow = editor.getWin();\n      const initialDocEle = editor.getDoc().documentElement;\n      const lastWindowDimensions = Cell(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));\n      const lastDocumentDimensions = Cell(SugarPosition(initialDocEle.offsetWidth, initialDocEle.offsetHeight));\n      const resizeWindow = () => {\n        const outer = lastWindowDimensions.get();\n        if (outer.left !== contentWindow.innerWidth || outer.top !== contentWindow.innerHeight) {\n          lastWindowDimensions.set(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));\n          fireResizeContent(editor);\n        }\n      };\n      const resizeDocument = () => {\n        const docEle = editor.getDoc().documentElement;\n        const inner = lastDocumentDimensions.get();\n        if (inner.left !== docEle.offsetWidth || inner.top !== docEle.offsetHeight) {\n          lastDocumentDimensions.set(SugarPosition(docEle.offsetWidth, docEle.offsetHeight));\n          fireResizeContent(editor);\n        }\n      };\n      const scroll = e => {\n        fireScrollContent(editor, e);\n      };\n      dom.bind(contentWindow, 'resize', resizeWindow);\n      dom.bind(contentWindow, 'scroll', scroll);\n      const elementLoad = capture(SugarElement.fromDom(editor.getBody()), 'load', resizeDocument);\n      editor.on('hide', () => {\n        each$1(uiMotherships, m => {\n          set$8(m.element, 'display', 'none');\n        });\n      });\n      editor.on('show', () => {\n        each$1(uiMotherships, m => {\n          remove$7(m.element, 'display');\n        });\n      });\n      editor.on('NodeChange', resizeDocument);\n      editor.on('remove', () => {\n        elementLoad.unbind();\n        dom.unbind(contentWindow, 'resize', resizeWindow);\n        dom.unbind(contentWindow, 'scroll', scroll);\n        contentWindow = null;\n      });\n    };\n    const attachUiMotherships = (editor, uiRoot, uiRefs) => {\n      if (isSplitUiMode(editor)) {\n        attachSystemAfter(uiRefs.mainUi.mothership.element, uiRefs.popupUi.mothership);\n      }\n      attachSystem(uiRoot, uiRefs.dialogUi.mothership);\n    };\n    const render$1 = (editor, uiRefs, rawUiConfig, backstage, args) => {\n      const {mainUi, uiMotherships} = uiRefs;\n      const lastToolbarWidth = Cell(0);\n      const outerContainer = mainUi.outerContainer;\n      iframe(editor);\n      const eTargetNode = SugarElement.fromDom(args.targetNode);\n      const uiRoot = getContentContainer(getRootNode(eTargetNode));\n      attachSystemAfter(eTargetNode, mainUi.mothership);\n      attachUiMotherships(editor, uiRoot, uiRefs);\n      editor.on('SkinLoaded', () => {\n        OuterContainer.setSidebar(outerContainer, rawUiConfig.sidebar, getSidebarShow(editor));\n        setToolbar(editor, uiRefs, rawUiConfig, backstage);\n        lastToolbarWidth.set(editor.getWin().innerWidth);\n        OuterContainer.setMenubar(outerContainer, identifyMenus(editor, rawUiConfig));\n        OuterContainer.setViews(outerContainer, rawUiConfig.views);\n        setupEvents$1(editor, uiRefs);\n      });\n      const socket = OuterContainer.getSocket(outerContainer).getOrDie('Could not find expected socket element');\n      if (isiOS12) {\n        setAll(socket.element, {\n          'overflow': 'scroll',\n          '-webkit-overflow-scrolling': 'touch'\n        });\n        const limit = first(() => {\n          editor.dispatch('ScrollContent');\n        }, 20);\n        const unbinder = bind(socket.element, 'scroll', limit.throttle);\n        editor.on('remove', unbinder.unbind);\n      }\n      setupReadonlyModeSwitch(editor, uiRefs);\n      editor.addCommand('ToggleSidebar', (_ui, value) => {\n        OuterContainer.toggleSidebar(outerContainer, value);\n        editor.dispatch('ToggleSidebar');\n      });\n      editor.addQueryValueHandler('ToggleSidebar', () => {\n        var _a;\n        return (_a = OuterContainer.whichSidebar(outerContainer)) !== null && _a !== void 0 ? _a : '';\n      });\n      editor.addCommand('ToggleView', (_ui, value) => {\n        if (OuterContainer.toggleView(outerContainer, value)) {\n          const target = outerContainer.element;\n          mainUi.mothership.broadcastOn([dismissPopups()], { target });\n          each$1(uiMotherships, m => {\n            m.broadcastOn([dismissPopups()], { target });\n          });\n          if (isNull(OuterContainer.whichView(outerContainer))) {\n            editor.focus();\n            editor.nodeChanged();\n            OuterContainer.refreshToolbar(outerContainer);\n          }\n        }\n      });\n      editor.addQueryValueHandler('ToggleView', () => {\n        var _a;\n        return (_a = OuterContainer.whichView(outerContainer)) !== null && _a !== void 0 ? _a : '';\n      });\n      const toolbarMode = getToolbarMode(editor);\n      const refreshDrawer = () => {\n        OuterContainer.refreshToolbar(uiRefs.mainUi.outerContainer);\n      };\n      if (toolbarMode === ToolbarMode$1.sliding || toolbarMode === ToolbarMode$1.floating) {\n        editor.on('ResizeWindow ResizeEditor ResizeContent', () => {\n          const width = editor.getWin().innerWidth;\n          if (width !== lastToolbarWidth.get()) {\n            refreshDrawer();\n            lastToolbarWidth.set(width);\n          }\n        });\n      }\n      const api = {\n        setEnabled: state => {\n          broadcastReadonly(uiRefs, !state);\n        },\n        isEnabled: () => !Disabling.isDisabled(outerContainer)\n      };\n      return {\n        iframeContainer: socket.element.dom,\n        editorContainer: outerContainer.element.dom,\n        api\n      };\n    };\n\n    var Iframe = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        render: render$1\n    });\n\n    const parseToInt = val => {\n      const re = /^[0-9\\.]+(|px)$/i;\n      if (re.test('' + val)) {\n        return Optional.some(parseInt('' + val, 10));\n      }\n      return Optional.none();\n    };\n    const numToPx = val => isNumber(val) ? val + 'px' : val;\n    const calcCappedSize = (size, minSize, maxSize) => {\n      const minOverride = minSize.filter(min => size < min);\n      const maxOverride = maxSize.filter(max => size > max);\n      return minOverride.or(maxOverride).getOr(size);\n    };\n\n    const getHeight = editor => {\n      const baseHeight = getHeightOption(editor);\n      const minHeight = getMinHeightOption(editor);\n      const maxHeight = getMaxHeightOption(editor);\n      return parseToInt(baseHeight).map(height => calcCappedSize(height, minHeight, maxHeight));\n    };\n    const getHeightWithFallback = editor => {\n      const height = getHeight(editor);\n      return height.getOr(getHeightOption(editor));\n    };\n    const getWidth = editor => {\n      const baseWidth = getWidthOption(editor);\n      const minWidth = getMinWidthOption(editor);\n      const maxWidth = getMaxWidthOption(editor);\n      return parseToInt(baseWidth).map(width => calcCappedSize(width, minWidth, maxWidth));\n    };\n    const getWidthWithFallback = editor => {\n      const width = getWidth(editor);\n      return width.getOr(getWidthOption(editor));\n    };\n\n    const {ToolbarLocation, ToolbarMode} = Options;\n    const maximumDistanceToEdge = 40;\n    const InlineHeader = (editor, targetElm, uiRefs, backstage, floatContainer) => {\n      const {mainUi, uiMotherships} = uiRefs;\n      const DOM = global$8.DOM;\n      const useFixedToolbarContainer = useFixedContainer(editor);\n      const isSticky = isStickyToolbar(editor);\n      const editorMaxWidthOpt = getMaxWidthOption(editor).or(getWidth(editor));\n      const headerBackstage = backstage.shared.header;\n      const isPositionedAtTop = headerBackstage.isPositionedAtTop;\n      const minimumToolbarWidth = 150;\n      const toolbarMode = getToolbarMode(editor);\n      const isSplitToolbar = toolbarMode === ToolbarMode.sliding || toolbarMode === ToolbarMode.floating;\n      const visible = Cell(false);\n      const isVisible = () => visible.get() && !editor.removed;\n      const calcToolbarOffset = toolbar => isSplitToolbar ? toolbar.fold(constant$1(0), tbar => tbar.components().length > 1 ? get$e(tbar.components()[1].element) : 0) : 0;\n      const calcMode = container => {\n        switch (getToolbarLocation(editor)) {\n        case ToolbarLocation.auto:\n          const toolbar = OuterContainer.getToolbar(mainUi.outerContainer);\n          const offset = calcToolbarOffset(toolbar);\n          const toolbarHeight = get$e(container.element) - offset;\n          const targetBounds = box$1(targetElm);\n          const roomAtTop = targetBounds.y > toolbarHeight;\n          if (roomAtTop) {\n            return 'top';\n          } else {\n            const doc = documentElement(targetElm);\n            const docHeight = Math.max(doc.dom.scrollHeight, get$e(doc));\n            const roomAtBottom = targetBounds.bottom < docHeight - toolbarHeight;\n            if (roomAtBottom) {\n              return 'bottom';\n            } else {\n              const winBounds = win();\n              const isRoomAtBottomViewport = winBounds.bottom < targetBounds.bottom - toolbarHeight;\n              return isRoomAtBottomViewport ? 'bottom' : 'top';\n            }\n          }\n        case ToolbarLocation.bottom:\n          return 'bottom';\n        case ToolbarLocation.top:\n        default:\n          return 'top';\n        }\n      };\n      const setupMode = mode => {\n        floatContainer.on(container => {\n          Docking.setModes(container, [mode]);\n          headerBackstage.setDockingMode(mode);\n          const verticalDir = isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop;\n          set$9(container.element, Attribute, verticalDir);\n        });\n      };\n      const updateChromeWidth = () => {\n        floatContainer.on(container => {\n          const maxWidth = editorMaxWidthOpt.getOrThunk(() => {\n            return getBounds$3().width - viewport$1(targetElm).left - 10;\n          });\n          set$8(container.element, 'max-width', maxWidth + 'px');\n        });\n      };\n      const updateChromePosition = (isOuterContainerWidthRestored, prevScroll) => {\n        floatContainer.on(container => {\n          const toolbar = OuterContainer.getToolbar(mainUi.outerContainer);\n          const offset = calcToolbarOffset(toolbar);\n          const targetBounds = box$1(targetElm);\n          const offsetParent = getOffsetParent$1(editor, mainUi.outerContainer.element);\n          const getLeft = () => offsetParent.fold(() => targetBounds.x, offsetParent => {\n            const offsetBox = box$1(offsetParent);\n            const isOffsetParentBody = eq(offsetParent, body());\n            return isOffsetParentBody ? targetBounds.x : targetBounds.x - offsetBox.x;\n          });\n          const getTop = () => offsetParent.fold(() => isPositionedAtTop() ? Math.max(targetBounds.y - get$e(container.element) + offset, 0) : targetBounds.bottom, offsetParent => {\n            var _a;\n            const offsetBox = box$1(offsetParent);\n            const scrollDelta = (_a = offsetParent.dom.scrollTop) !== null && _a !== void 0 ? _a : 0;\n            const isOffsetParentBody = eq(offsetParent, body());\n            const topValue = isOffsetParentBody ? Math.max(targetBounds.y - get$e(container.element) + offset, 0) : targetBounds.y - offsetBox.y + scrollDelta - get$e(container.element) + offset;\n            return isPositionedAtTop() ? topValue : targetBounds.bottom;\n          });\n          const left = getLeft();\n          const widthProperties = someIf(isOuterContainerWidthRestored, Math.ceil(mainUi.outerContainer.element.dom.getBoundingClientRect().width)).filter(w => w > minimumToolbarWidth).map(toolbarWidth => {\n            const scroll = prevScroll.getOr(get$c());\n            const availableWidth = window.innerWidth - (left - scroll.left);\n            const width = Math.max(Math.min(toolbarWidth, availableWidth), minimumToolbarWidth);\n            if (availableWidth < toolbarWidth) {\n              set$8(mainUi.outerContainer.element, 'width', width + 'px');\n            }\n            return { width: width + 'px' };\n          }).getOr({ width: 'max-content' });\n          const baseProperties = {\n            position: 'absolute',\n            left: Math.round(left) + 'px',\n            top: getTop() + 'px'\n          };\n          setAll(mainUi.outerContainer.element, {\n            ...baseProperties,\n            ...widthProperties\n          });\n        });\n      };\n      const getOffsetParent$1 = (editor, element) => isSplitUiMode(editor) ? getOffsetParent(element) : Optional.none();\n      const repositionPopups$1 = () => {\n        each$1(uiMotherships, m => {\n          m.broadcastOn([repositionPopups()], {});\n        });\n      };\n      const restoreOuterContainerWidth = () => {\n        if (!useFixedToolbarContainer) {\n          const toolbarCurrentRightsidePosition = absolute$3(mainUi.outerContainer.element).left + getOuter$1(mainUi.outerContainer.element);\n          if (toolbarCurrentRightsidePosition >= window.innerWidth - maximumDistanceToEdge || getRaw(mainUi.outerContainer.element, 'width').isSome()) {\n            set$8(mainUi.outerContainer.element, 'position', 'absolute');\n            set$8(mainUi.outerContainer.element, 'left', '0px');\n            remove$7(mainUi.outerContainer.element, 'width');\n            return true;\n          }\n        }\n        return false;\n      };\n      const update = stickyAction => {\n        if (!isVisible()) {\n          return;\n        }\n        if (!useFixedToolbarContainer) {\n          updateChromeWidth();\n        }\n        const prevScroll = get$c();\n        const isOuterContainerWidthRestored = useFixedToolbarContainer ? false : restoreOuterContainerWidth();\n        if (isSplitToolbar) {\n          OuterContainer.refreshToolbar(mainUi.outerContainer);\n        }\n        if (!useFixedToolbarContainer) {\n          const currentScroll = get$c();\n          const optScroll = someIf(prevScroll.left !== currentScroll.left, prevScroll);\n          updateChromePosition(isOuterContainerWidthRestored, optScroll);\n          optScroll.each(scroll => {\n            to(scroll.left, currentScroll.top);\n          });\n        }\n        if (isSticky) {\n          floatContainer.on(stickyAction);\n        }\n        repositionPopups$1();\n      };\n      const doUpdateMode = () => {\n        if (useFixedToolbarContainer || !isSticky || !isVisible()) {\n          return false;\n        }\n        return floatContainer.get().exists(fc => {\n          const currentMode = headerBackstage.getDockingMode();\n          const newMode = calcMode(fc);\n          if (newMode !== currentMode) {\n            setupMode(newMode);\n            return true;\n          } else {\n            return false;\n          }\n        });\n      };\n      const show = () => {\n        visible.set(true);\n        set$8(mainUi.outerContainer.element, 'display', 'flex');\n        DOM.addClass(editor.getBody(), 'mce-edit-focus');\n        each$1(uiMotherships, m => {\n          remove$7(m.element, 'display');\n        });\n        doUpdateMode();\n        if (isSplitUiMode(editor)) {\n          update(elem => Docking.isDocked(elem) ? Docking.reset(elem) : Docking.refresh(elem));\n        } else {\n          update(Docking.refresh);\n        }\n      };\n      const hide = () => {\n        visible.set(false);\n        set$8(mainUi.outerContainer.element, 'display', 'none');\n        DOM.removeClass(editor.getBody(), 'mce-edit-focus');\n        each$1(uiMotherships, m => {\n          set$8(m.element, 'display', 'none');\n        });\n      };\n      const updateMode = () => {\n        const changedMode = doUpdateMode();\n        if (changedMode) {\n          update(Docking.reset);\n        }\n      };\n      return {\n        isVisible,\n        isPositionedAtTop,\n        show,\n        hide,\n        update,\n        updateMode,\n        repositionPopups: repositionPopups$1\n      };\n    };\n\n    const getTargetPosAndBounds = (targetElm, isToolbarTop) => {\n      const bounds = box$1(targetElm);\n      return {\n        pos: isToolbarTop ? bounds.y : bounds.bottom,\n        bounds\n      };\n    };\n    const setupEvents = (editor, targetElm, ui, toolbarPersist) => {\n      const prevPosAndBounds = Cell(getTargetPosAndBounds(targetElm, ui.isPositionedAtTop()));\n      const resizeContent = e => {\n        const {pos, bounds} = getTargetPosAndBounds(targetElm, ui.isPositionedAtTop());\n        const {\n          pos: prevPos,\n          bounds: prevBounds\n        } = prevPosAndBounds.get();\n        const hasResized = bounds.height !== prevBounds.height || bounds.width !== prevBounds.width;\n        prevPosAndBounds.set({\n          pos,\n          bounds\n        });\n        if (hasResized) {\n          fireResizeContent(editor, e);\n        }\n        if (ui.isVisible()) {\n          if (prevPos !== pos) {\n            ui.update(Docking.reset);\n          } else if (hasResized) {\n            ui.updateMode();\n            ui.repositionPopups();\n          }\n        }\n      };\n      if (!toolbarPersist) {\n        editor.on('activate', ui.show);\n        editor.on('deactivate', ui.hide);\n      }\n      editor.on('SkinLoaded ResizeWindow', () => ui.update(Docking.reset));\n      editor.on('NodeChange keydown', e => {\n        requestAnimationFrame(() => resizeContent(e));\n      });\n      let lastScrollX = 0;\n      const updateUi = last(() => ui.update(Docking.refresh), 33);\n      editor.on('ScrollWindow', () => {\n        const newScrollX = get$c().left;\n        if (newScrollX !== lastScrollX) {\n          lastScrollX = newScrollX;\n          updateUi.throttle();\n        }\n        ui.updateMode();\n      });\n      if (isSplitUiMode(editor)) {\n        editor.on('ElementScroll', _args => {\n          ui.update(Docking.refresh);\n        });\n      }\n      const elementLoad = unbindable();\n      elementLoad.set(capture(SugarElement.fromDom(editor.getBody()), 'load', e => resizeContent(e.raw)));\n      editor.on('remove', () => {\n        elementLoad.clear();\n      });\n    };\n    const render = (editor, uiRefs, rawUiConfig, backstage, args) => {\n      const {mainUi} = uiRefs;\n      const floatContainer = value$4();\n      const targetElm = SugarElement.fromDom(args.targetNode);\n      const ui = InlineHeader(editor, targetElm, uiRefs, backstage, floatContainer);\n      const toolbarPersist = isToolbarPersist(editor);\n      inline(editor);\n      const render = () => {\n        if (floatContainer.isSet()) {\n          ui.show();\n          return;\n        }\n        floatContainer.set(OuterContainer.getHeader(mainUi.outerContainer).getOrDie());\n        const uiContainer = getUiContainer(editor);\n        if (isSplitUiMode(editor)) {\n          attachSystemAfter(targetElm, mainUi.mothership);\n          attachSystemAfter(targetElm, uiRefs.popupUi.mothership);\n        } else {\n          attachSystem(uiContainer, mainUi.mothership);\n        }\n        attachSystem(uiContainer, uiRefs.dialogUi.mothership);\n        const setup = () => {\n          setToolbar(editor, uiRefs, rawUiConfig, backstage);\n          OuterContainer.setMenubar(mainUi.outerContainer, identifyMenus(editor, rawUiConfig));\n          ui.show();\n          setupEvents(editor, targetElm, ui, toolbarPersist);\n          editor.nodeChanged();\n        };\n        if (toolbarPersist) {\n          editor.once('SkinLoaded', setup);\n        } else {\n          setup();\n        }\n      };\n      editor.on('show', render);\n      editor.on('hide', ui.hide);\n      if (!toolbarPersist) {\n        editor.on('focus', render);\n        editor.on('blur', ui.hide);\n      }\n      editor.on('init', () => {\n        if (editor.hasFocus() || toolbarPersist) {\n          render();\n        }\n      });\n      setupReadonlyModeSwitch(editor, uiRefs);\n      const api = {\n        show: render,\n        hide: ui.hide,\n        setEnabled: state => {\n          broadcastReadonly(uiRefs, !state);\n        },\n        isEnabled: () => !Disabling.isDisabled(mainUi.outerContainer)\n      };\n      return {\n        editorContainer: mainUi.outerContainer.element.dom,\n        api\n      };\n    };\n\n    var Inline = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        render: render\n    });\n\n    const LazyUiReferences = () => {\n      const dialogUi = value$4();\n      const popupUi = value$4();\n      const mainUi = value$4();\n      const lazyGetInOuterOrDie = (label, f) => () => mainUi.get().bind(oc => f(oc.outerContainer)).getOrDie(`Could not find ${ label } element in OuterContainer`);\n      const getUiMotherships = () => {\n        const optDialogMothership = dialogUi.get().map(ui => ui.mothership);\n        const optPopupMothership = popupUi.get().map(ui => ui.mothership);\n        return optDialogMothership.fold(() => optPopupMothership.toArray(), dm => optPopupMothership.fold(() => [dm], pm => eq(dm.element, pm.element) ? [dm] : [\n          dm,\n          pm\n        ]));\n      };\n      return {\n        dialogUi,\n        popupUi,\n        mainUi,\n        getUiMotherships,\n        lazyGetInOuterOrDie\n      };\n    };\n\n    const showContextToolbarEvent = 'contexttoolbar-show';\n    const hideContextToolbarEvent = 'contexttoolbar-hide';\n\n    const getFormApi = input => ({\n      hide: () => emit(input, sandboxClose()),\n      getValue: () => Representing.getValue(input)\n    });\n    const runOnExecute = (memInput, original) => run$1(internalToolbarButtonExecute, (comp, se) => {\n      const input = memInput.get(comp);\n      const formApi = getFormApi(input);\n      original.onAction(formApi, se.event.buttonApi);\n    });\n    const renderContextButton = (memInput, button, providers) => {\n      const {primary, ...rest} = button.original;\n      const bridged = getOrDie(createToolbarButton({\n        ...rest,\n        type: 'button',\n        onAction: noop\n      }));\n      return renderToolbarButtonWith(bridged, providers, [runOnExecute(memInput, button)]);\n    };\n    const renderContextToggleButton = (memInput, button, providers) => {\n      const {primary, ...rest} = button.original;\n      const bridged = getOrDie(createToggleButton({\n        ...rest,\n        type: 'togglebutton',\n        onAction: noop\n      }));\n      return renderToolbarToggleButtonWith(bridged, providers, [runOnExecute(memInput, button)]);\n    };\n    const isToggleButton = button => button.type === 'contextformtogglebutton';\n    const generateOne = (memInput, button, providersBackstage) => {\n      if (isToggleButton(button)) {\n        return renderContextToggleButton(memInput, button, providersBackstage);\n      } else {\n        return renderContextButton(memInput, button, providersBackstage);\n      }\n    };\n    const generate = (memInput, buttons, providersBackstage) => {\n      const mementos = map$2(buttons, button => record(generateOne(memInput, button, providersBackstage)));\n      const asSpecs = () => map$2(mementos, mem => mem.asSpec());\n      const findPrimary = compInSystem => findMap(buttons, (button, i) => {\n        if (button.primary) {\n          return Optional.from(mementos[i]).bind(mem => mem.getOpt(compInSystem)).filter(not(Disabling.isDisabled));\n        } else {\n          return Optional.none();\n        }\n      });\n      return {\n        asSpecs,\n        findPrimary\n      };\n    };\n\n    const buildInitGroups = (ctx, providers) => {\n      const inputAttributes = ctx.label.fold(() => ({}), label => ({ 'aria-label': label }));\n      const memInput = record(Input.sketch({\n        inputClasses: [\n          'tox-toolbar-textfield',\n          'tox-toolbar-nav-js'\n        ],\n        data: ctx.initValue(),\n        inputAttributes,\n        selectOnFocus: true,\n        inputBehaviours: derive$1([Keying.config({\n            mode: 'special',\n            onEnter: input => commands.findPrimary(input).map(primary => {\n              emitExecute(primary);\n              return true;\n            }),\n            onLeft: (comp, se) => {\n              se.cut();\n              return Optional.none();\n            },\n            onRight: (comp, se) => {\n              se.cut();\n              return Optional.none();\n            }\n          })])\n      }));\n      const commands = generate(memInput, ctx.commands, providers);\n      return [\n        {\n          title: Optional.none(),\n          items: [memInput.asSpec()]\n        },\n        {\n          title: Optional.none(),\n          items: commands.asSpecs()\n        }\n      ];\n    };\n    const renderContextForm = (toolbarType, ctx, providers) => renderToolbar({\n      type: toolbarType,\n      uid: generate$6('context-toolbar'),\n      initGroups: buildInitGroups(ctx, providers),\n      onEscape: Optional.none,\n      cyclicKeying: true,\n      providers\n    });\n    const ContextForm = {\n      renderContextForm,\n      buildInitGroups\n    };\n\n    const isVerticalOverlap = (a, b, threshold) => b.bottom - a.y >= threshold && a.bottom - b.y >= threshold;\n    const getRangeRect = rng => {\n      const rect = rng.getBoundingClientRect();\n      if (rect.height <= 0 && rect.width <= 0) {\n        const leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset).element;\n        const elm = isText(leaf$1) ? parent(leaf$1) : Optional.some(leaf$1);\n        return elm.filter(isElement$1).map(e => e.dom.getBoundingClientRect()).getOr(rect);\n      } else {\n        return rect;\n      }\n    };\n    const getSelectionBounds = editor => {\n      const rng = editor.selection.getRng();\n      const rect = getRangeRect(rng);\n      if (editor.inline) {\n        const scroll = get$c();\n        return bounds(scroll.left + rect.left, scroll.top + rect.top, rect.width, rect.height);\n      } else {\n        const bodyPos = absolute$2(SugarElement.fromDom(editor.getBody()));\n        return bounds(bodyPos.x + rect.left, bodyPos.y + rect.top, rect.width, rect.height);\n      }\n    };\n    const getAnchorElementBounds = (editor, lastElement) => lastElement.filter(elem => inBody(elem) && isHTMLElement(elem)).map(absolute$2).getOrThunk(() => getSelectionBounds(editor));\n    const getHorizontalBounds = (contentAreaBox, viewportBounds, margin) => {\n      const x = Math.max(contentAreaBox.x + margin, viewportBounds.x);\n      const right = Math.min(contentAreaBox.right - margin, viewportBounds.right);\n      return {\n        x,\n        width: right - x\n      };\n    };\n    const getVerticalBounds = (editor, contentAreaBox, viewportBounds, isToolbarLocationTop, toolbarType, margin) => {\n      const container = SugarElement.fromDom(editor.getContainer());\n      const header = descendant(container, '.tox-editor-header').getOr(container);\n      const headerBox = box$1(header);\n      const isToolbarBelowContentArea = headerBox.y >= contentAreaBox.bottom;\n      const isToolbarAbove = isToolbarLocationTop && !isToolbarBelowContentArea;\n      if (editor.inline && isToolbarAbove) {\n        return {\n          y: Math.max(headerBox.bottom + margin, viewportBounds.y),\n          bottom: viewportBounds.bottom\n        };\n      }\n      if (editor.inline && !isToolbarAbove) {\n        return {\n          y: viewportBounds.y,\n          bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)\n        };\n      }\n      const containerBounds = toolbarType === 'line' ? box$1(container) : contentAreaBox;\n      if (isToolbarAbove) {\n        return {\n          y: Math.max(headerBox.bottom + margin, viewportBounds.y),\n          bottom: Math.min(containerBounds.bottom - margin, viewportBounds.bottom)\n        };\n      }\n      return {\n        y: Math.max(containerBounds.y + margin, viewportBounds.y),\n        bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)\n      };\n    };\n    const getContextToolbarBounds = (editor, sharedBackstage, toolbarType, margin = 0) => {\n      const viewportBounds = getBounds$3(window);\n      const contentAreaBox = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));\n      const toolbarOrMenubarEnabled = isMenubarEnabled(editor) || isToolbarEnabled(editor) || isMultipleToolbars(editor);\n      const {x, width} = getHorizontalBounds(contentAreaBox, viewportBounds, margin);\n      if (editor.inline && !toolbarOrMenubarEnabled) {\n        return bounds(x, viewportBounds.y, width, viewportBounds.height);\n      } else {\n        const isToolbarTop = sharedBackstage.header.isPositionedAtTop();\n        const {y, bottom} = getVerticalBounds(editor, contentAreaBox, viewportBounds, isToolbarTop, toolbarType, margin);\n        return bounds(x, y, width, bottom - y);\n      }\n    };\n\n    const bubbleSize$1 = 12;\n    const bubbleAlignments$1 = {\n      valignCentre: [],\n      alignCentre: [],\n      alignLeft: ['tox-pop--align-left'],\n      alignRight: ['tox-pop--align-right'],\n      right: ['tox-pop--right'],\n      left: ['tox-pop--left'],\n      bottom: ['tox-pop--bottom'],\n      top: ['tox-pop--top'],\n      inset: ['tox-pop--inset']\n    };\n    const anchorOverrides = {\n      maxHeightFunction: expandable$1(),\n      maxWidthFunction: expandable()\n    };\n    const isEntireElementSelected = (editor, elem) => {\n      const rng = editor.selection.getRng();\n      const leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset);\n      return rng.startContainer === rng.endContainer && rng.startOffset === rng.endOffset - 1 && eq(leaf$1.element, elem);\n    };\n    const preservePosition = (elem, position, f) => {\n      const currentPosition = getRaw(elem, 'position');\n      set$8(elem, 'position', position);\n      const result = f(elem);\n      currentPosition.each(pos => set$8(elem, 'position', pos));\n      return result;\n    };\n    const shouldUseInsetLayouts = position => position === 'node';\n    const determineInsetLayout = (editor, contextbar, elem, data, bounds) => {\n      const selectionBounds = getSelectionBounds(editor);\n      const isSameAnchorElement = data.lastElement().exists(prev => eq(elem, prev));\n      if (isEntireElementSelected(editor, elem)) {\n        return isSameAnchorElement ? preserve : north;\n      } else if (isSameAnchorElement) {\n        return preservePosition(contextbar, data.getMode(), () => {\n          const isOverlapping = isVerticalOverlap(selectionBounds, box$1(contextbar), -20);\n          return isOverlapping && !data.isReposition() ? flip : preserve;\n        });\n      } else {\n        const yBounds = data.getMode() === 'fixed' ? bounds.y + get$c().top : bounds.y;\n        const contextbarHeight = get$e(contextbar) + bubbleSize$1;\n        return yBounds + contextbarHeight <= selectionBounds.y ? north : south;\n      }\n    };\n    const getAnchorSpec$2 = (editor, mobile, data, position) => {\n      const smartInsetLayout = elem => (anchor, element, bubbles, placee, bounds) => {\n        const layout = determineInsetLayout(editor, placee, elem, data, bounds);\n        const newAnchor = {\n          ...anchor,\n          y: bounds.y,\n          height: bounds.height\n        };\n        return {\n          ...layout(newAnchor, element, bubbles, placee, bounds),\n          alwaysFit: true\n        };\n      };\n      const getInsetLayouts = elem => shouldUseInsetLayouts(position) ? [smartInsetLayout(elem)] : [];\n      const desktopAnchorSpecLayouts = {\n        onLtr: elem => [\n          north$2,\n          south$2,\n          northeast$2,\n          southeast$2,\n          northwest$2,\n          southwest$2\n        ].concat(getInsetLayouts(elem)),\n        onRtl: elem => [\n          north$2,\n          south$2,\n          northwest$2,\n          southwest$2,\n          northeast$2,\n          southeast$2\n        ].concat(getInsetLayouts(elem))\n      };\n      const mobileAnchorSpecLayouts = {\n        onLtr: elem => [\n          south$2,\n          southeast$2,\n          southwest$2,\n          northeast$2,\n          northwest$2,\n          north$2\n        ].concat(getInsetLayouts(elem)),\n        onRtl: elem => [\n          south$2,\n          southwest$2,\n          southeast$2,\n          northwest$2,\n          northeast$2,\n          north$2\n        ].concat(getInsetLayouts(elem))\n      };\n      return mobile ? mobileAnchorSpecLayouts : desktopAnchorSpecLayouts;\n    };\n    const getAnchorLayout = (editor, position, isTouch, data) => {\n      if (position === 'line') {\n        return {\n          bubble: nu$5(bubbleSize$1, 0, bubbleAlignments$1),\n          layouts: {\n            onLtr: () => [east$2],\n            onRtl: () => [west$2]\n          },\n          overrides: anchorOverrides\n        };\n      } else {\n        return {\n          bubble: nu$5(0, bubbleSize$1, bubbleAlignments$1, 1 / bubbleSize$1),\n          layouts: getAnchorSpec$2(editor, isTouch, data, position),\n          overrides: anchorOverrides\n        };\n      }\n    };\n\n    const matchTargetWith = (elem, candidates) => {\n      const ctxs = filter$2(candidates, toolbarApi => toolbarApi.predicate(elem.dom));\n      const {pass, fail} = partition$3(ctxs, t => t.type === 'contexttoolbar');\n      return {\n        contextToolbars: pass,\n        contextForms: fail\n      };\n    };\n    const filterByPositionForStartNode = toolbars => {\n      if (toolbars.length <= 1) {\n        return toolbars;\n      } else {\n        const doesPositionExist = value => exists(toolbars, t => t.position === value);\n        const filterToolbarsByPosition = value => filter$2(toolbars, t => t.position === value);\n        const hasSelectionToolbars = doesPositionExist('selection');\n        const hasNodeToolbars = doesPositionExist('node');\n        if (hasSelectionToolbars || hasNodeToolbars) {\n          if (hasNodeToolbars && hasSelectionToolbars) {\n            const nodeToolbars = filterToolbarsByPosition('node');\n            const selectionToolbars = map$2(filterToolbarsByPosition('selection'), t => ({\n              ...t,\n              position: 'node'\n            }));\n            return nodeToolbars.concat(selectionToolbars);\n          } else {\n            return hasSelectionToolbars ? filterToolbarsByPosition('selection') : filterToolbarsByPosition('node');\n          }\n        } else {\n          return filterToolbarsByPosition('line');\n        }\n      }\n    };\n    const filterByPositionForAncestorNode = toolbars => {\n      if (toolbars.length <= 1) {\n        return toolbars;\n      } else {\n        const findPosition = value => find$5(toolbars, t => t.position === value);\n        const basePosition = findPosition('selection').orThunk(() => findPosition('node')).orThunk(() => findPosition('line')).map(t => t.position);\n        return basePosition.fold(() => [], pos => filter$2(toolbars, t => t.position === pos));\n      }\n    };\n    const matchStartNode = (elem, nodeCandidates, editorCandidates) => {\n      const nodeMatches = matchTargetWith(elem, nodeCandidates);\n      if (nodeMatches.contextForms.length > 0) {\n        return Optional.some({\n          elem,\n          toolbars: [nodeMatches.contextForms[0]]\n        });\n      } else {\n        const editorMatches = matchTargetWith(elem, editorCandidates);\n        if (editorMatches.contextForms.length > 0) {\n          return Optional.some({\n            elem,\n            toolbars: [editorMatches.contextForms[0]]\n          });\n        } else if (nodeMatches.contextToolbars.length > 0 || editorMatches.contextToolbars.length > 0) {\n          const toolbars = filterByPositionForStartNode(nodeMatches.contextToolbars.concat(editorMatches.contextToolbars));\n          return Optional.some({\n            elem,\n            toolbars\n          });\n        } else {\n          return Optional.none();\n        }\n      }\n    };\n    const matchAncestor = (isRoot, startNode, scopes) => {\n      if (isRoot(startNode)) {\n        return Optional.none();\n      } else {\n        return ancestor$2(startNode, ancestorElem => {\n          if (isElement$1(ancestorElem)) {\n            const {contextToolbars, contextForms} = matchTargetWith(ancestorElem, scopes.inNodeScope);\n            const toolbars = contextForms.length > 0 ? contextForms : filterByPositionForAncestorNode(contextToolbars);\n            return toolbars.length > 0 ? Optional.some({\n              elem: ancestorElem,\n              toolbars\n            }) : Optional.none();\n          } else {\n            return Optional.none();\n          }\n        }, isRoot);\n      }\n    };\n    const lookup$1 = (scopes, editor) => {\n      const rootElem = SugarElement.fromDom(editor.getBody());\n      const isRoot = elem => eq(elem, rootElem);\n      const isOutsideRoot = startNode => !isRoot(startNode) && !contains(rootElem, startNode);\n      const startNode = SugarElement.fromDom(editor.selection.getNode());\n      if (isOutsideRoot(startNode)) {\n        return Optional.none();\n      }\n      return matchStartNode(startNode, scopes.inNodeScope, scopes.inEditorScope).orThunk(() => matchAncestor(isRoot, startNode, scopes));\n    };\n\n    const categorise = (contextToolbars, navigate) => {\n      const forms = {};\n      const inNodeScope = [];\n      const inEditorScope = [];\n      const formNavigators = {};\n      const lookupTable = {};\n      const registerForm = (key, toolbarSpec) => {\n        const contextForm = getOrDie(createContextForm(toolbarSpec));\n        forms[key] = contextForm;\n        contextForm.launch.map(launch => {\n          formNavigators['form:' + key + ''] = {\n            ...toolbarSpec.launch,\n            type: launch.type === 'contextformtogglebutton' ? 'togglebutton' : 'button',\n            onAction: () => {\n              navigate(contextForm);\n            }\n          };\n        });\n        if (contextForm.scope === 'editor') {\n          inEditorScope.push(contextForm);\n        } else {\n          inNodeScope.push(contextForm);\n        }\n        lookupTable[key] = contextForm;\n      };\n      const registerToolbar = (key, toolbarSpec) => {\n        createContextToolbar(toolbarSpec).each(contextToolbar => {\n          if (toolbarSpec.scope === 'editor') {\n            inEditorScope.push(contextToolbar);\n          } else {\n            inNodeScope.push(contextToolbar);\n          }\n          lookupTable[key] = contextToolbar;\n        });\n      };\n      const keys$1 = keys(contextToolbars);\n      each$1(keys$1, key => {\n        const toolbarApi = contextToolbars[key];\n        if (toolbarApi.type === 'contextform') {\n          registerForm(key, toolbarApi);\n        } else if (toolbarApi.type === 'contexttoolbar') {\n          registerToolbar(key, toolbarApi);\n        }\n      });\n      return {\n        forms,\n        inNodeScope,\n        inEditorScope,\n        lookupTable,\n        formNavigators\n      };\n    };\n\n    const forwardSlideEvent = generate$6('forward-slide');\n    const backSlideEvent = generate$6('backward-slide');\n    const changeSlideEvent = generate$6('change-slide-event');\n    const resizingClass = 'tox-pop--resizing';\n    const renderContextToolbar = spec => {\n      const stack = Cell([]);\n      return InlineView.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-pop']\n        },\n        fireDismissalEventInstead: { event: 'doNotDismissYet' },\n        onShow: comp => {\n          stack.set([]);\n          InlineView.getContent(comp).each(c => {\n            remove$7(c.element, 'visibility');\n          });\n          remove$3(comp.element, resizingClass);\n          remove$7(comp.element, 'width');\n        },\n        inlineBehaviours: derive$1([\n          config('context-toolbar-events', [\n            runOnSource(transitionend(), (comp, se) => {\n              if (se.event.raw.propertyName === 'width') {\n                remove$3(comp.element, resizingClass);\n                remove$7(comp.element, 'width');\n              }\n            }),\n            run$1(changeSlideEvent, (comp, se) => {\n              const elem = comp.element;\n              remove$7(elem, 'width');\n              const currentWidth = get$d(elem);\n              InlineView.setContent(comp, se.event.contents);\n              add$2(elem, resizingClass);\n              const newWidth = get$d(elem);\n              set$8(elem, 'width', currentWidth + 'px');\n              InlineView.getContent(comp).each(newContents => {\n                se.event.focus.bind(f => {\n                  focus$3(f);\n                  return search(elem);\n                }).orThunk(() => {\n                  Keying.focusIn(newContents);\n                  return active$1(getRootNode(elem));\n                });\n              });\n              setTimeout(() => {\n                set$8(comp.element, 'width', newWidth + 'px');\n              }, 0);\n            }),\n            run$1(forwardSlideEvent, (comp, se) => {\n              InlineView.getContent(comp).each(oldContents => {\n                stack.set(stack.get().concat([{\n                    bar: oldContents,\n                    focus: active$1(getRootNode(comp.element))\n                  }]));\n              });\n              emitWith(comp, changeSlideEvent, {\n                contents: se.event.forwardContents,\n                focus: Optional.none()\n              });\n            }),\n            run$1(backSlideEvent, (comp, _se) => {\n              last$1(stack.get()).each(last => {\n                stack.set(stack.get().slice(0, stack.get().length - 1));\n                emitWith(comp, changeSlideEvent, {\n                  contents: premade(last.bar),\n                  focus: last.focus\n                });\n              });\n            })\n          ]),\n          Keying.config({\n            mode: 'special',\n            onEscape: comp => last$1(stack.get()).fold(() => spec.onEscape(), _ => {\n              emit(comp, backSlideEvent);\n              return Optional.some(true);\n            })\n          })\n        ]),\n        lazySink: () => Result.value(spec.sink)\n      });\n    };\n\n    const transitionClass = 'tox-pop--transition';\n    const register$9 = (editor, registryContextToolbars, sink, extras) => {\n      const backstage = extras.backstage;\n      const sharedBackstage = backstage.shared;\n      const isTouch = detect$1().deviceType.isTouch;\n      const lastElement = value$4();\n      const lastTrigger = value$4();\n      const lastContextPosition = value$4();\n      const contextbar = build$1(renderContextToolbar({\n        sink,\n        onEscape: () => {\n          editor.focus();\n          return Optional.some(true);\n        }\n      }));\n      const getBounds = () => {\n        const position = lastContextPosition.get().getOr('node');\n        const margin = shouldUseInsetLayouts(position) ? 1 : 0;\n        return getContextToolbarBounds(editor, sharedBackstage, position, margin);\n      };\n      const canLaunchToolbar = () => {\n        return !editor.removed && !(isTouch() && backstage.isContextMenuOpen());\n      };\n      const isSameLaunchElement = elem => is$1(lift2(elem, lastElement.get(), eq), true);\n      const shouldContextToolbarHide = () => {\n        if (!canLaunchToolbar()) {\n          return true;\n        } else {\n          const contextToolbarBounds = getBounds();\n          const anchorBounds = is$1(lastContextPosition.get(), 'node') ? getAnchorElementBounds(editor, lastElement.get()) : getSelectionBounds(editor);\n          return contextToolbarBounds.height <= 0 || !isVerticalOverlap(anchorBounds, contextToolbarBounds, 0.01);\n        }\n      };\n      const close = () => {\n        lastElement.clear();\n        lastTrigger.clear();\n        lastContextPosition.clear();\n        InlineView.hide(contextbar);\n      };\n      const hideOrRepositionIfNecessary = () => {\n        if (InlineView.isOpen(contextbar)) {\n          const contextBarEle = contextbar.element;\n          remove$7(contextBarEle, 'display');\n          if (shouldContextToolbarHide()) {\n            set$8(contextBarEle, 'display', 'none');\n          } else {\n            lastTrigger.set(0);\n            InlineView.reposition(contextbar);\n          }\n        }\n      };\n      const wrapInPopDialog = toolbarSpec => ({\n        dom: {\n          tag: 'div',\n          classes: ['tox-pop__dialog']\n        },\n        components: [toolbarSpec],\n        behaviours: derive$1([\n          Keying.config({ mode: 'acyclic' }),\n          config('pop-dialog-wrap-events', [\n            runOnAttached(comp => {\n              editor.shortcuts.add('ctrl+F9', 'focus statusbar', () => Keying.focusIn(comp));\n            }),\n            runOnDetached(_comp => {\n              editor.shortcuts.remove('ctrl+F9');\n            })\n          ])\n        ])\n      });\n      const getScopes = cached(() => categorise(registryContextToolbars, toolbarApi => {\n        const alloySpec = buildToolbar([toolbarApi]);\n        emitWith(contextbar, forwardSlideEvent, { forwardContents: wrapInPopDialog(alloySpec) });\n      }));\n      const buildContextToolbarGroups = (allButtons, ctx) => identifyButtons(editor, {\n        buttons: allButtons,\n        toolbar: ctx.items,\n        allowToolbarGroups: false\n      }, extras.backstage, Optional.some(['form:']));\n      const buildContextFormGroups = (ctx, providers) => ContextForm.buildInitGroups(ctx, providers);\n      const buildToolbar = toolbars => {\n        const {buttons} = editor.ui.registry.getAll();\n        const scopes = getScopes();\n        const allButtons = {\n          ...buttons,\n          ...scopes.formNavigators\n        };\n        const toolbarType = getToolbarMode(editor) === ToolbarMode$1.scrolling ? ToolbarMode$1.scrolling : ToolbarMode$1.default;\n        const initGroups = flatten(map$2(toolbars, ctx => ctx.type === 'contexttoolbar' ? buildContextToolbarGroups(allButtons, ctx) : buildContextFormGroups(ctx, sharedBackstage.providers)));\n        return renderToolbar({\n          type: toolbarType,\n          uid: generate$6('context-toolbar'),\n          initGroups,\n          onEscape: Optional.none,\n          cyclicKeying: true,\n          providers: sharedBackstage.providers\n        });\n      };\n      const getAnchor = (position, element) => {\n        const anchorage = position === 'node' ? sharedBackstage.anchors.node(element) : sharedBackstage.anchors.cursor();\n        const anchorLayout = getAnchorLayout(editor, position, isTouch(), {\n          lastElement: lastElement.get,\n          isReposition: () => is$1(lastTrigger.get(), 0),\n          getMode: () => Positioning.getMode(sink)\n        });\n        return deepMerge(anchorage, anchorLayout);\n      };\n      const launchContext = (toolbarApi, elem) => {\n        launchContextToolbar.cancel();\n        if (!canLaunchToolbar()) {\n          return;\n        }\n        const toolbarSpec = buildToolbar(toolbarApi);\n        const position = toolbarApi[0].position;\n        const anchor = getAnchor(position, elem);\n        lastContextPosition.set(position);\n        lastTrigger.set(1);\n        const contextBarEle = contextbar.element;\n        remove$7(contextBarEle, 'display');\n        if (!isSameLaunchElement(elem)) {\n          remove$3(contextBarEle, transitionClass);\n          Positioning.reset(sink, contextbar);\n        }\n        InlineView.showWithinBounds(contextbar, wrapInPopDialog(toolbarSpec), {\n          anchor,\n          transition: {\n            classes: [transitionClass],\n            mode: 'placement'\n          }\n        }, () => Optional.some(getBounds()));\n        elem.fold(lastElement.clear, lastElement.set);\n        if (shouldContextToolbarHide()) {\n          set$8(contextBarEle, 'display', 'none');\n        }\n      };\n      let isDragging = false;\n      const launchContextToolbar = last(() => {\n        if (!editor.hasFocus() || editor.removed || isDragging) {\n          return;\n        }\n        if (has(contextbar.element, transitionClass)) {\n          launchContextToolbar.throttle();\n        } else {\n          const scopes = getScopes();\n          lookup$1(scopes, editor).fold(close, info => {\n            launchContext(info.toolbars, Optional.some(info.elem));\n          });\n        }\n      }, 17);\n      editor.on('init', () => {\n        editor.on('remove', close);\n        editor.on('ScrollContent ScrollWindow ObjectResized ResizeEditor longpress', hideOrRepositionIfNecessary);\n        editor.on('click keyup focus SetContent', launchContextToolbar.throttle);\n        editor.on(hideContextToolbarEvent, close);\n        editor.on(showContextToolbarEvent, e => {\n          const scopes = getScopes();\n          get$h(scopes.lookupTable, e.toolbarKey).each(ctx => {\n            launchContext([ctx], someIf(e.target !== editor, e.target));\n            InlineView.getContent(contextbar).each(Keying.focusIn);\n          });\n        });\n        editor.on('focusout', _e => {\n          global$9.setEditorTimeout(editor, () => {\n            if (search(sink.element).isNone() && search(contextbar.element).isNone()) {\n              close();\n            }\n          }, 0);\n        });\n        editor.on('SwitchMode', () => {\n          if (editor.mode.isReadOnly()) {\n            close();\n          }\n        });\n        editor.on('ExecCommand', ({command}) => {\n          if (command.toLowerCase() === 'toggleview') {\n            close();\n          }\n        });\n        editor.on('AfterProgressState', event => {\n          if (event.state) {\n            close();\n          } else if (editor.hasFocus()) {\n            launchContextToolbar.throttle();\n          }\n        });\n        editor.on('dragstart', () => {\n          isDragging = true;\n        });\n        editor.on('dragend drop', () => {\n          isDragging = false;\n        });\n        editor.on('NodeChange', _e => {\n          search(contextbar.element).fold(launchContextToolbar.throttle, noop);\n        });\n      });\n    };\n\n    const register$8 = editor => {\n      const alignToolbarButtons = [\n        {\n          name: 'alignleft',\n          text: 'Align left',\n          cmd: 'JustifyLeft',\n          icon: 'align-left'\n        },\n        {\n          name: 'aligncenter',\n          text: 'Align center',\n          cmd: 'JustifyCenter',\n          icon: 'align-center'\n        },\n        {\n          name: 'alignright',\n          text: 'Align right',\n          cmd: 'JustifyRight',\n          icon: 'align-right'\n        },\n        {\n          name: 'alignjustify',\n          text: 'Justify',\n          cmd: 'JustifyFull',\n          icon: 'align-justify'\n        }\n      ];\n      each$1(alignToolbarButtons, item => {\n        editor.ui.registry.addToggleButton(item.name, {\n          tooltip: item.text,\n          icon: item.icon,\n          onAction: onActionExecCommand(editor, item.cmd),\n          onSetup: onSetupStateToggle(editor, item.name)\n        });\n      });\n      editor.ui.registry.addButton('alignnone', {\n        tooltip: 'No alignment',\n        icon: 'align-none',\n        onSetup: onSetupEditableToggle(editor),\n        onAction: onActionExecCommand(editor, 'JustifyNone')\n      });\n    };\n\n    const registerController = (editor, spec) => {\n      const getMenuItems = () => {\n        const options = spec.getOptions(editor);\n        const initial = spec.getCurrent(editor).map(spec.hash);\n        const current = value$4();\n        return map$2(options, value => ({\n          type: 'togglemenuitem',\n          text: spec.display(value),\n          onSetup: api => {\n            const setActive = active => {\n              if (active) {\n                current.on(oldApi => oldApi.setActive(false));\n                current.set(api);\n              }\n              api.setActive(active);\n            };\n            setActive(is$1(initial, spec.hash(value)));\n            const unbindWatcher = spec.watcher(editor, value, setActive);\n            return () => {\n              current.clear();\n              unbindWatcher();\n            };\n          },\n          onAction: () => spec.setCurrent(editor, value)\n        }));\n      };\n      editor.ui.registry.addMenuButton(spec.name, {\n        tooltip: spec.text,\n        icon: spec.icon,\n        fetch: callback => callback(getMenuItems()),\n        onSetup: spec.onToolbarSetup\n      });\n      editor.ui.registry.addNestedMenuItem(spec.name, {\n        type: 'nestedmenuitem',\n        text: spec.text,\n        getSubmenuItems: getMenuItems,\n        onSetup: spec.onMenuSetup\n      });\n    };\n    const lineHeightSpec = editor => ({\n      name: 'lineheight',\n      text: 'Line height',\n      icon: 'line-height',\n      getOptions: getLineHeightFormats,\n      hash: input => normalise(input, [\n        'fixed',\n        'relative',\n        'empty'\n      ]).getOr(input),\n      display: identity,\n      watcher: (editor, value, callback) => editor.formatter.formatChanged('lineheight', callback, false, { value }).unbind,\n      getCurrent: editor => Optional.from(editor.queryCommandValue('LineHeight')),\n      setCurrent: (editor, value) => editor.execCommand('LineHeight', false, value),\n      onToolbarSetup: onSetupEditableToggle(editor),\n      onMenuSetup: onSetupEditableToggle(editor)\n    });\n    const languageSpec = editor => {\n      const settingsOpt = Optional.from(getContentLanguages(editor));\n      return settingsOpt.map(settings => ({\n        name: 'language',\n        text: 'Language',\n        icon: 'language',\n        getOptions: constant$1(settings),\n        hash: input => isUndefined(input.customCode) ? input.code : `${ input.code }/${ input.customCode }`,\n        display: input => input.title,\n        watcher: (editor, value, callback) => {\n          var _a;\n          return editor.formatter.formatChanged('lang', callback, false, {\n            value: value.code,\n            customValue: (_a = value.customCode) !== null && _a !== void 0 ? _a : null\n          }).unbind;\n        },\n        getCurrent: editor => {\n          const node = SugarElement.fromDom(editor.selection.getNode());\n          return closest$4(node, n => Optional.some(n).filter(isElement$1).bind(ele => {\n            const codeOpt = getOpt(ele, 'lang');\n            return codeOpt.map(code => {\n              const customCode = getOpt(ele, 'data-mce-lang').getOrUndefined();\n              return {\n                code,\n                customCode,\n                title: ''\n              };\n            });\n          }));\n        },\n        setCurrent: (editor, lang) => editor.execCommand('Lang', false, lang),\n        onToolbarSetup: api => {\n          const unbinder = unbindable();\n          api.setActive(editor.formatter.match('lang', {}, undefined, true));\n          unbinder.set(editor.formatter.formatChanged('lang', api.setActive, true));\n          return composeUnbinders(unbinder.clear, onSetupEditableToggle(editor)(api));\n        },\n        onMenuSetup: onSetupEditableToggle(editor)\n      }));\n    };\n    const register$7 = editor => {\n      registerController(editor, lineHeightSpec(editor));\n      languageSpec(editor).each(spec => registerController(editor, spec));\n    };\n\n    const register$6 = (editor, backstage) => {\n      createAlignMenu(editor, backstage);\n      createFontFamilyMenu(editor, backstage);\n      createStylesMenu(editor, backstage);\n      createBlocksMenu(editor, backstage);\n      createFontSizeMenu(editor, backstage);\n    };\n\n    const onSetupOutdentState = editor => onSetupEvent(editor, 'NodeChange', api => {\n      api.setEnabled(editor.queryCommandState('outdent') && editor.selection.isEditable());\n    });\n    const registerButtons$2 = editor => {\n      editor.ui.registry.addButton('outdent', {\n        tooltip: 'Decrease indent',\n        icon: 'outdent',\n        onSetup: onSetupOutdentState(editor),\n        onAction: onActionExecCommand(editor, 'outdent')\n      });\n      editor.ui.registry.addButton('indent', {\n        tooltip: 'Increase indent',\n        icon: 'indent',\n        onSetup: onSetupEditableToggle(editor),\n        onAction: onActionExecCommand(editor, 'indent')\n      });\n    };\n    const register$5 = editor => {\n      registerButtons$2(editor);\n    };\n\n    const makeSetupHandler = (editor, pasteAsText) => api => {\n      api.setActive(pasteAsText.get());\n      const pastePlainTextToggleHandler = e => {\n        pasteAsText.set(e.state);\n        api.setActive(e.state);\n      };\n      editor.on('PastePlainTextToggle', pastePlainTextToggleHandler);\n      return composeUnbinders(() => editor.off('PastePlainTextToggle', pastePlainTextToggleHandler), onSetupEditableToggle(editor)(api));\n    };\n    const register$4 = editor => {\n      const pasteAsText = Cell(getPasteAsText(editor));\n      const onAction = () => editor.execCommand('mceTogglePlainTextPaste');\n      editor.ui.registry.addToggleButton('pastetext', {\n        active: false,\n        icon: 'paste-text',\n        tooltip: 'Paste as text',\n        onAction,\n        onSetup: makeSetupHandler(editor, pasteAsText)\n      });\n      editor.ui.registry.addToggleMenuItem('pastetext', {\n        text: 'Paste as text',\n        icon: 'paste-text',\n        onAction,\n        onSetup: makeSetupHandler(editor, pasteAsText)\n      });\n    };\n\n    const onActionToggleFormat = (editor, fmt) => () => {\n      editor.execCommand('mceToggleFormat', false, fmt);\n    };\n    const registerFormatButtons = editor => {\n      global$1.each([\n        {\n          name: 'bold',\n          text: 'Bold',\n          icon: 'bold',\n          shortcut: 'Meta+B'\n        },\n        {\n          name: 'italic',\n          text: 'Italic',\n          icon: 'italic',\n          shortcut: 'Meta+I'\n        },\n        {\n          name: 'underline',\n          text: 'Underline',\n          icon: 'underline',\n          shortcut: 'Meta+U'\n        },\n        {\n          name: 'strikethrough',\n          text: 'Strikethrough',\n          icon: 'strike-through'\n        },\n        {\n          name: 'subscript',\n          text: 'Subscript',\n          icon: 'subscript'\n        },\n        {\n          name: 'superscript',\n          text: 'Superscript',\n          icon: 'superscript'\n        }\n      ], (btn, _idx) => {\n        editor.ui.registry.addToggleButton(btn.name, {\n          tooltip: btn.text,\n          icon: btn.icon,\n          onSetup: onSetupStateToggle(editor, btn.name),\n          onAction: onActionToggleFormat(editor, btn.name),\n          shortcut: btn.shortcut\n        });\n      });\n      for (let i = 1; i <= 6; i++) {\n        const name = 'h' + i;\n        const shortcut = `Access+${ i }`;\n        editor.ui.registry.addToggleButton(name, {\n          text: name.toUpperCase(),\n          tooltip: 'Heading ' + i,\n          onSetup: onSetupStateToggle(editor, name),\n          onAction: onActionToggleFormat(editor, name),\n          shortcut\n        });\n      }\n    };\n    const registerCommandButtons = editor => {\n      global$1.each([\n        {\n          name: 'copy',\n          text: 'Copy',\n          action: 'Copy',\n          icon: 'copy'\n        },\n        {\n          name: 'help',\n          text: 'Help',\n          action: 'mceHelp',\n          icon: 'help',\n          shortcut: 'Alt+0'\n        },\n        {\n          name: 'selectall',\n          text: 'Select all',\n          action: 'SelectAll',\n          icon: 'select-all',\n          shortcut: 'Meta+A'\n        },\n        {\n          name: 'newdocument',\n          text: 'New document',\n          action: 'mceNewDocument',\n          icon: 'new-document'\n        },\n        {\n          name: 'print',\n          text: 'Print',\n          action: 'mcePrint',\n          icon: 'print',\n          shortcut: 'Meta+P'\n        }\n      ], btn => {\n        editor.ui.registry.addButton(btn.name, {\n          tooltip: btn.text,\n          icon: btn.icon,\n          onAction: onActionExecCommand(editor, btn.action),\n          shortcut: btn.shortcut\n        });\n      });\n      global$1.each([\n        {\n          name: 'cut',\n          text: 'Cut',\n          action: 'Cut',\n          icon: 'cut'\n        },\n        {\n          name: 'paste',\n          text: 'Paste',\n          action: 'Paste',\n          icon: 'paste'\n        },\n        {\n          name: 'removeformat',\n          text: 'Clear formatting',\n          action: 'RemoveFormat',\n          icon: 'remove-formatting'\n        },\n        {\n          name: 'remove',\n          text: 'Remove',\n          action: 'Delete',\n          icon: 'remove'\n        },\n        {\n          name: 'hr',\n          text: 'Horizontal line',\n          action: 'InsertHorizontalRule',\n          icon: 'horizontal-rule'\n        }\n      ], btn => {\n        editor.ui.registry.addButton(btn.name, {\n          tooltip: btn.text,\n          icon: btn.icon,\n          onSetup: onSetupEditableToggle(editor),\n          onAction: onActionExecCommand(editor, btn.action)\n        });\n      });\n    };\n    const registerCommandToggleButtons = editor => {\n      global$1.each([{\n          name: 'blockquote',\n          text: 'Blockquote',\n          action: 'mceBlockQuote',\n          icon: 'quote'\n        }], btn => {\n        editor.ui.registry.addToggleButton(btn.name, {\n          tooltip: btn.text,\n          icon: btn.icon,\n          onAction: onActionExecCommand(editor, btn.action),\n          onSetup: onSetupStateToggle(editor, btn.name)\n        });\n      });\n    };\n    const registerButtons$1 = editor => {\n      registerFormatButtons(editor);\n      registerCommandButtons(editor);\n      registerCommandToggleButtons(editor);\n    };\n    const registerMenuItems$2 = editor => {\n      global$1.each([\n        {\n          name: 'newdocument',\n          text: 'New document',\n          action: 'mceNewDocument',\n          icon: 'new-document'\n        },\n        {\n          name: 'copy',\n          text: 'Copy',\n          action: 'Copy',\n          icon: 'copy',\n          shortcut: 'Meta+C'\n        },\n        {\n          name: 'selectall',\n          text: 'Select all',\n          action: 'SelectAll',\n          icon: 'select-all',\n          shortcut: 'Meta+A'\n        },\n        {\n          name: 'print',\n          text: 'Print...',\n          action: 'mcePrint',\n          icon: 'print',\n          shortcut: 'Meta+P'\n        }\n      ], menuitem => {\n        editor.ui.registry.addMenuItem(menuitem.name, {\n          text: menuitem.text,\n          icon: menuitem.icon,\n          shortcut: menuitem.shortcut,\n          onAction: onActionExecCommand(editor, menuitem.action)\n        });\n      });\n      global$1.each([\n        {\n          name: 'bold',\n          text: 'Bold',\n          action: 'Bold',\n          icon: 'bold',\n          shortcut: 'Meta+B'\n        },\n        {\n          name: 'italic',\n          text: 'Italic',\n          action: 'Italic',\n          icon: 'italic',\n          shortcut: 'Meta+I'\n        },\n        {\n          name: 'underline',\n          text: 'Underline',\n          action: 'Underline',\n          icon: 'underline',\n          shortcut: 'Meta+U'\n        },\n        {\n          name: 'strikethrough',\n          text: 'Strikethrough',\n          action: 'Strikethrough',\n          icon: 'strike-through'\n        },\n        {\n          name: 'subscript',\n          text: 'Subscript',\n          action: 'Subscript',\n          icon: 'subscript'\n        },\n        {\n          name: 'superscript',\n          text: 'Superscript',\n          action: 'Superscript',\n          icon: 'superscript'\n        },\n        {\n          name: 'removeformat',\n          text: 'Clear formatting',\n          action: 'RemoveFormat',\n          icon: 'remove-formatting'\n        },\n        {\n          name: 'cut',\n          text: 'Cut',\n          action: 'Cut',\n          icon: 'cut',\n          shortcut: 'Meta+X'\n        },\n        {\n          name: 'paste',\n          text: 'Paste',\n          action: 'Paste',\n          icon: 'paste',\n          shortcut: 'Meta+V'\n        },\n        {\n          name: 'hr',\n          text: 'Horizontal line',\n          action: 'InsertHorizontalRule',\n          icon: 'horizontal-rule'\n        }\n      ], menuitem => {\n        editor.ui.registry.addMenuItem(menuitem.name, {\n          text: menuitem.text,\n          icon: menuitem.icon,\n          shortcut: menuitem.shortcut,\n          onSetup: onSetupEditableToggle(editor),\n          onAction: onActionExecCommand(editor, menuitem.action)\n        });\n      });\n      editor.ui.registry.addMenuItem('codeformat', {\n        text: 'Code',\n        icon: 'sourcecode',\n        onSetup: onSetupEditableToggle(editor),\n        onAction: onActionToggleFormat(editor, 'code')\n      });\n    };\n    const register$3 = editor => {\n      registerButtons$1(editor);\n      registerMenuItems$2(editor);\n    };\n\n    const onSetupUndoRedoState = (editor, type) => onSetupEvent(editor, 'Undo Redo AddUndo TypingUndo ClearUndos SwitchMode', api => {\n      api.setEnabled(!editor.mode.isReadOnly() && editor.undoManager[type]());\n    });\n    const registerMenuItems$1 = editor => {\n      editor.ui.registry.addMenuItem('undo', {\n        text: 'Undo',\n        icon: 'undo',\n        shortcut: 'Meta+Z',\n        onSetup: onSetupUndoRedoState(editor, 'hasUndo'),\n        onAction: onActionExecCommand(editor, 'undo')\n      });\n      editor.ui.registry.addMenuItem('redo', {\n        text: 'Redo',\n        icon: 'redo',\n        shortcut: 'Meta+Y',\n        onSetup: onSetupUndoRedoState(editor, 'hasRedo'),\n        onAction: onActionExecCommand(editor, 'redo')\n      });\n    };\n    const registerButtons = editor => {\n      editor.ui.registry.addButton('undo', {\n        tooltip: 'Undo',\n        icon: 'undo',\n        enabled: false,\n        onSetup: onSetupUndoRedoState(editor, 'hasUndo'),\n        onAction: onActionExecCommand(editor, 'undo'),\n        shortcut: 'Meta+Z'\n      });\n      editor.ui.registry.addButton('redo', {\n        tooltip: 'Redo',\n        icon: 'redo',\n        enabled: false,\n        onSetup: onSetupUndoRedoState(editor, 'hasRedo'),\n        onAction: onActionExecCommand(editor, 'redo'),\n        shortcut: 'Meta+Y'\n      });\n    };\n    const register$2 = editor => {\n      registerMenuItems$1(editor);\n      registerButtons(editor);\n    };\n\n    const onSetupVisualAidState = editor => onSetupEvent(editor, 'VisualAid', api => {\n      api.setActive(editor.hasVisual);\n    });\n    const registerMenuItems = editor => {\n      editor.ui.registry.addToggleMenuItem('visualaid', {\n        text: 'Visual aids',\n        onSetup: onSetupVisualAidState(editor),\n        onAction: onActionExecCommand(editor, 'mceToggleVisualAid')\n      });\n    };\n    const registerToolbarButton = editor => {\n      editor.ui.registry.addButton('visualaid', {\n        tooltip: 'Visual aids',\n        text: 'Visual aids',\n        onAction: onActionExecCommand(editor, 'mceToggleVisualAid')\n      });\n    };\n    const register$1 = editor => {\n      registerToolbarButton(editor);\n      registerMenuItems(editor);\n    };\n\n    const setup$6 = (editor, backstage) => {\n      register$8(editor);\n      register$3(editor);\n      register$6(editor, backstage);\n      register$2(editor);\n      register$c(editor);\n      register$1(editor);\n      register$5(editor);\n      register$7(editor);\n      register$4(editor);\n    };\n\n    const patchPipeConfig = config => isString(config) ? config.split(/[ ,]/) : config;\n    const option = name => editor => editor.options.get(name);\n    const register = editor => {\n      const registerOption = editor.options.register;\n      registerOption('contextmenu_avoid_overlap', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('contextmenu_never_use_native', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('contextmenu', {\n        processor: value => {\n          if (value === false) {\n            return {\n              value: [],\n              valid: true\n            };\n          } else if (isString(value) || isArrayOf(value, isString)) {\n            return {\n              value: patchPipeConfig(value),\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false or a string.'\n            };\n          }\n        },\n        default: 'link linkchecker image editimage table spellchecker configurepermanentpen'\n      });\n    };\n    const shouldNeverUseNative = option('contextmenu_never_use_native');\n    const getAvoidOverlapSelector = option('contextmenu_avoid_overlap');\n    const isContextMenuDisabled = editor => getContextMenu(editor).length === 0;\n    const getContextMenu = editor => {\n      const contextMenus = editor.ui.registry.getAll().contextMenus;\n      const contextMenu = editor.options.get('contextmenu');\n      if (editor.options.isSet('contextmenu')) {\n        return contextMenu;\n      } else {\n        return filter$2(contextMenu, item => has$2(contextMenus, item));\n      }\n    };\n\n    const nu = (x, y) => ({\n      type: 'makeshift',\n      x,\n      y\n    });\n    const transpose = (pos, dx, dy) => {\n      return nu(pos.x + dx, pos.y + dy);\n    };\n    const isTouchEvent$1 = e => e.type === 'longpress' || e.type.indexOf('touch') === 0;\n    const fromPageXY = e => {\n      if (isTouchEvent$1(e)) {\n        const touch = e.touches[0];\n        return nu(touch.pageX, touch.pageY);\n      } else {\n        return nu(e.pageX, e.pageY);\n      }\n    };\n    const fromClientXY = e => {\n      if (isTouchEvent$1(e)) {\n        const touch = e.touches[0];\n        return nu(touch.clientX, touch.clientY);\n      } else {\n        return nu(e.clientX, e.clientY);\n      }\n    };\n    const transposeContentAreaContainer = (element, pos) => {\n      const containerPos = global$8.DOM.getPos(element);\n      return transpose(pos, containerPos.x, containerPos.y);\n    };\n    const getPointAnchor = (editor, e) => {\n      if (e.type === 'contextmenu' || e.type === 'longpress') {\n        if (editor.inline) {\n          return fromPageXY(e);\n        } else {\n          return transposeContentAreaContainer(editor.getContentAreaContainer(), fromClientXY(e));\n        }\n      } else {\n        return getSelectionAnchor(editor);\n      }\n    };\n    const getSelectionAnchor = editor => {\n      return {\n        type: 'selection',\n        root: SugarElement.fromDom(editor.selection.getNode())\n      };\n    };\n    const getNodeAnchor = editor => ({\n      type: 'node',\n      node: Optional.some(SugarElement.fromDom(editor.selection.getNode())),\n      root: SugarElement.fromDom(editor.getBody())\n    });\n    const getAnchorSpec$1 = (editor, e, anchorType) => {\n      switch (anchorType) {\n      case 'node':\n        return getNodeAnchor(editor);\n      case 'point':\n        return getPointAnchor(editor, e);\n      case 'selection':\n        return getSelectionAnchor(editor);\n      }\n    };\n\n    const initAndShow$1 = (editor, e, buildMenu, backstage, contextmenu, anchorType) => {\n      const items = buildMenu();\n      const anchorSpec = getAnchorSpec$1(editor, e, anchorType);\n      build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {\n        isHorizontalMenu: false,\n        search: Optional.none()\n      }).map(menuData => {\n        e.preventDefault();\n        InlineView.showMenuAt(contextmenu, { anchor: anchorSpec }, {\n          menu: { markers: markers('normal') },\n          data: menuData\n        });\n      });\n    };\n\n    const layouts = {\n      onLtr: () => [\n        south$2,\n        southeast$2,\n        southwest$2,\n        northeast$2,\n        northwest$2,\n        north$2,\n        north,\n        south,\n        northeast,\n        southeast,\n        northwest,\n        southwest\n      ],\n      onRtl: () => [\n        south$2,\n        southwest$2,\n        southeast$2,\n        northwest$2,\n        northeast$2,\n        north$2,\n        north,\n        south,\n        northwest,\n        southwest,\n        northeast,\n        southeast\n      ]\n    };\n    const bubbleSize = 12;\n    const bubbleAlignments = {\n      valignCentre: [],\n      alignCentre: [],\n      alignLeft: ['tox-pop--align-left'],\n      alignRight: ['tox-pop--align-right'],\n      right: ['tox-pop--right'],\n      left: ['tox-pop--left'],\n      bottom: ['tox-pop--bottom'],\n      top: ['tox-pop--top']\n    };\n    const isTouchWithinSelection = (editor, e) => {\n      const selection = editor.selection;\n      if (selection.isCollapsed() || e.touches.length < 1) {\n        return false;\n      } else {\n        const touch = e.touches[0];\n        const rng = selection.getRng();\n        const rngRectOpt = getFirstRect(editor.getWin(), SimSelection.domRange(rng));\n        return rngRectOpt.exists(rngRect => rngRect.left <= touch.clientX && rngRect.right >= touch.clientX && rngRect.top <= touch.clientY && rngRect.bottom >= touch.clientY);\n      }\n    };\n    const setupiOSOverrides = editor => {\n      const originalSelection = editor.selection.getRng();\n      const selectionReset = () => {\n        global$9.setEditorTimeout(editor, () => {\n          editor.selection.setRng(originalSelection);\n        }, 10);\n        unbindEventListeners();\n      };\n      editor.once('touchend', selectionReset);\n      const preventMousedown = e => {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n      };\n      editor.on('mousedown', preventMousedown, true);\n      const clearSelectionReset = () => unbindEventListeners();\n      editor.once('longpresscancel', clearSelectionReset);\n      const unbindEventListeners = () => {\n        editor.off('touchend', selectionReset);\n        editor.off('longpresscancel', clearSelectionReset);\n        editor.off('mousedown', preventMousedown);\n      };\n    };\n    const getAnchorSpec = (editor, e, anchorType) => {\n      const anchorSpec = getAnchorSpec$1(editor, e, anchorType);\n      const bubbleYOffset = anchorType === 'point' ? bubbleSize : 0;\n      return {\n        bubble: nu$5(0, bubbleYOffset, bubbleAlignments),\n        layouts,\n        overrides: {\n          maxWidthFunction: expandable(),\n          maxHeightFunction: expandable$1()\n        },\n        ...anchorSpec\n      };\n    };\n    const show = (editor, e, items, backstage, contextmenu, anchorType, highlightImmediately) => {\n      const anchorSpec = getAnchorSpec(editor, e, anchorType);\n      build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {\n        isHorizontalMenu: true,\n        search: Optional.none()\n      }).map(menuData => {\n        e.preventDefault();\n        const highlightOnOpen = highlightImmediately ? HighlightOnOpen.HighlightMenuAndItem : HighlightOnOpen.HighlightNone;\n        InlineView.showMenuWithinBounds(contextmenu, { anchor: anchorSpec }, {\n          menu: {\n            markers: markers('normal'),\n            highlightOnOpen\n          },\n          data: menuData,\n          type: 'horizontal'\n        }, () => Optional.some(getContextToolbarBounds(editor, backstage.shared, anchorType === 'node' ? 'node' : 'selection')));\n        editor.dispatch(hideContextToolbarEvent);\n      });\n    };\n    const initAndShow = (editor, e, buildMenu, backstage, contextmenu, anchorType) => {\n      const detection = detect$1();\n      const isiOS = detection.os.isiOS();\n      const isMacOS = detection.os.isMacOS();\n      const isAndroid = detection.os.isAndroid();\n      const isTouch = detection.deviceType.isTouch();\n      const shouldHighlightImmediately = () => !(isAndroid || isiOS || isMacOS && isTouch);\n      const open = () => {\n        const items = buildMenu();\n        show(editor, e, items, backstage, contextmenu, anchorType, shouldHighlightImmediately());\n      };\n      if ((isMacOS || isiOS) && anchorType !== 'node') {\n        const openiOS = () => {\n          setupiOSOverrides(editor);\n          open();\n        };\n        if (isTouchWithinSelection(editor, e)) {\n          openiOS();\n        } else {\n          editor.once('selectionchange', openiOS);\n          editor.once('touchend', () => editor.off('selectionchange', openiOS));\n        }\n      } else {\n        open();\n      }\n    };\n\n    const isSeparator = item => isString(item) ? item === '|' : item.type === 'separator';\n    const separator = { type: 'separator' };\n    const makeContextItem = item => {\n      const commonMenuItem = item => ({\n        text: item.text,\n        icon: item.icon,\n        enabled: item.enabled,\n        shortcut: item.shortcut\n      });\n      if (isString(item)) {\n        return item;\n      } else {\n        switch (item.type) {\n        case 'separator':\n          return separator;\n        case 'submenu':\n          return {\n            type: 'nestedmenuitem',\n            ...commonMenuItem(item),\n            getSubmenuItems: () => {\n              const items = item.getSubmenuItems();\n              if (isString(items)) {\n                return items;\n              } else {\n                return map$2(items, makeContextItem);\n              }\n            }\n          };\n        default:\n          const commonItem = item;\n          return {\n            type: 'menuitem',\n            ...commonMenuItem(commonItem),\n            onAction: noarg(commonItem.onAction)\n          };\n        }\n      }\n    };\n    const addContextMenuGroup = (xs, groupItems) => {\n      if (groupItems.length === 0) {\n        return xs;\n      }\n      const lastMenuItem = last$1(xs).filter(item => !isSeparator(item));\n      const before = lastMenuItem.fold(() => [], _ => [separator]);\n      return xs.concat(before).concat(groupItems).concat([separator]);\n    };\n    const generateContextMenu = (contextMenus, menuConfig, selectedElement) => {\n      const sections = foldl(menuConfig, (acc, name) => {\n        return get$h(contextMenus, name.toLowerCase()).map(menu => {\n          const items = menu.update(selectedElement);\n          if (isString(items) && isNotEmpty(trim$1(items))) {\n            return addContextMenuGroup(acc, items.split(' '));\n          } else if (isArray(items) && items.length > 0) {\n            const allItems = map$2(items, makeContextItem);\n            return addContextMenuGroup(acc, allItems);\n          } else {\n            return acc;\n          }\n        }).getOrThunk(() => acc.concat([name]));\n      }, []);\n      if (sections.length > 0 && isSeparator(sections[sections.length - 1])) {\n        sections.pop();\n      }\n      return sections;\n    };\n    const isNativeOverrideKeyEvent = (editor, e) => e.ctrlKey && !shouldNeverUseNative(editor);\n    const isTouchEvent = e => e.type === 'longpress' || has$2(e, 'touches');\n    const isTriggeredByKeyboard = (editor, e) => !isTouchEvent(e) && (e.button !== 2 || e.target === editor.getBody() && e.pointerType === '');\n    const getSelectedElement = (editor, e) => isTriggeredByKeyboard(editor, e) ? editor.selection.getStart(true) : e.target;\n    const getAnchorType = (editor, e) => {\n      const selector = getAvoidOverlapSelector(editor);\n      const anchorType = isTriggeredByKeyboard(editor, e) ? 'selection' : 'point';\n      if (isNotEmpty(selector)) {\n        const target = getSelectedElement(editor, e);\n        const selectorExists = closest(SugarElement.fromDom(target), selector);\n        return selectorExists ? 'node' : anchorType;\n      } else {\n        return anchorType;\n      }\n    };\n    const setup$5 = (editor, lazySink, backstage) => {\n      const detection = detect$1();\n      const isTouch = detection.deviceType.isTouch;\n      const contextmenu = build$1(InlineView.sketch({\n        dom: { tag: 'div' },\n        lazySink,\n        onEscape: () => editor.focus(),\n        onShow: () => backstage.setContextMenuState(true),\n        onHide: () => backstage.setContextMenuState(false),\n        fireDismissalEventInstead: {},\n        inlineBehaviours: derive$1([config('dismissContextMenu', [run$1(dismissRequested(), (comp, _se) => {\n              Sandboxing.close(comp);\n              editor.focus();\n            })])])\n      }));\n      const hideContextMenu = () => InlineView.hide(contextmenu);\n      const showContextMenu = e => {\n        if (shouldNeverUseNative(editor)) {\n          e.preventDefault();\n        }\n        if (isNativeOverrideKeyEvent(editor, e) || isContextMenuDisabled(editor)) {\n          return;\n        }\n        const anchorType = getAnchorType(editor, e);\n        const buildMenu = () => {\n          const selectedElement = getSelectedElement(editor, e);\n          const registry = editor.ui.registry.getAll();\n          const menuConfig = getContextMenu(editor);\n          return generateContextMenu(registry.contextMenus, menuConfig, selectedElement);\n        };\n        const initAndShow$2 = isTouch() ? initAndShow : initAndShow$1;\n        initAndShow$2(editor, e, buildMenu, backstage, contextmenu, anchorType);\n      };\n      editor.on('init', () => {\n        const hideEvents = 'ResizeEditor ScrollContent ScrollWindow longpresscancel' + (isTouch() ? '' : ' ResizeWindow');\n        editor.on(hideEvents, hideContextMenu);\n        editor.on('longpress contextmenu', showContextMenu);\n      });\n    };\n\n    const adt = Adt.generate([\n      {\n        offset: [\n          'x',\n          'y'\n        ]\n      },\n      {\n        absolute: [\n          'x',\n          'y'\n        ]\n      },\n      {\n        fixed: [\n          'x',\n          'y'\n        ]\n      }\n    ]);\n    const subtract = change => point => point.translate(-change.left, -change.top);\n    const add = change => point => point.translate(change.left, change.top);\n    const transform = changes => (x, y) => foldl(changes, (rest, f) => f(rest), SugarPosition(x, y));\n    const asFixed = (coord, scroll, origin) => coord.fold(transform([\n      add(origin),\n      subtract(scroll)\n    ]), transform([subtract(scroll)]), transform([]));\n    const asAbsolute = (coord, scroll, origin) => coord.fold(transform([add(origin)]), transform([]), transform([add(scroll)]));\n    const asOffset = (coord, scroll, origin) => coord.fold(transform([]), transform([subtract(origin)]), transform([\n      add(scroll),\n      subtract(origin)\n    ]));\n    const withinRange = (coord1, coord2, xRange, yRange, scroll, origin) => {\n      const a1 = asAbsolute(coord1, scroll, origin);\n      const a2 = asAbsolute(coord2, scroll, origin);\n      return Math.abs(a1.left - a2.left) <= xRange && Math.abs(a1.top - a2.top) <= yRange;\n    };\n    const getDeltas = (coord1, coord2, xRange, yRange, scroll, origin) => {\n      const a1 = asAbsolute(coord1, scroll, origin);\n      const a2 = asAbsolute(coord2, scroll, origin);\n      const left = Math.abs(a1.left - a2.left);\n      const top = Math.abs(a1.top - a2.top);\n      return SugarPosition(left, top);\n    };\n    const toStyles = (coord, scroll, origin) => {\n      const stylesOpt = coord.fold((x, y) => ({\n        position: Optional.some('absolute'),\n        left: Optional.some(x + 'px'),\n        top: Optional.some(y + 'px')\n      }), (x, y) => ({\n        position: Optional.some('absolute'),\n        left: Optional.some(x - origin.left + 'px'),\n        top: Optional.some(y - origin.top + 'px')\n      }), (x, y) => ({\n        position: Optional.some('fixed'),\n        left: Optional.some(x + 'px'),\n        top: Optional.some(y + 'px')\n      }));\n      return {\n        right: Optional.none(),\n        bottom: Optional.none(),\n        ...stylesOpt\n      };\n    };\n    const translate = (coord, deltaX, deltaY) => coord.fold((x, y) => offset(x + deltaX, y + deltaY), (x, y) => absolute(x + deltaX, y + deltaY), (x, y) => fixed(x + deltaX, y + deltaY));\n    const absorb = (partialCoord, originalCoord, scroll, origin) => {\n      const absorbOne = (stencil, nu) => (optX, optY) => {\n        const original = stencil(originalCoord, scroll, origin);\n        return nu(optX.getOr(original.left), optY.getOr(original.top));\n      };\n      return partialCoord.fold(absorbOne(asOffset, offset), absorbOne(asAbsolute, absolute), absorbOne(asFixed, fixed));\n    };\n    const offset = adt.offset;\n    const absolute = adt.absolute;\n    const fixed = adt.fixed;\n\n    const parseAttrToInt = (element, name) => {\n      const value = get$g(element, name);\n      return isUndefined(value) ? NaN : parseInt(value, 10);\n    };\n    const get$1 = (component, snapsInfo) => {\n      const element = component.element;\n      const x = parseAttrToInt(element, snapsInfo.leftAttr);\n      const y = parseAttrToInt(element, snapsInfo.topAttr);\n      return isNaN(x) || isNaN(y) ? Optional.none() : Optional.some(SugarPosition(x, y));\n    };\n    const set = (component, snapsInfo, pt) => {\n      const element = component.element;\n      set$9(element, snapsInfo.leftAttr, pt.left + 'px');\n      set$9(element, snapsInfo.topAttr, pt.top + 'px');\n    };\n    const clear = (component, snapsInfo) => {\n      const element = component.element;\n      remove$8(element, snapsInfo.leftAttr);\n      remove$8(element, snapsInfo.topAttr);\n    };\n\n    const getCoords = (component, snapInfo, coord, delta) => get$1(component, snapInfo).fold(() => coord, fixed$1 => fixed(fixed$1.left + delta.left, fixed$1.top + delta.top));\n    const moveOrSnap = (component, snapInfo, coord, delta, scroll, origin) => {\n      const newCoord = getCoords(component, snapInfo, coord, delta);\n      const snap = snapInfo.mustSnap ? findClosestSnap(component, snapInfo, newCoord, scroll, origin) : findSnap(component, snapInfo, newCoord, scroll, origin);\n      const fixedCoord = asFixed(newCoord, scroll, origin);\n      set(component, snapInfo, fixedCoord);\n      return snap.fold(() => ({\n        coord: fixed(fixedCoord.left, fixedCoord.top),\n        extra: Optional.none()\n      }), spanned => ({\n        coord: spanned.output,\n        extra: spanned.extra\n      }));\n    };\n    const stopDrag = (component, snapInfo) => {\n      clear(component, snapInfo);\n    };\n    const findMatchingSnap = (snaps, newCoord, scroll, origin) => findMap(snaps, snap => {\n      const sensor = snap.sensor;\n      const inRange = withinRange(newCoord, sensor, snap.range.left, snap.range.top, scroll, origin);\n      return inRange ? Optional.some({\n        output: absorb(snap.output, newCoord, scroll, origin),\n        extra: snap.extra\n      }) : Optional.none();\n    });\n    const findClosestSnap = (component, snapInfo, newCoord, scroll, origin) => {\n      const snaps = snapInfo.getSnapPoints(component);\n      const matchSnap = findMatchingSnap(snaps, newCoord, scroll, origin);\n      return matchSnap.orThunk(() => {\n        const bestSnap = foldl(snaps, (acc, snap) => {\n          const sensor = snap.sensor;\n          const deltas = getDeltas(newCoord, sensor, snap.range.left, snap.range.top, scroll, origin);\n          return acc.deltas.fold(() => ({\n            deltas: Optional.some(deltas),\n            snap: Optional.some(snap)\n          }), bestDeltas => {\n            const currAvg = (deltas.left + deltas.top) / 2;\n            const bestAvg = (bestDeltas.left + bestDeltas.top) / 2;\n            if (currAvg <= bestAvg) {\n              return {\n                deltas: Optional.some(deltas),\n                snap: Optional.some(snap)\n              };\n            } else {\n              return acc;\n            }\n          });\n        }, {\n          deltas: Optional.none(),\n          snap: Optional.none()\n        });\n        return bestSnap.snap.map(snap => ({\n          output: absorb(snap.output, newCoord, scroll, origin),\n          extra: snap.extra\n        }));\n      });\n    };\n    const findSnap = (component, snapInfo, newCoord, scroll, origin) => {\n      const snaps = snapInfo.getSnapPoints(component);\n      return findMatchingSnap(snaps, newCoord, scroll, origin);\n    };\n    const snapTo$1 = (snap, scroll, origin) => ({\n      coord: absorb(snap.output, snap.output, scroll, origin),\n      extra: snap.extra\n    });\n\n    const snapTo = (component, dragConfig, _state, snap) => {\n      const target = dragConfig.getTarget(component.element);\n      if (dragConfig.repositionTarget) {\n        const doc = owner$4(component.element);\n        const scroll = get$c(doc);\n        const origin = getOrigin(target);\n        const snapPin = snapTo$1(snap, scroll, origin);\n        const styles = toStyles(snapPin.coord, scroll, origin);\n        setOptions(target, styles);\n      }\n    };\n\n    var DraggingApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        snapTo: snapTo\n    });\n\n    const initialAttribute = 'data-initial-z-index';\n    const resetZIndex = blocker => {\n      parent(blocker.element).filter(isElement$1).each(root => {\n        getOpt(root, initialAttribute).fold(() => remove$7(root, 'z-index'), zIndex => set$8(root, 'z-index', zIndex));\n        remove$8(root, initialAttribute);\n      });\n    };\n    const changeZIndex = blocker => {\n      parent(blocker.element).filter(isElement$1).each(root => {\n        getRaw(root, 'z-index').each(zindex => {\n          set$9(root, initialAttribute, zindex);\n        });\n        set$8(root, 'z-index', get$f(blocker.element, 'z-index'));\n      });\n    };\n    const instigate = (anyComponent, blocker) => {\n      anyComponent.getSystem().addToGui(blocker);\n      changeZIndex(blocker);\n    };\n    const discard = blocker => {\n      resetZIndex(blocker);\n      blocker.getSystem().removeFromGui(blocker);\n    };\n    const createComponent = (component, blockerClass, blockerEvents) => component.getSystem().build(Container.sketch({\n      dom: {\n        styles: {\n          'left': '0px',\n          'top': '0px',\n          'width': '100%',\n          'height': '100%',\n          'position': 'fixed',\n          'z-index': '1000000000000000'\n        },\n        classes: [blockerClass]\n      },\n      events: blockerEvents\n    }));\n\n    var SnapSchema = optionObjOf('snaps', [\n      required$1('getSnapPoints'),\n      onHandler('onSensor'),\n      required$1('leftAttr'),\n      required$1('topAttr'),\n      defaulted('lazyViewport', win),\n      defaulted('mustSnap', false)\n    ]);\n\n    const schema$6 = [\n      defaulted('useFixed', never),\n      required$1('blockerClass'),\n      defaulted('getTarget', identity),\n      defaulted('onDrag', noop),\n      defaulted('repositionTarget', true),\n      defaulted('onDrop', noop),\n      defaultedFunction('getBounds', win),\n      SnapSchema\n    ];\n\n    const getCurrentCoord = target => lift3(getRaw(target, 'left'), getRaw(target, 'top'), getRaw(target, 'position'), (left, top, position) => {\n      const nu = position === 'fixed' ? fixed : offset;\n      return nu(parseInt(left, 10), parseInt(top, 10));\n    }).getOrThunk(() => {\n      const location = absolute$3(target);\n      return absolute(location.left, location.top);\n    });\n    const clampCoords = (component, coords, scroll, origin, startData) => {\n      const bounds = startData.bounds;\n      const absoluteCoord = asAbsolute(coords, scroll, origin);\n      const newX = clamp(absoluteCoord.left, bounds.x, bounds.x + bounds.width - startData.width);\n      const newY = clamp(absoluteCoord.top, bounds.y, bounds.y + bounds.height - startData.height);\n      const newCoords = absolute(newX, newY);\n      return coords.fold(() => {\n        const offset$1 = asOffset(newCoords, scroll, origin);\n        return offset(offset$1.left, offset$1.top);\n      }, constant$1(newCoords), () => {\n        const fixed$1 = asFixed(newCoords, scroll, origin);\n        return fixed(fixed$1.left, fixed$1.top);\n      });\n    };\n    const calcNewCoord = (component, optSnaps, currentCoord, scroll, origin, delta, startData) => {\n      const newCoord = optSnaps.fold(() => {\n        const translated = translate(currentCoord, delta.left, delta.top);\n        const fixedCoord = asFixed(translated, scroll, origin);\n        return fixed(fixedCoord.left, fixedCoord.top);\n      }, snapInfo => {\n        const snapping = moveOrSnap(component, snapInfo, currentCoord, delta, scroll, origin);\n        snapping.extra.each(extra => {\n          snapInfo.onSensor(component, extra);\n        });\n        return snapping.coord;\n      });\n      return clampCoords(component, newCoord, scroll, origin, startData);\n    };\n    const dragBy = (component, dragConfig, startData, delta) => {\n      const target = dragConfig.getTarget(component.element);\n      if (dragConfig.repositionTarget) {\n        const doc = owner$4(component.element);\n        const scroll = get$c(doc);\n        const origin = getOrigin(target);\n        const currentCoord = getCurrentCoord(target);\n        const newCoord = calcNewCoord(component, dragConfig.snaps, currentCoord, scroll, origin, delta, startData);\n        const styles = toStyles(newCoord, scroll, origin);\n        setOptions(target, styles);\n      }\n      dragConfig.onDrag(component, target, delta);\n    };\n\n    const calcStartData = (dragConfig, comp) => ({\n      bounds: dragConfig.getBounds(),\n      height: getOuter$2(comp.element),\n      width: getOuter$1(comp.element)\n    });\n    const move = (component, dragConfig, dragState, dragMode, event) => {\n      const delta = dragState.update(dragMode, event);\n      const dragStartData = dragState.getStartData().getOrThunk(() => calcStartData(dragConfig, component));\n      delta.each(dlt => {\n        dragBy(component, dragConfig, dragStartData, dlt);\n      });\n    };\n    const stop = (component, blocker, dragConfig, dragState) => {\n      blocker.each(discard);\n      dragConfig.snaps.each(snapInfo => {\n        stopDrag(component, snapInfo);\n      });\n      const target = dragConfig.getTarget(component.element);\n      dragState.reset();\n      dragConfig.onDrop(component, target);\n    };\n    const handlers = events => (dragConfig, dragState) => {\n      const updateStartState = comp => {\n        dragState.setStartData(calcStartData(dragConfig, comp));\n      };\n      return derive$2([\n        run$1(windowScroll(), comp => {\n          dragState.getStartData().each(() => updateStartState(comp));\n        }),\n        ...events(dragConfig, dragState, updateStartState)\n      ]);\n    };\n\n    const init$3 = dragApi => derive$2([\n      run$1(mousedown(), dragApi.forceDrop),\n      run$1(mouseup(), dragApi.drop),\n      run$1(mousemove(), (comp, simulatedEvent) => {\n        dragApi.move(simulatedEvent.event);\n      }),\n      run$1(mouseout(), dragApi.delayDrop)\n    ]);\n\n    const getData$1 = event => Optional.from(SugarPosition(event.x, event.y));\n    const getDelta$1 = (old, nu) => SugarPosition(nu.left - old.left, nu.top - old.top);\n\n    var MouseData = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        getData: getData$1,\n        getDelta: getDelta$1\n    });\n\n    const events$3 = (dragConfig, dragState, updateStartState) => [run$1(mousedown(), (component, simulatedEvent) => {\n        const raw = simulatedEvent.event.raw;\n        if (raw.button !== 0) {\n          return;\n        }\n        simulatedEvent.stop();\n        const stop$1 = () => stop(component, Optional.some(blocker), dragConfig, dragState);\n        const delayDrop = DelayedFunction(stop$1, 200);\n        const dragApi = {\n          drop: stop$1,\n          delayDrop: delayDrop.schedule,\n          forceDrop: stop$1,\n          move: event => {\n            delayDrop.cancel();\n            move(component, dragConfig, dragState, MouseData, event);\n          }\n        };\n        const blocker = createComponent(component, dragConfig.blockerClass, init$3(dragApi));\n        const start = () => {\n          updateStartState(component);\n          instigate(component, blocker);\n        };\n        start();\n      })];\n    const schema$5 = [\n      ...schema$6,\n      output$1('dragger', { handlers: handlers(events$3) })\n    ];\n\n    const init$2 = dragApi => derive$2([\n      run$1(touchstart(), dragApi.forceDrop),\n      run$1(touchend(), dragApi.drop),\n      run$1(touchcancel(), dragApi.drop),\n      run$1(touchmove(), (comp, simulatedEvent) => {\n        dragApi.move(simulatedEvent.event);\n      })\n    ]);\n\n    const getDataFrom = touches => {\n      const touch = touches[0];\n      return Optional.some(SugarPosition(touch.clientX, touch.clientY));\n    };\n    const getData = event => {\n      const raw = event.raw;\n      const touches = raw.touches;\n      return touches.length === 1 ? getDataFrom(touches) : Optional.none();\n    };\n    const getDelta = (old, nu) => SugarPosition(nu.left - old.left, nu.top - old.top);\n\n    var TouchData = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        getData: getData,\n        getDelta: getDelta\n    });\n\n    const events$2 = (dragConfig, dragState, updateStartState) => {\n      const blockerSingleton = value$4();\n      const stopBlocking = component => {\n        stop(component, blockerSingleton.get(), dragConfig, dragState);\n        blockerSingleton.clear();\n      };\n      return [\n        run$1(touchstart(), (component, simulatedEvent) => {\n          simulatedEvent.stop();\n          const stop = () => stopBlocking(component);\n          const dragApi = {\n            drop: stop,\n            delayDrop: noop,\n            forceDrop: stop,\n            move: event => {\n              move(component, dragConfig, dragState, TouchData, event);\n            }\n          };\n          const blocker = createComponent(component, dragConfig.blockerClass, init$2(dragApi));\n          blockerSingleton.set(blocker);\n          const start = () => {\n            updateStartState(component);\n            instigate(component, blocker);\n          };\n          start();\n        }),\n        run$1(touchmove(), (component, simulatedEvent) => {\n          simulatedEvent.stop();\n          move(component, dragConfig, dragState, TouchData, simulatedEvent.event);\n        }),\n        run$1(touchend(), (component, simulatedEvent) => {\n          simulatedEvent.stop();\n          stopBlocking(component);\n        }),\n        run$1(touchcancel(), stopBlocking)\n      ];\n    };\n    const schema$4 = [\n      ...schema$6,\n      output$1('dragger', { handlers: handlers(events$2) })\n    ];\n\n    const events$1 = (dragConfig, dragState, updateStartState) => [\n      ...events$3(dragConfig, dragState, updateStartState),\n      ...events$2(dragConfig, dragState, updateStartState)\n    ];\n    const schema$3 = [\n      ...schema$6,\n      output$1('dragger', { handlers: handlers(events$1) })\n    ];\n\n    const mouse = schema$5;\n    const touch = schema$4;\n    const mouseOrTouch = schema$3;\n\n    var DraggingBranches = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        mouse: mouse,\n        touch: touch,\n        mouseOrTouch: mouseOrTouch\n    });\n\n    const init$1 = () => {\n      let previous = Optional.none();\n      let startData = Optional.none();\n      const reset = () => {\n        previous = Optional.none();\n        startData = Optional.none();\n      };\n      const calculateDelta = (mode, nu) => {\n        const result = previous.map(old => mode.getDelta(old, nu));\n        previous = Optional.some(nu);\n        return result;\n      };\n      const update = (mode, dragEvent) => mode.getData(dragEvent).bind(nuData => calculateDelta(mode, nuData));\n      const setStartData = data => {\n        startData = Optional.some(data);\n      };\n      const getStartData = () => startData;\n      const readState = constant$1({});\n      return nu$7({\n        readState,\n        reset,\n        update,\n        getStartData,\n        setStartData\n      });\n    };\n\n    var DragState = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        init: init$1\n    });\n\n    const Dragging = createModes({\n      branchKey: 'mode',\n      branches: DraggingBranches,\n      name: 'dragging',\n      active: {\n        events: (dragConfig, dragState) => {\n          const dragger = dragConfig.dragger;\n          return dragger.handlers(dragConfig, dragState);\n        }\n      },\n      extra: {\n        snap: sConfig => ({\n          sensor: sConfig.sensor,\n          range: sConfig.range,\n          output: sConfig.output,\n          extra: Optional.from(sConfig.extra)\n        })\n      },\n      state: DragState,\n      apis: DraggingApis\n    });\n\n    const snapWidth = 40;\n    const snapOffset = snapWidth / 2;\n    const calcSnap = (selectorOpt, td, x, y, width, height) => selectorOpt.fold(() => Dragging.snap({\n      sensor: absolute(x - snapOffset, y - snapOffset),\n      range: SugarPosition(width, height),\n      output: absolute(Optional.some(x), Optional.some(y)),\n      extra: { td }\n    }), selectorHandle => {\n      const sensorLeft = x - snapOffset;\n      const sensorTop = y - snapOffset;\n      const sensorWidth = snapWidth;\n      const sensorHeight = snapWidth;\n      const rect = selectorHandle.element.dom.getBoundingClientRect();\n      return Dragging.snap({\n        sensor: absolute(sensorLeft, sensorTop),\n        range: SugarPosition(sensorWidth, sensorHeight),\n        output: absolute(Optional.some(x - rect.width / 2), Optional.some(y - rect.height / 2)),\n        extra: { td }\n      });\n    });\n    const getSnapsConfig = (getSnapPoints, cell, onChange) => {\n      const isSameCell = (cellOpt, td) => cellOpt.exists(currentTd => eq(currentTd, td));\n      return {\n        getSnapPoints,\n        leftAttr: 'data-drag-left',\n        topAttr: 'data-drag-top',\n        onSensor: (component, extra) => {\n          const td = extra.td;\n          if (!isSameCell(cell.get(), td)) {\n            cell.set(td);\n            onChange(td);\n          }\n        },\n        mustSnap: true\n      };\n    };\n    const createSelector = snaps => record(Button.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-selector']\n      },\n      buttonBehaviours: derive$1([\n        Dragging.config({\n          mode: 'mouseOrTouch',\n          blockerClass: 'blocker',\n          snaps\n        }),\n        Unselecting.config({})\n      ]),\n      eventOrder: {\n        mousedown: [\n          'dragging',\n          'alloy.base.behaviour'\n        ],\n        touchstart: [\n          'dragging',\n          'alloy.base.behaviour'\n        ]\n      }\n    }));\n    const setup$4 = (editor, sink) => {\n      const tlTds = Cell([]);\n      const brTds = Cell([]);\n      const isVisible = Cell(false);\n      const startCell = value$4();\n      const finishCell = value$4();\n      const getTopLeftSnap = td => {\n        const box = absolute$2(td);\n        return calcSnap(memTopLeft.getOpt(sink), td, box.x, box.y, box.width, box.height);\n      };\n      const getTopLeftSnaps = () => map$2(tlTds.get(), td => getTopLeftSnap(td));\n      const getBottomRightSnap = td => {\n        const box = absolute$2(td);\n        return calcSnap(memBottomRight.getOpt(sink), td, box.right, box.bottom, box.width, box.height);\n      };\n      const getBottomRightSnaps = () => map$2(brTds.get(), td => getBottomRightSnap(td));\n      const topLeftSnaps = getSnapsConfig(getTopLeftSnaps, startCell, start => {\n        finishCell.get().each(finish => {\n          editor.dispatch('TableSelectorChange', {\n            start,\n            finish\n          });\n        });\n      });\n      const bottomRightSnaps = getSnapsConfig(getBottomRightSnaps, finishCell, finish => {\n        startCell.get().each(start => {\n          editor.dispatch('TableSelectorChange', {\n            start,\n            finish\n          });\n        });\n      });\n      const memTopLeft = createSelector(topLeftSnaps);\n      const memBottomRight = createSelector(bottomRightSnaps);\n      const topLeft = build$1(memTopLeft.asSpec());\n      const bottomRight = build$1(memBottomRight.asSpec());\n      const showOrHideHandle = (selector, cell, isAbove, isBelow) => {\n        const cellRect = cell.dom.getBoundingClientRect();\n        remove$7(selector.element, 'display');\n        const viewportHeight = defaultView(SugarElement.fromDom(editor.getBody())).dom.innerHeight;\n        const aboveViewport = isAbove(cellRect);\n        const belowViewport = isBelow(cellRect, viewportHeight);\n        if (aboveViewport || belowViewport) {\n          set$8(selector.element, 'display', 'none');\n        }\n      };\n      const snapTo = (selector, cell, getSnapConfig, pos) => {\n        const snap = getSnapConfig(cell);\n        Dragging.snapTo(selector, snap);\n        const isAbove = rect => rect[pos] < 0;\n        const isBelow = (rect, viewportHeight) => rect[pos] > viewportHeight;\n        showOrHideHandle(selector, cell, isAbove, isBelow);\n      };\n      const snapTopLeft = cell => snapTo(topLeft, cell, getTopLeftSnap, 'top');\n      const snapLastTopLeft = () => startCell.get().each(snapTopLeft);\n      const snapBottomRight = cell => snapTo(bottomRight, cell, getBottomRightSnap, 'bottom');\n      const snapLastBottomRight = () => finishCell.get().each(snapBottomRight);\n      if (detect$1().deviceType.isTouch()) {\n        const domToSugar = arr => map$2(arr, SugarElement.fromDom);\n        editor.on('TableSelectionChange', e => {\n          if (!isVisible.get()) {\n            attach(sink, topLeft);\n            attach(sink, bottomRight);\n            isVisible.set(true);\n          }\n          const start = SugarElement.fromDom(e.start);\n          const finish = SugarElement.fromDom(e.finish);\n          startCell.set(start);\n          finishCell.set(finish);\n          Optional.from(e.otherCells).each(otherCells => {\n            tlTds.set(domToSugar(otherCells.upOrLeftCells));\n            brTds.set(domToSugar(otherCells.downOrRightCells));\n            snapTopLeft(start);\n            snapBottomRight(finish);\n          });\n        });\n        editor.on('ResizeEditor ResizeWindow ScrollContent', () => {\n          snapLastTopLeft();\n          snapLastBottomRight();\n        });\n        editor.on('TableSelectionClear', () => {\n          if (isVisible.get()) {\n            detach(topLeft);\n            detach(bottomRight);\n            isVisible.set(false);\n          }\n          startCell.clear();\n          finishCell.clear();\n        });\n      }\n    };\n\n    var Logo = \"<svg height=\\\"16\\\" viewBox=\\\"0 0 80 16\\\" width=\\\"80\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><g opacity=\\\".8\\\"><path d=\\\"m80 3.537v-2.202h-7.976v11.585h7.976v-2.25h-5.474v-2.621h4.812v-2.069h-4.812v-2.443zm-10.647 6.929c-.493.217-1.13.337-1.864.337s-1.276-.156-1.805-.47a3.732 3.732 0 0 1 -1.3-1.298c-.324-.554-.48-1.191-.48-1.877s.156-1.335.48-1.877a3.635 3.635 0 0 1 1.3-1.299 3.466 3.466 0 0 1 1.805-.481c.65 0 .914.06 1.263.18.36.12.698.277.986.47.289.192.578.384.842.6l.12.085v-2.586l-.023-.024c-.385-.35-.855-.614-1.384-.818-.53-.205-1.155-.313-1.877-.313-.721 0-1.6.144-2.333.445a5.773 5.773 0 0 0 -1.937 1.251 5.929 5.929 0 0 0 -1.324 1.9c-.324.735-.48 1.565-.48 2.455s.156 1.72.48 2.454c.325.734.758 1.383 1.324 1.913.553.53 1.215.938 1.937 1.25a6.286 6.286 0 0 0 2.333.434c.819 0 1.384-.108 1.961-.313.59-.216 1.083-.505 1.468-.866l.024-.024v-2.49l-.12.096c-.41.337-.878.626-1.396.866zm-14.869-4.15-4.8-5.04-.024-.025h-.902v11.67h2.502v-6.847l2.827 3.08.385.409.397-.41 2.791-3.067v6.845h2.502v-11.679h-.902l-4.788 5.052z\\\"/><path clip-rule=\\\"evenodd\\\" d=\\\"m15.543 5.137c0-3.032-2.466-5.113-4.957-5.137-.36 0-.745.024-1.094.096-.157.024-3.85.758-3.85.758-3.032.602-4.62 2.466-4.704 4.788-.024.89-.024 4.27-.024 4.27.036 3.165 2.406 5.138 5.017 5.126.337 0 1.119-.109 1.287-.145.144-.024.385-.084.746-.144.661-.12 1.684-.325 3.067-.602 2.37-.409 4.103-2.009 4.44-4.33.156-1.023.084-4.692.084-4.692zm-3.213 3.308-2.346.457v2.31l-5.859 1.143v-5.75l2.346-.458v3.441l3.513-.686v-3.44l-3.513.685v-2.297l5.859-1.143v5.75zm20.09-3.296-.083-1.023h-2.13v8.794h2.346v-4.884c0-1.107.95-1.985 2.057-1.997 1.095 0 1.901.89 1.901 1.997v4.884h2.346v-5.245c-.012-2.105-1.588-3.777-3.67-3.765a3.764 3.764 0 0 0 -2.778 1.25l.012-.011zm-6.014-4.102 2.346-.458v2.298l-2.346.457z\\\" fill-rule=\\\"evenodd\\\"/><path d=\\\"m28.752 4.126h-2.346v8.794h2.346z\\\"/><path clip-rule=\\\"evenodd\\\" d=\\\"m43.777 15.483 4.043-11.357h-2.418l-1.54 4.355-.445 1.324-.36-1.324-1.54-4.355h-2.418l3.151 8.794-1.083 3.08zm-21.028-5.51c0 .722.541 1.034.878 1.034s.638-.048.95-.144l.518 1.708c-.217.145-.879.518-2.13.518a2.565 2.565 0 0 1 -2.562-2.587c-.024-1.082-.024-2.49 0-4.21h-1.54v-2.142h1.54v-1.912l2.346-.458v2.37h2.201v2.142h-2.2v3.693-.012z\\\" fill-rule=\\\"evenodd\\\"/></g></svg>\\n\";\n\n    const describedBy = (describedElement, describeElement) => {\n      const describeId = Optional.from(get$g(describedElement, 'id')).getOrThunk(() => {\n        const id = generate$6('aria');\n        set$9(describeElement, 'id', id);\n        return id;\n      });\n      set$9(describedElement, 'aria-describedby', describeId);\n    };\n    const remove = describedElement => {\n      remove$8(describedElement, 'aria-describedby');\n    };\n\n    const isHidden = elm => elm.nodeName === 'BR' || !!elm.getAttribute('data-mce-bogus') || elm.getAttribute('data-mce-type') === 'bookmark';\n    const renderElementPath = (editor, settings, providersBackstage) => {\n      var _a;\n      const delimiter = (_a = settings.delimiter) !== null && _a !== void 0 ? _a : '\\u203A';\n      const renderElement = (name, element, index) => Button.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-statusbar__path-item'],\n          attributes: { 'data-index': index }\n        },\n        components: [text$2(name)],\n        action: _btn => {\n          editor.focus();\n          editor.selection.select(element);\n          editor.nodeChanged();\n        },\n        buttonBehaviours: derive$1([\n          Tooltipping.config({\n            ...providersBackstage.tooltips.getConfig({\n              tooltipText: providersBackstage.translate([\n                'Select the {0} element',\n                element.nodeName.toLowerCase()\n              ]),\n              onShow: (comp, tooltip) => {\n                describedBy(comp.element, tooltip.element);\n              },\n              onHide: comp => {\n                remove(comp.element);\n              }\n            })\n          }),\n          DisablingConfigs.button(providersBackstage.isDisabled),\n          receivingConfig()\n        ])\n      });\n      const renderDivider = () => ({\n        dom: {\n          tag: 'div',\n          classes: ['tox-statusbar__path-divider'],\n          attributes: { 'aria-hidden': true }\n        },\n        components: [text$2(` ${ delimiter } `)]\n      });\n      const renderPathData = data => foldl(data, (acc, path, index) => {\n        const element = renderElement(path.name, path.element, index);\n        if (index === 0) {\n          return acc.concat([element]);\n        } else {\n          return acc.concat([\n            renderDivider(),\n            element\n          ]);\n        }\n      }, []);\n      const updatePath = parents => {\n        const newPath = [];\n        let i = parents.length;\n        while (i-- > 0) {\n          const parent = parents[i];\n          if (parent.nodeType === 1 && !isHidden(parent)) {\n            const args = fireResolveName(editor, parent);\n            if (!args.isDefaultPrevented()) {\n              newPath.push({\n                name: args.name,\n                element: parent\n              });\n            }\n            if (args.isPropagationStopped()) {\n              break;\n            }\n          }\n        }\n        return newPath;\n      };\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-statusbar__path'],\n          attributes: { role: 'navigation' }\n        },\n        behaviours: derive$1([\n          Keying.config({\n            mode: 'flow',\n            selector: 'div[role=button]'\n          }),\n          Disabling.config({ disabled: providersBackstage.isDisabled }),\n          receivingConfig(),\n          Tabstopping.config({}),\n          Replacing.config({}),\n          config('elementPathEvents', [runOnAttached((comp, _e) => {\n              editor.shortcuts.add('alt+F11', 'focus statusbar elementpath', () => Keying.focusIn(comp));\n              editor.on('NodeChange', e => {\n                const newPath = updatePath(e.parents);\n                const newChildren = newPath.length > 0 ? renderPathData(newPath) : [];\n                Replacing.set(comp, newChildren);\n              });\n            })])\n        ]),\n        components: []\n      };\n    };\n\n    var ResizeTypes;\n    (function (ResizeTypes) {\n      ResizeTypes[ResizeTypes['None'] = 0] = 'None';\n      ResizeTypes[ResizeTypes['Both'] = 1] = 'Both';\n      ResizeTypes[ResizeTypes['Vertical'] = 2] = 'Vertical';\n    }(ResizeTypes || (ResizeTypes = {})));\n    const getDimensions = (editor, deltas, resizeType, originalHeight, originalWidth) => {\n      const dimensions = { height: calcCappedSize(originalHeight + deltas.top, getMinHeightOption(editor), getMaxHeightOption(editor)) };\n      if (resizeType === ResizeTypes.Both) {\n        dimensions.width = calcCappedSize(originalWidth + deltas.left, getMinWidthOption(editor), getMaxWidthOption(editor));\n      }\n      return dimensions;\n    };\n    const resize = (editor, deltas, resizeType) => {\n      const container = SugarElement.fromDom(editor.getContainer());\n      const dimensions = getDimensions(editor, deltas, resizeType, get$e(container), get$d(container));\n      each(dimensions, (val, dim) => {\n        if (isNumber(val)) {\n          set$8(container, dim, numToPx(val));\n        }\n      });\n      fireResizeEditor(editor);\n    };\n\n    const getResizeType = editor => {\n      const resize = getResize(editor);\n      if (resize === false) {\n        return ResizeTypes.None;\n      } else if (resize === 'both') {\n        return ResizeTypes.Both;\n      } else {\n        return ResizeTypes.Vertical;\n      }\n    };\n    const keyboardHandler = (editor, resizeType, x, y) => {\n      const scale = 20;\n      const delta = SugarPosition(x * scale, y * scale);\n      resize(editor, delta, resizeType);\n      return Optional.some(true);\n    };\n    const renderResizeHandler = (editor, providersBackstage) => {\n      const resizeType = getResizeType(editor);\n      if (resizeType === ResizeTypes.None) {\n        return Optional.none();\n      }\n      const resizeLabel = resizeType === ResizeTypes.Both ? 'Press the arrow keys to resize the editor.' : 'Press the Up and Down arrow keys to resize the editor.';\n      return Optional.some(render$3('resize-handle', {\n        tag: 'div',\n        classes: ['tox-statusbar__resize-handle'],\n        attributes: {\n          'aria-label': providersBackstage.translate(resizeLabel),\n          'data-mce-name': 'resize-handle'\n        },\n        behaviours: [\n          Dragging.config({\n            mode: 'mouse',\n            repositionTarget: false,\n            onDrag: (_comp, _target, delta) => resize(editor, delta, resizeType),\n            blockerClass: 'tox-blocker'\n          }),\n          Keying.config({\n            mode: 'special',\n            onLeft: () => keyboardHandler(editor, resizeType, -1, 0),\n            onRight: () => keyboardHandler(editor, resizeType, 1, 0),\n            onUp: () => keyboardHandler(editor, resizeType, 0, -1),\n            onDown: () => keyboardHandler(editor, resizeType, 0, 1)\n          }),\n          Tabstopping.config({}),\n          Focusing.config({}),\n          Tooltipping.config(providersBackstage.tooltips.getConfig({ tooltipText: providersBackstage.translate('Resize') }))\n        ]\n      }, providersBackstage.icons));\n    };\n\n    const renderWordCount = (editor, providersBackstage) => {\n      const replaceCountText = (comp, count, mode) => Replacing.set(comp, [text$2(providersBackstage.translate([\n          '{0} ' + mode,\n          count[mode]\n        ]))]);\n      return Button.sketch({\n        dom: {\n          tag: 'button',\n          classes: ['tox-statusbar__wordcount']\n        },\n        components: [],\n        buttonBehaviours: derive$1([\n          DisablingConfigs.button(providersBackstage.isDisabled),\n          receivingConfig(),\n          Tabstopping.config({}),\n          Replacing.config({}),\n          Representing.config({\n            store: {\n              mode: 'memory',\n              initialValue: {\n                mode: 'words',\n                count: {\n                  words: 0,\n                  characters: 0\n                }\n              }\n            }\n          }),\n          config('wordcount-events', [\n            runOnExecute$1(comp => {\n              const currentVal = Representing.getValue(comp);\n              const newMode = currentVal.mode === 'words' ? 'characters' : 'words';\n              Representing.setValue(comp, {\n                mode: newMode,\n                count: currentVal.count\n              });\n              replaceCountText(comp, currentVal.count, newMode);\n            }),\n            runOnAttached(comp => {\n              editor.on('wordCountUpdate', e => {\n                const {mode} = Representing.getValue(comp);\n                Representing.setValue(comp, {\n                  mode,\n                  count: e.wordCount\n                });\n                replaceCountText(comp, e.wordCount, mode);\n              });\n            })\n          ])\n        ]),\n        eventOrder: {\n          [execute$5()]: [\n            'disabling',\n            'alloy.base.behaviour',\n            'wordcount-events'\n          ]\n        }\n      });\n    };\n\n    const renderStatusbar = (editor, providersBackstage) => {\n      const renderBranding = () => {\n        return {\n          dom: {\n            tag: 'span',\n            classes: ['tox-statusbar__branding']\n          },\n          components: [{\n              dom: {\n                tag: 'a',\n                attributes: {\n                  'href': 'https://www.tiny.cloud/powered-by-tiny?utm_campaign=poweredby&utm_source=tiny&utm_medium=referral&utm_content=v7',\n                  'rel': 'noopener',\n                  'target': '_blank',\n                  'aria-label': editor.translate([\n                    'Build with {0}',\n                    'TinyMCE'\n                  ])\n                },\n                innerHtml: editor.translate([\n                  'Build with {0}',\n                  Logo.trim()\n                ])\n              },\n              behaviours: derive$1([Focusing.config({})])\n            }]\n        };\n      };\n      const renderHelpAccessibility = () => {\n        const shortcutText = convertText('Alt+0');\n        const text = `Press {0} for help`;\n        return {\n          dom: {\n            tag: 'div',\n            classes: ['tox-statusbar__help-text']\n          },\n          components: [text$2(global$5.translate([\n              text,\n              shortcutText\n            ]))]\n        };\n      };\n      const renderRightContainer = () => {\n        const components = [];\n        if (editor.hasPlugin('wordcount')) {\n          components.push(renderWordCount(editor, providersBackstage));\n        }\n        if (useBranding(editor)) {\n          components.push(renderBranding());\n        }\n        return {\n          dom: {\n            tag: 'div',\n            classes: ['tox-statusbar__right-container']\n          },\n          components\n        };\n      };\n      const getTextComponents = () => {\n        const components = [];\n        const shouldRenderHelp = useHelpAccessibility(editor);\n        const shouldRenderElementPath = useElementPath(editor);\n        const shouldRenderRightContainer = useBranding(editor) || editor.hasPlugin('wordcount');\n        const getTextComponentClasses = () => {\n          const flexStart = 'tox-statusbar__text-container--flex-start';\n          const flexEnd = 'tox-statusbar__text-container--flex-end';\n          const spaceAround = 'tox-statusbar__text-container--space-around';\n          if (shouldRenderHelp) {\n            const container3Columns = 'tox-statusbar__text-container-3-cols';\n            if (!shouldRenderRightContainer && !shouldRenderElementPath) {\n              return [\n                container3Columns,\n                spaceAround\n              ];\n            }\n            if (shouldRenderRightContainer && !shouldRenderElementPath) {\n              return [\n                container3Columns,\n                flexEnd\n              ];\n            }\n            return [\n              container3Columns,\n              flexStart\n            ];\n          }\n          return [shouldRenderRightContainer && !shouldRenderElementPath ? flexEnd : flexStart];\n        };\n        if (shouldRenderElementPath) {\n          components.push(renderElementPath(editor, {}, providersBackstage));\n        }\n        if (shouldRenderHelp) {\n          components.push(renderHelpAccessibility());\n        }\n        if (shouldRenderRightContainer) {\n          components.push(renderRightContainer());\n        }\n        if (components.length > 0) {\n          return [{\n              dom: {\n                tag: 'div',\n                classes: [\n                  'tox-statusbar__text-container',\n                  ...getTextComponentClasses()\n                ]\n              },\n              components\n            }];\n        }\n        return [];\n      };\n      const getComponents = () => {\n        const components = getTextComponents();\n        const resizeHandler = renderResizeHandler(editor, providersBackstage);\n        return components.concat(resizeHandler.toArray());\n      };\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-statusbar']\n        },\n        components: getComponents()\n      };\n    };\n\n    const getLazyMothership = (label, singleton) => singleton.get().getOrDie(`UI for ${ label } has not been rendered`);\n    const setup$3 = (editor, setupForTheme) => {\n      const isInline = editor.inline;\n      const mode = isInline ? Inline : Iframe;\n      const header = isStickyToolbar(editor) ? StickyHeader : StaticHeader;\n      const lazyUiRefs = LazyUiReferences();\n      const lazyMothership = value$4();\n      const lazyDialogMothership = value$4();\n      const lazyPopupMothership = value$4();\n      const platform = detect$1();\n      const isTouch = platform.deviceType.isTouch();\n      const touchPlatformClass = 'tox-platform-touch';\n      const deviceClasses = isTouch ? [touchPlatformClass] : [];\n      const isToolbarBottom = isToolbarLocationBottom(editor);\n      const toolbarMode = getToolbarMode(editor);\n      const memAnchorBar = record({\n        dom: {\n          tag: 'div',\n          classes: ['tox-anchorbar']\n        }\n      });\n      const memBottomAnchorBar = record({\n        dom: {\n          tag: 'div',\n          classes: ['tox-bottom-anchorbar']\n        }\n      });\n      const lazyHeader = () => lazyUiRefs.mainUi.get().map(ui => ui.outerContainer).bind(OuterContainer.getHeader);\n      const lazyDialogSinkResult = () => Result.fromOption(lazyUiRefs.dialogUi.get().map(ui => ui.sink), 'UI has not been rendered');\n      const lazyPopupSinkResult = () => Result.fromOption(lazyUiRefs.popupUi.get().map(ui => ui.sink), '(popup) UI has not been rendered');\n      const lazyAnchorBar = lazyUiRefs.lazyGetInOuterOrDie('anchor bar', memAnchorBar.getOpt);\n      const lazyBottomAnchorBar = lazyUiRefs.lazyGetInOuterOrDie('bottom anchor bar', memBottomAnchorBar.getOpt);\n      const lazyToolbar = lazyUiRefs.lazyGetInOuterOrDie('toolbar', OuterContainer.getToolbar);\n      const lazyThrobber = lazyUiRefs.lazyGetInOuterOrDie('throbber', OuterContainer.getThrobber);\n      const backstages = init$5({\n        popup: lazyPopupSinkResult,\n        dialog: lazyDialogSinkResult\n      }, editor, lazyAnchorBar, lazyBottomAnchorBar);\n      const makeHeaderPart = () => {\n        const verticalDirAttributes = { attributes: { [Attribute]: isToolbarBottom ? AttributeValue.BottomToTop : AttributeValue.TopToBottom } };\n        const partMenubar = OuterContainer.parts.menubar({\n          dom: {\n            tag: 'div',\n            classes: ['tox-menubar']\n          },\n          backstage: backstages.popup,\n          onEscape: () => {\n            editor.focus();\n          }\n        });\n        const partToolbar = OuterContainer.parts.toolbar({\n          dom: {\n            tag: 'div',\n            classes: ['tox-toolbar']\n          },\n          getSink: backstages.popup.shared.getSink,\n          providers: backstages.popup.shared.providers,\n          onEscape: () => {\n            editor.focus();\n          },\n          onToolbarToggled: state => {\n            fireToggleToolbarDrawer(editor, state);\n          },\n          type: toolbarMode,\n          lazyToolbar,\n          lazyHeader: () => lazyHeader().getOrDie('Could not find header element'),\n          ...verticalDirAttributes\n        });\n        const partMultipleToolbar = OuterContainer.parts['multiple-toolbar']({\n          dom: {\n            tag: 'div',\n            classes: ['tox-toolbar-overlord']\n          },\n          providers: backstages.popup.shared.providers,\n          onEscape: () => {\n            editor.focus();\n          },\n          type: toolbarMode\n        });\n        const hasMultipleToolbar = isMultipleToolbars(editor);\n        const hasToolbar = isToolbarEnabled(editor);\n        const hasMenubar = isMenubarEnabled(editor);\n        const shouldHavePromotion = promotionEnabled(editor);\n        const partPromotion = makePromotion();\n        const hasAnyContents = hasMultipleToolbar || hasToolbar || hasMenubar;\n        const getPartToolbar = () => {\n          if (hasMultipleToolbar) {\n            return [partMultipleToolbar];\n          } else if (hasToolbar) {\n            return [partToolbar];\n          } else {\n            return [];\n          }\n        };\n        const menubarCollection = shouldHavePromotion ? [\n          partPromotion,\n          partMenubar\n        ] : [partMenubar];\n        return OuterContainer.parts.header({\n          dom: {\n            tag: 'div',\n            classes: ['tox-editor-header'].concat(hasAnyContents ? [] : ['tox-editor-header--empty']),\n            ...verticalDirAttributes\n          },\n          components: flatten([\n            hasMenubar ? menubarCollection : [],\n            getPartToolbar(),\n            useFixedContainer(editor) ? [] : [memAnchorBar.asSpec()]\n          ]),\n          sticky: isStickyToolbar(editor),\n          editor,\n          sharedBackstage: backstages.popup.shared\n        });\n      };\n      const makePromotion = () => {\n        return OuterContainer.parts.promotion({\n          dom: {\n            tag: 'div',\n            classes: ['tox-promotion']\n          }\n        });\n      };\n      const makeSidebarDefinition = () => {\n        const partSocket = OuterContainer.parts.socket({\n          dom: {\n            tag: 'div',\n            classes: ['tox-edit-area']\n          }\n        });\n        const partSidebar = OuterContainer.parts.sidebar({\n          dom: {\n            tag: 'div',\n            classes: ['tox-sidebar']\n          }\n        });\n        return {\n          dom: {\n            tag: 'div',\n            classes: ['tox-sidebar-wrap']\n          },\n          components: [\n            partSocket,\n            partSidebar\n          ]\n        };\n      };\n      const renderDialogUi = () => {\n        const uiContainer = getUiContainer(editor);\n        const isGridUiContainer = eq(body(), uiContainer) && get$f(uiContainer, 'display') === 'grid';\n        const sinkSpec = {\n          dom: {\n            tag: 'div',\n            classes: [\n              'tox',\n              'tox-silver-sink',\n              'tox-tinymce-aux'\n            ].concat(deviceClasses),\n            attributes: { ...global$5.isRtl() ? { dir: 'rtl' } : {} }\n          },\n          behaviours: derive$1([Positioning.config({ useFixed: () => header.isDocked(lazyHeader) })])\n        };\n        const reactiveWidthSpec = {\n          dom: { styles: { width: document.body.clientWidth + 'px' } },\n          events: derive$2([run$1(windowResize(), comp => {\n              set$8(comp.element, 'width', document.body.clientWidth + 'px');\n            })])\n        };\n        const sink = build$1(deepMerge(sinkSpec, isGridUiContainer ? reactiveWidthSpec : {}));\n        const uiMothership = takeover(sink);\n        lazyDialogMothership.set(uiMothership);\n        return {\n          sink,\n          mothership: uiMothership\n        };\n      };\n      const renderPopupUi = () => {\n        const sinkSpec = {\n          dom: {\n            tag: 'div',\n            classes: [\n              'tox',\n              'tox-silver-sink',\n              'tox-silver-popup-sink',\n              'tox-tinymce-aux'\n            ].concat(deviceClasses),\n            attributes: { ...global$5.isRtl() ? { dir: 'rtl' } : {} }\n          },\n          behaviours: derive$1([Positioning.config({\n              useFixed: () => header.isDocked(lazyHeader),\n              getBounds: () => setupForTheme.getPopupSinkBounds()\n            })])\n        };\n        const sink = build$1(sinkSpec);\n        const uiMothership = takeover(sink);\n        lazyPopupMothership.set(uiMothership);\n        return {\n          sink,\n          mothership: uiMothership\n        };\n      };\n      const renderMainUi = () => {\n        const partHeader = makeHeaderPart();\n        const sidebarContainer = makeSidebarDefinition();\n        const partThrobber = OuterContainer.parts.throbber({\n          dom: {\n            tag: 'div',\n            classes: ['tox-throbber']\n          },\n          backstage: backstages.popup\n        });\n        const partViewWrapper = OuterContainer.parts.viewWrapper({ backstage: backstages.popup });\n        const statusbar = useStatusBar(editor) && !isInline ? Optional.some(renderStatusbar(editor, backstages.popup.shared.providers)) : Optional.none();\n        const editorComponents = flatten([\n          isToolbarBottom ? [] : [partHeader],\n          isInline ? [] : [sidebarContainer],\n          isToolbarBottom ? [partHeader] : []\n        ]);\n        const editorContainer = OuterContainer.parts.editorContainer({\n          components: flatten([\n            editorComponents,\n            isInline ? [] : [memBottomAnchorBar.asSpec()]\n          ])\n        });\n        const isHidden = isDistractionFree(editor);\n        const attributes = {\n          role: 'application',\n          ...global$5.isRtl() ? { dir: 'rtl' } : {},\n          ...isHidden ? { 'aria-hidden': 'true' } : {}\n        };\n        const outerContainer = build$1(OuterContainer.sketch({\n          dom: {\n            tag: 'div',\n            classes: [\n              'tox',\n              'tox-tinymce'\n            ].concat(isInline ? ['tox-tinymce-inline'] : []).concat(isToolbarBottom ? ['tox-tinymce--toolbar-bottom'] : []).concat(deviceClasses),\n            styles: {\n              visibility: 'hidden',\n              ...isHidden ? {\n                opacity: '0',\n                border: '0'\n              } : {}\n            },\n            attributes\n          },\n          components: [\n            editorContainer,\n            ...isInline ? [] : [\n              partViewWrapper,\n              ...statusbar.toArray()\n            ],\n            partThrobber\n          ],\n          behaviours: derive$1([\n            receivingConfig(),\n            Disabling.config({ disableClass: 'tox-tinymce--disabled' }),\n            Keying.config({\n              mode: 'cyclic',\n              selector: '.tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle'\n            })\n          ])\n        }));\n        const mothership = takeover(outerContainer);\n        lazyMothership.set(mothership);\n        return {\n          mothership,\n          outerContainer\n        };\n      };\n      const setEditorSize = outerContainer => {\n        const parsedHeight = numToPx(getHeightWithFallback(editor));\n        const parsedWidth = numToPx(getWidthWithFallback(editor));\n        if (!editor.inline) {\n          if (isValidValue$1('div', 'width', parsedWidth)) {\n            set$8(outerContainer.element, 'width', parsedWidth);\n          }\n          if (isValidValue$1('div', 'height', parsedHeight)) {\n            set$8(outerContainer.element, 'height', parsedHeight);\n          } else {\n            set$8(outerContainer.element, 'height', '400px');\n          }\n        }\n        return parsedHeight;\n      };\n      const setupShortcutsAndCommands = outerContainer => {\n        editor.addShortcut('alt+F9', 'focus menubar', () => {\n          OuterContainer.focusMenubar(outerContainer);\n        });\n        editor.addShortcut('alt+F10', 'focus toolbar', () => {\n          OuterContainer.focusToolbar(outerContainer);\n        });\n        editor.addCommand('ToggleToolbarDrawer', (_ui, options) => {\n          if (options === null || options === void 0 ? void 0 : options.skipFocus) {\n            OuterContainer.toggleToolbarDrawerWithoutFocusing(outerContainer);\n          } else {\n            OuterContainer.toggleToolbarDrawer(outerContainer);\n          }\n        });\n        editor.addQueryStateHandler('ToggleToolbarDrawer', () => OuterContainer.isToolbarDrawerToggled(outerContainer));\n      };\n      const renderUIWithRefs = uiRefs => {\n        const {mainUi, popupUi, uiMotherships} = uiRefs;\n        map$1(getToolbarGroups(editor), (toolbarGroupButtonConfig, name) => {\n          editor.ui.registry.addGroupToolbarButton(name, toolbarGroupButtonConfig);\n        });\n        const {buttons, menuItems, contextToolbars, sidebars, views} = editor.ui.registry.getAll();\n        const toolbarOpt = getMultipleToolbarsOption(editor);\n        const rawUiConfig = {\n          menuItems,\n          menus: getMenus(editor),\n          menubar: getMenubar(editor),\n          toolbar: toolbarOpt.getOrThunk(() => getToolbar(editor)),\n          allowToolbarGroups: toolbarMode === ToolbarMode$1.floating,\n          buttons,\n          sidebar: sidebars,\n          views\n        };\n        setupShortcutsAndCommands(mainUi.outerContainer);\n        setup$b(editor, mainUi.mothership, uiMotherships);\n        header.setup(editor, backstages.popup.shared, lazyHeader);\n        setup$6(editor, backstages.popup);\n        setup$5(editor, backstages.popup.shared.getSink, backstages.popup);\n        setup$8(editor);\n        setup$7(editor, lazyThrobber, backstages.popup.shared);\n        register$9(editor, contextToolbars, popupUi.sink, { backstage: backstages.popup });\n        setup$4(editor, popupUi.sink);\n        const elm = editor.getElement();\n        const height = setEditorSize(mainUi.outerContainer);\n        const args = {\n          targetNode: elm,\n          height\n        };\n        return mode.render(editor, uiRefs, rawUiConfig, backstages.popup, args);\n      };\n      const reuseDialogUiForPopuUi = dialogUi => {\n        lazyPopupMothership.set(dialogUi.mothership);\n        return dialogUi;\n      };\n      const renderUI = () => {\n        const mainUi = renderMainUi();\n        const dialogUi = renderDialogUi();\n        const popupUi = isSplitUiMode(editor) ? renderPopupUi() : reuseDialogUiForPopuUi(dialogUi);\n        lazyUiRefs.dialogUi.set(dialogUi);\n        lazyUiRefs.popupUi.set(popupUi);\n        lazyUiRefs.mainUi.set(mainUi);\n        const uiRefs = {\n          popupUi,\n          dialogUi,\n          mainUi,\n          uiMotherships: lazyUiRefs.getUiMotherships()\n        };\n        return renderUIWithRefs(uiRefs);\n      };\n      return {\n        popups: {\n          backstage: backstages.popup,\n          getMothership: () => getLazyMothership('popups', lazyPopupMothership)\n        },\n        dialogs: {\n          backstage: backstages.dialog,\n          getMothership: () => getLazyMothership('dialogs', lazyDialogMothership)\n        },\n        renderUI\n      };\n    };\n\n    const get = element => element.dom.textContent;\n\n    const labelledBy = (labelledElement, labelElement) => {\n      const labelId = getOpt(labelledElement, 'id').fold(() => {\n        const id = generate$6('dialog-label');\n        set$9(labelElement, 'id', id);\n        return id;\n      }, identity);\n      set$9(labelledElement, 'aria-labelledby', labelId);\n    };\n\n    const schema$2 = constant$1([\n      required$1('lazySink'),\n      option$3('dragBlockClass'),\n      defaultedFunction('getBounds', win),\n      defaulted('useTabstopAt', always),\n      defaulted('firstTabstop', 0),\n      defaulted('eventOrder', {}),\n      field('modalBehaviours', [Keying]),\n      onKeyboardHandler('onExecute'),\n      onStrictKeyboardHandler('onEscape')\n    ]);\n    const basic = { sketch: identity };\n    const parts$2 = constant$1([\n      optional({\n        name: 'draghandle',\n        overrides: (detail, spec) => {\n          return {\n            behaviours: derive$1([Dragging.config({\n                mode: 'mouse',\n                getTarget: handle => {\n                  return ancestor(handle, '[role=\"dialog\"]').getOr(handle);\n                },\n                blockerClass: detail.dragBlockClass.getOrDie(new Error('The drag blocker class was not specified for a dialog with a drag handle: \\n' + JSON.stringify(spec, null, 2)).message),\n                getBounds: detail.getDragBounds\n              })])\n          };\n        }\n      }),\n      required({\n        schema: [required$1('dom')],\n        name: 'title'\n      }),\n      required({\n        factory: basic,\n        schema: [required$1('dom')],\n        name: 'close'\n      }),\n      required({\n        factory: basic,\n        schema: [required$1('dom')],\n        name: 'body'\n      }),\n      optional({\n        factory: basic,\n        schema: [required$1('dom')],\n        name: 'footer'\n      }),\n      external({\n        factory: {\n          sketch: (spec, detail) => ({\n            ...spec,\n            dom: detail.dom,\n            components: detail.components\n          })\n        },\n        schema: [\n          defaulted('dom', {\n            tag: 'div',\n            styles: {\n              position: 'fixed',\n              left: '0px',\n              top: '0px',\n              right: '0px',\n              bottom: '0px'\n            }\n          }),\n          defaulted('components', [])\n        ],\n        name: 'blocker'\n      })\n    ]);\n\n    const factory$4 = (detail, components, spec, externals) => {\n      const dialogComp = value$4();\n      const showDialog = dialog => {\n        dialogComp.set(dialog);\n        const sink = detail.lazySink(dialog).getOrDie();\n        const externalBlocker = externals.blocker();\n        const blocker = sink.getSystem().build({\n          ...externalBlocker,\n          components: externalBlocker.components.concat([premade(dialog)]),\n          behaviours: derive$1([\n            Focusing.config({}),\n            config('dialog-blocker-events', [runOnSource(focusin(), () => {\n                Blocking.isBlocked(dialog) ? noop() : Keying.focusIn(dialog);\n              })])\n          ])\n        });\n        attach(sink, blocker);\n        Keying.focusIn(dialog);\n      };\n      const hideDialog = dialog => {\n        dialogComp.clear();\n        parent(dialog.element).each(blockerDom => {\n          dialog.getSystem().getByDom(blockerDom).each(blocker => {\n            detach(blocker);\n          });\n        });\n      };\n      const getDialogBody = dialog => getPartOrDie(dialog, detail, 'body');\n      const getDialogFooter = dialog => getPart(dialog, detail, 'footer');\n      const setBusy = (dialog, getBusySpec) => {\n        Blocking.block(dialog, getBusySpec);\n      };\n      const setIdle = dialog => {\n        Blocking.unblock(dialog);\n      };\n      const modalEventsId = generate$6('modal-events');\n      const eventOrder = {\n        ...detail.eventOrder,\n        [attachedToDom()]: [modalEventsId].concat(detail.eventOrder['alloy.system.attached'] || [])\n      };\n      const browser = detect$1();\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components,\n        apis: {\n          show: showDialog,\n          hide: hideDialog,\n          getBody: getDialogBody,\n          getFooter: getDialogFooter,\n          setIdle,\n          setBusy\n        },\n        eventOrder,\n        domModification: {\n          attributes: {\n            'role': 'dialog',\n            'aria-modal': 'true'\n          }\n        },\n        behaviours: augment(detail.modalBehaviours, [\n          Replacing.config({}),\n          Keying.config({\n            mode: 'cyclic',\n            onEnter: detail.onExecute,\n            onEscape: detail.onEscape,\n            useTabstopAt: detail.useTabstopAt,\n            firstTabstop: detail.firstTabstop\n          }),\n          Blocking.config({ getRoot: dialogComp.get }),\n          config(modalEventsId, [runOnAttached(c => {\n              const titleElm = getPartOrDie(c, detail, 'title').element;\n              const title = get(titleElm);\n              if (browser.os.isMacOS() && isNonNullable(title)) {\n                set$9(c.element, 'aria-label', title);\n              } else {\n                labelledBy(c.element, titleElm);\n              }\n            })])\n        ])\n      };\n    };\n    const ModalDialog = composite({\n      name: 'ModalDialog',\n      configFields: schema$2(),\n      partFields: parts$2(),\n      factory: factory$4,\n      apis: {\n        show: (apis, dialog) => {\n          apis.show(dialog);\n        },\n        hide: (apis, dialog) => {\n          apis.hide(dialog);\n        },\n        getBody: (apis, dialog) => apis.getBody(dialog),\n        getFooter: (apis, dialog) => apis.getFooter(dialog),\n        setBusy: (apis, dialog, getBusySpec) => {\n          apis.setBusy(dialog, getBusySpec);\n        },\n        setIdle: (apis, dialog) => {\n          apis.setIdle(dialog);\n        }\n      }\n    });\n\n    const dialogToggleMenuItemSchema = objOf([\n      type,\n      name$1\n    ].concat(commonMenuItemFields));\n    const dialogToggleMenuItemDataProcessor = boolean;\n\n    const baseFooterButtonFields = [\n      generatedName('button'),\n      optionalIcon,\n      defaultedStringEnum('align', 'end', [\n        'start',\n        'end'\n      ]),\n      primary,\n      enabled,\n      optionStringEnum('buttonType', [\n        'primary',\n        'secondary'\n      ])\n    ];\n    const dialogFooterButtonFields = [\n      ...baseFooterButtonFields,\n      text\n    ];\n    const normalFooterButtonFields = [\n      requiredStringEnum('type', [\n        'submit',\n        'cancel',\n        'custom'\n      ]),\n      ...dialogFooterButtonFields\n    ];\n    const menuFooterButtonFields = [\n      requiredStringEnum('type', ['menu']),\n      optionalText,\n      optionalTooltip,\n      optionalIcon,\n      requiredArrayOf('items', dialogToggleMenuItemSchema),\n      ...baseFooterButtonFields\n    ];\n    const toggleButtonSpecFields = [\n      ...baseFooterButtonFields,\n      requiredStringEnum('type', ['togglebutton']),\n      optionalTooltip,\n      optionalIcon,\n      optionalText,\n      defaultedBoolean('active', false)\n    ];\n    const dialogFooterButtonSchema = choose$1('type', {\n      submit: normalFooterButtonFields,\n      cancel: normalFooterButtonFields,\n      custom: normalFooterButtonFields,\n      menu: menuFooterButtonFields,\n      togglebutton: toggleButtonSpecFields\n    });\n\n    const alertBannerFields = [\n      type,\n      text,\n      requiredStringEnum('level', [\n        'info',\n        'warn',\n        'error',\n        'success'\n      ]),\n      icon,\n      defaulted('url', '')\n    ];\n    const alertBannerSchema = objOf(alertBannerFields);\n\n    const createBarFields = itemsField => [\n      type,\n      itemsField\n    ];\n\n    const buttonFields = [\n      type,\n      text,\n      enabled,\n      generatedName('button'),\n      optionalIcon,\n      borderless,\n      optionStringEnum('buttonType', [\n        'primary',\n        'secondary',\n        'toolbar'\n      ]),\n      primary\n    ];\n    const buttonSchema = objOf(buttonFields);\n\n    const formComponentFields = [\n      type,\n      name$1\n    ];\n    const formComponentWithLabelFields = formComponentFields.concat([optionalLabel]);\n\n    const checkboxFields = formComponentFields.concat([\n      label,\n      enabled\n    ]);\n    const checkboxSchema = objOf(checkboxFields);\n    const checkboxDataProcessor = boolean;\n\n    const collectionFields = formComponentWithLabelFields.concat([defaultedColumns('auto')]);\n    const collectionSchema = objOf(collectionFields);\n    const collectionDataProcessor = arrOfObj([\n      value$1,\n      text,\n      icon\n    ]);\n\n    const colorInputFields = formComponentWithLabelFields.concat([defaultedString('storageKey', 'default')]);\n    const colorInputSchema = objOf(colorInputFields);\n    const colorInputDataProcessor = string;\n\n    const colorPickerFields = formComponentWithLabelFields;\n    const colorPickerSchema = objOf(colorPickerFields);\n    const colorPickerDataProcessor = string;\n\n    const customEditorFields = formComponentFields.concat([\n      defaultedString('tag', 'textarea'),\n      requiredString('scriptId'),\n      requiredString('scriptUrl'),\n      optionFunction('onFocus'),\n      defaultedPostMsg('settings', undefined)\n    ]);\n    const customEditorFieldsOld = formComponentFields.concat([\n      defaultedString('tag', 'textarea'),\n      requiredFunction('init')\n    ]);\n    const customEditorSchema = valueOf(v => asRaw('customeditor.old', objOfOnly(customEditorFieldsOld), v).orThunk(() => asRaw('customeditor.new', objOfOnly(customEditorFields), v)));\n    const customEditorDataProcessor = string;\n\n    const dropZoneFields = formComponentWithLabelFields;\n    const dropZoneSchema = objOf(dropZoneFields);\n    const dropZoneDataProcessor = arrOfVal();\n\n    const createGridFields = itemsField => [\n      type,\n      requiredNumber('columns'),\n      itemsField\n    ];\n\n    const htmlPanelFields = [\n      type,\n      requiredString('html'),\n      defaultedStringEnum('presets', 'presentation', [\n        'presentation',\n        'document'\n      ]),\n      defaultedFunction('onInit', noop),\n      defaultedBoolean('stretched', false)\n    ];\n    const htmlPanelSchema = objOf(htmlPanelFields);\n\n    const iframeFields = formComponentWithLabelFields.concat([\n      defaultedBoolean('border', false),\n      defaultedBoolean('sandboxed', true),\n      defaultedBoolean('streamContent', false),\n      defaultedBoolean('transparent', true)\n    ]);\n    const iframeSchema = objOf(iframeFields);\n    const iframeDataProcessor = string;\n\n    const imagePreviewSchema = objOf(formComponentFields.concat([optionString('height')]));\n    const imagePreviewDataProcessor = objOf([\n      requiredString('url'),\n      optionNumber('zoom'),\n      optionNumber('cachedWidth'),\n      optionNumber('cachedHeight')\n    ]);\n\n    const inputFields = formComponentWithLabelFields.concat([\n      optionString('inputMode'),\n      optionString('placeholder'),\n      defaultedBoolean('maximized', false),\n      enabled\n    ]);\n    const inputSchema = objOf(inputFields);\n    const inputDataProcessor = string;\n\n    const createLabelFields = itemsField => [\n      type,\n      label,\n      itemsField,\n      defaultedStringEnum('align', 'start', [\n        'start',\n        'center',\n        'end'\n      ]),\n      optionString('for')\n    ];\n\n    const listBoxSingleItemFields = [\n      text,\n      value$1\n    ];\n    const listBoxNestedItemFields = [\n      text,\n      requiredArrayOf('items', thunkOf('items', () => listBoxItemSchema))\n    ];\n    const listBoxItemSchema = oneOf([\n      objOf(listBoxSingleItemFields),\n      objOf(listBoxNestedItemFields)\n    ]);\n    const listBoxFields = formComponentWithLabelFields.concat([\n      requiredArrayOf('items', listBoxItemSchema),\n      enabled\n    ]);\n    const listBoxSchema = objOf(listBoxFields);\n    const listBoxDataProcessor = string;\n\n    const selectBoxFields = formComponentWithLabelFields.concat([\n      requiredArrayOfObj('items', [\n        text,\n        value$1\n      ]),\n      defaultedNumber('size', 1),\n      enabled\n    ]);\n    const selectBoxSchema = objOf(selectBoxFields);\n    const selectBoxDataProcessor = string;\n\n    const sizeInputFields = formComponentWithLabelFields.concat([\n      defaultedBoolean('constrain', true),\n      enabled\n    ]);\n    const sizeInputSchema = objOf(sizeInputFields);\n    const sizeInputDataProcessor = objOf([\n      requiredString('width'),\n      requiredString('height')\n    ]);\n\n    const sliderFields = formComponentFields.concat([\n      label,\n      defaultedNumber('min', 0),\n      defaultedNumber('max', 0)\n    ]);\n    const sliderSchema = objOf(sliderFields);\n    const sliderInputDataProcessor = number;\n\n    const tableFields = [\n      type,\n      requiredArrayOf('header', string),\n      requiredArrayOf('cells', arrOf(string))\n    ];\n    const tableSchema = objOf(tableFields);\n\n    const textAreaFields = formComponentWithLabelFields.concat([\n      optionString('placeholder'),\n      defaultedBoolean('maximized', false),\n      enabled\n    ]);\n    const textAreaSchema = objOf(textAreaFields);\n    const textAreaDataProcessor = string;\n\n    const baseTreeItemFields = [\n      requiredStringEnum('type', [\n        'directory',\n        'leaf'\n      ]),\n      title,\n      requiredString('id'),\n      optionOf('menu', MenuButtonSchema)\n    ];\n    const treeItemLeafFields = baseTreeItemFields;\n    const treeItemLeafSchema = objOf(treeItemLeafFields);\n    const treeItemDirectoryFields = baseTreeItemFields.concat([requiredArrayOf('children', thunkOf('children', () => {\n        return choose$2('type', {\n          directory: treeItemDirectorySchema,\n          leaf: treeItemLeafSchema\n        });\n      }))]);\n    const treeItemDirectorySchema = objOf(treeItemDirectoryFields);\n    const treeItemSchema = choose$2('type', {\n      directory: treeItemDirectorySchema,\n      leaf: treeItemLeafSchema\n    });\n    const treeFields = [\n      type,\n      requiredArrayOf('items', treeItemSchema),\n      optionFunction('onLeafAction'),\n      optionFunction('onToggleExpand'),\n      defaultedArrayOf('defaultExpandedIds', [], string),\n      optionString('defaultSelectedId')\n    ];\n    const treeSchema = objOf(treeFields);\n\n    const urlInputFields = formComponentWithLabelFields.concat([\n      defaultedStringEnum('filetype', 'file', [\n        'image',\n        'media',\n        'file'\n      ]),\n      enabled,\n      optionString('picker_text')\n    ]);\n    const urlInputSchema = objOf(urlInputFields);\n    const urlInputDataProcessor = objOf([\n      value$1,\n      defaultedMeta\n    ]);\n\n    const createItemsField = name => field$1('items', 'items', required$2(), arrOf(valueOf(v => asRaw(`Checking item of ${ name }`, itemSchema, v).fold(sErr => Result.error(formatError(sErr)), passValue => Result.value(passValue)))));\n    const itemSchema = valueThunk(() => choose$2('type', {\n      alertbanner: alertBannerSchema,\n      bar: objOf(createBarFields(createItemsField('bar'))),\n      button: buttonSchema,\n      checkbox: checkboxSchema,\n      colorinput: colorInputSchema,\n      colorpicker: colorPickerSchema,\n      dropzone: dropZoneSchema,\n      grid: objOf(createGridFields(createItemsField('grid'))),\n      iframe: iframeSchema,\n      input: inputSchema,\n      listbox: listBoxSchema,\n      selectbox: selectBoxSchema,\n      sizeinput: sizeInputSchema,\n      slider: sliderSchema,\n      textarea: textAreaSchema,\n      urlinput: urlInputSchema,\n      customeditor: customEditorSchema,\n      htmlpanel: htmlPanelSchema,\n      imagepreview: imagePreviewSchema,\n      collection: collectionSchema,\n      label: objOf(createLabelFields(createItemsField('label'))),\n      table: tableSchema,\n      tree: treeSchema,\n      panel: panelSchema\n    }));\n    const panelFields = [\n      type,\n      defaulted('classes', []),\n      requiredArrayOf('items', itemSchema)\n    ];\n    const panelSchema = objOf(panelFields);\n\n    const tabFields = [\n      generatedName('tab'),\n      title,\n      requiredArrayOf('items', itemSchema)\n    ];\n    const tabPanelFields = [\n      type,\n      requiredArrayOfObj('tabs', tabFields)\n    ];\n    const tabPanelSchema = objOf(tabPanelFields);\n\n    const dialogButtonFields = dialogFooterButtonFields;\n    const dialogButtonSchema = dialogFooterButtonSchema;\n    const dialogSchema = objOf([\n      requiredString('title'),\n      requiredOf('body', choose$2('type', {\n        panel: panelSchema,\n        tabpanel: tabPanelSchema\n      })),\n      defaultedString('size', 'normal'),\n      defaultedArrayOf('buttons', [], dialogButtonSchema),\n      defaulted('initialData', {}),\n      defaultedFunction('onAction', noop),\n      defaultedFunction('onChange', noop),\n      defaultedFunction('onSubmit', noop),\n      defaultedFunction('onClose', noop),\n      defaultedFunction('onCancel', noop),\n      defaultedFunction('onTabChange', noop)\n    ]);\n    const createDialog = spec => asRaw('dialog', dialogSchema, spec);\n\n    const urlDialogButtonSchema = objOf([\n      requiredStringEnum('type', [\n        'cancel',\n        'custom'\n      ]),\n      ...dialogButtonFields\n    ]);\n    const urlDialogSchema = objOf([\n      requiredString('title'),\n      requiredString('url'),\n      optionNumber('height'),\n      optionNumber('width'),\n      optionArrayOf('buttons', urlDialogButtonSchema),\n      defaultedFunction('onAction', noop),\n      defaultedFunction('onCancel', noop),\n      defaultedFunction('onClose', noop),\n      defaultedFunction('onMessage', noop)\n    ]);\n    const createUrlDialog = spec => asRaw('dialog', urlDialogSchema, spec);\n\n    const getAllObjects = obj => {\n      if (isObject(obj)) {\n        return [obj].concat(bind$3(values(obj), getAllObjects));\n      } else if (isArray(obj)) {\n        return bind$3(obj, getAllObjects);\n      } else {\n        return [];\n      }\n    };\n\n    const isNamedItem = obj => isString(obj.type) && isString(obj.name);\n    const dataProcessors = {\n      checkbox: checkboxDataProcessor,\n      colorinput: colorInputDataProcessor,\n      colorpicker: colorPickerDataProcessor,\n      dropzone: dropZoneDataProcessor,\n      input: inputDataProcessor,\n      iframe: iframeDataProcessor,\n      imagepreview: imagePreviewDataProcessor,\n      selectbox: selectBoxDataProcessor,\n      sizeinput: sizeInputDataProcessor,\n      slider: sliderInputDataProcessor,\n      listbox: listBoxDataProcessor,\n      size: sizeInputDataProcessor,\n      textarea: textAreaDataProcessor,\n      urlinput: urlInputDataProcessor,\n      customeditor: customEditorDataProcessor,\n      collection: collectionDataProcessor,\n      togglemenuitem: dialogToggleMenuItemDataProcessor\n    };\n    const getDataProcessor = item => Optional.from(dataProcessors[item.type]);\n    const getNamedItems = structure => filter$2(getAllObjects(structure), isNamedItem);\n\n    const createDataValidator = structure => {\n      const namedItems = getNamedItems(structure);\n      const fields = bind$3(namedItems, item => getDataProcessor(item).fold(() => [], schema => [requiredOf(item.name, schema)]));\n      return objOf(fields);\n    };\n\n    const extract = structure => {\n      var _a;\n      const internalDialog = getOrDie(createDialog(structure));\n      const dataValidator = createDataValidator(structure);\n      const initialData = (_a = structure.initialData) !== null && _a !== void 0 ? _a : {};\n      return {\n        internalDialog,\n        dataValidator,\n        initialData\n      };\n    };\n    const DialogManager = {\n      open: (factory, structure) => {\n        const extraction = extract(structure);\n        return factory(extraction.internalDialog, extraction.initialData, extraction.dataValidator);\n      },\n      openUrl: (factory, structure) => {\n        const internalDialog = getOrDie(createUrlDialog(structure));\n        return factory(internalDialog);\n      },\n      redial: structure => extract(structure)\n    };\n\n    const events = (reflectingConfig, reflectingState) => {\n      const update = (component, data) => {\n        reflectingConfig.updateState.each(updateState => {\n          const newState = updateState(component, data);\n          reflectingState.set(newState);\n        });\n        reflectingConfig.renderComponents.each(renderComponents => {\n          const newComponents = renderComponents(data, reflectingState.get());\n          const replacer = reflectingConfig.reuseDom ? withReuse : withoutReuse;\n          replacer(component, newComponents);\n        });\n      };\n      return derive$2([\n        run$1(receive(), (component, message) => {\n          const receivingData = message;\n          if (!receivingData.universal) {\n            const channel = reflectingConfig.channel;\n            if (contains$2(receivingData.channels, channel)) {\n              update(component, receivingData.data);\n            }\n          }\n        }),\n        runOnAttached((comp, _se) => {\n          reflectingConfig.initialData.each(rawData => {\n            update(comp, rawData);\n          });\n        })\n      ]);\n    };\n\n    var ActiveReflecting = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        events: events\n    });\n\n    const getState = (component, replaceConfig, reflectState) => reflectState;\n\n    var ReflectingApis = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        getState: getState\n    });\n\n    var ReflectingSchema = [\n      required$1('channel'),\n      option$3('renderComponents'),\n      option$3('updateState'),\n      option$3('initialData'),\n      defaultedBoolean('reuseDom', true)\n    ];\n\n    const init = () => {\n      const cell = Cell(Optional.none());\n      const clear = () => cell.set(Optional.none());\n      const readState = () => cell.get().getOr('none');\n      return {\n        readState,\n        get: cell.get,\n        set: cell.set,\n        clear\n      };\n    };\n\n    var ReflectingState = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        init: init\n    });\n\n    const Reflecting = create$4({\n      fields: ReflectingSchema,\n      name: 'reflecting',\n      active: ActiveReflecting,\n      apis: ReflectingApis,\n      state: ReflectingState\n    });\n\n    const toValidValues = values => {\n      const errors = [];\n      const result = {};\n      each(values, (value, name) => {\n        value.fold(() => {\n          errors.push(name);\n        }, v => {\n          result[name] = v;\n        });\n      });\n      return errors.length > 0 ? Result.error(errors) : Result.value(result);\n    };\n\n    const renderBodyPanel = (spec, dialogData, backstage, getCompByName) => {\n      const memForm = record(Form.sketch(parts => ({\n        dom: {\n          tag: 'div',\n          classes: ['tox-form'].concat(spec.classes)\n        },\n        components: map$2(spec.items, item => interpretInForm(parts, item, dialogData, backstage, getCompByName))\n      })));\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-dialog__body']\n        },\n        components: [{\n            dom: {\n              tag: 'div',\n              classes: ['tox-dialog__body-content']\n            },\n            components: [memForm.asSpec()]\n          }],\n        behaviours: derive$1([\n          Keying.config({\n            mode: 'acyclic',\n            useTabstopAt: not(isPseudoStop)\n          }),\n          ComposingConfigs.memento(memForm),\n          memento(memForm, {\n            postprocess: formValue => toValidValues(formValue).fold(err => {\n              console.error(err);\n              return {};\n            }, identity)\n          }),\n          config('dialog-body-panel', [run$1(focusin(), (comp, se) => {\n              comp.getSystem().broadcastOn([dialogFocusShiftedChannel], { newFocus: Optional.some(se.event.target) });\n            })])\n        ])\n      };\n    };\n\n    const factory$3 = (detail, _spec) => ({\n      uid: detail.uid,\n      dom: detail.dom,\n      components: detail.components,\n      events: events$9(detail.action),\n      behaviours: augment(detail.tabButtonBehaviours, [\n        Focusing.config({}),\n        Keying.config({\n          mode: 'execution',\n          useSpace: true,\n          useEnter: true\n        }),\n        Representing.config({\n          store: {\n            mode: 'memory',\n            initialValue: detail.value\n          }\n        })\n      ]),\n      domModification: detail.domModification\n    });\n    const TabButton = single({\n      name: 'TabButton',\n      configFields: [\n        defaulted('uid', undefined),\n        required$1('value'),\n        field$1('dom', 'dom', mergeWithThunk(() => ({\n          attributes: {\n            'role': 'tab',\n            'id': generate$6('aria'),\n            'aria-selected': 'false'\n          }\n        })), anyValue()),\n        option$3('action'),\n        defaulted('domModification', {}),\n        field('tabButtonBehaviours', [\n          Focusing,\n          Keying,\n          Representing\n        ]),\n        required$1('view')\n      ],\n      factory: factory$3\n    });\n\n    const schema$1 = constant$1([\n      required$1('tabs'),\n      required$1('dom'),\n      defaulted('clickToDismiss', false),\n      field('tabbarBehaviours', [\n        Highlighting,\n        Keying\n      ]),\n      markers$1([\n        'tabClass',\n        'selectedClass'\n      ])\n    ]);\n    const tabsPart = group({\n      factory: TabButton,\n      name: 'tabs',\n      unit: 'tab',\n      overrides: barDetail => {\n        const dismissTab$1 = (tabbar, button) => {\n          Highlighting.dehighlight(tabbar, button);\n          emitWith(tabbar, dismissTab(), {\n            tabbar,\n            button\n          });\n        };\n        const changeTab$1 = (tabbar, button) => {\n          Highlighting.highlight(tabbar, button);\n          emitWith(tabbar, changeTab(), {\n            tabbar,\n            button\n          });\n        };\n        return {\n          action: button => {\n            const tabbar = button.getSystem().getByUid(barDetail.uid).getOrDie();\n            const activeButton = Highlighting.isHighlighted(tabbar, button);\n            const response = (() => {\n              if (activeButton && barDetail.clickToDismiss) {\n                return dismissTab$1;\n              } else if (!activeButton) {\n                return changeTab$1;\n              } else {\n                return noop;\n              }\n            })();\n            response(tabbar, button);\n          },\n          domModification: { classes: [barDetail.markers.tabClass] }\n        };\n      }\n    });\n    const parts$1 = constant$1([tabsPart]);\n\n    const factory$2 = (detail, components, _spec, _externals) => ({\n      'uid': detail.uid,\n      'dom': detail.dom,\n      components,\n      'debug.sketcher': 'Tabbar',\n      'domModification': { attributes: { role: 'tablist' } },\n      'behaviours': augment(detail.tabbarBehaviours, [\n        Highlighting.config({\n          highlightClass: detail.markers.selectedClass,\n          itemClass: detail.markers.tabClass,\n          onHighlight: (tabbar, tab) => {\n            set$9(tab.element, 'aria-selected', 'true');\n          },\n          onDehighlight: (tabbar, tab) => {\n            set$9(tab.element, 'aria-selected', 'false');\n          }\n        }),\n        Keying.config({\n          mode: 'flow',\n          getInitial: tabbar => {\n            return Highlighting.getHighlighted(tabbar).map(tab => tab.element);\n          },\n          selector: '.' + detail.markers.tabClass,\n          executeOnMove: true\n        })\n      ])\n    });\n    const Tabbar = composite({\n      name: 'Tabbar',\n      configFields: schema$1(),\n      partFields: parts$1(),\n      factory: factory$2\n    });\n\n    const factory$1 = (detail, _spec) => ({\n      uid: detail.uid,\n      dom: detail.dom,\n      behaviours: augment(detail.tabviewBehaviours, [Replacing.config({})]),\n      domModification: { attributes: { role: 'tabpanel' } }\n    });\n    const Tabview = single({\n      name: 'Tabview',\n      configFields: [field('tabviewBehaviours', [Replacing])],\n      factory: factory$1\n    });\n\n    const schema = constant$1([\n      defaulted('selectFirst', true),\n      onHandler('onChangeTab'),\n      onHandler('onDismissTab'),\n      defaulted('tabs', []),\n      field('tabSectionBehaviours', [])\n    ]);\n    const barPart = required({\n      factory: Tabbar,\n      schema: [\n        required$1('dom'),\n        requiredObjOf('markers', [\n          required$1('tabClass'),\n          required$1('selectedClass')\n        ])\n      ],\n      name: 'tabbar',\n      defaults: detail => {\n        return { tabs: detail.tabs };\n      }\n    });\n    const viewPart = required({\n      factory: Tabview,\n      name: 'tabview'\n    });\n    const parts = constant$1([\n      barPart,\n      viewPart\n    ]);\n\n    const factory = (detail, components, _spec, _externals) => {\n      const changeTab$1 = button => {\n        const tabValue = Representing.getValue(button);\n        getPart(button, detail, 'tabview').each(tabview => {\n          const tabWithValue = find$5(detail.tabs, t => t.value === tabValue);\n          tabWithValue.each(tabData => {\n            const panel = tabData.view();\n            getOpt(button.element, 'id').each(id => {\n              set$9(tabview.element, 'aria-labelledby', id);\n            });\n            Replacing.set(tabview, panel);\n            detail.onChangeTab(tabview, button, panel);\n          });\n        });\n      };\n      const changeTabBy = (section, byPred) => {\n        getPart(section, detail, 'tabbar').each(tabbar => {\n          byPred(tabbar).each(emitExecute);\n        });\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components,\n        behaviours: get$4(detail.tabSectionBehaviours),\n        events: derive$2(flatten([\n          detail.selectFirst ? [runOnAttached((section, _simulatedEvent) => {\n              changeTabBy(section, Highlighting.getFirst);\n            })] : [],\n          [\n            run$1(changeTab(), (section, simulatedEvent) => {\n              const button = simulatedEvent.event.button;\n              changeTab$1(button);\n            }),\n            run$1(dismissTab(), (section, simulatedEvent) => {\n              const button = simulatedEvent.event.button;\n              detail.onDismissTab(section, button);\n            })\n          ]\n        ])),\n        apis: {\n          getViewItems: section => {\n            return getPart(section, detail, 'tabview').map(tabview => Replacing.contents(tabview)).getOr([]);\n          },\n          showTab: (section, tabKey) => {\n            const getTabIfNotActive = tabbar => {\n              const candidates = Highlighting.getCandidates(tabbar);\n              const optTab = find$5(candidates, c => Representing.getValue(c) === tabKey);\n              return optTab.filter(tab => !Highlighting.isHighlighted(tabbar, tab));\n            };\n            changeTabBy(section, getTabIfNotActive);\n          }\n        }\n      };\n    };\n    const TabSection = composite({\n      name: 'TabSection',\n      configFields: schema(),\n      partFields: parts(),\n      factory,\n      apis: {\n        getViewItems: (apis, component) => apis.getViewItems(component),\n        showTab: (apis, component, tabKey) => {\n          apis.showTab(component, tabKey);\n        }\n      }\n    });\n\n    const measureHeights = (allTabs, tabview, tabviewComp) => map$2(allTabs, (_tab, i) => {\n      Replacing.set(tabviewComp, allTabs[i].view());\n      const rect = tabview.dom.getBoundingClientRect();\n      Replacing.set(tabviewComp, []);\n      return rect.height;\n    });\n    const getMaxHeight = heights => head(sort(heights, (a, b) => {\n      if (a > b) {\n        return -1;\n      } else if (a < b) {\n        return +1;\n      } else {\n        return 0;\n      }\n    }));\n    const getMaxTabviewHeight = (dialog, tabview, tablist) => {\n      const documentElement$1 = documentElement(dialog).dom;\n      const rootElm = ancestor(dialog, '.tox-dialog-wrap').getOr(dialog);\n      const isFixed = get$f(rootElm, 'position') === 'fixed';\n      let maxHeight;\n      if (isFixed) {\n        maxHeight = Math.max(documentElement$1.clientHeight, window.innerHeight);\n      } else {\n        maxHeight = Math.max(documentElement$1.offsetHeight, documentElement$1.scrollHeight);\n      }\n      const tabviewHeight = get$e(tabview);\n      const isTabListBeside = tabview.dom.offsetLeft >= tablist.dom.offsetLeft + get$d(tablist);\n      const currentTabHeight = isTabListBeside ? Math.max(get$e(tablist), tabviewHeight) : tabviewHeight;\n      const dialogTopMargin = parseInt(get$f(dialog, 'margin-top'), 10) || 0;\n      const dialogBottomMargin = parseInt(get$f(dialog, 'margin-bottom'), 10) || 0;\n      const dialogHeight = get$e(dialog) + dialogTopMargin + dialogBottomMargin;\n      const chromeHeight = dialogHeight - currentTabHeight;\n      return maxHeight - chromeHeight;\n    };\n    const showTab = (allTabs, comp) => {\n      head(allTabs).each(tab => TabSection.showTab(comp, tab.value));\n    };\n    const setTabviewHeight = (tabview, height) => {\n      set$8(tabview, 'height', height + 'px');\n      set$8(tabview, 'flex-basis', height + 'px');\n    };\n    const updateTabviewHeight = (dialogBody, tabview, maxTabHeight) => {\n      ancestor(dialogBody, '[role=\"dialog\"]').each(dialog => {\n        descendant(dialog, '[role=\"tablist\"]').each(tablist => {\n          maxTabHeight.get().map(height => {\n            set$8(tabview, 'height', '0');\n            set$8(tabview, 'flex-basis', '0');\n            return Math.min(height, getMaxTabviewHeight(dialog, tabview, tablist));\n          }).each(height => {\n            setTabviewHeight(tabview, height);\n          });\n        });\n      });\n    };\n    const getTabview = dialog => descendant(dialog, '[role=\"tabpanel\"]');\n    const smartMode = allTabs => {\n      const maxTabHeight = value$4();\n      const extraEvents = [\n        runOnAttached(comp => {\n          const dialog = comp.element;\n          getTabview(dialog).each(tabview => {\n            set$8(tabview, 'visibility', 'hidden');\n            comp.getSystem().getByDom(tabview).toOptional().each(tabviewComp => {\n              const heights = measureHeights(allTabs, tabview, tabviewComp);\n              const maxTabHeightOpt = getMaxHeight(heights);\n              maxTabHeightOpt.fold(maxTabHeight.clear, maxTabHeight.set);\n            });\n            updateTabviewHeight(dialog, tabview, maxTabHeight);\n            remove$7(tabview, 'visibility');\n            showTab(allTabs, comp);\n            requestAnimationFrame(() => {\n              updateTabviewHeight(dialog, tabview, maxTabHeight);\n            });\n          });\n        }),\n        run$1(windowResize(), comp => {\n          const dialog = comp.element;\n          getTabview(dialog).each(tabview => {\n            updateTabviewHeight(dialog, tabview, maxTabHeight);\n          });\n        }),\n        run$1(formResizeEvent, (comp, _se) => {\n          const dialog = comp.element;\n          getTabview(dialog).each(tabview => {\n            const oldFocus = active$1(getRootNode(tabview));\n            set$8(tabview, 'visibility', 'hidden');\n            const oldHeight = getRaw(tabview, 'height').map(h => parseInt(h, 10));\n            remove$7(tabview, 'height');\n            remove$7(tabview, 'flex-basis');\n            const newHeight = tabview.dom.getBoundingClientRect().height;\n            const hasGrown = oldHeight.forall(h => newHeight > h);\n            if (hasGrown) {\n              maxTabHeight.set(newHeight);\n              updateTabviewHeight(dialog, tabview, maxTabHeight);\n            } else {\n              oldHeight.each(h => {\n                setTabviewHeight(tabview, h);\n              });\n            }\n            remove$7(tabview, 'visibility');\n            oldFocus.each(focus$3);\n          });\n        })\n      ];\n      const selectFirst = false;\n      return {\n        extraEvents,\n        selectFirst\n      };\n    };\n\n    const SendDataToSectionChannel = 'send-data-to-section';\n    const SendDataToViewChannel = 'send-data-to-view';\n    const renderTabPanel = (spec, dialogData, backstage, getCompByName) => {\n      const storedValue = Cell({});\n      const updateDataWithForm = form => {\n        const formData = Representing.getValue(form);\n        const validData = toValidValues(formData).getOr({});\n        const currentData = storedValue.get();\n        const newData = deepMerge(currentData, validData);\n        storedValue.set(newData);\n      };\n      const setDataOnForm = form => {\n        const tabData = storedValue.get();\n        Representing.setValue(form, tabData);\n      };\n      const oldTab = Cell(null);\n      const allTabs = map$2(spec.tabs, tab => {\n        return {\n          value: tab.name,\n          dom: {\n            tag: 'div',\n            classes: ['tox-dialog__body-nav-item']\n          },\n          components: [text$2(backstage.shared.providers.translate(tab.title))],\n          view: () => {\n            return [Form.sketch(parts => ({\n                dom: {\n                  tag: 'div',\n                  classes: ['tox-form']\n                },\n                components: map$2(tab.items, item => interpretInForm(parts, item, dialogData, backstage, getCompByName)),\n                formBehaviours: derive$1([\n                  Keying.config({\n                    mode: 'acyclic',\n                    useTabstopAt: not(isPseudoStop)\n                  }),\n                  config('TabView.form.events', [\n                    runOnAttached(setDataOnForm),\n                    runOnDetached(updateDataWithForm)\n                  ]),\n                  Receiving.config({\n                    channels: wrapAll([\n                      {\n                        key: SendDataToSectionChannel,\n                        value: { onReceive: updateDataWithForm }\n                      },\n                      {\n                        key: SendDataToViewChannel,\n                        value: { onReceive: setDataOnForm }\n                      }\n                    ])\n                  })\n                ])\n              }))];\n          }\n        };\n      });\n      const tabMode = smartMode(allTabs);\n      return TabSection.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-dialog__body']\n        },\n        onChangeTab: (section, button, _viewItems) => {\n          const name = Representing.getValue(button);\n          emitWith(section, formTabChangeEvent, {\n            name,\n            oldName: oldTab.get()\n          });\n          oldTab.set(name);\n        },\n        tabs: allTabs,\n        components: [\n          TabSection.parts.tabbar({\n            dom: {\n              tag: 'div',\n              classes: ['tox-dialog__body-nav']\n            },\n            components: [Tabbar.parts.tabs({})],\n            markers: {\n              tabClass: 'tox-tab',\n              selectedClass: 'tox-dialog__body-nav-item--active'\n            },\n            tabbarBehaviours: derive$1([Tabstopping.config({})])\n          }),\n          TabSection.parts.tabview({\n            dom: {\n              tag: 'div',\n              classes: ['tox-dialog__body-content']\n            }\n          })\n        ],\n        selectFirst: tabMode.selectFirst,\n        tabSectionBehaviours: derive$1([\n          config('tabpanel', tabMode.extraEvents),\n          Keying.config({ mode: 'acyclic' }),\n          Composing.config({ find: comp => head(TabSection.getViewItems(comp)) }),\n          withComp(Optional.none(), tsection => {\n            tsection.getSystem().broadcastOn([SendDataToSectionChannel], {});\n            return storedValue.get();\n          }, (tsection, value) => {\n            storedValue.set(value);\n            tsection.getSystem().broadcastOn([SendDataToViewChannel], {});\n          })\n        ])\n      });\n    };\n\n    const renderBody = (spec, dialogId, contentId, backstage, ariaAttrs, getCompByName) => {\n      const renderComponents = incoming => {\n        const body = incoming.body;\n        switch (body.type) {\n        case 'tabpanel': {\n            return [renderTabPanel(body, incoming.initialData, backstage, getCompByName)];\n          }\n        default: {\n            return [renderBodyPanel(body, incoming.initialData, backstage, getCompByName)];\n          }\n        }\n      };\n      const updateState = (_comp, incoming) => Optional.some({ isTabPanel: () => incoming.body.type === 'tabpanel' });\n      const ariaAttributes = { 'aria-live': 'polite' };\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-dialog__content-js'],\n          attributes: {\n            ...contentId.map(x => ({ id: x })).getOr({}),\n            ...ariaAttrs ? ariaAttributes : {}\n          }\n        },\n        components: [],\n        behaviours: derive$1([\n          ComposingConfigs.childAt(0),\n          Reflecting.config({\n            channel: `${ bodyChannel }-${ dialogId }`,\n            updateState,\n            renderComponents,\n            initialData: spec\n          })\n        ])\n      };\n    };\n    const renderInlineBody = (spec, dialogId, contentId, backstage, ariaAttrs, getCompByName) => renderBody(spec, dialogId, Optional.some(contentId), backstage, ariaAttrs, getCompByName);\n    const renderModalBody = (spec, dialogId, backstage, getCompByName) => {\n      const bodySpec = renderBody(spec, dialogId, Optional.none(), backstage, false, getCompByName);\n      return ModalDialog.parts.body(bodySpec);\n    };\n    const renderIframeBody = spec => {\n      const bodySpec = {\n        dom: {\n          tag: 'div',\n          classes: ['tox-dialog__content-js']\n        },\n        components: [{\n            dom: {\n              tag: 'div',\n              classes: ['tox-dialog__body-iframe']\n            },\n            components: [craft(Optional.none(), {\n                dom: {\n                  tag: 'iframe',\n                  attributes: { src: spec.url }\n                },\n                behaviours: derive$1([\n                  Tabstopping.config({}),\n                  Focusing.config({})\n                ])\n              })]\n          }],\n        behaviours: derive$1([Keying.config({\n            mode: 'acyclic',\n            useTabstopAt: not(isPseudoStop)\n          })])\n      };\n      return ModalDialog.parts.body(bodySpec);\n    };\n\n    const isTouch = global$6.deviceType.isTouch();\n    const hiddenHeader = (title, close) => ({\n      dom: {\n        tag: 'div',\n        styles: { display: 'none' },\n        classes: ['tox-dialog__header']\n      },\n      components: [\n        title,\n        close\n      ]\n    });\n    const pClose = (onClose, providersBackstage) => ModalDialog.parts.close(Button.sketch({\n      dom: {\n        tag: 'button',\n        classes: [\n          'tox-button',\n          'tox-button--icon',\n          'tox-button--naked'\n        ],\n        attributes: {\n          'type': 'button',\n          'aria-label': providersBackstage.translate('Close')\n        }\n      },\n      action: onClose,\n      buttonBehaviours: derive$1([Tabstopping.config({})])\n    }));\n    const pUntitled = () => ModalDialog.parts.title({\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__title'],\n        innerHtml: '',\n        styles: { display: 'none' }\n      }\n    });\n    const pBodyMessage = (message, providersBackstage) => ModalDialog.parts.body({\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__body']\n      },\n      components: [{\n          dom: {\n            tag: 'div',\n            classes: ['tox-dialog__body-content']\n          },\n          components: [{ dom: fromHtml(`<p>${ sanitizeHtmlString(providersBackstage.translate(message)) }</p>`) }]\n        }]\n    });\n    const pFooter = buttons => ModalDialog.parts.footer({\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__footer']\n      },\n      components: buttons\n    });\n    const pFooterGroup = (startButtons, endButtons) => [\n      Container.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-dialog__footer-start']\n        },\n        components: startButtons\n      }),\n      Container.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-dialog__footer-end']\n        },\n        components: endButtons\n      })\n    ];\n    const renderDialog$1 = spec => {\n      const dialogClass = 'tox-dialog';\n      const blockerClass = dialogClass + '-wrap';\n      const blockerBackdropClass = blockerClass + '__backdrop';\n      const scrollLockClass = dialogClass + '__disable-scroll';\n      return ModalDialog.sketch({\n        lazySink: spec.lazySink,\n        onEscape: comp => {\n          spec.onEscape(comp);\n          return Optional.some(true);\n        },\n        useTabstopAt: elem => !isPseudoStop(elem),\n        firstTabstop: spec.firstTabstop,\n        dom: {\n          tag: 'div',\n          classes: [dialogClass].concat(spec.extraClasses),\n          styles: {\n            position: 'relative',\n            ...spec.extraStyles\n          }\n        },\n        components: [\n          spec.header,\n          spec.body,\n          ...spec.footer.toArray()\n        ],\n        parts: {\n          blocker: {\n            dom: fromHtml(`<div class=\"${ blockerClass }\"></div>`),\n            components: [{\n                dom: {\n                  tag: 'div',\n                  classes: isTouch ? [\n                    blockerBackdropClass,\n                    blockerBackdropClass + '--opaque'\n                  ] : [blockerBackdropClass]\n                }\n              }]\n          }\n        },\n        dragBlockClass: blockerClass,\n        modalBehaviours: derive$1([\n          Focusing.config({}),\n          config('dialog-events', spec.dialogEvents.concat([\n            runOnSource(focusin(), (comp, _se) => {\n              Blocking.isBlocked(comp) ? noop() : Keying.focusIn(comp);\n            }),\n            run$1(focusShifted(), (comp, se) => {\n              comp.getSystem().broadcastOn([dialogFocusShiftedChannel], { newFocus: se.event.newFocus });\n            })\n          ])),\n          config('scroll-lock', [\n            runOnAttached(() => {\n              add$2(body(), scrollLockClass);\n            }),\n            runOnDetached(() => {\n              remove$3(body(), scrollLockClass);\n            })\n          ]),\n          ...spec.extraBehaviours\n        ]),\n        eventOrder: {\n          [execute$5()]: ['dialog-events'],\n          [attachedToDom()]: [\n            'scroll-lock',\n            'dialog-events',\n            'alloy.base.behaviour'\n          ],\n          [detachedFromDom()]: [\n            'alloy.base.behaviour',\n            'dialog-events',\n            'scroll-lock'\n          ],\n          ...spec.eventOrder\n        }\n      });\n    };\n\n    const renderClose = providersBackstage => Button.sketch({\n      dom: {\n        tag: 'button',\n        classes: [\n          'tox-button',\n          'tox-button--icon',\n          'tox-button--naked'\n        ],\n        attributes: {\n          'type': 'button',\n          'aria-label': providersBackstage.translate('Close'),\n          'data-mce-name': 'close'\n        }\n      },\n      buttonBehaviours: derive$1([\n        Tabstopping.config({}),\n        Tooltipping.config(providersBackstage.tooltips.getConfig({ tooltipText: providersBackstage.translate('Close') }))\n      ]),\n      components: [render$3('close', {\n          tag: 'span',\n          classes: ['tox-icon']\n        }, providersBackstage.icons)],\n      action: comp => {\n        emit(comp, formCancelEvent);\n      }\n    });\n    const renderTitle = (spec, dialogId, titleId, providersBackstage) => {\n      const renderComponents = data => [text$2(providersBackstage.translate(data.title))];\n      return {\n        dom: {\n          tag: 'h1',\n          classes: ['tox-dialog__title'],\n          attributes: { ...titleId.map(x => ({ id: x })).getOr({}) }\n        },\n        components: [],\n        behaviours: derive$1([Reflecting.config({\n            channel: `${ titleChannel }-${ dialogId }`,\n            initialData: spec,\n            renderComponents\n          })])\n      };\n    };\n    const renderDragHandle = () => ({ dom: fromHtml('<div class=\"tox-dialog__draghandle\"></div>') });\n    const renderInlineHeader = (spec, dialogId, titleId, providersBackstage) => Container.sketch({\n      dom: fromHtml('<div class=\"tox-dialog__header\"></div>'),\n      components: [\n        renderTitle(spec, dialogId, Optional.some(titleId), providersBackstage),\n        renderDragHandle(),\n        renderClose(providersBackstage)\n      ],\n      containerBehaviours: derive$1([Dragging.config({\n          mode: 'mouse',\n          blockerClass: 'blocker',\n          getTarget: handle => {\n            return closest$1(handle, '[role=\"dialog\"]').getOrDie();\n          },\n          snaps: {\n            getSnapPoints: () => [],\n            leftAttr: 'data-drag-left',\n            topAttr: 'data-drag-top'\n          }\n        })])\n    });\n    const renderModalHeader = (spec, dialogId, providersBackstage) => {\n      const pTitle = ModalDialog.parts.title(renderTitle(spec, dialogId, Optional.none(), providersBackstage));\n      const pHandle = ModalDialog.parts.draghandle(renderDragHandle());\n      const pClose = ModalDialog.parts.close(renderClose(providersBackstage));\n      const components = [pTitle].concat(spec.draggable ? [pHandle] : []).concat([pClose]);\n      return Container.sketch({\n        dom: fromHtml('<div class=\"tox-dialog__header\"></div>'),\n        components\n      });\n    };\n\n    const getHeader = (title, dialogId, backstage) => renderModalHeader({\n      title: backstage.shared.providers.translate(title),\n      draggable: backstage.dialog.isDraggableModal()\n    }, dialogId, backstage.shared.providers);\n    const getBusySpec = (message, bs, providers, headerHeight) => ({\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__busy-spinner'],\n        attributes: { 'aria-label': providers.translate(message) },\n        styles: {\n          left: '0px',\n          right: '0px',\n          bottom: '0px',\n          top: `${ headerHeight.getOr(0) }px`,\n          position: 'absolute'\n        }\n      },\n      behaviours: bs,\n      components: [{ dom: fromHtml('<div class=\"tox-spinner\"><div></div><div></div><div></div></div>') }]\n    });\n    const getEventExtras = (lazyDialog, providers, extra) => ({\n      onClose: () => extra.closeWindow(),\n      onBlock: blockEvent => {\n        const headerHeight = descendant(lazyDialog().element, '.tox-dialog__header').map(header => get$e(header));\n        ModalDialog.setBusy(lazyDialog(), (_comp, bs) => getBusySpec(blockEvent.message, bs, providers, headerHeight));\n      },\n      onUnblock: () => {\n        ModalDialog.setIdle(lazyDialog());\n      }\n    });\n    const fullscreenClass = 'tox-dialog--fullscreen';\n    const largeDialogClass = 'tox-dialog--width-lg';\n    const mediumDialogClass = 'tox-dialog--width-md';\n    const getDialogSizeClass = size => {\n      switch (size) {\n      case 'large':\n        return Optional.some(largeDialogClass);\n      case 'medium':\n        return Optional.some(mediumDialogClass);\n      default:\n        return Optional.none();\n      }\n    };\n    const updateDialogSizeClass = (size, component) => {\n      const dialogBody = SugarElement.fromDom(component.element.dom);\n      if (!has(dialogBody, fullscreenClass)) {\n        remove$2(dialogBody, [\n          largeDialogClass,\n          mediumDialogClass\n        ]);\n        getDialogSizeClass(size).each(dialogSizeClass => add$2(dialogBody, dialogSizeClass));\n      }\n    };\n    const toggleFullscreen = (comp, currentSize) => {\n      const dialogBody = SugarElement.fromDom(comp.element.dom);\n      const classes = get$9(dialogBody);\n      const currentSizeClass = find$5(classes, c => c === largeDialogClass || c === mediumDialogClass).or(getDialogSizeClass(currentSize));\n      toggle$3(dialogBody, [\n        fullscreenClass,\n        ...currentSizeClass.toArray()\n      ]);\n    };\n    const renderModalDialog = (spec, dialogEvents, backstage) => build$1(renderDialog$1({\n      ...spec,\n      firstTabstop: 1,\n      lazySink: backstage.shared.getSink,\n      extraBehaviours: [\n        memory({}),\n        ...spec.extraBehaviours\n      ],\n      onEscape: comp => {\n        emit(comp, formCancelEvent);\n      },\n      dialogEvents,\n      eventOrder: {\n        [receive()]: [\n          Reflecting.name(),\n          Receiving.name()\n        ],\n        [attachedToDom()]: [\n          'scroll-lock',\n          Reflecting.name(),\n          'messages',\n          'dialog-events',\n          'alloy.base.behaviour'\n        ],\n        [detachedFromDom()]: [\n          'alloy.base.behaviour',\n          'dialog-events',\n          'messages',\n          Reflecting.name(),\n          'scroll-lock'\n        ]\n      }\n    }));\n    const mapMenuButtons = (buttons, menuItemStates = {}) => {\n      const mapItems = button => {\n        const items = map$2(button.items, item => {\n          const cell = get$h(menuItemStates, item.name).getOr(Cell(false));\n          return {\n            ...item,\n            storage: cell\n          };\n        });\n        return {\n          ...button,\n          items\n        };\n      };\n      return map$2(buttons, button => {\n        return button.type === 'menu' ? mapItems(button) : button;\n      });\n    };\n    const extractCellsToObject = buttons => foldl(buttons, (acc, button) => {\n      if (button.type === 'menu') {\n        const menuButton = button;\n        return foldl(menuButton.items, (innerAcc, item) => {\n          innerAcc[item.name] = item.storage;\n          return innerAcc;\n        }, acc);\n      }\n      return acc;\n    }, {});\n\n    const initCommonEvents = (fireApiEvent, extras) => [\n      runWithTarget(focusin(), onFocus),\n      fireApiEvent(formCloseEvent, (_api, spec, _event, self) => {\n        active$1(getRootNode(self.element)).fold(noop, blur$1);\n        extras.onClose();\n        spec.onClose();\n      }),\n      fireApiEvent(formCancelEvent, (api, spec, _event, self) => {\n        spec.onCancel(api);\n        emit(self, formCloseEvent);\n      }),\n      run$1(formUnblockEvent, (_c, _se) => extras.onUnblock()),\n      run$1(formBlockEvent, (_c, se) => extras.onBlock(se.event))\n    ];\n    const initUrlDialog = (getInstanceApi, extras) => {\n      const fireApiEvent = (eventName, f) => run$1(eventName, (c, se) => {\n        withSpec(c, (spec, _c) => {\n          f(getInstanceApi(), spec, se.event, c);\n        });\n      });\n      const withSpec = (c, f) => {\n        Reflecting.getState(c).get().each(currentDialog => {\n          f(currentDialog, c);\n        });\n      };\n      return [\n        ...initCommonEvents(fireApiEvent, extras),\n        fireApiEvent(formActionEvent, (api, spec, event) => {\n          spec.onAction(api, { name: event.name });\n        })\n      ];\n    };\n    const initDialog = (getInstanceApi, extras, getSink) => {\n      const fireApiEvent = (eventName, f) => run$1(eventName, (c, se) => {\n        withSpec(c, (spec, _c) => {\n          f(getInstanceApi(), spec, se.event, c);\n        });\n      });\n      const withSpec = (c, f) => {\n        Reflecting.getState(c).get().each(currentDialogInit => {\n          f(currentDialogInit.internalDialog, c);\n        });\n      };\n      return [\n        ...initCommonEvents(fireApiEvent, extras),\n        fireApiEvent(formSubmitEvent, (api, spec) => spec.onSubmit(api)),\n        fireApiEvent(formChangeEvent, (api, spec, event) => {\n          spec.onChange(api, { name: event.name });\n        }),\n        fireApiEvent(formActionEvent, (api, spec, event, component) => {\n          const focusIn = () => component.getSystem().isConnected() ? Keying.focusIn(component) : undefined;\n          const isDisabled = focused => has$1(focused, 'disabled') || getOpt(focused, 'aria-disabled').exists(val => val === 'true');\n          const rootNode = getRootNode(component.element);\n          const current = active$1(rootNode);\n          spec.onAction(api, {\n            name: event.name,\n            value: event.value\n          });\n          active$1(rootNode).fold(focusIn, focused => {\n            if (isDisabled(focused)) {\n              focusIn();\n            } else if (current.exists(cur => contains(focused, cur) && isDisabled(cur))) {\n              focusIn();\n            } else {\n              getSink().toOptional().filter(sink => !contains(sink.element, focused)).each(focusIn);\n            }\n          });\n        }),\n        fireApiEvent(formTabChangeEvent, (api, spec, event) => {\n          spec.onTabChange(api, {\n            newTabName: event.name,\n            oldTabName: event.oldName\n          });\n        }),\n        runOnDetached(component => {\n          const api = getInstanceApi();\n          Representing.setValue(component, api.getData());\n        })\n      ];\n    };\n\n    const makeButton = (button, backstage) => renderFooterButton(button, button.type, backstage);\n    const lookup = (compInSystem, footerButtons, buttonName) => find$5(footerButtons, button => button.name === buttonName).bind(memButton => memButton.memento.getOpt(compInSystem));\n    const renderComponents = (_data, state) => {\n      const footerButtons = state.map(s => s.footerButtons).getOr([]);\n      const buttonGroups = partition$3(footerButtons, button => button.align === 'start');\n      const makeGroup = (edge, buttons) => Container.sketch({\n        dom: {\n          tag: 'div',\n          classes: [`tox-dialog__footer-${ edge }`]\n        },\n        components: map$2(buttons, button => button.memento.asSpec())\n      });\n      const startButtons = makeGroup('start', buttonGroups.pass);\n      const endButtons = makeGroup('end', buttonGroups.fail);\n      return [\n        startButtons,\n        endButtons\n      ];\n    };\n    const renderFooter = (initSpec, dialogId, backstage) => {\n      const updateState = (comp, data) => {\n        const footerButtons = map$2(data.buttons, button => {\n          const memButton = record(makeButton(button, backstage));\n          return {\n            name: button.name,\n            align: button.align,\n            memento: memButton\n          };\n        });\n        const lookupByName = buttonName => lookup(comp, footerButtons, buttonName);\n        return Optional.some({\n          lookupByName,\n          footerButtons\n        });\n      };\n      return {\n        dom: fromHtml('<div class=\"tox-dialog__footer\"></div>'),\n        components: [],\n        behaviours: derive$1([Reflecting.config({\n            channel: `${ footerChannel }-${ dialogId }`,\n            initialData: initSpec,\n            updateState,\n            renderComponents\n          })])\n      };\n    };\n    const renderInlineFooter = (initSpec, dialogId, backstage) => renderFooter(initSpec, dialogId, backstage);\n    const renderModalFooter = (initSpec, dialogId, backstage) => ModalDialog.parts.footer(renderFooter(initSpec, dialogId, backstage));\n\n    const getCompByName = (access, name) => {\n      const root = access.getRoot();\n      if (root.getSystem().isConnected()) {\n        const form = Composing.getCurrent(access.getFormWrapper()).getOr(access.getFormWrapper());\n        return Form.getField(form, name).orThunk(() => {\n          const footer = access.getFooter();\n          const footerState = footer.bind(f => Reflecting.getState(f).get());\n          return footerState.bind(f => f.lookupByName(name));\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const validateData$1 = (access, data) => {\n      const root = access.getRoot();\n      return Reflecting.getState(root).get().map(dialogState => getOrDie(asRaw('data', dialogState.dataValidator, data))).getOr(data);\n    };\n    const getDialogApi = (access, doRedial, menuItemStates) => {\n      const withRoot = f => {\n        const root = access.getRoot();\n        if (root.getSystem().isConnected()) {\n          f(root);\n        }\n      };\n      const getData = () => {\n        const root = access.getRoot();\n        const valueComp = root.getSystem().isConnected() ? access.getFormWrapper() : root;\n        const representedValues = Representing.getValue(valueComp);\n        const menuItemCurrentState = map$1(menuItemStates, cell => cell.get());\n        return {\n          ...representedValues,\n          ...menuItemCurrentState\n        };\n      };\n      const setData = newData => {\n        withRoot(_ => {\n          const prevData = instanceApi.getData();\n          const mergedData = deepMerge(prevData, newData);\n          const newInternalData = validateData$1(access, mergedData);\n          const form = access.getFormWrapper();\n          Representing.setValue(form, newInternalData);\n          each(menuItemStates, (v, k) => {\n            if (has$2(mergedData, k)) {\n              v.set(mergedData[k]);\n            }\n          });\n        });\n      };\n      const setEnabled = (name, state) => {\n        getCompByName(access, name).each(state ? Disabling.enable : Disabling.disable);\n      };\n      const focus = name => {\n        getCompByName(access, name).each(Focusing.focus);\n      };\n      const block = message => {\n        if (!isString(message)) {\n          throw new Error('The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument');\n        }\n        withRoot(root => {\n          emitWith(root, formBlockEvent, { message });\n        });\n      };\n      const unblock = () => {\n        withRoot(root => {\n          emit(root, formUnblockEvent);\n        });\n      };\n      const showTab = name => {\n        withRoot(_ => {\n          const body = access.getBody();\n          const bodyState = Reflecting.getState(body);\n          if (bodyState.get().exists(b => b.isTabPanel())) {\n            Composing.getCurrent(body).each(tabSection => {\n              TabSection.showTab(tabSection, name);\n            });\n          }\n        });\n      };\n      const redial = d => {\n        withRoot(root => {\n          const id = access.getId();\n          const dialogInit = doRedial(d);\n          const storedMenuButtons = mapMenuButtons(dialogInit.internalDialog.buttons, menuItemStates);\n          root.getSystem().broadcastOn([`${ dialogChannel }-${ id }`], dialogInit);\n          root.getSystem().broadcastOn([`${ titleChannel }-${ id }`], dialogInit.internalDialog);\n          root.getSystem().broadcastOn([`${ bodyChannel }-${ id }`], dialogInit.internalDialog);\n          root.getSystem().broadcastOn([`${ footerChannel }-${ id }`], {\n            ...dialogInit.internalDialog,\n            buttons: storedMenuButtons\n          });\n          instanceApi.setData(dialogInit.initialData);\n        });\n      };\n      const close = () => {\n        withRoot(root => {\n          emit(root, formCloseEvent);\n        });\n      };\n      const instanceApi = {\n        getData,\n        setData,\n        setEnabled,\n        focus,\n        block,\n        unblock,\n        showTab,\n        redial,\n        close,\n        toggleFullscreen: access.toggleFullscreen\n      };\n      return instanceApi;\n    };\n\n    const renderDialog = (dialogInit, extra, backstage) => {\n      const dialogId = generate$6('dialog');\n      const internalDialog = dialogInit.internalDialog;\n      const header = getHeader(internalDialog.title, dialogId, backstage);\n      const dialogSize = Cell(internalDialog.size);\n      const getCompByName$1 = name => getCompByName(modalAccess, name);\n      const dialogSizeClasses = getDialogSizeClass(dialogSize.get()).toArray();\n      const updateState = (comp, incoming) => {\n        dialogSize.set(incoming.internalDialog.size);\n        updateDialogSizeClass(incoming.internalDialog.size, comp);\n        return Optional.some(incoming);\n      };\n      const body = renderModalBody({\n        body: internalDialog.body,\n        initialData: internalDialog.initialData\n      }, dialogId, backstage, getCompByName$1);\n      const storedMenuButtons = mapMenuButtons(internalDialog.buttons);\n      const objOfCells = extractCellsToObject(storedMenuButtons);\n      const footer = someIf(storedMenuButtons.length !== 0, renderModalFooter({ buttons: storedMenuButtons }, dialogId, backstage));\n      const dialogEvents = initDialog(() => instanceApi, getEventExtras(() => dialog, backstage.shared.providers, extra), backstage.shared.getSink);\n      const spec = {\n        id: dialogId,\n        header,\n        body,\n        footer,\n        extraClasses: dialogSizeClasses,\n        extraBehaviours: [Reflecting.config({\n            channel: `${ dialogChannel }-${ dialogId }`,\n            updateState,\n            initialData: dialogInit\n          })],\n        extraStyles: {}\n      };\n      const dialog = renderModalDialog(spec, dialogEvents, backstage);\n      const modalAccess = (() => {\n        const getForm = () => {\n          const outerForm = ModalDialog.getBody(dialog);\n          return Composing.getCurrent(outerForm).getOr(outerForm);\n        };\n        const toggleFullscreen$1 = () => {\n          toggleFullscreen(dialog, dialogSize.get());\n        };\n        return {\n          getId: constant$1(dialogId),\n          getRoot: constant$1(dialog),\n          getBody: () => ModalDialog.getBody(dialog),\n          getFooter: () => ModalDialog.getFooter(dialog),\n          getFormWrapper: getForm,\n          toggleFullscreen: toggleFullscreen$1\n        };\n      })();\n      const instanceApi = getDialogApi(modalAccess, extra.redial, objOfCells);\n      return {\n        dialog,\n        instanceApi\n      };\n    };\n\n    const renderInlineDialog = (dialogInit, extra, backstage, ariaAttrs = false, refreshDocking) => {\n      const dialogId = generate$6('dialog');\n      const dialogLabelId = generate$6('dialog-label');\n      const dialogContentId = generate$6('dialog-content');\n      const internalDialog = dialogInit.internalDialog;\n      const getCompByName$1 = name => getCompByName(modalAccess, name);\n      const dialogSize = Cell(internalDialog.size);\n      const dialogSizeClass = getDialogSizeClass(dialogSize.get()).toArray();\n      const updateState = (comp, incoming) => {\n        dialogSize.set(incoming.internalDialog.size);\n        updateDialogSizeClass(incoming.internalDialog.size, comp);\n        refreshDocking();\n        return Optional.some(incoming);\n      };\n      const memHeader = record(renderInlineHeader({\n        title: internalDialog.title,\n        draggable: true\n      }, dialogId, dialogLabelId, backstage.shared.providers));\n      const memBody = record(renderInlineBody({\n        body: internalDialog.body,\n        initialData: internalDialog.initialData\n      }, dialogId, dialogContentId, backstage, ariaAttrs, getCompByName$1));\n      const storagedMenuButtons = mapMenuButtons(internalDialog.buttons);\n      const objOfCells = extractCellsToObject(storagedMenuButtons);\n      const optMemFooter = someIf(storagedMenuButtons.length !== 0, record(renderInlineFooter({ buttons: storagedMenuButtons }, dialogId, backstage)));\n      const dialogEvents = initDialog(() => instanceApi, {\n        onBlock: event => {\n          Blocking.block(dialog, (_comp, bs) => {\n            const headerHeight = memHeader.getOpt(dialog).map(dialog => get$e(dialog.element));\n            return getBusySpec(event.message, bs, backstage.shared.providers, headerHeight);\n          });\n        },\n        onUnblock: () => {\n          Blocking.unblock(dialog);\n        },\n        onClose: () => extra.closeWindow()\n      }, backstage.shared.getSink);\n      const inlineClass = 'tox-dialog-inline';\n      const os = detect$1().os;\n      const dialog = build$1({\n        dom: {\n          tag: 'div',\n          classes: [\n            'tox-dialog',\n            inlineClass,\n            ...dialogSizeClass\n          ],\n          attributes: {\n            role: 'dialog',\n            ...os.isMacOS() ? { 'aria-label': internalDialog.title } : { 'aria-labelledby': dialogLabelId }\n          }\n        },\n        eventOrder: {\n          [receive()]: [\n            Reflecting.name(),\n            Receiving.name()\n          ],\n          [execute$5()]: ['execute-on-form'],\n          [attachedToDom()]: [\n            'reflecting',\n            'execute-on-form'\n          ]\n        },\n        behaviours: derive$1([\n          Keying.config({\n            mode: 'cyclic',\n            onEscape: c => {\n              emit(c, formCloseEvent);\n              return Optional.some(true);\n            },\n            useTabstopAt: elem => !isPseudoStop(elem) && (name$3(elem) !== 'button' || get$g(elem, 'disabled') !== 'disabled'),\n            firstTabstop: 1\n          }),\n          Reflecting.config({\n            channel: `${ dialogChannel }-${ dialogId }`,\n            updateState,\n            initialData: dialogInit\n          }),\n          Focusing.config({}),\n          config('execute-on-form', dialogEvents.concat([\n            runOnSource(focusin(), (comp, _se) => {\n              Keying.focusIn(comp);\n            }),\n            run$1(focusShifted(), (comp, se) => {\n              comp.getSystem().broadcastOn([dialogFocusShiftedChannel], { newFocus: se.event.newFocus });\n            })\n          ])),\n          Blocking.config({ getRoot: () => Optional.some(dialog) }),\n          Replacing.config({}),\n          memory({})\n        ]),\n        components: [\n          memHeader.asSpec(),\n          memBody.asSpec(),\n          ...optMemFooter.map(memFooter => memFooter.asSpec()).toArray()\n        ]\n      });\n      const toggleFullscreen$1 = () => {\n        toggleFullscreen(dialog, dialogSize.get());\n      };\n      const modalAccess = {\n        getId: constant$1(dialogId),\n        getRoot: constant$1(dialog),\n        getFooter: () => optMemFooter.map(memFooter => memFooter.get(dialog)),\n        getBody: () => memBody.get(dialog),\n        getFormWrapper: () => {\n          const body = memBody.get(dialog);\n          return Composing.getCurrent(body).getOr(body);\n        },\n        toggleFullscreen: toggleFullscreen$1\n      };\n      const instanceApi = getDialogApi(modalAccess, extra.redial, objOfCells);\n      return {\n        dialog,\n        instanceApi\n      };\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.util.URI');\n\n    const getUrlDialogApi = root => {\n      const withRoot = f => {\n        if (root.getSystem().isConnected()) {\n          f(root);\n        }\n      };\n      const block = message => {\n        if (!isString(message)) {\n          throw new Error('The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument');\n        }\n        withRoot(root => {\n          emitWith(root, formBlockEvent, { message });\n        });\n      };\n      const unblock = () => {\n        withRoot(root => {\n          emit(root, formUnblockEvent);\n        });\n      };\n      const close = () => {\n        withRoot(root => {\n          emit(root, formCloseEvent);\n        });\n      };\n      const sendMessage = data => {\n        withRoot(root => {\n          root.getSystem().broadcastOn([bodySendMessageChannel], data);\n        });\n      };\n      return {\n        block,\n        unblock,\n        close,\n        sendMessage\n      };\n    };\n\n    const SUPPORTED_MESSAGE_ACTIONS = [\n      'insertContent',\n      'setContent',\n      'execCommand',\n      'close',\n      'block',\n      'unblock'\n    ];\n    const isSupportedMessage = data => isObject(data) && SUPPORTED_MESSAGE_ACTIONS.indexOf(data.mceAction) !== -1;\n    const isCustomMessage = data => !isSupportedMessage(data) && isObject(data) && has$2(data, 'mceAction');\n    const handleMessage = (editor, api, data) => {\n      switch (data.mceAction) {\n      case 'insertContent':\n        editor.insertContent(data.content);\n        break;\n      case 'setContent':\n        editor.setContent(data.content);\n        break;\n      case 'execCommand':\n        const ui = isBoolean(data.ui) ? data.ui : false;\n        editor.execCommand(data.cmd, ui, data.value);\n        break;\n      case 'close':\n        api.close();\n        break;\n      case 'block':\n        api.block(data.message);\n        break;\n      case 'unblock':\n        api.unblock();\n        break;\n      }\n    };\n    const renderUrlDialog = (internalDialog, extra, editor, backstage) => {\n      const dialogId = generate$6('dialog');\n      const header = getHeader(internalDialog.title, dialogId, backstage);\n      const body = renderIframeBody(internalDialog);\n      const footer = internalDialog.buttons.bind(buttons => {\n        if (buttons.length === 0) {\n          return Optional.none();\n        } else {\n          return Optional.some(renderModalFooter({ buttons }, dialogId, backstage));\n        }\n      });\n      const dialogEvents = initUrlDialog(() => instanceApi, getEventExtras(() => dialog, backstage.shared.providers, extra));\n      const styles = {\n        ...internalDialog.height.fold(() => ({}), height => ({\n          'height': height + 'px',\n          'max-height': height + 'px'\n        })),\n        ...internalDialog.width.fold(() => ({}), width => ({\n          'width': width + 'px',\n          'max-width': width + 'px'\n        }))\n      };\n      const classes = internalDialog.width.isNone() && internalDialog.height.isNone() ? ['tox-dialog--width-lg'] : [];\n      const iframeUri = new global(internalDialog.url, { base_uri: new global(window.location.href) });\n      const iframeDomain = `${ iframeUri.protocol }://${ iframeUri.host }${ iframeUri.port ? ':' + iframeUri.port : '' }`;\n      const messageHandlerUnbinder = unbindable();\n      const updateState = (_comp, incoming) => Optional.some(incoming);\n      const extraBehaviours = [\n        Reflecting.config({\n          channel: `${ dialogChannel }-${ dialogId }`,\n          updateState,\n          initialData: internalDialog\n        }),\n        config('messages', [\n          runOnAttached(() => {\n            const unbind = bind(SugarElement.fromDom(window), 'message', e => {\n              if (iframeUri.isSameOrigin(new global(e.raw.origin))) {\n                const data = e.raw.data;\n                if (isSupportedMessage(data)) {\n                  handleMessage(editor, instanceApi, data);\n                } else if (isCustomMessage(data)) {\n                  internalDialog.onMessage(instanceApi, data);\n                }\n              }\n            });\n            messageHandlerUnbinder.set(unbind);\n          }),\n          runOnDetached(messageHandlerUnbinder.clear)\n        ]),\n        Receiving.config({\n          channels: {\n            [bodySendMessageChannel]: {\n              onReceive: (comp, data) => {\n                descendant(comp.element, 'iframe').each(iframeEle => {\n                  const iframeWin = iframeEle.dom.contentWindow;\n                  if (isNonNullable(iframeWin)) {\n                    iframeWin.postMessage(data, iframeDomain);\n                  }\n                });\n              }\n            }\n          }\n        })\n      ];\n      const spec = {\n        id: dialogId,\n        header,\n        body,\n        footer,\n        extraClasses: classes,\n        extraBehaviours,\n        extraStyles: styles\n      };\n      const dialog = renderModalDialog(spec, dialogEvents, backstage);\n      const instanceApi = getUrlDialogApi(dialog);\n      return {\n        dialog,\n        instanceApi\n      };\n    };\n\n    const setup$2 = backstage => {\n      const sharedBackstage = backstage.shared;\n      const open = (message, callback) => {\n        const closeDialog = () => {\n          ModalDialog.hide(alertDialog);\n          callback();\n        };\n        const memFooterClose = record(renderFooterButton({\n          name: 'close-alert',\n          text: 'OK',\n          primary: true,\n          buttonType: Optional.some('primary'),\n          align: 'end',\n          enabled: true,\n          icon: Optional.none()\n        }, 'cancel', backstage));\n        const titleSpec = pUntitled();\n        const closeSpec = pClose(closeDialog, sharedBackstage.providers);\n        const alertDialog = build$1(renderDialog$1({\n          lazySink: () => sharedBackstage.getSink(),\n          header: hiddenHeader(titleSpec, closeSpec),\n          body: pBodyMessage(message, sharedBackstage.providers),\n          footer: Optional.some(pFooter(pFooterGroup([], [memFooterClose.asSpec()]))),\n          onEscape: closeDialog,\n          extraClasses: ['tox-alert-dialog'],\n          extraBehaviours: [],\n          extraStyles: {},\n          dialogEvents: [run$1(formCancelEvent, closeDialog)],\n          eventOrder: {}\n        }));\n        ModalDialog.show(alertDialog);\n        const footerCloseButton = memFooterClose.get(alertDialog);\n        Focusing.focus(footerCloseButton);\n      };\n      return { open };\n    };\n\n    const setup$1 = backstage => {\n      const sharedBackstage = backstage.shared;\n      const open = (message, callback) => {\n        const closeDialog = state => {\n          ModalDialog.hide(confirmDialog);\n          callback(state);\n        };\n        const memFooterYes = record(renderFooterButton({\n          name: 'yes',\n          text: 'Yes',\n          primary: true,\n          buttonType: Optional.some('primary'),\n          align: 'end',\n          enabled: true,\n          icon: Optional.none()\n        }, 'submit', backstage));\n        const footerNo = renderFooterButton({\n          name: 'no',\n          text: 'No',\n          primary: false,\n          buttonType: Optional.some('secondary'),\n          align: 'end',\n          enabled: true,\n          icon: Optional.none()\n        }, 'cancel', backstage);\n        const titleSpec = pUntitled();\n        const closeSpec = pClose(() => closeDialog(false), sharedBackstage.providers);\n        const confirmDialog = build$1(renderDialog$1({\n          lazySink: () => sharedBackstage.getSink(),\n          header: hiddenHeader(titleSpec, closeSpec),\n          body: pBodyMessage(message, sharedBackstage.providers),\n          footer: Optional.some(pFooter(pFooterGroup([], [\n            footerNo,\n            memFooterYes.asSpec()\n          ]))),\n          onEscape: () => closeDialog(false),\n          extraClasses: ['tox-confirm-dialog'],\n          extraBehaviours: [],\n          extraStyles: {},\n          dialogEvents: [\n            run$1(formCancelEvent, () => closeDialog(false)),\n            run$1(formSubmitEvent, () => closeDialog(true))\n          ],\n          eventOrder: {}\n        }));\n        ModalDialog.show(confirmDialog);\n        const footerYesButton = memFooterYes.get(confirmDialog);\n        Focusing.focus(footerYesButton);\n      };\n      return { open };\n    };\n\n    const validateData = (data, validator) => getOrDie(asRaw('data', validator, data));\n    const isAlertOrConfirmDialog = target => closest(target, '.tox-alert-dialog') || closest(target, '.tox-confirm-dialog');\n    const inlineAdditionalBehaviours = (editor, isStickyToolbar, isToolbarLocationTop) => {\n      if (isStickyToolbar && isToolbarLocationTop) {\n        return [];\n      } else {\n        return [Docking.config({\n            contextual: {\n              lazyContext: () => Optional.some(box$1(SugarElement.fromDom(editor.getContentAreaContainer()))),\n              fadeInClass: 'tox-dialog-dock-fadein',\n              fadeOutClass: 'tox-dialog-dock-fadeout',\n              transitionClass: 'tox-dialog-dock-transition'\n            },\n            modes: ['top'],\n            lazyViewport: comp => {\n              const optScrollingContext = detectWhenSplitUiMode(editor, comp.element);\n              return optScrollingContext.map(sc => {\n                const combinedBounds = getBoundsFrom(sc);\n                return {\n                  bounds: combinedBounds,\n                  optScrollEnv: Optional.some({\n                    currentScrollTop: sc.element.dom.scrollTop,\n                    scrollElmTop: absolute$3(sc.element).top\n                  })\n                };\n              }).getOrThunk(() => ({\n                bounds: win(),\n                optScrollEnv: Optional.none()\n              }));\n            }\n          })];\n      }\n    };\n    const setup = extras => {\n      const editor = extras.editor;\n      const isStickyToolbar$1 = isStickyToolbar(editor);\n      const alertDialog = setup$2(extras.backstages.dialog);\n      const confirmDialog = setup$1(extras.backstages.dialog);\n      const open = (config, params, closeWindow) => {\n        if (!isUndefined(params)) {\n          if (params.inline === 'toolbar') {\n            return openInlineDialog(config, extras.backstages.popup.shared.anchors.inlineDialog(), closeWindow, params);\n          } else if (params.inline === 'bottom') {\n            return openBottomInlineDialog(config, extras.backstages.popup.shared.anchors.inlineBottomDialog(), closeWindow, params);\n          } else if (params.inline === 'cursor') {\n            return openInlineDialog(config, extras.backstages.popup.shared.anchors.cursor(), closeWindow, params);\n          }\n        }\n        return openModalDialog(config, closeWindow);\n      };\n      const openUrl = (config, closeWindow) => openModalUrlDialog(config, closeWindow);\n      const openModalUrlDialog = (config, closeWindow) => {\n        const factory = contents => {\n          const dialog = renderUrlDialog(contents, {\n            closeWindow: () => {\n              ModalDialog.hide(dialog.dialog);\n              closeWindow(dialog.instanceApi);\n            }\n          }, editor, extras.backstages.dialog);\n          ModalDialog.show(dialog.dialog);\n          return dialog.instanceApi;\n        };\n        return DialogManager.openUrl(factory, config);\n      };\n      const openModalDialog = (config, closeWindow) => {\n        const factory = (contents, internalInitialData, dataValidator) => {\n          const initialData = internalInitialData;\n          const dialogInit = {\n            dataValidator,\n            initialData,\n            internalDialog: contents\n          };\n          const dialog = renderDialog(dialogInit, {\n            redial: DialogManager.redial,\n            closeWindow: () => {\n              ModalDialog.hide(dialog.dialog);\n              closeWindow(dialog.instanceApi);\n            }\n          }, extras.backstages.dialog);\n          ModalDialog.show(dialog.dialog);\n          dialog.instanceApi.setData(initialData);\n          return dialog.instanceApi;\n        };\n        return DialogManager.open(factory, config);\n      };\n      const openInlineDialog = (config$1, anchor, closeWindow, windowParams) => {\n        const factory = (contents, internalInitialData, dataValidator) => {\n          const initialData = validateData(internalInitialData, dataValidator);\n          const inlineDialog = value$4();\n          const isToolbarLocationTop = extras.backstages.popup.shared.header.isPositionedAtTop();\n          const dialogInit = {\n            dataValidator,\n            initialData,\n            internalDialog: contents\n          };\n          const refreshDocking = () => inlineDialog.on(dialog => {\n            InlineView.reposition(dialog);\n            if (!isStickyToolbar$1 || !isToolbarLocationTop) {\n              Docking.refresh(dialog);\n            }\n          });\n          const dialogUi = renderInlineDialog(dialogInit, {\n            redial: DialogManager.redial,\n            closeWindow: () => {\n              inlineDialog.on(InlineView.hide);\n              editor.off('ResizeEditor', refreshDocking);\n              inlineDialog.clear();\n              closeWindow(dialogUi.instanceApi);\n            }\n          }, extras.backstages.popup, windowParams.ariaAttrs, refreshDocking);\n          const inlineDialogComp = build$1(InlineView.sketch({\n            lazySink: extras.backstages.popup.shared.getSink,\n            dom: {\n              tag: 'div',\n              classes: []\n            },\n            fireDismissalEventInstead: windowParams.persistent ? { event: 'doNotDismissYet' } : {},\n            ...isToolbarLocationTop ? {} : { fireRepositionEventInstead: {} },\n            inlineBehaviours: derive$1([\n              config('window-manager-inline-events', [run$1(dismissRequested(), (_comp, _se) => {\n                  emit(dialogUi.dialog, formCancelEvent);\n                })]),\n              ...inlineAdditionalBehaviours(editor, isStickyToolbar$1, isToolbarLocationTop)\n            ]),\n            isExtraPart: (_comp, target) => isAlertOrConfirmDialog(target)\n          }));\n          inlineDialog.set(inlineDialogComp);\n          const getInlineDialogBounds = () => {\n            const elem = editor.inline ? body() : SugarElement.fromDom(editor.getContainer());\n            const bounds = box$1(elem);\n            return Optional.some(bounds);\n          };\n          InlineView.showWithinBounds(inlineDialogComp, premade(dialogUi.dialog), { anchor }, getInlineDialogBounds);\n          if (!isStickyToolbar$1 || !isToolbarLocationTop) {\n            Docking.refresh(inlineDialogComp);\n            editor.on('ResizeEditor', refreshDocking);\n          }\n          dialogUi.instanceApi.setData(initialData);\n          Keying.focusIn(dialogUi.dialog);\n          return dialogUi.instanceApi;\n        };\n        return DialogManager.open(factory, config$1);\n      };\n      const openBottomInlineDialog = (config$1, anchor, closeWindow, windowParams) => {\n        const factory = (contents, internalInitialData, dataValidator) => {\n          const initialData = validateData(internalInitialData, dataValidator);\n          const inlineDialog = value$4();\n          const isToolbarLocationTop = extras.backstages.popup.shared.header.isPositionedAtTop();\n          const dialogInit = {\n            dataValidator,\n            initialData,\n            internalDialog: contents\n          };\n          const refreshDocking = () => inlineDialog.on(dialog => {\n            InlineView.reposition(dialog);\n            Docking.refresh(dialog);\n          });\n          const dialogUi = renderInlineDialog(dialogInit, {\n            redial: DialogManager.redial,\n            closeWindow: () => {\n              inlineDialog.on(InlineView.hide);\n              editor.off('ResizeEditor ScrollWindow ElementScroll', refreshDocking);\n              inlineDialog.clear();\n              closeWindow(dialogUi.instanceApi);\n            }\n          }, extras.backstages.popup, windowParams.ariaAttrs, refreshDocking);\n          const inlineDialogComp = build$1(InlineView.sketch({\n            lazySink: extras.backstages.popup.shared.getSink,\n            dom: {\n              tag: 'div',\n              classes: []\n            },\n            fireDismissalEventInstead: windowParams.persistent ? { event: 'doNotDismissYet' } : {},\n            ...isToolbarLocationTop ? {} : { fireRepositionEventInstead: {} },\n            inlineBehaviours: derive$1([\n              config('window-manager-inline-events', [run$1(dismissRequested(), (_comp, _se) => {\n                  emit(dialogUi.dialog, formCancelEvent);\n                })]),\n              Docking.config({\n                contextual: {\n                  lazyContext: () => Optional.some(box$1(SugarElement.fromDom(editor.getContentAreaContainer()))),\n                  fadeInClass: 'tox-dialog-dock-fadein',\n                  fadeOutClass: 'tox-dialog-dock-fadeout',\n                  transitionClass: 'tox-dialog-dock-transition'\n                },\n                modes: [\n                  'top',\n                  'bottom'\n                ],\n                lazyViewport: comp => {\n                  const optScrollingContext = detectWhenSplitUiMode(editor, comp.element);\n                  return optScrollingContext.map(sc => {\n                    const combinedBounds = getBoundsFrom(sc);\n                    return {\n                      bounds: combinedBounds,\n                      optScrollEnv: Optional.some({\n                        currentScrollTop: sc.element.dom.scrollTop,\n                        scrollElmTop: absolute$3(sc.element).top\n                      })\n                    };\n                  }).getOrThunk(() => ({\n                    bounds: win(),\n                    optScrollEnv: Optional.none()\n                  }));\n                }\n              })\n            ]),\n            isExtraPart: (_comp, target) => isAlertOrConfirmDialog(target)\n          }));\n          inlineDialog.set(inlineDialogComp);\n          const getInlineDialogBounds = () => {\n            return extras.backstages.popup.shared.getSink().toOptional().bind(s => {\n              const optScrollingContext = detectWhenSplitUiMode(editor, s.element);\n              const margin = 15;\n              const bounds$1 = optScrollingContext.map(sc => getBoundsFrom(sc)).getOr(win());\n              const contentAreaContainer = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));\n              const constrainedBounds = constrain(contentAreaContainer, bounds$1);\n              return Optional.some(bounds(constrainedBounds.x, constrainedBounds.y, constrainedBounds.width, constrainedBounds.height - margin));\n            });\n          };\n          InlineView.showWithinBounds(inlineDialogComp, premade(dialogUi.dialog), { anchor }, getInlineDialogBounds);\n          Docking.refresh(inlineDialogComp);\n          editor.on('ResizeEditor ScrollWindow ElementScroll ResizeWindow', refreshDocking);\n          dialogUi.instanceApi.setData(initialData);\n          Keying.focusIn(dialogUi.dialog);\n          return dialogUi.instanceApi;\n        };\n        return DialogManager.open(factory, config$1);\n      };\n      const confirm = (message, callback) => {\n        confirmDialog.open(message, callback);\n      };\n      const alert = (message, callback) => {\n        alertDialog.open(message, callback);\n      };\n      const close = instanceApi => {\n        instanceApi.close();\n      };\n      return {\n        open,\n        openUrl,\n        alert,\n        close,\n        confirm\n      };\n    };\n\n    const registerOptions = editor => {\n      register$e(editor);\n      register$d(editor);\n      register(editor);\n    };\n    var Theme = () => {\n      global$a.add('silver', editor => {\n        registerOptions(editor);\n        let popupSinkBounds = () => win();\n        const {\n          dialogs,\n          popups,\n          renderUI: renderModeUI\n        } = setup$3(editor, { getPopupSinkBounds: () => popupSinkBounds() });\n        const renderUI = () => {\n          const renderResult = renderModeUI();\n          const optScrollingContext = detectWhenSplitUiMode(editor, popups.getMothership().element);\n          optScrollingContext.each(sc => {\n            popupSinkBounds = () => {\n              return getBoundsFrom(sc);\n            };\n          });\n          return renderResult;\n        };\n        Autocompleter.register(editor, popups.backstage.shared);\n        const windowMgr = setup({\n          editor,\n          backstages: {\n            popup: popups.backstage,\n            dialog: dialogs.backstage\n          }\n        });\n        const notificationRegion = value$4();\n        const getNotificationManagerImpl = () => NotificationManagerImpl(editor, { backstage: popups.backstage }, popups.getMothership(), notificationRegion);\n        return {\n          renderUI,\n          getWindowManagerImpl: constant$1(windowMgr),\n          getNotificationManagerImpl\n        };\n      });\n    };\n\n    Theme();\n\n})();\n\n\n//# sourceURL=webpack://keenthemes/./node_modules/tinymce/themes/silver/theme.js?");

/***/ }),

/***/ "./node_modules/tinymce/tinymce.js":
/*!*****************************************!*\
  !*** ./node_modules/tinymce/tinymce.js ***!
  \*****************************************/
/***/ ((module) => {

eval("/**\n * TinyMCE version 7.2.1 (2024-07-03)\n */\n\n(function () {\n    'use strict';\n\n    var typeOf$1 = function (x) {\n      if (x === null) {\n        return 'null';\n      }\n      if (x === undefined) {\n        return 'undefined';\n      }\n      var t = typeof x;\n      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\n        return 'array';\n      }\n      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\n        return 'string';\n      }\n      return t;\n    };\n    var isEquatableType = function (x) {\n      return [\n        'undefined',\n        'boolean',\n        'number',\n        'string',\n        'function',\n        'xml',\n        'null'\n      ].indexOf(x) !== -1;\n    };\n\n    var sort$1 = function (xs, compareFn) {\n      var clone = Array.prototype.slice.call(xs);\n      return clone.sort(compareFn);\n    };\n\n    var contramap = function (eqa, f) {\n      return eq$2(function (x, y) {\n        return eqa.eq(f(x), f(y));\n      });\n    };\n    var eq$2 = function (f) {\n      return { eq: f };\n    };\n    var tripleEq = eq$2(function (x, y) {\n      return x === y;\n    });\n    var eqString = tripleEq;\n    var eqArray = function (eqa) {\n      return eq$2(function (x, y) {\n        if (x.length !== y.length) {\n          return false;\n        }\n        var len = x.length;\n        for (var i = 0; i < len; i++) {\n          if (!eqa.eq(x[i], y[i])) {\n            return false;\n          }\n        }\n        return true;\n      });\n    };\n    var eqSortedArray = function (eqa, compareFn) {\n      return contramap(eqArray(eqa), function (xs) {\n        return sort$1(xs, compareFn);\n      });\n    };\n    var eqRecord = function (eqa) {\n      return eq$2(function (x, y) {\n        var kx = Object.keys(x);\n        var ky = Object.keys(y);\n        if (!eqSortedArray(eqString).eq(kx, ky)) {\n          return false;\n        }\n        var len = kx.length;\n        for (var i = 0; i < len; i++) {\n          var q = kx[i];\n          if (!eqa.eq(x[q], y[q])) {\n            return false;\n          }\n        }\n        return true;\n      });\n    };\n    var eqAny = eq$2(function (x, y) {\n      if (x === y) {\n        return true;\n      }\n      var tx = typeOf$1(x);\n      var ty = typeOf$1(y);\n      if (tx !== ty) {\n        return false;\n      }\n      if (isEquatableType(tx)) {\n        return x === y;\n      } else if (tx === 'array') {\n        return eqArray(eqAny).eq(x, y);\n      } else if (tx === 'object') {\n        return eqRecord(eqAny).eq(x, y);\n      }\n      return false;\n    });\n\n    const getPrototypeOf$2 = Object.getPrototypeOf;\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const eq$1 = t => a => t === a;\n    const is$4 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isPlainObject = value => is$4(value, Object);\n    const isArray$1 = isType$1('array');\n    const isNull = eq$1(null);\n    const isBoolean = isSimpleType('boolean');\n    const isUndefined = eq$1(undefined);\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n    const isArrayOf = (value, pred) => {\n      if (isArray$1(value)) {\n        for (let i = 0, len = value.length; i < len; ++i) {\n          if (!pred(value[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    };\n\n    const noop = () => {\n    };\n    const compose = (fa, fb) => {\n      return (...args) => {\n        return fa(fb.apply(null, args));\n      };\n    };\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const identity = x => {\n      return x;\n    };\n    const tripleEquals = (a, b) => {\n      return a === b;\n    };\n    function curry(fn, ...initialArgs) {\n      return (...restArgs) => {\n        const all = initialArgs.concat(restArgs);\n        return fn.apply(null, all);\n      };\n    }\n    const not = f => t => !f(t);\n    const die = msg => {\n      return () => {\n        throw new Error(msg);\n      };\n    };\n    const apply$1 = f => {\n      return f();\n    };\n    const call = f => {\n      f();\n    };\n    const never = constant(false);\n    const always = constant(true);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const indexOf$1 = (xs, x) => {\n      const r = rawIndexOf(xs, x);\n      return r === -1 ? Optional.none() : Optional.some(r);\n    };\n    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const map$3 = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each$e = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const eachr = (xs, f) => {\n      for (let i = xs.length - 1; i >= 0; i--) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const partition$2 = (xs, pred) => {\n      const pass = [];\n      const fail = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        const arr = pred(x, i) ? pass : fail;\n        arr.push(x);\n      }\n      return {\n        pass,\n        fail\n      };\n    };\n    const filter$5 = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    const foldr = (xs, f, acc) => {\n      eachr(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const foldl = (xs, f, acc) => {\n      each$e(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const findUntil$1 = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const find$2 = (xs, pred) => {\n      return findUntil$1(xs, pred, never);\n    };\n    const findIndex$2 = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(i);\n        }\n      }\n      return Optional.none();\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray$1(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind$3 = (xs, f) => flatten(map$3(xs, f));\n    const forall = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        const x = xs[i];\n        if (pred(x, i) !== true) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const reverse = xs => {\n      const r = nativeSlice.call(xs, 0);\n      r.reverse();\n      return r;\n    };\n    const difference = (a1, a2) => filter$5(a1, x => !contains$2(a2, x));\n    const mapToObject = (xs, f) => {\n      const r = {};\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        r[String(x)] = f(x, i);\n      }\n      return r;\n    };\n    const sort = (xs, comparator) => {\n      const copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n    const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = xs => get$b(xs, 0);\n    const last$2 = xs => get$b(xs, xs.length - 1);\n    const from = isFunction(Array.from) ? Array.from : x => nativeSlice.call(x);\n    const findMap = (arr, f) => {\n      for (let i = 0; i < arr.length; i++) {\n        const r = f(arr[i], i);\n        if (r.isSome()) {\n          return r;\n        }\n      }\n      return Optional.none();\n    };\n    const unique$1 = (xs, comparator) => {\n      const r = [];\n      const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$2(r, x);\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (!isDuplicated(x)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n\n    const keys = Object.keys;\n    const hasOwnProperty$1 = Object.hasOwnProperty;\n    const each$d = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const map$2 = (obj, f) => {\n      return tupleMap(obj, (x, i) => ({\n        k: i,\n        v: f(x, i)\n      }));\n    };\n    const tupleMap = (obj, f) => {\n      const r = {};\n      each$d(obj, (x, i) => {\n        const tuple = f(x, i);\n        r[tuple.k] = tuple.v;\n      });\n      return r;\n    };\n    const objAcc = r => (x, i) => {\n      r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n      each$d(obj, (x, i) => {\n        (pred(x, i) ? onTrue : onFalse)(x, i);\n      });\n    };\n    const bifilter = (obj, pred) => {\n      const t = {};\n      const f = {};\n      internalFilter(obj, pred, objAcc(t), objAcc(f));\n      return {\n        t,\n        f\n      };\n    };\n    const filter$4 = (obj, pred) => {\n      const t = {};\n      internalFilter(obj, pred, objAcc(t), noop);\n      return t;\n    };\n    const mapToArray = (obj, f) => {\n      const r = [];\n      each$d(obj, (value, name) => {\n        r.push(f(value, name));\n      });\n      return r;\n    };\n    const values = obj => {\n      return mapToArray(obj, identity);\n    };\n    const get$a = (obj, key) => {\n      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\n    };\n    const has$2 = (obj, key) => hasOwnProperty$1.call(obj, key);\n    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\n    const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);\n\n    const stringArray = a => {\n      const all = {};\n      each$e(a, key => {\n        all[key] = {};\n      });\n      return keys(all);\n    };\n\n    const isArrayLike = o => o.length !== undefined;\n    const isArray = Array.isArray;\n    const toArray$1 = obj => {\n      if (!isArray(obj)) {\n        const array = [];\n        for (let i = 0, l = obj.length; i < l; i++) {\n          array[i] = obj[i];\n        }\n        return array;\n      } else {\n        return obj;\n      }\n    };\n    const each$c = (o, cb, s) => {\n      if (!o) {\n        return false;\n      }\n      s = s || o;\n      if (isArrayLike(o)) {\n        for (let n = 0, l = o.length; n < l; n++) {\n          if (cb.call(s, o[n], n, o) === false) {\n            return false;\n          }\n        }\n      } else {\n        for (const n in o) {\n          if (has$2(o, n)) {\n            if (cb.call(s, o[n], n, o) === false) {\n              return false;\n            }\n          }\n        }\n      }\n      return true;\n    };\n    const map$1 = (array, callback) => {\n      const out = [];\n      each$c(array, (item, index) => {\n        out.push(callback(item, index, array));\n      });\n      return out;\n    };\n    const filter$3 = (a, f) => {\n      const o = [];\n      each$c(a, (v, index) => {\n        if (!f || f(v, index, a)) {\n          o.push(v);\n        }\n      });\n      return o;\n    };\n    const indexOf = (a, v) => {\n      if (a) {\n        for (let i = 0, l = a.length; i < l; i++) {\n          if (a[i] === v) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    const reduce = (collection, iteratee, accumulator, thisArg) => {\n      let acc = isUndefined(accumulator) ? collection[0] : accumulator;\n      for (let i = 0; i < collection.length; i++) {\n        acc = iteratee.call(thisArg, acc, collection[i], i);\n      }\n      return acc;\n    };\n    const findIndex$1 = (array, predicate, thisArg) => {\n      for (let i = 0, l = array.length; i < l; i++) {\n        if (predicate.call(thisArg, array[i], i, array)) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    const last$1 = collection => collection[collection.length - 1];\n\n    const cached = f => {\n      let called = false;\n      let r;\n      return (...args) => {\n        if (!called) {\n          called = true;\n          r = f.apply(null, args);\n        }\n        return r;\n      };\n    };\n\n    const DeviceType = (os, browser, userAgent, mediaMatch) => {\n      const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n      const isiPhone = os.isiOS() && !isiPad;\n      const isMobile = os.isiOS() || os.isAndroid();\n      const isTouch = isMobile || mediaMatch('(pointer:coarse)');\n      const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n      const isPhone = isiPhone || isMobile && !isTablet;\n      const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n      const isDesktop = !isPhone && !isTablet && !iOSwebview;\n      return {\n        isiPad: constant(isiPad),\n        isiPhone: constant(isiPhone),\n        isTablet: constant(isTablet),\n        isPhone: constant(isPhone),\n        isTouch: constant(isTouch),\n        isAndroid: os.isAndroid,\n        isiOS: os.isiOS,\n        isWebView: constant(iOSwebview),\n        isDesktop: constant(isDesktop)\n      };\n    };\n\n    const firstMatch = (regexes, s) => {\n      for (let i = 0; i < regexes.length; i++) {\n        const x = regexes[i];\n        if (x.test(s)) {\n          return x;\n        }\n      }\n      return undefined;\n    };\n    const find$1 = (regexes, agent) => {\n      const r = firstMatch(regexes, agent);\n      if (!r) {\n        return {\n          major: 0,\n          minor: 0\n        };\n      }\n      const group = i => {\n        return Number(agent.replace(r, '$' + i));\n      };\n      return nu$3(group(1), group(2));\n    };\n    const detect$4 = (versionRegexes, agent) => {\n      const cleanedAgent = String(agent).toLowerCase();\n      if (versionRegexes.length === 0) {\n        return unknown$2();\n      }\n      return find$1(versionRegexes, cleanedAgent);\n    };\n    const unknown$2 = () => {\n      return nu$3(0, 0);\n    };\n    const nu$3 = (major, minor) => {\n      return {\n        major,\n        minor\n      };\n    };\n    const Version = {\n      nu: nu$3,\n      detect: detect$4,\n      unknown: unknown$2\n    };\n\n    const detectBrowser$1 = (browsers, userAgentData) => {\n      return findMap(userAgentData.brands, uaBrand => {\n        const lcBrand = uaBrand.brand.toLowerCase();\n        return find$2(browsers, browser => {\n          var _a;\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n        }).map(info => ({\n          current: info.name,\n          version: Version.nu(parseInt(uaBrand.version, 10), 0)\n        }));\n      });\n    };\n\n    const detect$3 = (candidates, userAgent) => {\n      const agent = String(userAgent).toLowerCase();\n      return find$2(candidates, candidate => {\n        return candidate.search(agent);\n      });\n    };\n    const detectBrowser = (browsers, userAgent) => {\n      return detect$3(browsers, userAgent).map(browser => {\n        const version = Version.detect(browser.versionRegexes, userAgent);\n        return {\n          current: browser.name,\n          version\n        };\n      });\n    };\n    const detectOs = (oses, userAgent) => {\n      return detect$3(oses, userAgent).map(os => {\n        const version = Version.detect(os.versionRegexes, userAgent);\n        return {\n          current: os.name,\n          version\n        };\n      });\n    };\n\n    const removeFromStart = (str, numChars) => {\n      return str.substring(numChars);\n    };\n\n    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n    const removeLeading = (str, prefix) => {\n      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\n    };\n    const contains$1 = (str, substr, start = 0, end) => {\n      const idx = str.indexOf(substr, start);\n      if (idx !== -1) {\n        return isUndefined(end) ? true : idx + substr.length <= end;\n      } else {\n        return false;\n      }\n    };\n    const startsWith = (str, prefix) => {\n      return checkRange(str, prefix, 0);\n    };\n    const endsWith = (str, suffix) => {\n      return checkRange(str, suffix, str.length - suffix.length);\n    };\n    const blank = r => s => s.replace(r, '');\n    const trim$4 = blank(/^\\s+|\\s+$/g);\n    const lTrim = blank(/^\\s+/g);\n    const rTrim = blank(/\\s+$/g);\n    const isNotEmpty = s => s.length > 0;\n    const isEmpty$3 = s => !isNotEmpty(s);\n    const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);\n    const toInt = (value, radix = 10) => {\n      const num = parseInt(value, radix);\n      return isNaN(num) ? Optional.none() : Optional.some(num);\n    };\n\n    const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n    const checkContains = target => {\n      return uastring => {\n        return contains$1(uastring, target);\n      };\n    };\n    const browsers = [\n      {\n        name: 'Edge',\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n        search: uastring => {\n          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\n        }\n      },\n      {\n        name: 'Chromium',\n        brand: 'Chromium',\n        versionRegexes: [\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\n          normalVersionRegex\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\n        }\n      },\n      {\n        name: 'IE',\n        versionRegexes: [\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\n        }\n      },\n      {\n        name: 'Opera',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\n        ],\n        search: checkContains('opera')\n      },\n      {\n        name: 'Firefox',\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n        search: checkContains('firefox')\n      },\n      {\n        name: 'Safari',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\n        ],\n        search: uastring => {\n          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\n        }\n      }\n    ];\n    const oses = [\n      {\n        name: 'Windows',\n        search: checkContains('win'),\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'iOS',\n        search: uastring => {\n          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\n        },\n        versionRegexes: [\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\n        ]\n      },\n      {\n        name: 'Android',\n        search: checkContains('android'),\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'macOS',\n        search: checkContains('mac os x'),\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n      },\n      {\n        name: 'Linux',\n        search: checkContains('linux'),\n        versionRegexes: []\n      },\n      {\n        name: 'Solaris',\n        search: checkContains('sunos'),\n        versionRegexes: []\n      },\n      {\n        name: 'FreeBSD',\n        search: checkContains('freebsd'),\n        versionRegexes: []\n      },\n      {\n        name: 'ChromeOS',\n        search: checkContains('cros'),\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n      }\n    ];\n    const PlatformInfo = {\n      browsers: constant(browsers),\n      oses: constant(oses)\n    };\n\n    const edge = 'Edge';\n    const chromium = 'Chromium';\n    const ie = 'IE';\n    const opera = 'Opera';\n    const firefox = 'Firefox';\n    const safari = 'Safari';\n    const unknown$1 = () => {\n      return nu$2({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$2 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isBrowser = name => () => current === name;\n      return {\n        current,\n        version,\n        isEdge: isBrowser(edge),\n        isChromium: isBrowser(chromium),\n        isIE: isBrowser(ie),\n        isOpera: isBrowser(opera),\n        isFirefox: isBrowser(firefox),\n        isSafari: isBrowser(safari)\n      };\n    };\n    const Browser = {\n      unknown: unknown$1,\n      nu: nu$2,\n      edge: constant(edge),\n      chromium: constant(chromium),\n      ie: constant(ie),\n      opera: constant(opera),\n      firefox: constant(firefox),\n      safari: constant(safari)\n    };\n\n    const windows = 'Windows';\n    const ios = 'iOS';\n    const android = 'Android';\n    const linux = 'Linux';\n    const macos = 'macOS';\n    const solaris = 'Solaris';\n    const freebsd = 'FreeBSD';\n    const chromeos = 'ChromeOS';\n    const unknown = () => {\n      return nu$1({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$1 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isOS = name => () => current === name;\n      return {\n        current,\n        version,\n        isWindows: isOS(windows),\n        isiOS: isOS(ios),\n        isAndroid: isOS(android),\n        isMacOS: isOS(macos),\n        isLinux: isOS(linux),\n        isSolaris: isOS(solaris),\n        isFreeBSD: isOS(freebsd),\n        isChromeOS: isOS(chromeos)\n      };\n    };\n    const OperatingSystem = {\n      unknown,\n      nu: nu$1,\n      windows: constant(windows),\n      ios: constant(ios),\n      android: constant(android),\n      linux: constant(linux),\n      macos: constant(macos),\n      solaris: constant(solaris),\n      freebsd: constant(freebsd),\n      chromeos: constant(chromeos)\n    };\n\n    const detect$2 = (userAgent, userAgentDataOpt, mediaMatch) => {\n      const browsers = PlatformInfo.browsers();\n      const oses = PlatformInfo.oses();\n      const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\n      const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n      const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n      return {\n        browser,\n        os,\n        deviceType\n      };\n    };\n    const PlatformDetection = { detect: detect$2 };\n\n    const mediaMatch = query => window.matchMedia(query).matches;\n    let platform$4 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));\n    const detect$1 = () => platform$4();\n\n    const userAgent = navigator.userAgent;\n    const platform$3 = detect$1();\n    const browser$3 = platform$3.browser;\n    const os$1 = platform$3.os;\n    const deviceType = platform$3.deviceType;\n    const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;\n    const Env = {\n      transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\n      documentMode: browser$3.isIE() ? document.documentMode || 7 : 10,\n      cacheSuffix: null,\n      container: null,\n      canHaveCSP: !browser$3.isIE(),\n      windowsPhone,\n      browser: {\n        current: browser$3.current,\n        version: browser$3.version,\n        isChromium: browser$3.isChromium,\n        isEdge: browser$3.isEdge,\n        isFirefox: browser$3.isFirefox,\n        isIE: browser$3.isIE,\n        isOpera: browser$3.isOpera,\n        isSafari: browser$3.isSafari\n      },\n      os: {\n        current: os$1.current,\n        version: os$1.version,\n        isAndroid: os$1.isAndroid,\n        isChromeOS: os$1.isChromeOS,\n        isFreeBSD: os$1.isFreeBSD,\n        isiOS: os$1.isiOS,\n        isLinux: os$1.isLinux,\n        isMacOS: os$1.isMacOS,\n        isSolaris: os$1.isSolaris,\n        isWindows: os$1.isWindows\n      },\n      deviceType: {\n        isDesktop: deviceType.isDesktop,\n        isiPad: deviceType.isiPad,\n        isiPhone: deviceType.isiPhone,\n        isPhone: deviceType.isPhone,\n        isTablet: deviceType.isTablet,\n        isTouch: deviceType.isTouch,\n        isWebView: deviceType.isWebView\n      }\n    };\n\n    const whiteSpaceRegExp$1 = /^\\s*|\\s*$/g;\n    const trim$3 = str => {\n      return isNullable(str) ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');\n    };\n    const is$3 = (obj, type) => {\n      if (!type) {\n        return obj !== undefined;\n      }\n      if (type === 'array' && isArray(obj)) {\n        return true;\n      }\n      return typeof obj === type;\n    };\n    const makeMap$4 = (items, delim, map = {}) => {\n      const resolvedItems = isString(items) ? items.split(delim || ',') : items || [];\n      let i = resolvedItems.length;\n      while (i--) {\n        map[resolvedItems[i]] = {};\n      }\n      return map;\n    };\n    const hasOwnProperty = has$2;\n    const extend$3 = (obj, ...exts) => {\n      for (let i = 0; i < exts.length; i++) {\n        const ext = exts[i];\n        for (const name in ext) {\n          if (has$2(ext, name)) {\n            const value = ext[name];\n            if (value !== undefined) {\n              obj[name] = value;\n            }\n          }\n        }\n      }\n      return obj;\n    };\n    const walk$4 = function (o, f, n, s) {\n      s = s || this;\n      if (o) {\n        if (n) {\n          o = o[n];\n        }\n        each$c(o, (o, i) => {\n          if (f.call(s, o, i, n) === false) {\n            return false;\n          } else {\n            walk$4(o, f, n, s);\n            return true;\n          }\n        });\n      }\n    };\n    const resolve$3 = (n, o = window) => {\n      const path = n.split('.');\n      for (let i = 0, l = path.length; i < l; i++) {\n        o = o[path[i]];\n        if (!o) {\n          break;\n        }\n      }\n      return o;\n    };\n    const explode$3 = (s, d) => {\n      if (isArray$1(s)) {\n        return s;\n      } else if (s === '') {\n        return [];\n      } else {\n        return map$1(s.split(d || ','), trim$3);\n      }\n    };\n    const _addCacheSuffix = url => {\n      const cacheSuffix = Env.cacheSuffix;\n      if (cacheSuffix) {\n        url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;\n      }\n      return url;\n    };\n    const Tools = {\n      trim: trim$3,\n      isArray: isArray,\n      is: is$3,\n      toArray: toArray$1,\n      makeMap: makeMap$4,\n      each: each$c,\n      map: map$1,\n      grep: filter$3,\n      inArray: indexOf,\n      hasOwn: hasOwnProperty,\n      extend: extend$3,\n      walk: walk$4,\n      resolve: resolve$3,\n      explode: explode$3,\n      _addCacheSuffix\n    };\n\n    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\n    const cat = arr => {\n      const r = [];\n      const push = x => {\n        r.push(x);\n      };\n      for (let i = 0; i < arr.length; i++) {\n        arr[i].each(push);\n      }\n      return r;\n    };\n    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\n    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n\n    const Global = typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const path = (parts, scope) => {\n      let o = scope !== undefined && scope !== null ? scope : Global;\n      for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n        o = o[parts[i]];\n      }\n      return o;\n    };\n    const resolve$2 = (p, scope) => {\n      const parts = p.split('.');\n      return path(parts, scope);\n    };\n\n    const unsafe = (name, scope) => {\n      return resolve$2(name, scope);\n    };\n    const getOrDie = (name, scope) => {\n      const actual = unsafe(name, scope);\n      if (actual === undefined || actual === null) {\n        throw new Error(name + ' not available on this browser');\n      }\n      return actual;\n    };\n\n    const getPrototypeOf$1 = Object.getPrototypeOf;\n    const sandHTMLElement = scope => {\n      return getOrDie('HTMLElement', scope);\n    };\n    const isPrototypeOf = x => {\n      const scope = resolve$2('ownerDocument.defaultView', x);\n      return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf$1(x).constructor.name));\n    };\n\n    const COMMENT = 8;\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const name = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type$1 = element => element.dom.nodeType;\n    const isType = t => element => type$1(element) === t;\n    const isComment$1 = element => type$1(element) === COMMENT || name(element) === '#comment';\n    const isHTMLElement$1 = element => isElement$7(element) && isPrototypeOf(element.dom);\n    const isElement$7 = isType(ELEMENT);\n    const isText$c = isType(TEXT);\n    const isDocument$2 = isType(DOCUMENT);\n    const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);\n    const isTag = tag => e => isElement$7(e) && name(e) === tag;\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const set$3 = (element, key, value) => {\n      rawSet(element.dom, key, value);\n    };\n    const setAll$1 = (element, attrs) => {\n      const dom = element.dom;\n      each$d(attrs, (v, k) => {\n        rawSet(dom, k, v);\n      });\n    };\n    const get$9 = (element, key) => {\n      const v = element.dom.getAttribute(key);\n      return v === null ? undefined : v;\n    };\n    const getOpt = (element, key) => Optional.from(get$9(element, key));\n    const has$1 = (element, key) => {\n      const dom = element.dom;\n      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\n    };\n    const remove$9 = (element, key) => {\n      element.dom.removeAttribute(key);\n    };\n    const hasNone = element => {\n      const attrs = element.dom.attributes;\n      return attrs === undefined || attrs === null || attrs.length === 0;\n    };\n    const clone$4 = element => foldl(element.dom.attributes, (acc, attr) => {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n\n    const read$4 = (element, attr) => {\n      const value = get$9(element, attr);\n      return value === undefined || value === '' ? [] : value.split(' ');\n    };\n    const add$4 = (element, attr, id) => {\n      const old = read$4(element, attr);\n      const nu = old.concat([id]);\n      set$3(element, attr, nu.join(' '));\n      return true;\n    };\n    const remove$8 = (element, attr, id) => {\n      const nu = filter$5(read$4(element, attr), v => v !== id);\n      if (nu.length > 0) {\n        set$3(element, attr, nu.join(' '));\n      } else {\n        remove$9(element, attr);\n      }\n      return false;\n    };\n\n    const supports = element => element.dom.classList !== undefined;\n    const get$8 = element => read$4(element, 'class');\n    const add$3 = (element, clazz) => add$4(element, 'class', clazz);\n    const remove$7 = (element, clazz) => remove$8(element, 'class', clazz);\n    const toggle$2 = (element, clazz) => {\n      if (contains$2(get$8(element), clazz)) {\n        return remove$7(element, clazz);\n      } else {\n        return add$3(element, clazz);\n      }\n    };\n\n    const add$2 = (element, clazz) => {\n      if (supports(element)) {\n        element.dom.classList.add(clazz);\n      } else {\n        add$3(element, clazz);\n      }\n    };\n    const cleanClass = element => {\n      const classList = supports(element) ? element.dom.classList : get$8(element);\n      if (classList.length === 0) {\n        remove$9(element, 'class');\n      }\n    };\n    const remove$6 = (element, clazz) => {\n      if (supports(element)) {\n        const classList = element.dom.classList;\n        classList.remove(clazz);\n      } else {\n        remove$7(element, clazz);\n      }\n      cleanClass(element);\n    };\n    const toggle$1 = (element, clazz) => {\n      const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);\n      cleanClass(element);\n      return result;\n    };\n    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n\n    const fromHtml$1 = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom$2(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom$2(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom$2(node);\n    };\n    const fromDom$2 = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);\n    const SugarElement = {\n      fromHtml: fromHtml$1,\n      fromTag,\n      fromText,\n      fromDom: fromDom$2,\n      fromPoint: fromPoint$2\n    };\n\n    const toArray = (target, f) => {\n      const r = [];\n      const recurse = e => {\n        r.push(e);\n        return f(e);\n      };\n      let cur = f(target);\n      do {\n        cur = cur.bind(recurse);\n      } while (cur.isSome());\n      return r;\n    };\n\n    const is$1 = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n    const all = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n    const one = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n    };\n\n    const eq = (e1, e2) => e1.dom === e2.dom;\n    const contains = (e1, e2) => {\n      const d1 = e1.dom;\n      const d2 = e2.dom;\n      return d1 === d2 ? false : d1.contains(d2);\n    };\n\n    const owner$1 = element => SugarElement.fromDom(element.dom.ownerDocument);\n    const documentOrOwner = dos => isDocument$2(dos) ? dos : owner$1(dos);\n    const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n    const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const parents$1 = (element, isRoot) => {\n      const stop = isFunction(isRoot) ? isRoot : never;\n      let dom = element.dom;\n      const ret = [];\n      while (dom.parentNode !== null && dom.parentNode !== undefined) {\n        const rawParent = dom.parentNode;\n        const p = SugarElement.fromDom(rawParent);\n        ret.push(p);\n        if (stop(p) === true) {\n          break;\n        } else {\n          dom = rawParent;\n        }\n      }\n      return ret;\n    };\n    const siblings = element => {\n      const filterSelf = elements => filter$5(elements, x => !eq(element, x));\n      return parent(element).map(children$1).map(filterSelf).getOr([]);\n    };\n    const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const prevSiblings = element => reverse(toArray(element, prevSibling));\n    const nextSiblings = element => toArray(element, nextSibling);\n    const children$1 = element => map$3(element.dom.childNodes, SugarElement.fromDom);\n    const child$1 = (element, index) => {\n      const cs = element.dom.childNodes;\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = element => child$1(element, 0);\n    const lastChild = element => child$1(element, element.dom.childNodes.length - 1);\n    const childNodesCount = element => element.dom.childNodes.length;\n\n    const getHead = doc => {\n      const b = doc.dom.head;\n      if (b === null || b === undefined) {\n        throw new Error('Head is not available yet');\n      }\n      return SugarElement.fromDom(b);\n    };\n\n    const isShadowRoot = dos => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);\n    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n    const isSupported$1 = constant(supported);\n    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n    const getStyleContainer = dos => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));\n    const getContentContainer = dos => isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);\n    const getShadowRoot = e => {\n      const r = getRootNode(e);\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n    const getOriginalEventTarget = event => {\n      if (isSupported$1() && isNonNullable(event.target)) {\n        const el = SugarElement.fromDom(event.target);\n        if (isElement$7(el) && isOpenShadowHost(el)) {\n          if (event.composed && event.composedPath) {\n            const composedPath = event.composedPath();\n            if (composedPath) {\n              return head(composedPath);\n            }\n          }\n        }\n      }\n      return Optional.from(event.target);\n    };\n    const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\n\n    const inBody = element => {\n      const dom = isText$c(element) ? element.dom.parentNode : element.dom;\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\n        return false;\n      }\n      const doc = dom.ownerDocument;\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n      if (is(scope, a)) {\n        return Optional.some(scope);\n      } else if (isFunction(isRoot) && isRoot(scope)) {\n        return Optional.none();\n      } else {\n        return ancestor(scope, a, isRoot);\n      }\n    };\n\n    const ancestor$4 = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$4 = (scope, predicate, isRoot) => {\n      const is = (s, test) => test(s);\n      return ClosestOrAncestor(is, ancestor$4, scope, predicate, isRoot);\n    };\n    const sibling$1 = (scope, predicate) => {\n      const element = scope.dom;\n      if (!element.parentNode) {\n        return Optional.none();\n      }\n      return child(SugarElement.fromDom(element.parentNode), x => !eq(scope, x) && predicate(x));\n    };\n    const child = (scope, predicate) => {\n      const pred = node => predicate(SugarElement.fromDom(node));\n      const result = find$2(scope.dom.childNodes, pred);\n      return result.map(SugarElement.fromDom);\n    };\n    const descendant$2 = (scope, predicate) => {\n      const descend = node => {\n        for (let i = 0; i < node.childNodes.length; i++) {\n          const child = SugarElement.fromDom(node.childNodes[i]);\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(node.childNodes[i]);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope.dom);\n    };\n\n    const ancestor$3 = (scope, selector, isRoot) => ancestor$4(scope, e => is$1(e, selector), isRoot);\n    const descendant$1 = (scope, selector) => one(selector, scope);\n    const closest$3 = (scope, selector, isRoot) => {\n      const is = (element, selector) => is$1(element, selector);\n      return ClosestOrAncestor(is, ancestor$3, scope, selector, isRoot);\n    };\n\n    const closest$2 = target => closest$3(target, '[contenteditable]');\n    const isEditable$2 = (element, assumeEditable = false) => {\n      if (inBody(element)) {\n        return element.dom.isContentEditable;\n      } else {\n        return closest$2(element).fold(constant(assumeEditable), editable => getRaw$1(editable) === 'true');\n      }\n    };\n    const getRaw$1 = element => element.dom.contentEditable;\n\n    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const internalSet = (dom, property, value) => {\n      if (!isString(value)) {\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n        throw new Error('CSS value must be a string: ' + value);\n      }\n      if (isSupported(dom)) {\n        dom.style.setProperty(property, value);\n      }\n    };\n    const internalRemove = (dom, property) => {\n      if (isSupported(dom)) {\n        dom.style.removeProperty(property);\n      }\n    };\n    const set$2 = (element, property, value) => {\n      const dom = element.dom;\n      internalSet(dom, property, value);\n    };\n    const setAll = (element, css) => {\n      const dom = element.dom;\n      each$d(css, (v, k) => {\n        internalSet(dom, k, v);\n      });\n    };\n    const get$7 = (element, property) => {\n      const dom = element.dom;\n      const styles = window.getComputedStyle(dom);\n      const r = styles.getPropertyValue(property);\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n    };\n    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\n    const getRaw = (element, property) => {\n      const dom = element.dom;\n      const raw = getUnsafeProperty(dom, property);\n      return Optional.from(raw).filter(r => r.length > 0);\n    };\n    const getAllRaw = element => {\n      const css = {};\n      const dom = element.dom;\n      if (isSupported(dom)) {\n        for (let i = 0; i < dom.style.length; i++) {\n          const ruleName = dom.style.item(i);\n          css[ruleName] = dom.style[ruleName];\n        }\n      }\n      return css;\n    };\n    const remove$5 = (element, property) => {\n      const dom = element.dom;\n      internalRemove(dom, property);\n      if (is$2(getOpt(element, 'style').map(trim$4), '')) {\n        remove$9(element, 'style');\n      }\n    };\n    const reflow = e => e.dom.offsetWidth;\n\n    const before$3 = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const after$4 = (marker, element) => {\n      const sibling = nextSibling(marker);\n      sibling.fold(() => {\n        const parent$1 = parent(marker);\n        parent$1.each(v => {\n          append$1(v, element);\n        });\n      }, v => {\n        before$3(v, element);\n      });\n    };\n    const prepend = (parent, element) => {\n      const firstChild$1 = firstChild(parent);\n      firstChild$1.fold(() => {\n        append$1(parent, element);\n      }, v => {\n        parent.dom.insertBefore(element.dom, v.dom);\n      });\n    };\n    const append$1 = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n    const wrap$2 = (element, wrapper) => {\n      before$3(element, wrapper);\n      append$1(wrapper, element);\n    };\n\n    const after$3 = (marker, elements) => {\n      each$e(elements, (x, i) => {\n        const e = i === 0 ? marker : elements[i - 1];\n        after$4(e, x);\n      });\n    };\n    const append = (parent, elements) => {\n      each$e(elements, x => {\n        append$1(parent, x);\n      });\n    };\n\n    const empty = element => {\n      element.dom.textContent = '';\n      each$e(children$1(element), rogue => {\n        remove$4(rogue);\n      });\n    };\n    const remove$4 = element => {\n      const dom = element.dom;\n      if (dom.parentNode !== null) {\n        dom.parentNode.removeChild(dom);\n      }\n    };\n    const unwrap = wrapper => {\n      const children = children$1(wrapper);\n      if (children.length > 0) {\n        after$3(wrapper, children);\n      }\n      remove$4(wrapper);\n    };\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      return children$1(SugarElement.fromDom(div));\n    };\n    const fromDom$1 = nodes => map$3(nodes, SugarElement.fromDom);\n\n    const get$6 = element => element.dom.innerHTML;\n    const set$1 = (element, content) => {\n      const owner = owner$1(element);\n      const docDom = owner.dom;\n      const fragment = SugarElement.fromDom(docDom.createDocumentFragment());\n      const contentElements = fromHtml(content, docDom);\n      append(fragment, contentElements);\n      empty(element);\n      append$1(element, fragment);\n    };\n    const getOuter = element => {\n      const container = SugarElement.fromTag('div');\n      const clone = SugarElement.fromDom(element.dom.cloneNode(true));\n      append$1(container, clone);\n      return get$6(container);\n    };\n\n    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\n      target,\n      x,\n      y,\n      stop,\n      prevent,\n      kill,\n      raw\n    });\n    const fromRawEvent = rawEvent => {\n      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n      const stop = () => rawEvent.stopPropagation();\n      const prevent = () => rawEvent.preventDefault();\n      const kill = compose(prevent, stop);\n      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n    };\n    const handle$1 = (filter, handler) => rawEvent => {\n      if (filter(rawEvent)) {\n        handler(fromRawEvent(rawEvent));\n      }\n    };\n    const binder = (element, event, filter, handler, useCapture) => {\n      const wrapped = handle$1(filter, handler);\n      element.dom.addEventListener(event, wrapped, useCapture);\n      return { unbind: curry(unbind, element, event, wrapped, useCapture) };\n    };\n    const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\n    const unbind = (element, event, handler, useCapture) => {\n      element.dom.removeEventListener(event, handler, useCapture);\n    };\n\n    const r = (left, top) => {\n      const translate = (x, y) => r(left + x, top + y);\n      return {\n        left,\n        top,\n        translate\n      };\n    };\n    const SugarPosition = r;\n\n    const boxPosition = dom => {\n      const box = dom.getBoundingClientRect();\n      return SugarPosition(box.left, box.top);\n    };\n    const firstDefinedOrZero = (a, b) => {\n      if (a !== undefined) {\n        return a;\n      } else {\n        return b !== undefined ? b : 0;\n      }\n    };\n    const absolute = element => {\n      const doc = element.dom.ownerDocument;\n      const body = doc.body;\n      const win = doc.defaultView;\n      const html = doc.documentElement;\n      if (body === element.dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n      const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n      const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n      const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n    };\n    const viewport = element => {\n      const dom = element.dom;\n      const doc = dom.ownerDocument;\n      const body = doc.body;\n      if (body === dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      if (!inBody(element)) {\n        return SugarPosition(0, 0);\n      }\n      return boxPosition(dom);\n    };\n\n    const get$5 = _DOC => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n      const y = doc.body.scrollTop || doc.documentElement.scrollTop;\n      return SugarPosition(x, y);\n    };\n    const to = (x, y, _DOC) => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const win = doc.defaultView;\n      if (win) {\n        win.scrollTo(x, y);\n      }\n    };\n    const intoView = (element, alignToTop) => {\n      const isSafari = detect$1().browser.isSafari();\n      if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {\n        element.dom.scrollIntoViewIfNeeded(false);\n      } else {\n        element.dom.scrollIntoView(alignToTop);\n      }\n    };\n\n    const get$4 = _win => {\n      const win = _win === undefined ? window : _win;\n      if (detect$1().browser.isFirefox()) {\n        return Optional.none();\n      } else {\n        return Optional.from(win.visualViewport);\n      }\n    };\n    const bounds = (x, y, width, height) => ({\n      x,\n      y,\n      width,\n      height,\n      right: x + width,\n      bottom: y + height\n    });\n    const getBounds = _win => {\n      const win = _win === undefined ? window : _win;\n      const doc = win.document;\n      const scroll = get$5(SugarElement.fromDom(doc));\n      return get$4(win).fold(() => {\n        const html = win.document.documentElement;\n        const width = html.clientWidth;\n        const height = html.clientHeight;\n        return bounds(scroll.left, scroll.top, width, height);\n      }, visualViewport => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));\n    };\n\n    const children = (scope, predicate) => filter$5(children$1(scope), predicate);\n    const descendants$1 = (scope, predicate) => {\n      let result = [];\n      each$e(children$1(scope), x => {\n        if (predicate(x)) {\n          result = result.concat([x]);\n        }\n        result = result.concat(descendants$1(x, predicate));\n      });\n      return result;\n    };\n\n    const descendants = (scope, selector) => all(selector, scope);\n\n    const ancestor$2 = (scope, predicate, isRoot) => ancestor$4(scope, predicate, isRoot).isSome();\n    const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();\n    const descendant = (scope, predicate) => descendant$2(scope, predicate).isSome();\n\n    class DomTreeWalker {\n      constructor(startNode, rootNode) {\n        this.node = startNode;\n        this.rootNode = rootNode;\n        this.current = this.current.bind(this);\n        this.next = this.next.bind(this);\n        this.prev = this.prev.bind(this);\n        this.prev2 = this.prev2.bind(this);\n      }\n      current() {\n        return this.node;\n      }\n      next(shallow) {\n        this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);\n        return this.node;\n      }\n      prev(shallow) {\n        this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);\n        return this.node;\n      }\n      prev2(shallow) {\n        this.node = this.findPreviousNode(this.node, shallow);\n        return this.node;\n      }\n      findSibling(node, startName, siblingName, shallow) {\n        if (node) {\n          if (!shallow && node[startName]) {\n            return node[startName];\n          }\n          if (node !== this.rootNode) {\n            let sibling = node[siblingName];\n            if (sibling) {\n              return sibling;\n            }\n            for (let parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {\n              sibling = parent[siblingName];\n              if (sibling) {\n                return sibling;\n              }\n            }\n          }\n        }\n        return undefined;\n      }\n      findPreviousNode(node, shallow) {\n        if (node) {\n          const sibling = node.previousSibling;\n          if (this.rootNode && sibling === this.rootNode) {\n            return;\n          }\n          if (sibling) {\n            if (!shallow) {\n              for (let child = sibling.lastChild; child; child = child.lastChild) {\n                if (!child.lastChild) {\n                  return child;\n                }\n              }\n            }\n            return sibling;\n          }\n          const parent = node.parentNode;\n          if (parent && parent !== this.rootNode) {\n            return parent;\n          }\n        }\n        return undefined;\n      }\n    }\n\n    const zeroWidth = '\\uFEFF';\n    const nbsp = '\\xA0';\n    const isZwsp$2 = char => char === zeroWidth;\n    const removeZwsp = s => s.replace(/\\uFEFF/g, '');\n\n    const whiteSpaceRegExp = /^[ \\t\\r\\n]*$/;\n    const isWhitespaceText = text => whiteSpaceRegExp.test(text);\n    const isZwsp$1 = text => {\n      for (const c of text) {\n        if (!isZwsp$2(c)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const isCollapsibleWhitespace$1 = c => ' \\f\\t\\x0B'.indexOf(c) !== -1;\n    const isNewLineChar = c => c === '\\n' || c === '\\r';\n    const isNewline = (text, idx) => idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;\n    const normalize$4 = (text, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {\n      const tabSpace = repeat(' ', tabSpaces);\n      const normalizedText = text.replace(/\\t/g, tabSpace);\n      const result = foldl(normalizedText, (acc, c) => {\n        if (isCollapsibleWhitespace$1(c) || c === nbsp) {\n          if (acc.pcIsSpace || acc.str === '' && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {\n            return {\n              pcIsSpace: false,\n              str: acc.str + nbsp\n            };\n          } else {\n            return {\n              pcIsSpace: true,\n              str: acc.str + ' '\n            };\n          }\n        } else {\n          return {\n            pcIsSpace: isNewLineChar(c),\n            str: acc.str + c\n          };\n        }\n      }, {\n        pcIsSpace: false,\n        str: ''\n      });\n      return result.str;\n    };\n\n    const isNodeType = type => {\n      return node => {\n        return !!node && node.nodeType === type;\n      };\n    };\n    const isRestrictedNode = node => !!node && !Object.getPrototypeOf(node);\n    const isElement$6 = isNodeType(1);\n    const isHTMLElement = node => isElement$6(node) && isHTMLElement$1(SugarElement.fromDom(node));\n    const isSVGElement = node => isElement$6(node) && node.namespaceURI === 'http://www.w3.org/2000/svg';\n    const matchNodeName = name => {\n      const lowerCasedName = name.toLowerCase();\n      return node => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;\n    };\n    const matchNodeNames = names => {\n      const lowerCasedNames = names.map(s => s.toLowerCase());\n      return node => {\n        if (node && node.nodeName) {\n          const nodeName = node.nodeName.toLowerCase();\n          return contains$2(lowerCasedNames, nodeName);\n        }\n        return false;\n      };\n    };\n    const matchStyleValues = (name, values) => {\n      const items = values.toLowerCase().split(' ');\n      return node => {\n        if (isElement$6(node)) {\n          const win = node.ownerDocument.defaultView;\n          if (win) {\n            for (let i = 0; i < items.length; i++) {\n              const computed = win.getComputedStyle(node, null);\n              const cssValue = computed ? computed.getPropertyValue(name) : null;\n              if (cssValue === items[i]) {\n                return true;\n              }\n            }\n          }\n        }\n        return false;\n      };\n    };\n    const hasAttribute = attrName => {\n      return node => {\n        return isElement$6(node) && node.hasAttribute(attrName);\n      };\n    };\n    const isBogus$1 = node => isElement$6(node) && node.hasAttribute('data-mce-bogus');\n    const isBogusAll = node => isElement$6(node) && node.getAttribute('data-mce-bogus') === 'all';\n    const isTable$2 = node => isElement$6(node) && node.tagName === 'TABLE';\n    const hasContentEditableState = value => {\n      return node => {\n        if (isHTMLElement(node)) {\n          if (node.contentEditable === value) {\n            return true;\n          }\n          if (node.getAttribute('data-mce-contenteditable') === value) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const isTextareaOrInput = matchNodeNames([\n      'textarea',\n      'input'\n    ]);\n    const isText$b = isNodeType(3);\n    const isCData = isNodeType(4);\n    const isPi = isNodeType(7);\n    const isComment = isNodeType(8);\n    const isDocument$1 = isNodeType(9);\n    const isDocumentFragment = isNodeType(11);\n    const isBr$6 = matchNodeName('br');\n    const isImg = matchNodeName('img');\n    const isContentEditableTrue$3 = hasContentEditableState('true');\n    const isContentEditableFalse$b = hasContentEditableState('false');\n    const isTableCell$3 = matchNodeNames([\n      'td',\n      'th'\n    ]);\n    const isTableCellOrCaption = matchNodeNames([\n      'td',\n      'th',\n      'caption'\n    ]);\n    const isMedia$2 = matchNodeNames([\n      'video',\n      'audio',\n      'object',\n      'embed'\n    ]);\n    const isListItem$2 = matchNodeName('li');\n    const isDetails = matchNodeName('details');\n    const isSummary$1 = matchNodeName('summary');\n\n    const defaultOptionValues = {\n      skipBogus: true,\n      includeZwsp: false,\n      checkRootAsContent: false\n    };\n    const hasWhitespacePreserveParent = (node, rootNode, schema) => {\n      const rootElement = SugarElement.fromDom(rootNode);\n      const startNode = SugarElement.fromDom(node);\n      const whitespaceElements = schema.getWhitespaceElements();\n      const predicate = node => has$2(whitespaceElements, name(node));\n      return ancestor$2(startNode, predicate, curry(eq, rootElement));\n    };\n    const isNamedAnchor = node => {\n      return isElement$6(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));\n    };\n    const isNonEmptyElement$1 = (node, schema) => {\n      return isElement$6(node) && has$2(schema.getNonEmptyElements(), node.nodeName);\n    };\n    const isBookmark = hasAttribute('data-mce-bookmark');\n    const hasNonEditableParent = node => parentElement(SugarElement.fromDom(node)).exists(parent => !isEditable$2(parent));\n    const isWhitespace$1 = (node, rootNode, schema) => isWhitespaceText(node.data) && !hasWhitespacePreserveParent(node, rootNode, schema);\n    const isText$a = (node, rootNode, schema, options) => isText$b(node) && !isWhitespace$1(node, rootNode, schema) && (!options.includeZwsp || !isZwsp$1(node.data));\n    const isContentNode = (schema, node, rootNode, options) => {\n      return isFunction(options.isContent) && options.isContent(node) || isNonEmptyElement$1(node, schema) || isBookmark(node) || isNamedAnchor(node) || isText$a(node, rootNode, schema, options) || isContentEditableFalse$b(node) || isContentEditableTrue$3(node) && hasNonEditableParent(node);\n    };\n    const isEmptyNode = (schema, targetNode, opts) => {\n      const options = {\n        ...defaultOptionValues,\n        ...opts\n      };\n      if (options.checkRootAsContent) {\n        if (isContentNode(schema, targetNode, targetNode, options)) {\n          return false;\n        }\n      }\n      let node = targetNode.firstChild;\n      let brCount = 0;\n      if (!node) {\n        return true;\n      }\n      const walker = new DomTreeWalker(node, targetNode);\n      do {\n        if (options.skipBogus && isElement$6(node)) {\n          const bogusValue = node.getAttribute('data-mce-bogus');\n          if (bogusValue) {\n            node = walker.next(bogusValue === 'all');\n            continue;\n          }\n        }\n        if (isComment(node)) {\n          node = walker.next(true);\n          continue;\n        }\n        if (isBr$6(node)) {\n          brCount++;\n          node = walker.next();\n          continue;\n        }\n        if (isContentNode(schema, node, targetNode, options)) {\n          return false;\n        }\n        node = walker.next();\n      } while (node);\n      return brCount <= 1;\n    };\n    const isEmpty$2 = (schema, elm, options) => {\n      return isEmptyNode(schema, elm.dom, {\n        checkRootAsContent: true,\n        ...options\n      });\n    };\n    const isContent$1 = (schema, node, options) => {\n      return isContentNode(schema, node, node, {\n        includeZwsp: defaultOptionValues.includeZwsp,\n        ...options\n      });\n    };\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    const singleton = doRevoke => {\n      const subject = Cell(Optional.none());\n      const revoke = () => subject.get().each(doRevoke);\n      const clear = () => {\n        revoke();\n        subject.set(Optional.none());\n      };\n      const isSet = () => subject.get().isSome();\n      const get = () => subject.get();\n      const set = s => {\n        revoke();\n        subject.set(Optional.some(s));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const repeatable = delay => {\n      const intervalId = Cell(Optional.none());\n      const revoke = () => intervalId.get().each(id => clearInterval(id));\n      const clear = () => {\n        revoke();\n        intervalId.set(Optional.none());\n      };\n      const isSet = () => intervalId.get().isSome();\n      const get = () => intervalId.get();\n      const set = functionToRepeat => {\n        revoke();\n        intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const value$2 = () => {\n      const subject = singleton(noop);\n      const on = f => subject.get().each(f);\n      return {\n        ...subject,\n        on\n      };\n    };\n\n    const nodeNameToNamespaceType = name => {\n      const lowerCaseName = name.toLowerCase();\n      if (lowerCaseName === 'svg') {\n        return 'svg';\n      } else if (lowerCaseName === 'math') {\n        return 'math';\n      } else {\n        return 'html';\n      }\n    };\n    const isNonHtmlElementRootName = name => nodeNameToNamespaceType(name) !== 'html';\n    const isNonHtmlElementRoot = node => isNonHtmlElementRootName(node.nodeName);\n    const toScopeType = node => nodeNameToNamespaceType(node.nodeName);\n    const namespaceElements = [\n      'svg',\n      'math'\n    ];\n    const createNamespaceTracker = () => {\n      const currentScope = value$2();\n      const current = () => currentScope.get().map(toScopeType).getOr('html');\n      const track = node => {\n        if (isNonHtmlElementRoot(node)) {\n          currentScope.set(node);\n        } else if (currentScope.get().exists(scopeNode => !scopeNode.contains(node))) {\n          currentScope.clear();\n        }\n        return current();\n      };\n      const reset = () => {\n        currentScope.clear();\n      };\n      return {\n        track,\n        current,\n        reset\n      };\n    };\n\n    const transparentBlockAttr = 'data-mce-block';\n    const elementNames = map => filter$5(keys(map), key => !/[A-Z]/.test(key));\n    const makeSelectorFromSchemaMap = map => map$3(elementNames(map), name => {\n      const escapedName = CSS.escape(name);\n      return `${ escapedName }:` + map$3(namespaceElements, ns => `not(${ ns } ${ escapedName })`).join(':');\n    }).join(',');\n    const updateTransparent = (blocksSelector, transparent) => {\n      if (isNonNullable(transparent.querySelector(blocksSelector))) {\n        transparent.setAttribute(transparentBlockAttr, 'true');\n        if (transparent.getAttribute('data-mce-selected') === 'inline-boundary') {\n          transparent.removeAttribute('data-mce-selected');\n        }\n        return true;\n      } else {\n        transparent.removeAttribute(transparentBlockAttr);\n        return false;\n      }\n    };\n    const updateBlockStateOnChildren = (schema, scope) => {\n      const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());\n      const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\n      return filter$5(scope.querySelectorAll(transparentSelector), transparent => updateTransparent(blocksSelector, transparent));\n    };\n    const trimEdge = (schema, el, leftSide) => {\n      var _a;\n      const childPropertyName = leftSide ? 'lastChild' : 'firstChild';\n      for (let child = el[childPropertyName]; child; child = child[childPropertyName]) {\n        if (isEmptyNode(schema, child, { checkRootAsContent: true })) {\n          (_a = child.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child);\n          return;\n        }\n      }\n    };\n    const split$2 = (schema, parentElm, splitElm) => {\n      const range = document.createRange();\n      const parentNode = parentElm.parentNode;\n      if (parentNode) {\n        range.setStartBefore(parentElm);\n        range.setEndBefore(splitElm);\n        const beforeFragment = range.extractContents();\n        trimEdge(schema, beforeFragment, true);\n        range.setStartAfter(splitElm);\n        range.setEndAfter(parentElm);\n        const afterFragment = range.extractContents();\n        trimEdge(schema, afterFragment, false);\n        if (!isEmptyNode(schema, beforeFragment, { checkRootAsContent: true })) {\n          parentNode.insertBefore(beforeFragment, parentElm);\n        }\n        if (!isEmptyNode(schema, splitElm, { checkRootAsContent: true })) {\n          parentNode.insertBefore(splitElm, parentElm);\n        }\n        if (!isEmptyNode(schema, afterFragment, { checkRootAsContent: true })) {\n          parentNode.insertBefore(afterFragment, parentElm);\n        }\n        parentNode.removeChild(parentElm);\n      }\n    };\n    const splitInvalidChildren = (schema, scope, transparentBlocks) => {\n      const blocksElements = schema.getBlockElements();\n      const rootNode = SugarElement.fromDom(scope);\n      const isBlock = el => name(el) in blocksElements;\n      const isRoot = el => eq(el, rootNode);\n      each$e(fromDom$1(transparentBlocks), transparentBlock => {\n        ancestor$4(transparentBlock, isBlock, isRoot).each(parentBlock => {\n          const invalidChildren = children(transparentBlock, el => isBlock(el) && !schema.isValidChild(name(parentBlock), name(el)));\n          if (invalidChildren.length > 0) {\n            const stateScope = parentElement(parentBlock);\n            each$e(invalidChildren, child => {\n              ancestor$4(child, isBlock, isRoot).each(parentBlock => {\n                split$2(schema, parentBlock.dom, child.dom);\n              });\n            });\n            stateScope.each(scope => updateBlockStateOnChildren(schema, scope.dom));\n          }\n        });\n      });\n    };\n    const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {\n      each$e([\n        ...transparentBlocks,\n        ...isTransparentBlock(schema, scope) ? [scope] : []\n      ], block => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), elm => {\n        if (isTransparentInline(schema, elm.dom)) {\n          unwrap(elm);\n        }\n      }));\n    };\n    const updateChildren = (schema, scope) => {\n      const transparentBlocks = updateBlockStateOnChildren(schema, scope);\n      splitInvalidChildren(schema, scope, transparentBlocks);\n      unwrapInvalidChildren(schema, scope, transparentBlocks);\n    };\n    const updateElement = (schema, target) => {\n      if (isTransparentElement(schema, target)) {\n        const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\n        updateTransparent(blocksSelector, target);\n      }\n    };\n    const updateCaret = (schema, root, caretParent) => {\n      const isRoot = el => eq(el, SugarElement.fromDom(root));\n      const parents = parents$1(SugarElement.fromDom(caretParent), isRoot);\n      get$b(parents, parents.length - 2).filter(isElement$7).fold(() => updateChildren(schema, root), scope => updateChildren(schema, scope.dom));\n    };\n    const hasBlockAttr = el => el.hasAttribute(transparentBlockAttr);\n    const isTransparentElementName = (schema, name) => has$2(schema.getTransparentElements(), name);\n    const isTransparentElement = (schema, node) => isElement$6(node) && isTransparentElementName(schema, node.nodeName);\n    const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);\n    const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);\n    const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString(node.attr(transparentBlockAttr));\n\n    const browser$2 = detect$1().browser;\n    const firstElement = nodes => find$2(nodes, isElement$7);\n    const getTableCaptionDeltaY = elm => {\n      if (browser$2.isFirefox() && name(elm) === 'table') {\n        return firstElement(children$1(elm)).filter(elm => {\n          return name(elm) === 'caption';\n        }).bind(caption => {\n          return firstElement(nextSiblings(caption)).map(body => {\n            const bodyTop = body.dom.offsetTop;\n            const captionTop = caption.dom.offsetTop;\n            const captionHeight = caption.dom.offsetHeight;\n            return bodyTop <= captionTop ? -captionHeight : 0;\n          });\n        }).getOr(0);\n      } else {\n        return 0;\n      }\n    };\n    const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);\n    const getPos = (body, elm, rootElm) => {\n      let x = 0, y = 0;\n      const doc = body.ownerDocument;\n      rootElm = rootElm ? rootElm : body;\n      if (elm) {\n        if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {\n          const pos = elm.getBoundingClientRect();\n          x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;\n          y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;\n          return {\n            x,\n            y\n          };\n        }\n        let offsetParent = elm;\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n          const castOffsetParent = offsetParent;\n          x += castOffsetParent.offsetLeft || 0;\n          y += castOffsetParent.offsetTop || 0;\n          offsetParent = castOffsetParent.offsetParent;\n        }\n        offsetParent = elm.parentNode;\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n          x -= offsetParent.scrollLeft || 0;\n          y -= offsetParent.scrollTop || 0;\n          offsetParent = offsetParent.parentNode;\n        }\n        y += getTableCaptionDeltaY(SugarElement.fromDom(elm));\n      }\n      return {\n        x,\n        y\n      };\n    };\n\n    const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {\n      let idCount = 0;\n      const loadedStates = {};\n      const edos = SugarElement.fromDom(documentOrShadowRoot);\n      const doc = documentOrOwner(edos);\n      const _setReferrerPolicy = referrerPolicy => {\n        settings.referrerPolicy = referrerPolicy;\n      };\n      const _setContentCssCors = contentCssCors => {\n        settings.contentCssCors = contentCssCors;\n      };\n      const addStyle = element => {\n        append$1(getStyleContainer(edos), element);\n      };\n      const removeStyle = id => {\n        const styleContainer = getStyleContainer(edos);\n        descendant$1(styleContainer, '#' + id).each(remove$4);\n      };\n      const getOrCreateState = url => get$a(loadedStates, url).getOrThunk(() => ({\n        id: 'mce-u' + idCount++,\n        passed: [],\n        failed: [],\n        count: 0\n      }));\n      const load = url => new Promise((success, failure) => {\n        let link;\n        const urlWithSuffix = Tools._addCacheSuffix(url);\n        const state = getOrCreateState(urlWithSuffix);\n        loadedStates[urlWithSuffix] = state;\n        state.count++;\n        const resolve = (callbacks, status) => {\n          each$e(callbacks, call);\n          state.status = status;\n          state.passed = [];\n          state.failed = [];\n          if (link) {\n            link.onload = null;\n            link.onerror = null;\n            link = null;\n          }\n        };\n        const passed = () => resolve(state.passed, 2);\n        const failed = () => resolve(state.failed, 3);\n        if (success) {\n          state.passed.push(success);\n        }\n        if (failure) {\n          state.failed.push(failure);\n        }\n        if (state.status === 1) {\n          return;\n        }\n        if (state.status === 2) {\n          passed();\n          return;\n        }\n        if (state.status === 3) {\n          failed();\n          return;\n        }\n        state.status = 1;\n        const linkElem = SugarElement.fromTag('link', doc.dom);\n        setAll$1(linkElem, {\n          rel: 'stylesheet',\n          type: 'text/css',\n          id: state.id\n        });\n        if (settings.contentCssCors) {\n          set$3(linkElem, 'crossOrigin', 'anonymous');\n        }\n        if (settings.referrerPolicy) {\n          set$3(linkElem, 'referrerpolicy', settings.referrerPolicy);\n        }\n        link = linkElem.dom;\n        link.onload = passed;\n        link.onerror = failed;\n        addStyle(linkElem);\n        set$3(linkElem, 'href', urlWithSuffix);\n      });\n      const loadRawCss = (key, css) => {\n        const state = getOrCreateState(key);\n        loadedStates[key] = state;\n        state.count++;\n        const styleElem = SugarElement.fromTag('style', doc.dom);\n        setAll$1(styleElem, {\n          rel: 'stylesheet',\n          type: 'text/css',\n          id: state.id\n        });\n        styleElem.dom.innerHTML = css;\n        addStyle(styleElem);\n      };\n      const loadAll = urls => {\n        const loadedUrls = Promise.allSettled(map$3(urls, url => load(url).then(constant(url))));\n        return loadedUrls.then(results => {\n          const parts = partition$2(results, r => r.status === 'fulfilled');\n          if (parts.fail.length > 0) {\n            return Promise.reject(map$3(parts.fail, result => result.reason));\n          } else {\n            return map$3(parts.pass, result => result.value);\n          }\n        });\n      };\n      const unload = url => {\n        const urlWithSuffix = Tools._addCacheSuffix(url);\n        get$a(loadedStates, urlWithSuffix).each(state => {\n          const count = --state.count;\n          if (count === 0) {\n            delete loadedStates[urlWithSuffix];\n            removeStyle(state.id);\n          }\n        });\n      };\n      const unloadRawCss = key => {\n        get$a(loadedStates, key).each(state => {\n          const count = --state.count;\n          if (count === 0) {\n            delete loadedStates[key];\n            removeStyle(state.id);\n          }\n        });\n      };\n      const unloadAll = urls => {\n        each$e(urls, url => {\n          unload(url);\n        });\n      };\n      return {\n        load,\n        loadRawCss,\n        loadAll,\n        unload,\n        unloadRawCss,\n        unloadAll,\n        _setReferrerPolicy,\n        _setContentCssCors\n      };\n    };\n\n    const create$c = () => {\n      const map = new WeakMap();\n      const forElement = (referenceElement, settings) => {\n        const root = getRootNode(referenceElement);\n        const rootDom = root.dom;\n        return Optional.from(map.get(rootDom)).getOrThunk(() => {\n          const sl = StyleSheetLoader(rootDom, settings);\n          map.set(rootDom, sl);\n          return sl;\n        });\n      };\n      return { forElement };\n    };\n    const instance = create$c();\n\n    const isSpan = node => node.nodeName.toLowerCase() === 'span';\n    const isInlineContent = (node, schema) => isNonNullable(node) && (isContent$1(schema, node) || schema.isInline(node.nodeName.toLowerCase()));\n    const surroundedByInlineContent = (node, root, schema) => {\n      const prev = new DomTreeWalker(node, root).prev(false);\n      const next = new DomTreeWalker(node, root).next(false);\n      const prevIsInline = isUndefined(prev) || isInlineContent(prev, schema);\n      const nextIsInline = isUndefined(next) || isInlineContent(next, schema);\n      return prevIsInline && nextIsInline;\n    };\n    const isBookmarkNode$2 = node => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';\n    const isKeepTextNode = (node, root, schema) => isText$b(node) && node.data.length > 0 && surroundedByInlineContent(node, root, schema);\n    const isKeepElement = node => isElement$6(node) ? node.childNodes.length > 0 : false;\n    const isDocument = node => isDocumentFragment(node) || isDocument$1(node);\n    const trimNode = (dom, node, schema, root) => {\n      var _a;\n      const rootNode = root || node;\n      if (isElement$6(node) && isBookmarkNode$2(node)) {\n        return node;\n      }\n      const children = node.childNodes;\n      for (let i = children.length - 1; i >= 0; i--) {\n        trimNode(dom, children[i], schema, rootNode);\n      }\n      if (isElement$6(node)) {\n        const currentChildren = node.childNodes;\n        if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(currentChildren[0], node);\n        }\n      }\n      if (!isDocument(node) && !isContent$1(schema, node) && !isKeepElement(node) && !isKeepTextNode(node, rootNode, schema)) {\n        dom.remove(node);\n      }\n      return node;\n    };\n\n    const makeMap$3 = Tools.makeMap;\n    const attrsCharsRegExp = /[&<>\\\"\\u0060\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    const textCharsRegExp = /[<>&\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    const rawCharsRegExp = /[<>&\\\"\\']/g;\n    const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;\n    const asciiMap = {\n      128: '\\u20AC',\n      130: '\\u201A',\n      131: '\\u0192',\n      132: '\\u201E',\n      133: '\\u2026',\n      134: '\\u2020',\n      135: '\\u2021',\n      136: '\\u02c6',\n      137: '\\u2030',\n      138: '\\u0160',\n      139: '\\u2039',\n      140: '\\u0152',\n      142: '\\u017d',\n      145: '\\u2018',\n      146: '\\u2019',\n      147: '\\u201C',\n      148: '\\u201D',\n      149: '\\u2022',\n      150: '\\u2013',\n      151: '\\u2014',\n      152: '\\u02DC',\n      153: '\\u2122',\n      154: '\\u0161',\n      155: '\\u203A',\n      156: '\\u0153',\n      158: '\\u017e',\n      159: '\\u0178'\n    };\n    const baseEntities = {\n      '\"': '&quot;',\n      '\\'': '&#39;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '&': '&amp;',\n      '`': '&#96;'\n    };\n    const reverseEntities = {\n      '&lt;': '<',\n      '&gt;': '>',\n      '&amp;': '&',\n      '&quot;': '\"',\n      '&apos;': `'`\n    };\n    const nativeDecode = text => {\n      const elm = SugarElement.fromTag('div').dom;\n      elm.innerHTML = text;\n      return elm.textContent || elm.innerText || text;\n    };\n    const buildEntitiesLookup = (items, radix) => {\n      const lookup = {};\n      if (items) {\n        const itemList = items.split(',');\n        radix = radix || 10;\n        for (let i = 0; i < itemList.length; i += 2) {\n          const chr = String.fromCharCode(parseInt(itemList[i], radix));\n          if (!baseEntities[chr]) {\n            const entity = '&' + itemList[i + 1] + ';';\n            lookup[chr] = entity;\n            lookup[entity] = chr;\n          }\n        }\n        return lookup;\n      } else {\n        return undefined;\n      }\n    };\n    const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\n    const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      return baseEntities[chr] || chr;\n    });\n    const encodeAllRaw = text => ('' + text).replace(rawCharsRegExp, chr => {\n      return baseEntities[chr] || chr;\n    });\n    const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      if (chr.length > 1) {\n        return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n      }\n      return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';\n    });\n    const encodeNamed = (text, attr, entities) => {\n      const resolveEntities = entities || namedEntities;\n      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n        return baseEntities[chr] || resolveEntities[chr] || chr;\n      });\n    };\n    const getEncodeFunc = (name, entities) => {\n      const entitiesMap = buildEntitiesLookup(entities) || namedEntities;\n      const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n        if (baseEntities[chr] !== undefined) {\n          return baseEntities[chr];\n        }\n        if (entitiesMap[chr] !== undefined) {\n          return entitiesMap[chr];\n        }\n        if (chr.length > 1) {\n          return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n        }\n        return '&#' + chr.charCodeAt(0) + ';';\n      });\n      const encodeCustomNamed = (text, attr) => {\n        return encodeNamed(text, attr, entitiesMap);\n      };\n      const nameMap = makeMap$3(name.replace(/\\+/g, ','));\n      if (nameMap.named && nameMap.numeric) {\n        return encodeNamedAndNumeric;\n      }\n      if (nameMap.named) {\n        if (entities) {\n          return encodeCustomNamed;\n        }\n        return encodeNamed;\n      }\n      if (nameMap.numeric) {\n        return encodeNumeric;\n      }\n      return encodeRaw;\n    };\n    const decode = text => text.replace(entityRegExp, (all, numeric) => {\n      if (numeric) {\n        if (numeric.charAt(0).toLowerCase() === 'x') {\n          numeric = parseInt(numeric.substr(1), 16);\n        } else {\n          numeric = parseInt(numeric, 10);\n        }\n        if (numeric > 65535) {\n          numeric -= 65536;\n          return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));\n        }\n        return asciiMap[numeric] || String.fromCharCode(numeric);\n      }\n      return reverseEntities[all] || namedEntities[all] || nativeDecode(all);\n    });\n    const Entities = {\n      encodeRaw,\n      encodeAllRaw,\n      encodeNumeric,\n      encodeNamed,\n      getEncodeFunc,\n      decode\n    };\n\n    const split$1 = (items, delim) => {\n      items = Tools.trim(items);\n      return items ? items.split(delim || ' ') : [];\n    };\n    const patternToRegExp = str => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');\n    const isRegExp$1 = obj => isObject(obj) && obj.source && Object.prototype.toString.call(obj) === '[object RegExp]';\n    const deepCloneElementRule = obj => {\n      const helper = value => {\n        if (isArray$1(value)) {\n          return map$3(value, helper);\n        } else if (isRegExp$1(value)) {\n          return new RegExp(value.source, value.flags);\n        } else if (isObject(value)) {\n          return map$2(value, helper);\n        } else {\n          return value;\n        }\n      };\n      return helper(obj);\n    };\n\n    const parseCustomElementsRules = value => {\n      const customElementRegExp = /^(~)?(.+)$/;\n      return bind$3(split$1(value, ','), rule => {\n        const matches = customElementRegExp.exec(rule);\n        if (matches) {\n          const inline = matches[1] === '~';\n          const cloneName = inline ? 'span' : 'div';\n          const name = matches[2];\n          return [{\n              cloneName,\n              name\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const getGlobalAttributeSet = type => {\n      return Object.freeze([\n        'id',\n        'accesskey',\n        'class',\n        'dir',\n        'lang',\n        'style',\n        'tabindex',\n        'title',\n        'role',\n        ...type !== 'html4' ? [\n          'contenteditable',\n          'contextmenu',\n          'draggable',\n          'dropzone',\n          'hidden',\n          'spellcheck',\n          'translate',\n          'itemprop',\n          'itemscope',\n          'itemtype'\n        ] : [],\n        ...type !== 'html5-strict' ? ['xml:lang'] : []\n      ]);\n    };\n\n    const getElementSetsAsStrings = type => {\n      let blockContent;\n      let phrasingContent;\n      blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';\n      phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';\n      if (type !== 'html4') {\n        const transparentContent = 'a ins del canvas map';\n        blockContent += ' article aside details dialog figure main header footer hgroup section nav ' + transparentContent;\n        phrasingContent += ' audio canvas command data datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen svg';\n      }\n      if (type !== 'html5-strict') {\n        const html4PhrasingContent = 'acronym applet basefont big font strike tt';\n        phrasingContent = [\n          phrasingContent,\n          html4PhrasingContent\n        ].join(' ');\n        const html4BlockContent = 'center dir isindex noframes';\n        blockContent = [\n          blockContent,\n          html4BlockContent\n        ].join(' ');\n      }\n      const flowContent = [\n        blockContent,\n        phrasingContent\n      ].join(' ');\n      return {\n        blockContent,\n        phrasingContent,\n        flowContent\n      };\n    };\n    const getElementSets = type => {\n      const {blockContent, phrasingContent, flowContent} = getElementSetsAsStrings(type);\n      const toArr = value => {\n        return Object.freeze(value.split(' '));\n      };\n      return Object.freeze({\n        blockContent: toArr(blockContent),\n        phrasingContent: toArr(phrasingContent),\n        flowContent: toArr(flowContent)\n      });\n    };\n\n    const cachedSets = {\n      'html4': cached(() => getElementSets('html4')),\n      'html5': cached(() => getElementSets('html5')),\n      'html5-strict': cached(() => getElementSets('html5-strict'))\n    };\n    const getElementsPreset = (type, name) => {\n      const {blockContent, phrasingContent, flowContent} = cachedSets[type]();\n      if (name === 'blocks') {\n        return Optional.some(blockContent);\n      } else if (name === 'phrasing') {\n        return Optional.some(phrasingContent);\n      } else if (name === 'flow') {\n        return Optional.some(flowContent);\n      } else {\n        return Optional.none();\n      }\n    };\n\n    const makeSchema = type => {\n      const globalAttributes = getGlobalAttributeSet(type);\n      const {phrasingContent, flowContent} = getElementSetsAsStrings(type);\n      const schema = {};\n      const addElement = (name, attributes, children) => {\n        schema[name] = {\n          attributes: mapToObject(attributes, constant({})),\n          attributesOrder: attributes,\n          children: mapToObject(children, constant({}))\n        };\n      };\n      const add = (name, attributes = '', children = '') => {\n        const childNames = split$1(children);\n        const names = split$1(name);\n        let ni = names.length;\n        const allAttributes = [\n          ...globalAttributes,\n          ...split$1(attributes)\n        ];\n        while (ni--) {\n          addElement(names[ni], allAttributes.slice(), childNames);\n        }\n      };\n      const addAttrs = (name, attributes) => {\n        const names = split$1(name);\n        const attrs = split$1(attributes);\n        let ni = names.length;\n        while (ni--) {\n          const schemaItem = schema[names[ni]];\n          for (let i = 0, l = attrs.length; i < l; i++) {\n            schemaItem.attributes[attrs[i]] = {};\n            schemaItem.attributesOrder.push(attrs[i]);\n          }\n        }\n      };\n      if (type !== 'html5-strict') {\n        const html4PhrasingContent = 'acronym applet basefont big font strike tt';\n        each$e(split$1(html4PhrasingContent), name => {\n          add(name, '', phrasingContent);\n        });\n        const html4BlockContent = 'center dir isindex noframes';\n        each$e(split$1(html4BlockContent), name => {\n          add(name, '', flowContent);\n        });\n      }\n      add('html', 'manifest', 'head body');\n      add('head', '', 'base command link meta noscript script style title');\n      add('title hr noscript br');\n      add('base', 'href target');\n      add('link', 'href rel media hreflang type sizes hreflang');\n      add('meta', 'name http-equiv content charset');\n      add('style', 'media type scoped');\n      add('script', 'src async defer type charset');\n      add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);\n      add('dd div', '', flowContent);\n      add('address dt caption', '', type === 'html4' ? phrasingContent : flowContent);\n      add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);\n      add('blockquote', 'cite', flowContent);\n      add('ol', 'reversed start type', 'li');\n      add('ul', '', 'li');\n      add('li', 'value', flowContent);\n      add('dl', '', 'dt dd');\n      add('a', 'href target rel media hreflang type', type === 'html4' ? phrasingContent : flowContent);\n      add('q', 'cite', phrasingContent);\n      add('ins del', 'cite datetime', flowContent);\n      add('img', 'src sizes srcset alt usemap ismap width height');\n      add('iframe', 'src name width height', flowContent);\n      add('embed', 'src type width height');\n      add('object', 'data type typemustmatch name usemap form width height', [\n        flowContent,\n        'param'\n      ].join(' '));\n      add('param', 'name value');\n      add('map', 'name', [\n        flowContent,\n        'area'\n      ].join(' '));\n      add('area', 'alt coords shape href target rel media hreflang type');\n      add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));\n      add('colgroup', 'span', 'col');\n      add('col', 'span');\n      add('tbody thead tfoot', '', 'tr');\n      add('tr', '', 'td th');\n      add('td', 'colspan rowspan headers', flowContent);\n      add('th', 'colspan rowspan headers scope abbr', flowContent);\n      add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);\n      add('fieldset', 'disabled form name', [\n        flowContent,\n        'legend'\n      ].join(' '));\n      add('label', 'form for', phrasingContent);\n      add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');\n      add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);\n      add('select', 'disabled form multiple name required size', 'option optgroup');\n      add('optgroup', 'disabled label', 'option');\n      add('option', 'disabled label selected value');\n      add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');\n      add('menu', 'type label', [\n        flowContent,\n        'li'\n      ].join(' '));\n      add('noscript', '', flowContent);\n      if (type !== 'html4') {\n        add('wbr');\n        add('ruby', '', [\n          phrasingContent,\n          'rt rp'\n        ].join(' '));\n        add('figcaption', '', flowContent);\n        add('mark rt rp bdi', '', phrasingContent);\n        add('summary', '', [\n          phrasingContent,\n          'h1 h2 h3 h4 h5 h6'\n        ].join(' '));\n        add('canvas', 'width height', flowContent);\n        add('data', 'value', phrasingContent);\n        add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [\n          flowContent,\n          'track source'\n        ].join(' '));\n        add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [\n          flowContent,\n          'track source'\n        ].join(' '));\n        add('picture', '', 'img source');\n        add('source', 'src srcset type media sizes');\n        add('track', 'kind src srclang label default');\n        add('datalist', '', [\n          phrasingContent,\n          'option'\n        ].join(' '));\n        add('article section nav aside main header footer', '', flowContent);\n        add('hgroup', '', 'h1 h2 h3 h4 h5 h6');\n        add('figure', '', [\n          flowContent,\n          'figcaption'\n        ].join(' '));\n        add('time', 'datetime', phrasingContent);\n        add('dialog', 'open', flowContent);\n        add('command', 'type label icon disabled checked radiogroup command');\n        add('output', 'for form name', phrasingContent);\n        add('progress', 'value max', phrasingContent);\n        add('meter', 'value min max low high optimum', phrasingContent);\n        add('details', 'open', [\n          flowContent,\n          'summary'\n        ].join(' '));\n        add('keygen', 'autofocus challenge disabled form keytype name');\n        addElement('svg', 'id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform'.split(' '), []);\n      }\n      if (type !== 'html5-strict') {\n        addAttrs('script', 'language xml:space');\n        addAttrs('style', 'xml:space');\n        addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');\n        addAttrs('embed', 'align name hspace vspace');\n        addAttrs('param', 'valuetype type');\n        addAttrs('a', 'charset name rev shape coords');\n        addAttrs('br', 'clear');\n        addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');\n        addAttrs('img', 'name longdesc align border hspace vspace');\n        addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');\n        addAttrs('font basefont', 'size color face');\n        addAttrs('input', 'usemap align');\n        addAttrs('select');\n        addAttrs('textarea');\n        addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');\n        addAttrs('ul', 'type compact');\n        addAttrs('li', 'type');\n        addAttrs('ol dl menu dir', 'compact');\n        addAttrs('pre', 'width xml:space');\n        addAttrs('hr', 'align noshade size width');\n        addAttrs('isindex', 'prompt');\n        addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');\n        addAttrs('col', 'width align char charoff valign');\n        addAttrs('colgroup', 'width align char charoff valign');\n        addAttrs('thead', 'align char charoff valign');\n        addAttrs('tr', 'align char charoff valign bgcolor');\n        addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');\n        addAttrs('form', 'accept');\n        addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');\n        addAttrs('tfoot', 'align char charoff valign');\n        addAttrs('tbody', 'align char charoff valign');\n        addAttrs('area', 'nohref');\n        addAttrs('body', 'background bgcolor text link vlink alink');\n      }\n      if (type !== 'html4') {\n        addAttrs('input button select textarea', 'autofocus');\n        addAttrs('input textarea', 'placeholder');\n        addAttrs('a', 'download');\n        addAttrs('link script img', 'crossorigin');\n        addAttrs('img', 'loading');\n        addAttrs('iframe', 'sandbox seamless allow allowfullscreen loading referrerpolicy');\n      }\n      if (type !== 'html4') {\n        each$e([\n          schema.video,\n          schema.audio\n        ], item => {\n          delete item.children.audio;\n          delete item.children.video;\n        });\n      }\n      each$e(split$1('a form meter progress dfn'), name => {\n        if (schema[name]) {\n          delete schema[name].children[name];\n        }\n      });\n      delete schema.caption.children.table;\n      delete schema.script;\n      return schema;\n    };\n\n    const prefixToOperation = prefix => prefix === '-' ? 'remove' : 'add';\n    const parseValidChild = name => {\n      const validChildRegExp = /^(@?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)$/;\n      return Optional.from(validChildRegExp.exec(name)).map(matches => ({\n        preset: matches[1] === '@',\n        name: matches[2]\n      }));\n    };\n    const parseValidChildrenRules = value => {\n      const childRuleRegExp = /^([+\\-]?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)\\[([^\\]]+)]$/;\n      return bind$3(split$1(value, ','), rule => {\n        const matches = childRuleRegExp.exec(rule);\n        if (matches) {\n          const prefix = matches[1];\n          const operation = prefix ? prefixToOperation(prefix) : 'replace';\n          const name = matches[2];\n          const validChildren = bind$3(split$1(matches[3], '|'), validChild => parseValidChild(validChild).toArray());\n          return [{\n              operation,\n              name,\n              validChildren\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const parseValidElementsAttrDataIntoElement = (attrData, targetElement) => {\n      const attrRuleRegExp = /^([!\\-])?(\\w+[\\\\:]:\\w+|[^=~<]+)?(?:([=~<])(.*))?$/;\n      const hasPatternsRegExp = /[*?+]/;\n      const {attributes, attributesOrder} = targetElement;\n      return each$e(split$1(attrData, '|'), rule => {\n        const matches = attrRuleRegExp.exec(rule);\n        if (matches) {\n          const attr = {};\n          const attrType = matches[1];\n          const attrName = matches[2].replace(/[\\\\:]:/g, ':');\n          const attrPrefix = matches[3];\n          const value = matches[4];\n          if (attrType === '!') {\n            targetElement.attributesRequired = targetElement.attributesRequired || [];\n            targetElement.attributesRequired.push(attrName);\n            attr.required = true;\n          }\n          if (attrType === '-') {\n            delete attributes[attrName];\n            attributesOrder.splice(Tools.inArray(attributesOrder, attrName), 1);\n            return;\n          }\n          if (attrPrefix) {\n            if (attrPrefix === '=') {\n              targetElement.attributesDefault = targetElement.attributesDefault || [];\n              targetElement.attributesDefault.push({\n                name: attrName,\n                value\n              });\n              attr.defaultValue = value;\n            } else if (attrPrefix === '~') {\n              targetElement.attributesForced = targetElement.attributesForced || [];\n              targetElement.attributesForced.push({\n                name: attrName,\n                value\n              });\n              attr.forcedValue = value;\n            } else if (attrPrefix === '<') {\n              attr.validValues = Tools.makeMap(value, '?');\n            }\n          }\n          if (hasPatternsRegExp.test(attrName)) {\n            const attrPattern = attr;\n            targetElement.attributePatterns = targetElement.attributePatterns || [];\n            attrPattern.pattern = patternToRegExp(attrName);\n            targetElement.attributePatterns.push(attrPattern);\n          } else {\n            if (!attributes[attrName]) {\n              attributesOrder.push(attrName);\n            }\n            attributes[attrName] = attr;\n          }\n        }\n      });\n    };\n    const cloneAttributesInto = (from, to) => {\n      each$d(from.attributes, (value, key) => {\n        to.attributes[key] = value;\n      });\n      to.attributesOrder.push(...from.attributesOrder);\n    };\n    const parseValidElementsRules = (globalElement, validElements) => {\n      const elementRuleRegExp = /^([#+\\-])?([^\\[!\\/]+)(?:\\/([^\\[!]+))?(?:(!?)\\[([^\\]]+)])?$/;\n      return bind$3(split$1(validElements, ','), rule => {\n        const matches = elementRuleRegExp.exec(rule);\n        if (matches) {\n          const prefix = matches[1];\n          const elementName = matches[2];\n          const outputName = matches[3];\n          const attrsPrefix = matches[4];\n          const attrData = matches[5];\n          const element = {\n            attributes: {},\n            attributesOrder: []\n          };\n          globalElement.each(el => cloneAttributesInto(el, element));\n          if (prefix === '#') {\n            element.paddEmpty = true;\n          } else if (prefix === '-') {\n            element.removeEmpty = true;\n          }\n          if (attrsPrefix === '!') {\n            element.removeEmptyAttrs = true;\n          }\n          if (attrData) {\n            parseValidElementsAttrDataIntoElement(attrData, element);\n          }\n          if (outputName) {\n            element.outputName = elementName;\n          }\n          if (elementName === '@') {\n            if (globalElement.isNone()) {\n              globalElement = Optional.some(element);\n            } else {\n              return [];\n            }\n          }\n          return [outputName ? {\n              name: elementName,\n              element,\n              aliasName: outputName\n            } : {\n              name: elementName,\n              element\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const mapCache = {};\n    const makeMap$2 = Tools.makeMap, each$b = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode;\n    const createMap = (defaultValue, extendWith = {}) => {\n      const value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));\n      return extend$2(value, extendWith);\n    };\n    const getTextRootBlockElements = schema => createMap('td th li dt dd figcaption caption details summary', schema.getTextBlockElements());\n    const compileElementMap = (value, mode) => {\n      if (value) {\n        const styles = {};\n        if (isString(value)) {\n          value = { '*': value };\n        }\n        each$b(value, (value, key) => {\n          styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);\n        });\n        return styles;\n      } else {\n        return undefined;\n      }\n    };\n    const Schema = (settings = {}) => {\n      var _a;\n      const elements = {};\n      const children = {};\n      let patternElements = [];\n      const customElementsMap = {};\n      const specialElements = {};\n      const createLookupTable = (option, defaultValue, extendWith) => {\n        const value = settings[option];\n        if (!value) {\n          let newValue = mapCache[option];\n          if (!newValue) {\n            newValue = createMap(defaultValue, extendWith);\n            mapCache[option] = newValue;\n          }\n          return newValue;\n        } else {\n          return makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));\n        }\n      };\n      const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';\n      const schemaItems = makeSchema(schemaType);\n      if (settings.verify_html === false) {\n        settings.valid_elements = '*[*]';\n      }\n      const validStyles = compileElementMap(settings.valid_styles);\n      const invalidStyles = compileElementMap(settings.invalid_styles, 'map');\n      const validClasses = compileElementMap(settings.valid_classes, 'map');\n      const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');\n      const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');\n      const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');\n      const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls allowfullscreen');\n      const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';\n      const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre svg textarea summary', voidElementsMap);\n      const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);\n      const headings = 'h1 h2 h3 h4 h5 h6';\n      const textBlockElementsMap = createLookupTable('text_block_elements', headings + ' p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');\n      const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary html body multicol listing', textBlockElementsMap);\n      const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font s strike u var cite ' + 'dfn code mark q sup sub samp');\n      const transparentElementsMap = createLookupTable('transparent_elements', 'a ins del canvas map');\n      const wrapBlockElementsMap = createLookupTable('wrap_block_elements', 'pre ' + headings);\n      each$b('script noscript iframe noframes noembed title style textarea xmp plaintext'.split(' '), name => {\n        specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');\n      });\n      const addValidElements = validElements => {\n        const globalElement = Optional.from(elements['@']);\n        const hasPatternsRegExp = /[*?+]/;\n        each$e(parseValidElementsRules(globalElement, validElements !== null && validElements !== void 0 ? validElements : ''), ({name, element, aliasName}) => {\n          if (aliasName) {\n            elements[aliasName] = element;\n          }\n          if (hasPatternsRegExp.test(name)) {\n            const patternElement = element;\n            patternElement.pattern = patternToRegExp(name);\n            patternElements.push(patternElement);\n          } else {\n            elements[name] = element;\n          }\n        });\n      };\n      const setValidElements = validElements => {\n        patternElements = [];\n        each$e(keys(elements), name => {\n          delete elements[name];\n        });\n        addValidElements(validElements);\n      };\n      const addCustomElement = (name, spec) => {\n        var _a, _b;\n        delete mapCache.text_block_elements;\n        delete mapCache.block_elements;\n        const inline = spec.extends ? !isBlock(spec.extends) : false;\n        const cloneName = spec.extends;\n        children[name] = cloneName ? children[cloneName] : {};\n        customElementsMap[name] = cloneName !== null && cloneName !== void 0 ? cloneName : name;\n        nonEmptyElementsMap[name.toUpperCase()] = {};\n        nonEmptyElementsMap[name] = {};\n        if (!inline) {\n          blockElementsMap[name.toUpperCase()] = {};\n          blockElementsMap[name] = {};\n        }\n        if (cloneName && !elements[name] && elements[cloneName]) {\n          const customRule = deepCloneElementRule(elements[cloneName]);\n          delete customRule.removeEmptyAttrs;\n          delete customRule.removeEmpty;\n          elements[name] = customRule;\n        } else {\n          elements[name] = {\n            attributesOrder: [],\n            attributes: {}\n          };\n        }\n        if (isArray$1(spec.attributes)) {\n          const processAttrName = name => {\n            customRule.attributesOrder.push(name);\n            customRule.attributes[name] = {};\n          };\n          const customRule = (_a = elements[name]) !== null && _a !== void 0 ? _a : {};\n          delete customRule.attributesDefault;\n          delete customRule.attributesForced;\n          delete customRule.attributePatterns;\n          delete customRule.attributesRequired;\n          customRule.attributesOrder = [];\n          customRule.attributes = {};\n          each$e(spec.attributes, attrName => {\n            const globalAttrs = getGlobalAttributeSet(schemaType);\n            parseValidChild(attrName).each(({preset, name}) => {\n              if (preset) {\n                if (name === 'global') {\n                  each$e(globalAttrs, processAttrName);\n                }\n              } else {\n                processAttrName(name);\n              }\n            });\n          });\n          elements[name] = customRule;\n        }\n        if (isBoolean(spec.padEmpty)) {\n          const customRule = (_b = elements[name]) !== null && _b !== void 0 ? _b : {};\n          customRule.paddEmpty = spec.padEmpty;\n          elements[name] = customRule;\n        }\n        if (isArray$1(spec.children)) {\n          const customElementChildren = {};\n          const processNodeName = name => {\n            customElementChildren[name] = {};\n          };\n          const processPreset = name => {\n            getElementsPreset(schemaType, name).each(names => {\n              each$e(names, processNodeName);\n            });\n          };\n          each$e(spec.children, child => {\n            parseValidChild(child).each(({preset, name}) => {\n              if (preset) {\n                processPreset(name);\n              } else {\n                processNodeName(name);\n              }\n            });\n          });\n          children[name] = customElementChildren;\n        }\n        if (cloneName) {\n          each$d(children, (element, elmName) => {\n            if (element[cloneName]) {\n              children[elmName] = element = extend$2({}, children[elmName]);\n              element[name] = element[cloneName];\n            }\n          });\n        }\n      };\n      const addCustomElementsFromString = customElements => {\n        each$e(parseCustomElementsRules(customElements !== null && customElements !== void 0 ? customElements : ''), ({name, cloneName}) => {\n          addCustomElement(name, { extends: cloneName });\n        });\n      };\n      const addCustomElements = customElements => {\n        if (isObject(customElements)) {\n          each$d(customElements, (spec, name) => addCustomElement(name, spec));\n        } else if (isString(customElements)) {\n          addCustomElementsFromString(customElements);\n        }\n      };\n      const addValidChildren = validChildren => {\n        each$e(parseValidChildrenRules(validChildren !== null && validChildren !== void 0 ? validChildren : ''), ({operation, name, validChildren}) => {\n          const parent = operation === 'replace' ? { '#comment': {} } : children[name];\n          const processNodeName = name => {\n            if (operation === 'remove') {\n              delete parent[name];\n            } else {\n              parent[name] = {};\n            }\n          };\n          const processPreset = name => {\n            getElementsPreset(schemaType, name).each(names => {\n              each$e(names, processNodeName);\n            });\n          };\n          each$e(validChildren, ({preset, name}) => {\n            if (preset) {\n              processPreset(name);\n            } else {\n              processNodeName(name);\n            }\n          });\n          children[name] = parent;\n        });\n      };\n      const getElementRule = name => {\n        const element = elements[name];\n        if (element) {\n          return element;\n        }\n        let i = patternElements.length;\n        while (i--) {\n          const patternElement = patternElements[i];\n          if (patternElement.pattern.test(name)) {\n            return patternElement;\n          }\n        }\n        return undefined;\n      };\n      const setup = () => {\n        if (!settings.valid_elements) {\n          each$b(schemaItems, (element, name) => {\n            elements[name] = {\n              attributes: element.attributes,\n              attributesOrder: element.attributesOrder\n            };\n            children[name] = element.children;\n          });\n          each$b(split$1('strong/b em/i'), item => {\n            const items = split$1(item, '/');\n            elements[items[1]].outputName = items[0];\n          });\n          each$b(textInlineElementsMap, (_val, name) => {\n            if (elements[name]) {\n              if (settings.padd_empty_block_inline_children) {\n                elements[name].paddInEmptyBlock = true;\n              }\n              elements[name].removeEmpty = true;\n            }\n          });\n          each$b(split$1('ol ul blockquote a table tbody'), name => {\n            if (elements[name]) {\n              elements[name].removeEmpty = true;\n            }\n          });\n          each$b(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary'), name => {\n            if (elements[name]) {\n              elements[name].paddEmpty = true;\n            }\n          });\n          each$b(split$1('span'), name => {\n            elements[name].removeEmptyAttrs = true;\n          });\n        } else {\n          setValidElements(settings.valid_elements);\n          each$b(schemaItems, (element, name) => {\n            children[name] = element.children;\n          });\n        }\n        delete elements.svg;\n        addCustomElements(settings.custom_elements);\n        addValidChildren(settings.valid_children);\n        addValidElements(settings.extended_valid_elements);\n        addValidChildren('+ol[ul|ol],+ul[ul|ol]');\n        each$b({\n          dd: 'dl',\n          dt: 'dl',\n          li: 'ul ol',\n          td: 'tr',\n          th: 'tr',\n          tr: 'tbody thead tfoot',\n          tbody: 'table',\n          thead: 'table',\n          tfoot: 'table',\n          legend: 'fieldset',\n          area: 'map',\n          param: 'video audio object'\n        }, (parents, item) => {\n          if (elements[item]) {\n            elements[item].parentsRequired = split$1(parents);\n          }\n        });\n        if (settings.invalid_elements) {\n          each$b(explode$2(settings.invalid_elements), item => {\n            if (elements[item]) {\n              delete elements[item];\n            }\n          });\n        }\n        if (!getElementRule('span')) {\n          addValidElements('span[!data-mce-type|*]');\n        }\n      };\n      const getValidStyles = constant(validStyles);\n      const getInvalidStyles = constant(invalidStyles);\n      const getValidClasses = constant(validClasses);\n      const getBoolAttrs = constant(boolAttrMap);\n      const getBlockElements = constant(blockElementsMap);\n      const getTextBlockElements = constant(textBlockElementsMap);\n      const getTextInlineElements = constant(textInlineElementsMap);\n      const getVoidElements = constant(Object.seal(voidElementsMap));\n      const getSelfClosingElements = constant(selfClosingElementsMap);\n      const getNonEmptyElements = constant(nonEmptyElementsMap);\n      const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);\n      const getWhitespaceElements = constant(whitespaceElementsMap);\n      const getTransparentElements = constant(transparentElementsMap);\n      const getWrapBlockElements = constant(wrapBlockElementsMap);\n      const getSpecialElements = constant(Object.seal(specialElements));\n      const isValidChild = (name, child) => {\n        const parent = children[name.toLowerCase()];\n        return !!(parent && parent[child.toLowerCase()]);\n      };\n      const isValid = (name, attr) => {\n        const rule = getElementRule(name);\n        if (rule) {\n          if (attr) {\n            if (rule.attributes[attr]) {\n              return true;\n            }\n            const attrPatterns = rule.attributePatterns;\n            if (attrPatterns) {\n              let i = attrPatterns.length;\n              while (i--) {\n                if (attrPatterns[i].pattern.test(attr)) {\n                  return true;\n                }\n              }\n            }\n          } else {\n            return true;\n          }\n        }\n        return false;\n      };\n      const isBlock = name => has$2(getBlockElements(), name);\n      const isInline = name => !startsWith(name, '#') && isValid(name) && !isBlock(name);\n      const isWrapper = name => has$2(getWrapBlockElements(), name) || isInline(name);\n      const getCustomElements = constant(customElementsMap);\n      setup();\n      return {\n        type: schemaType,\n        children,\n        elements,\n        getValidStyles,\n        getValidClasses,\n        getBlockElements,\n        getInvalidStyles,\n        getVoidElements,\n        getTextBlockElements,\n        getTextInlineElements,\n        getBoolAttrs,\n        getElementRule,\n        getSelfClosingElements,\n        getNonEmptyElements,\n        getMoveCaretBeforeOnEnterElements,\n        getWhitespaceElements,\n        getTransparentElements,\n        getSpecialElements,\n        isValidChild,\n        isValid,\n        isBlock,\n        isInline,\n        isWrapper,\n        getCustomElements,\n        addValidElements,\n        setValidElements,\n        addCustomElements,\n        addValidChildren\n      };\n    };\n\n    const hexColour = value => ({ value: normalizeHex(value) });\n    const normalizeHex = hex => removeLeading(hex, '#').toUpperCase();\n    const toHex = component => {\n      const hex = component.toString(16);\n      return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\n    };\n    const fromRgba = rgbaColour => {\n      const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\n      return hexColour(value);\n    };\n\n    const rgbRegex = /^\\s*rgb\\s*\\(\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*\\)\\s*$/i;\n    const rgbaRegex = /^\\s*rgba\\s*\\(\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*((?:\\d?\\.\\d+|\\d+)%?)\\s*\\)\\s*$/i;\n    const rgbaColour = (red, green, blue, alpha) => ({\n      red,\n      green,\n      blue,\n      alpha\n    });\n    const fromStringValues = (red, green, blue, alpha) => {\n      const r = parseInt(red, 10);\n      const g = parseInt(green, 10);\n      const b = parseInt(blue, 10);\n      const a = parseFloat(alpha);\n      return rgbaColour(r, g, b, a);\n    };\n    const getColorFormat = colorString => {\n      if (rgbRegex.test(colorString)) {\n        return 'rgb';\n      } else if (rgbaRegex.test(colorString)) {\n        return 'rgba';\n      }\n      return 'other';\n    };\n    const fromString = rgbaString => {\n      const rgbMatch = rgbRegex.exec(rgbaString);\n      if (rgbMatch !== null) {\n        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\n      }\n      const rgbaMatch = rgbaRegex.exec(rgbaString);\n      if (rgbaMatch !== null) {\n        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\n      }\n      return Optional.none();\n    };\n    const toString = rgba => `rgba(${ rgba.red },${ rgba.green },${ rgba.blue },${ rgba.alpha })`;\n\n    const rgbaToHexString = color => fromString(color).map(fromRgba).map(h => '#' + h.value).getOr(color);\n\n    const Styles = (settings = {}, schema) => {\n      const urlOrStrRegExp = /(?:url(?:(?:\\(\\s*\\\"([^\\\"]+)\\\"\\s*\\))|(?:\\(\\s*\\'([^\\']+)\\'\\s*\\))|(?:\\(\\s*([^)\\s]+)\\s*\\))))|(?:\\'([^\\']+)\\')|(?:\\\"([^\\\"]+)\\\")/gi;\n      const styleRegExp = /\\s*([^:]+):\\s*([^;]+);?/g;\n      const trimRightRegExp = /\\s+$/;\n      const encodingLookup = {};\n      let validStyles;\n      let invalidStyles;\n      const invisibleChar = zeroWidth;\n      if (schema) {\n        validStyles = schema.getValidStyles();\n        invalidStyles = schema.getInvalidStyles();\n      }\n      const encodingItems = (`\\\\\" \\\\' \\\\; \\\\: ; : ` + invisibleChar).split(' ');\n      for (let i = 0; i < encodingItems.length; i++) {\n        encodingLookup[encodingItems[i]] = invisibleChar + i;\n        encodingLookup[invisibleChar + i] = encodingItems[i];\n      }\n      const self = {\n        parse: css => {\n          const styles = {};\n          let isEncoded = false;\n          const urlConverter = settings.url_converter;\n          const urlConverterScope = settings.url_converter_scope || self;\n          const compress = (prefix, suffix, noJoin) => {\n            const top = styles[prefix + '-top' + suffix];\n            if (!top) {\n              return;\n            }\n            const right = styles[prefix + '-right' + suffix];\n            if (!right) {\n              return;\n            }\n            const bottom = styles[prefix + '-bottom' + suffix];\n            if (!bottom) {\n              return;\n            }\n            const left = styles[prefix + '-left' + suffix];\n            if (!left) {\n              return;\n            }\n            const box = [\n              top,\n              right,\n              bottom,\n              left\n            ];\n            let i = box.length - 1;\n            while (i--) {\n              if (box[i] !== box[i + 1]) {\n                break;\n              }\n            }\n            if (i > -1 && noJoin) {\n              return;\n            }\n            styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');\n            delete styles[prefix + '-top' + suffix];\n            delete styles[prefix + '-right' + suffix];\n            delete styles[prefix + '-bottom' + suffix];\n            delete styles[prefix + '-left' + suffix];\n          };\n          const canCompress = key => {\n            const value = styles[key];\n            if (!value) {\n              return;\n            }\n            const values = value.indexOf(',') > -1 ? [value] : value.split(' ');\n            let i = values.length;\n            while (i--) {\n              if (values[i] !== values[0]) {\n                return false;\n              }\n            }\n            styles[key] = values[0];\n            return true;\n          };\n          const compress2 = (target, a, b, c) => {\n            if (!canCompress(a)) {\n              return;\n            }\n            if (!canCompress(b)) {\n              return;\n            }\n            if (!canCompress(c)) {\n              return;\n            }\n            styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];\n            delete styles[a];\n            delete styles[b];\n            delete styles[c];\n          };\n          const encode = str => {\n            isEncoded = true;\n            return encodingLookup[str];\n          };\n          const decode = (str, keepSlashes) => {\n            if (isEncoded) {\n              str = str.replace(/\\uFEFF[0-9]/g, str => {\n                return encodingLookup[str];\n              });\n            }\n            if (!keepSlashes) {\n              str = str.replace(/\\\\([\\'\\\";:])/g, '$1');\n            }\n            return str;\n          };\n          const decodeSingleHexSequence = escSeq => {\n            return String.fromCharCode(parseInt(escSeq.slice(1), 16));\n          };\n          const decodeHexSequences = value => {\n            return value.replace(/\\\\[0-9a-f]+/gi, decodeSingleHexSequence);\n          };\n          const processUrl = (match, url, url2, url3, str, str2) => {\n            str = str || str2;\n            if (str) {\n              str = decode(str);\n              return `'` + str.replace(/\\'/g, `\\\\'`) + `'`;\n            }\n            url = decode(url || url2 || url3 || '');\n            if (!settings.allow_script_urls) {\n              const scriptUrl = url.replace(/[\\s\\r\\n]+/g, '');\n              if (/(java|vb)script:/i.test(scriptUrl)) {\n                return '';\n              }\n              if (!settings.allow_svg_data_urls && /^data:image\\/svg/i.test(scriptUrl)) {\n                return '';\n              }\n            }\n            if (urlConverter) {\n              url = urlConverter.call(urlConverterScope, url, 'style');\n            }\n            return `url('` + url.replace(/\\'/g, `\\\\'`) + `')`;\n          };\n          if (css) {\n            css = css.replace(/[\\u0000-\\u001F]/g, '');\n            css = css.replace(/\\\\[\\\"\\';:\\uFEFF]/g, encode).replace(/\\\"[^\\\"]+\\\"|\\'[^\\']+\\'/g, str => {\n              return str.replace(/[;:]/g, encode);\n            });\n            let matches;\n            while (matches = styleRegExp.exec(css)) {\n              styleRegExp.lastIndex = matches.index + matches[0].length;\n              let name = matches[1].replace(trimRightRegExp, '').toLowerCase();\n              let value = matches[2].replace(trimRightRegExp, '');\n              if (name && value) {\n                name = decodeHexSequences(name);\n                value = decodeHexSequences(value);\n                if (name.indexOf(invisibleChar) !== -1 || name.indexOf('\"') !== -1) {\n                  continue;\n                }\n                if (!settings.allow_script_urls && (name === 'behavior' || /expression\\s*\\(|\\/\\*|\\*\\//.test(value))) {\n                  continue;\n                }\n                if (name === 'font-weight' && value === '700') {\n                  value = 'bold';\n                } else if (name === 'color' || name === 'background-color') {\n                  value = value.toLowerCase();\n                }\n                if (getColorFormat(value) === 'rgb') {\n                  fromString(value).each(rgba => {\n                    value = rgbaToHexString(toString(rgba)).toLowerCase();\n                  });\n                }\n                value = value.replace(urlOrStrRegExp, processUrl);\n                styles[name] = isEncoded ? decode(value, true) : value;\n              }\n            }\n            compress('border', '', true);\n            compress('border', '-width');\n            compress('border', '-color');\n            compress('border', '-style');\n            compress('padding', '');\n            compress('margin', '');\n            compress2('border', 'border-width', 'border-style', 'border-color');\n            if (styles.border === 'medium none') {\n              delete styles.border;\n            }\n            if (styles['border-image'] === 'none') {\n              delete styles['border-image'];\n            }\n          }\n          return styles;\n        },\n        serialize: (styles, elementName) => {\n          let css = '';\n          const serializeStyles = (elemName, validStyleList) => {\n            const styleList = validStyleList[elemName];\n            if (styleList) {\n              for (let i = 0, l = styleList.length; i < l; i++) {\n                const name = styleList[i];\n                const value = styles[name];\n                if (value) {\n                  css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n                }\n              }\n            }\n          };\n          const isValid = (name, elemName) => {\n            if (!invalidStyles || !elemName) {\n              return true;\n            }\n            let styleMap = invalidStyles['*'];\n            if (styleMap && styleMap[name]) {\n              return false;\n            }\n            styleMap = invalidStyles[elemName];\n            return !(styleMap && styleMap[name]);\n          };\n          if (elementName && validStyles) {\n            serializeStyles('*', validStyles);\n            serializeStyles(elementName, validStyles);\n          } else {\n            each$d(styles, (value, name) => {\n              if (value && isValid(name, elementName)) {\n                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n              }\n            });\n          }\n          return css;\n        }\n      };\n      return self;\n    };\n\n    const deprecated = {\n      keyLocation: true,\n      layerX: true,\n      layerY: true,\n      returnValue: true,\n      webkitMovementX: true,\n      webkitMovementY: true,\n      keyIdentifier: true,\n      mozPressure: true\n    };\n    const isNativeEvent = event => event instanceof Event || isFunction(event.initEvent);\n    const hasIsDefaultPrevented = event => event.isDefaultPrevented === always || event.isDefaultPrevented === never;\n    const needsNormalizing = event => isNullable(event.preventDefault) || isNativeEvent(event);\n    const clone$3 = (originalEvent, data) => {\n      const event = data !== null && data !== void 0 ? data : {};\n      for (const name in originalEvent) {\n        if (!has$2(deprecated, name)) {\n          event[name] = originalEvent[name];\n        }\n      }\n      if (isNonNullable(originalEvent.composedPath)) {\n        event.composedPath = () => originalEvent.composedPath();\n      }\n      if (isNonNullable(originalEvent.getModifierState)) {\n        event.getModifierState = keyArg => originalEvent.getModifierState(keyArg);\n      }\n      if (isNonNullable(originalEvent.getTargetRanges)) {\n        event.getTargetRanges = () => originalEvent.getTargetRanges();\n      }\n      return event;\n    };\n    const normalize$3 = (type, originalEvent, fallbackTarget, data) => {\n      var _a;\n      const event = clone$3(originalEvent, data);\n      event.type = type;\n      if (isNullable(event.target)) {\n        event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;\n      }\n      if (needsNormalizing(originalEvent)) {\n        event.preventDefault = () => {\n          event.defaultPrevented = true;\n          event.isDefaultPrevented = always;\n          if (isFunction(originalEvent.preventDefault)) {\n            originalEvent.preventDefault();\n          }\n        };\n        event.stopPropagation = () => {\n          event.cancelBubble = true;\n          event.isPropagationStopped = always;\n          if (isFunction(originalEvent.stopPropagation)) {\n            originalEvent.stopPropagation();\n          }\n        };\n        event.stopImmediatePropagation = () => {\n          event.isImmediatePropagationStopped = always;\n          event.stopPropagation();\n        };\n        if (!hasIsDefaultPrevented(event)) {\n          event.isDefaultPrevented = event.defaultPrevented === true ? always : never;\n          event.isPropagationStopped = event.cancelBubble === true ? always : never;\n          event.isImmediatePropagationStopped = never;\n        }\n      }\n      return event;\n    };\n\n    const eventExpandoPrefix = 'mce-data-';\n    const mouseEventRe = /^(?:mouse|contextmenu)|click/;\n    const addEvent = (target, name, callback, capture) => {\n      target.addEventListener(name, callback, capture || false);\n    };\n    const removeEvent = (target, name, callback, capture) => {\n      target.removeEventListener(name, callback, capture || false);\n    };\n    const isMouseEvent = event => isNonNullable(event) && mouseEventRe.test(event.type);\n    const fix = (originalEvent, data) => {\n      const event = normalize$3(originalEvent.type, originalEvent, document, data);\n      if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {\n        const eventDoc = event.target.ownerDocument || document;\n        const doc = eventDoc.documentElement;\n        const body = eventDoc.body;\n        const mouseEvent = event;\n        mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n        mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n      }\n      return event;\n    };\n    const bindOnReady = (win, callback, eventUtils) => {\n      const doc = win.document, event = { type: 'ready' };\n      if (eventUtils.domLoaded) {\n        callback(event);\n        return;\n      }\n      const isDocReady = () => {\n        return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;\n      };\n      const readyHandler = () => {\n        removeEvent(win, 'DOMContentLoaded', readyHandler);\n        removeEvent(win, 'load', readyHandler);\n        if (!eventUtils.domLoaded) {\n          eventUtils.domLoaded = true;\n          callback(event);\n        }\n        win = null;\n      };\n      if (isDocReady()) {\n        readyHandler();\n      } else {\n        addEvent(win, 'DOMContentLoaded', readyHandler);\n      }\n      if (!eventUtils.domLoaded) {\n        addEvent(win, 'load', readyHandler);\n      }\n    };\n    class EventUtils {\n      constructor() {\n        this.domLoaded = false;\n        this.events = {};\n        this.count = 1;\n        this.expando = eventExpandoPrefix + (+new Date()).toString(32);\n        this.hasFocusIn = 'onfocusin' in document.documentElement;\n        this.count = 1;\n      }\n      bind(target, names, callback, scope) {\n        const self = this;\n        let callbackList;\n        const win = window;\n        const defaultNativeHandler = evt => {\n          self.executeHandlers(fix(evt || win.event), id);\n        };\n        if (!target || isText$b(target) || isComment(target)) {\n          return callback;\n        }\n        let id;\n        if (!target[self.expando]) {\n          id = self.count++;\n          target[self.expando] = id;\n          self.events[id] = {};\n        } else {\n          id = target[self.expando];\n        }\n        scope = scope || target;\n        const namesList = names.split(' ');\n        let i = namesList.length;\n        while (i--) {\n          let name = namesList[i];\n          let nativeHandler = defaultNativeHandler;\n          let capture = false;\n          let fakeName = false;\n          if (name === 'DOMContentLoaded') {\n            name = 'ready';\n          }\n          if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {\n            callback.call(scope, fix({ type: name }));\n            continue;\n          }\n          if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {\n            capture = true;\n            fakeName = name === 'focusin' ? 'focus' : 'blur';\n            nativeHandler = evt => {\n              const event = fix(evt || win.event);\n              event.type = event.type === 'focus' ? 'focusin' : 'focusout';\n              self.executeHandlers(event, id);\n            };\n          }\n          callbackList = self.events[id][name];\n          if (!callbackList) {\n            self.events[id][name] = callbackList = [{\n                func: callback,\n                scope\n              }];\n            callbackList.fakeName = fakeName;\n            callbackList.capture = capture;\n            callbackList.nativeHandler = nativeHandler;\n            if (name === 'ready') {\n              bindOnReady(target, nativeHandler, self);\n            } else {\n              addEvent(target, fakeName || name, nativeHandler, capture);\n            }\n          } else {\n            if (name === 'ready' && self.domLoaded) {\n              callback(fix({ type: name }));\n            } else {\n              callbackList.push({\n                func: callback,\n                scope\n              });\n            }\n          }\n        }\n        target = callbackList = null;\n        return callback;\n      }\n      unbind(target, names, callback) {\n        if (!target || isText$b(target) || isComment(target)) {\n          return this;\n        }\n        const id = target[this.expando];\n        if (id) {\n          let eventMap = this.events[id];\n          if (names) {\n            const namesList = names.split(' ');\n            let i = namesList.length;\n            while (i--) {\n              const name = namesList[i];\n              const callbackList = eventMap[name];\n              if (callbackList) {\n                if (callback) {\n                  let ci = callbackList.length;\n                  while (ci--) {\n                    if (callbackList[ci].func === callback) {\n                      const nativeHandler = callbackList.nativeHandler;\n                      const fakeName = callbackList.fakeName, capture = callbackList.capture;\n                      const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));\n                      newCallbackList.nativeHandler = nativeHandler;\n                      newCallbackList.fakeName = fakeName;\n                      newCallbackList.capture = capture;\n                      eventMap[name] = newCallbackList;\n                    }\n                  }\n                }\n                if (!callback || callbackList.length === 0) {\n                  delete eventMap[name];\n                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n                }\n              }\n            }\n          } else {\n            each$d(eventMap, (callbackList, name) => {\n              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n            });\n            eventMap = {};\n          }\n          for (const name in eventMap) {\n            if (has$2(eventMap, name)) {\n              return this;\n            }\n          }\n          delete this.events[id];\n          try {\n            delete target[this.expando];\n          } catch (ex) {\n            target[this.expando] = null;\n          }\n        }\n        return this;\n      }\n      fire(target, name, args) {\n        return this.dispatch(target, name, args);\n      }\n      dispatch(target, name, args) {\n        if (!target || isText$b(target) || isComment(target)) {\n          return this;\n        }\n        const event = fix({\n          type: name,\n          target\n        }, args);\n        do {\n          const id = target[this.expando];\n          if (id) {\n            this.executeHandlers(event, id);\n          }\n          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;\n        } while (target && !event.isPropagationStopped());\n        return this;\n      }\n      clean(target) {\n        if (!target || isText$b(target) || isComment(target)) {\n          return this;\n        }\n        if (target[this.expando]) {\n          this.unbind(target);\n        }\n        if (!target.getElementsByTagName) {\n          target = target.document;\n        }\n        if (target && target.getElementsByTagName) {\n          this.unbind(target);\n          const children = target.getElementsByTagName('*');\n          let i = children.length;\n          while (i--) {\n            target = children[i];\n            if (target[this.expando]) {\n              this.unbind(target);\n            }\n          }\n        }\n        return this;\n      }\n      destroy() {\n        this.events = {};\n      }\n      cancel(e) {\n        if (e) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n        }\n        return false;\n      }\n      executeHandlers(evt, id) {\n        const container = this.events[id];\n        const callbackList = container && container[evt.type];\n        if (callbackList) {\n          for (let i = 0, l = callbackList.length; i < l; i++) {\n            const callback = callbackList[i];\n            if (callback && callback.func.call(callback.scope, evt) === false) {\n              evt.preventDefault();\n            }\n            if (evt.isImmediatePropagationStopped()) {\n              return;\n            }\n          }\n        }\n      }\n    }\n    EventUtils.Event = new EventUtils();\n\n    const each$a = Tools.each;\n    const grep = Tools.grep;\n    const internalStyleName = 'data-mce-style';\n    const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');\n    const legacySetAttribute = (elm, name, value) => {\n      if (isNullable(value) || value === '') {\n        remove$9(elm, name);\n      } else {\n        set$3(elm, name, value);\n      }\n    };\n    const camelCaseToHyphens = name => name.replace(/[A-Z]/g, v => '-' + v.toLowerCase());\n    const findNodeIndex = (node, normalized) => {\n      let idx = 0;\n      if (node) {\n        for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {\n          const nodeType = tempNode.nodeType;\n          if (normalized && isText$b(tempNode)) {\n            if (nodeType === lastNodeType || !tempNode.data.length) {\n              continue;\n            }\n          }\n          idx++;\n          lastNodeType = nodeType;\n        }\n      }\n      return idx;\n    };\n    const updateInternalStyleAttr = (styles, elm) => {\n      const rawValue = get$9(elm, 'style');\n      const value = styles.serialize(styles.parse(rawValue), name(elm));\n      legacySetAttribute(elm, internalStyleName, value);\n    };\n    const convertStyleToString = (cssValue, cssName) => {\n      if (isNumber(cssValue)) {\n        return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';\n      } else {\n        return cssValue;\n      }\n    };\n    const applyStyle$1 = ($elm, cssName, cssValue) => {\n      const normalizedName = camelCaseToHyphens(cssName);\n      if (isNullable(cssValue) || cssValue === '') {\n        remove$5($elm, normalizedName);\n      } else {\n        set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));\n      }\n    };\n    const setupAttrHooks = (styles, settings, getContext) => {\n      const keepValues = settings.keep_values;\n      const keepUrlHook = {\n        set: (elm, value, name) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          if (isFunction(settings.url_converter) && isNonNullable(value)) {\n            value = settings.url_converter.call(settings.url_converter_scope || getContext(), String(value), name, elm);\n          }\n          const internalName = 'data-mce-' + name;\n          legacySetAttribute(sugarElm, internalName, value);\n          legacySetAttribute(sugarElm, name, value);\n        },\n        get: (elm, name) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);\n        }\n      };\n      const attrHooks = {\n        style: {\n          set: (elm, value) => {\n            const sugarElm = SugarElement.fromDom(elm);\n            if (keepValues) {\n              legacySetAttribute(sugarElm, internalStyleName, value);\n            }\n            remove$9(sugarElm, 'style');\n            if (isString(value)) {\n              setAll(sugarElm, styles.parse(value));\n            }\n          },\n          get: elm => {\n            const sugarElm = SugarElement.fromDom(elm);\n            const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');\n            return styles.serialize(styles.parse(value), name(sugarElm));\n          }\n        }\n      };\n      if (keepValues) {\n        attrHooks.href = attrHooks.src = keepUrlHook;\n      }\n      return attrHooks;\n    };\n    const DOMUtils = (doc, settings = {}) => {\n      const addedStyles = {};\n      const win = window;\n      const files = {};\n      let counter = 0;\n      const stdMode = true;\n      const boxModel = true;\n      const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {\n        contentCssCors: settings.contentCssCors,\n        referrerPolicy: settings.referrerPolicy\n      });\n      const boundEvents = [];\n      const schema = settings.schema ? settings.schema : Schema({});\n      const styles = Styles({\n        url_converter: settings.url_converter,\n        url_converter_scope: settings.url_converter_scope\n      }, settings.schema);\n      const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;\n      const blockElementsMap = schema.getBlockElements();\n      const isBlock = node => {\n        if (isString(node)) {\n          return has$2(blockElementsMap, node);\n        } else {\n          return isElement$6(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));\n        }\n      };\n      const get = elm => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;\n      const _get = elm => {\n        const value = get(elm);\n        return isNonNullable(value) ? SugarElement.fromDom(value) : null;\n      };\n      const getAttrib = (elm, name, defaultVal = '') => {\n        let value;\n        const $elm = _get(elm);\n        if (isNonNullable($elm) && isElement$7($elm)) {\n          const hook = attrHooks[name];\n          if (hook && hook.get) {\n            value = hook.get($elm.dom, name);\n          } else {\n            value = get$9($elm, name);\n          }\n        }\n        return isNonNullable(value) ? value : defaultVal;\n      };\n      const getAttribs = elm => {\n        const node = get(elm);\n        return isNullable(node) ? [] : node.attributes;\n      };\n      const setAttrib = (elm, name, value) => {\n        run(elm, e => {\n          if (isElement$6(e)) {\n            const $elm = SugarElement.fromDom(e);\n            const val = value === '' ? null : value;\n            const originalValue = get$9($elm, name);\n            const hook = attrHooks[name];\n            if (hook && hook.set) {\n              hook.set($elm.dom, val, name);\n            } else {\n              legacySetAttribute($elm, name, val);\n            }\n            if (originalValue !== val && settings.onSetAttrib) {\n              settings.onSetAttrib({\n                attrElm: $elm.dom,\n                attrName: name,\n                attrValue: val\n              });\n            }\n          }\n        });\n      };\n      const clone = (node, deep) => {\n        return node.cloneNode(deep);\n      };\n      const getRoot = () => settings.root_element || doc.body;\n      const getViewPort = argWin => {\n        const vp = getBounds(argWin);\n        return {\n          x: vp.x,\n          y: vp.y,\n          w: vp.width,\n          h: vp.height\n        };\n      };\n      const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);\n      const setStyle = (elm, name, value) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          applyStyle$1($elm, name, value);\n          if (settings.update_styles) {\n            updateInternalStyleAttr(styles, $elm);\n          }\n        });\n      };\n      const setStyles = (elm, stylesArg) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          each$d(stylesArg, (v, n) => {\n            applyStyle$1($elm, n, v);\n          });\n          if (settings.update_styles) {\n            updateInternalStyleAttr(styles, $elm);\n          }\n        });\n      };\n      const getStyle = (elm, name, computed) => {\n        const $elm = get(elm);\n        if (isNullable($elm) || !isHTMLElement($elm) && !isSVGElement($elm)) {\n          return undefined;\n        }\n        if (computed) {\n          return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));\n        } else {\n          name = name.replace(/-(\\D)/g, (a, b) => b.toUpperCase());\n          if (name === 'float') {\n            name = 'cssFloat';\n          }\n          return $elm.style ? $elm.style[name] : undefined;\n        }\n      };\n      const getSize = elm => {\n        const $elm = get(elm);\n        if (!$elm) {\n          return {\n            w: 0,\n            h: 0\n          };\n        }\n        let w = getStyle($elm, 'width');\n        let h = getStyle($elm, 'height');\n        if (!w || w.indexOf('px') === -1) {\n          w = '0';\n        }\n        if (!h || h.indexOf('px') === -1) {\n          h = '0';\n        }\n        return {\n          w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,\n          h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight\n        };\n      };\n      const getRect = elm => {\n        const $elm = get(elm);\n        const pos = getPos$1($elm);\n        const size = getSize($elm);\n        return {\n          x: pos.x,\n          y: pos.y,\n          w: size.w,\n          h: size.h\n        };\n      };\n      const is = (elm, selector) => {\n        if (!elm) {\n          return false;\n        }\n        const elms = isArray$1(elm) ? elm : [elm];\n        return exists(elms, e => {\n          return is$1(SugarElement.fromDom(e), selector);\n        });\n      };\n      const getParents = (elm, selector, root, collect) => {\n        const result = [];\n        let node = get(elm);\n        collect = collect === undefined;\n        const resolvedRoot = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);\n        if (isString(selector)) {\n          if (selector === '*') {\n            selector = isElement$6;\n          } else {\n            const selectorVal = selector;\n            selector = node => is(node, selectorVal);\n          }\n        }\n        while (node) {\n          if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {\n            break;\n          }\n          if (!selector || selector(node)) {\n            if (collect) {\n              result.push(node);\n            } else {\n              return [node];\n            }\n          }\n          node = node.parentNode;\n        }\n        return collect ? result : null;\n      };\n      const getParent = (node, selector, root) => {\n        const parents = getParents(node, selector, root, false);\n        return parents && parents.length > 0 ? parents[0] : null;\n      };\n      const _findSib = (node, selector, name) => {\n        let func = selector;\n        if (node) {\n          if (isString(selector)) {\n            func = node => {\n              return is(node, selector);\n            };\n          }\n          for (let tempNode = node[name]; tempNode; tempNode = tempNode[name]) {\n            if (isFunction(func) && func(tempNode)) {\n              return tempNode;\n            }\n          }\n        }\n        return null;\n      };\n      const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');\n      const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');\n      const isParentNode = node => isFunction(node.querySelectorAll);\n      const select = (selector, scope) => {\n        var _a, _b;\n        const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;\n        return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];\n      };\n      const run = function (elm, func, scope) {\n        const context = scope !== null && scope !== void 0 ? scope : this;\n        if (isArray$1(elm)) {\n          const result = [];\n          each$a(elm, (e, i) => {\n            const node = get(e);\n            if (node) {\n              result.push(func.call(context, node, i));\n            }\n          });\n          return result;\n        } else {\n          const node = get(elm);\n          return !node ? false : func.call(context, node);\n        }\n      };\n      const setAttribs = (elm, attrs) => {\n        run(elm, $elm => {\n          each$d(attrs, (value, name) => {\n            setAttrib($elm, name, value);\n          });\n        });\n      };\n      const setHTML = (elm, html) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          set$1($elm, html);\n        });\n      };\n      const add = (parentElm, name, attrs, html, create) => run(parentElm, parentElm => {\n        const newElm = isString(name) ? doc.createElement(name) : name;\n        if (isNonNullable(attrs)) {\n          setAttribs(newElm, attrs);\n        }\n        if (html) {\n          if (!isString(html) && html.nodeType) {\n            newElm.appendChild(html);\n          } else if (isString(html)) {\n            setHTML(newElm, html);\n          }\n        }\n        return !create ? parentElm.appendChild(newElm) : newElm;\n      });\n      const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);\n      const decode = Entities.decode;\n      const encode = Entities.encodeAllRaw;\n      const createHTML = (name, attrs, html = '') => {\n        let outHtml = '<' + name;\n        for (const key in attrs) {\n          if (hasNonNullableKey(attrs, key)) {\n            outHtml += ' ' + key + '=\"' + encode(attrs[key]) + '\"';\n          }\n        }\n        if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {\n          return outHtml + ' />';\n        } else {\n          return outHtml + '>' + html + '</' + name + '>';\n        }\n      };\n      const createFragment = html => {\n        const container = doc.createElement('div');\n        const frag = doc.createDocumentFragment();\n        frag.appendChild(container);\n        if (html) {\n          container.innerHTML = html;\n        }\n        let node;\n        while (node = container.firstChild) {\n          frag.appendChild(node);\n        }\n        frag.removeChild(container);\n        return frag;\n      };\n      const remove = (node, keepChildren) => {\n        return run(node, n => {\n          const $node = SugarElement.fromDom(n);\n          if (keepChildren) {\n            each$e(children$1($node), child => {\n              if (isText$c(child) && child.dom.length === 0) {\n                remove$4(child);\n              } else {\n                before$3($node, child);\n              }\n            });\n          }\n          remove$4($node);\n          return $node.dom;\n        });\n      };\n      const removeAllAttribs = e => run(e, e => {\n        const attrs = e.attributes;\n        for (let i = attrs.length - 1; i >= 0; i--) {\n          e.removeAttributeNode(attrs.item(i));\n        }\n      });\n      const parseStyle = cssText => styles.parse(cssText);\n      const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);\n      const addStyle = cssText => {\n        if (self !== DOMUtils.DOM && doc === document) {\n          if (addedStyles[cssText]) {\n            return;\n          }\n          addedStyles[cssText] = true;\n        }\n        let styleElm = doc.getElementById('mceDefaultStyles');\n        if (!styleElm) {\n          styleElm = doc.createElement('style');\n          styleElm.id = 'mceDefaultStyles';\n          styleElm.type = 'text/css';\n          const head = doc.head;\n          if (head.firstChild) {\n            head.insertBefore(styleElm, head.firstChild);\n          } else {\n            head.appendChild(styleElm);\n          }\n        }\n        if (styleElm.styleSheet) {\n          styleElm.styleSheet.cssText += cssText;\n        } else {\n          styleElm.appendChild(doc.createTextNode(cssText));\n        }\n      };\n      const loadCSS = urls => {\n        if (!urls) {\n          urls = '';\n        }\n        each$e(urls.split(','), url => {\n          files[url] = true;\n          styleSheetLoader.load(url).catch(noop);\n        });\n      };\n      const toggleClass = (elm, cls, state) => {\n        run(elm, e => {\n          if (isElement$6(e)) {\n            const $elm = SugarElement.fromDom(e);\n            const classes = cls.split(' ');\n            each$e(classes, c => {\n              if (isNonNullable(state)) {\n                const fn = state ? add$2 : remove$6;\n                fn($elm, c);\n              } else {\n                toggle$1($elm, c);\n              }\n            });\n          }\n        });\n      };\n      const addClass = (elm, cls) => {\n        toggleClass(elm, cls, true);\n      };\n      const removeClass = (elm, cls) => {\n        toggleClass(elm, cls, false);\n      };\n      const hasClass = (elm, cls) => {\n        const $elm = _get(elm);\n        const classes = cls.split(' ');\n        return isNonNullable($elm) && forall(classes, c => has($elm, c));\n      };\n      const show = elm => {\n        run(elm, e => remove$5(SugarElement.fromDom(e), 'display'));\n      };\n      const hide = elm => {\n        run(elm, e => set$2(SugarElement.fromDom(e), 'display', 'none'));\n      };\n      const isHidden = elm => {\n        const $elm = _get(elm);\n        return isNonNullable($elm) && is$2(getRaw($elm, 'display'), 'none');\n      };\n      const uniqueId = prefix => (!prefix ? 'mce_' : prefix) + counter++;\n      const getOuterHTML = elm => {\n        const $elm = _get(elm);\n        if (isNonNullable($elm)) {\n          return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);\n        } else {\n          return '';\n        }\n      };\n      const setOuterHTML = (elm, html) => {\n        run(elm, $elm => {\n          if (isElement$6($elm)) {\n            $elm.outerHTML = html;\n          }\n        });\n      };\n      const insertAfter = (node, reference) => {\n        const referenceNode = get(reference);\n        return run(node, node => {\n          const parent = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;\n          const nextSibling = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;\n          if (parent) {\n            if (nextSibling) {\n              parent.insertBefore(node, nextSibling);\n            } else {\n              parent.appendChild(node);\n            }\n          }\n          return node;\n        });\n      };\n      const replace = (newElm, oldElm, keepChildren) => run(oldElm, elm => {\n        var _a;\n        const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;\n        if (keepChildren) {\n          each$a(grep(elm.childNodes), node => {\n            replacee.appendChild(node);\n          });\n        }\n        (_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(replacee, elm);\n        return elm;\n      });\n      const rename = (elm, name) => {\n        if (elm.nodeName !== name.toUpperCase()) {\n          const newElm = create(name);\n          each$a(getAttribs(elm), attrNode => {\n            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));\n          });\n          replace(newElm, elm, true);\n          return newElm;\n        } else {\n          return elm;\n        }\n      };\n      const findCommonAncestor = (a, b) => {\n        let ps = a;\n        while (ps) {\n          let pe = b;\n          while (pe && ps !== pe) {\n            pe = pe.parentNode;\n          }\n          if (ps === pe) {\n            break;\n          }\n          ps = ps.parentNode;\n        }\n        if (!ps && a.ownerDocument) {\n          return a.ownerDocument.documentElement;\n        } else {\n          return ps;\n        }\n      };\n      const isEmpty = (node, elements, options) => {\n        if (isPlainObject(elements)) {\n          const isContent = node => {\n            const name = node.nodeName.toLowerCase();\n            return Boolean(elements[name]);\n          };\n          return isEmptyNode(schema, node, {\n            ...options,\n            isContent\n          });\n        } else {\n          return isEmptyNode(schema, node, options);\n        }\n      };\n      const createRng = () => doc.createRange();\n      const split = (parentElm, splitElm, replacementElm) => {\n        let range = createRng();\n        let beforeFragment;\n        let afterFragment;\n        if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {\n          const parentNode = parentElm.parentNode;\n          range.setStart(parentNode, findNodeIndex(parentElm));\n          range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));\n          beforeFragment = range.extractContents();\n          range = createRng();\n          range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);\n          range.setEnd(parentNode, findNodeIndex(parentElm) + 1);\n          afterFragment = range.extractContents();\n          parentNode.insertBefore(trimNode(self, beforeFragment, schema), parentElm);\n          if (replacementElm) {\n            parentNode.insertBefore(replacementElm, parentElm);\n          } else {\n            parentNode.insertBefore(splitElm, parentElm);\n          }\n          parentNode.insertBefore(trimNode(self, afterFragment, schema), parentElm);\n          remove(parentElm);\n          return replacementElm || splitElm;\n        } else {\n          return undefined;\n        }\n      };\n      const bind = (target, name, func, scope) => {\n        if (isArray$1(target)) {\n          let i = target.length;\n          const rv = [];\n          while (i--) {\n            rv[i] = bind(target[i], name, func, scope);\n          }\n          return rv;\n        } else {\n          if (settings.collect && (target === doc || target === win)) {\n            boundEvents.push([\n              target,\n              name,\n              func,\n              scope\n            ]);\n          }\n          return events.bind(target, name, func, scope || self);\n        }\n      };\n      const unbind = (target, name, func) => {\n        if (isArray$1(target)) {\n          let i = target.length;\n          const rv = [];\n          while (i--) {\n            rv[i] = unbind(target[i], name, func);\n          }\n          return rv;\n        } else {\n          if (boundEvents.length > 0 && (target === doc || target === win)) {\n            let i = boundEvents.length;\n            while (i--) {\n              const [boundTarget, boundName, boundFunc] = boundEvents[i];\n              if (target === boundTarget && (!name || name === boundName) && (!func || func === boundFunc)) {\n                events.unbind(boundTarget, boundName, boundFunc);\n              }\n            }\n          }\n          return events.unbind(target, name, func);\n        }\n      };\n      const dispatch = (target, name, evt) => events.dispatch(target, name, evt);\n      const fire = (target, name, evt) => events.dispatch(target, name, evt);\n      const getContentEditable = node => {\n        if (node && isHTMLElement(node)) {\n          const contentEditable = node.getAttribute('data-mce-contenteditable');\n          if (contentEditable && contentEditable !== 'inherit') {\n            return contentEditable;\n          }\n          return node.contentEditable !== 'inherit' ? node.contentEditable : null;\n        } else {\n          return null;\n        }\n      };\n      const getContentEditableParent = node => {\n        const root = getRoot();\n        let state = null;\n        for (let tempNode = node; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n          state = getContentEditable(tempNode);\n          if (state !== null) {\n            break;\n          }\n        }\n        return state;\n      };\n      const isEditable = node => {\n        if (isNonNullable(node)) {\n          const scope = isElement$6(node) ? node : node.parentElement;\n          return isNonNullable(scope) && isHTMLElement(scope) && isEditable$2(SugarElement.fromDom(scope));\n        } else {\n          return false;\n        }\n      };\n      const destroy = () => {\n        if (boundEvents.length > 0) {\n          let i = boundEvents.length;\n          while (i--) {\n            const [boundTarget, boundName, boundFunc] = boundEvents[i];\n            events.unbind(boundTarget, boundName, boundFunc);\n          }\n        }\n        each$d(files, (_, url) => {\n          styleSheetLoader.unload(url);\n          delete files[url];\n        });\n      };\n      const isChildOf = (node, parent) => {\n        return node === parent || parent.contains(node);\n      };\n      const dumpRng = r => 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;\n      const self = {\n        doc,\n        settings,\n        win,\n        files,\n        stdMode,\n        boxModel,\n        styleSheetLoader,\n        boundEvents,\n        styles,\n        schema,\n        events,\n        isBlock: isBlock,\n        root: null,\n        clone,\n        getRoot,\n        getViewPort,\n        getRect,\n        getSize,\n        getParent,\n        getParents: getParents,\n        get,\n        getNext,\n        getPrev,\n        select,\n        is,\n        add,\n        create,\n        createHTML,\n        createFragment,\n        remove,\n        setStyle,\n        getStyle: getStyle,\n        setStyles,\n        removeAllAttribs,\n        setAttrib,\n        setAttribs,\n        getAttrib,\n        getPos: getPos$1,\n        parseStyle,\n        serializeStyle,\n        addStyle,\n        loadCSS,\n        addClass,\n        removeClass,\n        hasClass,\n        toggleClass,\n        show,\n        hide,\n        isHidden,\n        uniqueId,\n        setHTML,\n        getOuterHTML,\n        setOuterHTML,\n        decode,\n        encode,\n        insertAfter,\n        replace,\n        rename,\n        findCommonAncestor,\n        run,\n        getAttribs,\n        isEmpty,\n        createRng,\n        nodeIndex: findNodeIndex,\n        split,\n        bind: bind,\n        unbind: unbind,\n        fire,\n        dispatch,\n        getContentEditable,\n        getContentEditableParent,\n        isEditable,\n        destroy,\n        isChildOf,\n        dumpRng\n      };\n      const attrHooks = setupAttrHooks(styles, settings, constant(self));\n      return self;\n    };\n    DOMUtils.DOM = DOMUtils(document);\n    DOMUtils.nodeIndex = findNodeIndex;\n\n    const DOM$b = DOMUtils.DOM;\n    const QUEUED = 0;\n    const LOADING = 1;\n    const LOADED = 2;\n    const FAILED = 3;\n    class ScriptLoader {\n      constructor(settings = {}) {\n        this.states = {};\n        this.queue = [];\n        this.scriptLoadedCallbacks = {};\n        this.queueLoadedCallbacks = [];\n        this.loading = false;\n        this.settings = settings;\n      }\n      _setReferrerPolicy(referrerPolicy) {\n        this.settings.referrerPolicy = referrerPolicy;\n      }\n      loadScript(url) {\n        return new Promise((resolve, reject) => {\n          const dom = DOM$b;\n          let elm;\n          const cleanup = () => {\n            dom.remove(id);\n            if (elm) {\n              elm.onerror = elm.onload = elm = null;\n            }\n          };\n          const done = () => {\n            cleanup();\n            resolve();\n          };\n          const error = () => {\n            cleanup();\n            reject('Failed to load script: ' + url);\n          };\n          const id = dom.uniqueId();\n          elm = document.createElement('script');\n          elm.id = id;\n          elm.type = 'text/javascript';\n          elm.src = Tools._addCacheSuffix(url);\n          if (this.settings.referrerPolicy) {\n            dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);\n          }\n          elm.onload = done;\n          elm.onerror = error;\n          (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);\n        });\n      }\n      isDone(url) {\n        return this.states[url] === LOADED;\n      }\n      markDone(url) {\n        this.states[url] = LOADED;\n      }\n      add(url) {\n        const self = this;\n        self.queue.push(url);\n        const state = self.states[url];\n        if (state === undefined) {\n          self.states[url] = QUEUED;\n        }\n        return new Promise((resolve, reject) => {\n          if (!self.scriptLoadedCallbacks[url]) {\n            self.scriptLoadedCallbacks[url] = [];\n          }\n          self.scriptLoadedCallbacks[url].push({\n            resolve,\n            reject\n          });\n        });\n      }\n      load(url) {\n        return this.add(url);\n      }\n      remove(url) {\n        delete this.states[url];\n        delete this.scriptLoadedCallbacks[url];\n      }\n      loadQueue() {\n        const queue = this.queue;\n        this.queue = [];\n        return this.loadScripts(queue);\n      }\n      loadScripts(scripts) {\n        const self = this;\n        const execCallbacks = (name, url) => {\n          get$a(self.scriptLoadedCallbacks, url).each(callbacks => {\n            each$e(callbacks, callback => callback[name](url));\n          });\n          delete self.scriptLoadedCallbacks[url];\n        };\n        const processResults = results => {\n          const failures = filter$5(results, result => result.status === 'rejected');\n          if (failures.length > 0) {\n            return Promise.reject(bind$3(failures, ({reason}) => isArray$1(reason) ? reason : [reason]));\n          } else {\n            return Promise.resolve();\n          }\n        };\n        const load = urls => Promise.allSettled(map$3(urls, url => {\n          if (self.states[url] === LOADED) {\n            execCallbacks('resolve', url);\n            return Promise.resolve();\n          } else if (self.states[url] === FAILED) {\n            execCallbacks('reject', url);\n            return Promise.reject(url);\n          } else {\n            self.states[url] = LOADING;\n            return self.loadScript(url).then(() => {\n              self.states[url] = LOADED;\n              execCallbacks('resolve', url);\n              const queue = self.queue;\n              if (queue.length > 0) {\n                self.queue = [];\n                return load(queue).then(processResults);\n              } else {\n                return Promise.resolve();\n              }\n            }, () => {\n              self.states[url] = FAILED;\n              execCallbacks('reject', url);\n              return Promise.reject(url);\n            });\n          }\n        }));\n        const processQueue = urls => {\n          self.loading = true;\n          return load(urls).then(results => {\n            self.loading = false;\n            const nextQueuedItem = self.queueLoadedCallbacks.shift();\n            Optional.from(nextQueuedItem).each(call);\n            return processResults(results);\n          });\n        };\n        const uniqueScripts = stringArray(scripts);\n        if (self.loading) {\n          return new Promise((resolve, reject) => {\n            self.queueLoadedCallbacks.push(() => {\n              processQueue(uniqueScripts).then(resolve, reject);\n            });\n          });\n        } else {\n          return processQueue(uniqueScripts);\n        }\n      }\n    }\n    ScriptLoader.ScriptLoader = new ScriptLoader();\n\n    const isDuplicated = (items, item) => {\n      const firstIndex = items.indexOf(item);\n      return firstIndex !== -1 && items.indexOf(item, firstIndex + 1) > firstIndex;\n    };\n    const isRaw = str => isObject(str) && has$2(str, 'raw');\n    const isTokenised = str => isArray$1(str) && str.length > 1;\n    const data = {};\n    const currentCode = Cell('en');\n    const getLanguageData = () => get$a(data, currentCode.get());\n    const getData$1 = () => map$2(data, value => ({ ...value }));\n    const setCode = newCode => {\n      if (newCode) {\n        currentCode.set(newCode);\n      }\n    };\n    const getCode = () => currentCode.get();\n    const add$1 = (code, items) => {\n      let langData = data[code];\n      if (!langData) {\n        data[code] = langData = {};\n      }\n      const lcNames = map$3(keys(items), name => name.toLowerCase());\n      each$d(items, (translation, name) => {\n        const lcName = name.toLowerCase();\n        if (lcName !== name && isDuplicated(lcNames, lcName)) {\n          if (!has$2(items, lcName)) {\n            langData[lcName] = translation;\n          }\n          langData[name] = translation;\n        } else {\n          langData[lcName] = translation;\n        }\n      });\n    };\n    const translate = text => {\n      const langData = getLanguageData().getOr({});\n      const toString = obj => {\n        if (isFunction(obj)) {\n          return Object.prototype.toString.call(obj);\n        }\n        return !isEmpty(obj) ? '' + obj : '';\n      };\n      const isEmpty = text => text === '' || text === null || text === undefined;\n      const getLangData = text => {\n        const textStr = toString(text);\n        return has$2(langData, textStr) ? toString(langData[textStr]) : get$a(langData, textStr.toLowerCase()).map(toString).getOr(textStr);\n      };\n      const removeContext = str => str.replace(/{context:\\w+}$/, '');\n      if (isEmpty(text)) {\n        return '';\n      }\n      if (isRaw(text)) {\n        return toString(text.raw);\n      }\n      if (isTokenised(text)) {\n        const values = text.slice(1);\n        const substitued = getLangData(text[0]).replace(/\\{([0-9]+)\\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);\n        return removeContext(substitued);\n      }\n      return removeContext(getLangData(text));\n    };\n    const isRtl$1 = () => getLanguageData().bind(items => get$a(items, '_dir')).exists(dir => dir === 'rtl');\n    const hasCode = code => has$2(data, code);\n    const I18n = {\n      getData: getData$1,\n      setCode,\n      getCode,\n      add: add$1,\n      translate,\n      isRtl: isRtl$1,\n      hasCode\n    };\n\n    const AddOnManager = () => {\n      const items = [];\n      const urls = {};\n      const lookup = {};\n      const _listeners = [];\n      const runListeners = (name, state) => {\n        const matchedListeners = filter$5(_listeners, listener => listener.name === name && listener.state === state);\n        each$e(matchedListeners, listener => listener.resolve());\n      };\n      const isLoaded = name => has$2(urls, name);\n      const isAdded = name => has$2(lookup, name);\n      const get = name => {\n        if (lookup[name]) {\n          return lookup[name].instance;\n        }\n        return undefined;\n      };\n      const loadLanguagePack = (name, languages) => {\n        const language = I18n.getCode();\n        const wrappedLanguages = ',' + (languages || '') + ',';\n        if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {\n          return;\n        }\n        ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');\n      };\n      const requireLangPack = (name, languages) => {\n        if (AddOnManager.languageLoad !== false) {\n          if (isLoaded(name)) {\n            loadLanguagePack(name, languages);\n          } else {\n            waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));\n          }\n        }\n      };\n      const add = (id, addOn) => {\n        items.push(addOn);\n        lookup[id] = { instance: addOn };\n        runListeners(id, 'added');\n        return addOn;\n      };\n      const remove = name => {\n        delete urls[name];\n        delete lookup[name];\n      };\n      const createUrl = (baseUrl, dep) => {\n        if (isString(dep)) {\n          return isString(baseUrl) ? {\n            prefix: '',\n            resource: dep,\n            suffix: ''\n          } : {\n            prefix: baseUrl.prefix,\n            resource: dep,\n            suffix: baseUrl.suffix\n          };\n        } else {\n          return dep;\n        }\n      };\n      const load = (name, addOnUrl) => {\n        if (urls[name]) {\n          return Promise.resolve();\n        }\n        let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;\n        if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {\n          urlString = AddOnManager.baseURL + '/' + urlString;\n        }\n        urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));\n        const done = () => {\n          runListeners(name, 'loaded');\n          return Promise.resolve();\n        };\n        if (lookup[name]) {\n          return done();\n        } else {\n          return ScriptLoader.ScriptLoader.add(urlString).then(done);\n        }\n      };\n      const waitFor = (name, state = 'added') => {\n        if (state === 'added' && isAdded(name)) {\n          return Promise.resolve();\n        } else if (state === 'loaded' && isLoaded(name)) {\n          return Promise.resolve();\n        } else {\n          return new Promise(resolve => {\n            _listeners.push({\n              name,\n              state,\n              resolve\n            });\n          });\n        }\n      };\n      return {\n        items,\n        urls,\n        lookup,\n        get,\n        requireLangPack,\n        add,\n        remove,\n        createUrl,\n        load,\n        waitFor\n      };\n    };\n    AddOnManager.languageLoad = true;\n    AddOnManager.baseURL = '';\n    AddOnManager.PluginManager = AddOnManager();\n    AddOnManager.ThemeManager = AddOnManager();\n    AddOnManager.ModelManager = AddOnManager();\n\n    const first$1 = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        if (isNull(timer)) {\n          timer = setTimeout(() => {\n            timer = null;\n            fn.apply(null, args);\n          }, rate);\n        }\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n    const last = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        cancel();\n        timer = setTimeout(() => {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n\n    const ancestor$1 = (scope, selector, isRoot) => ancestor$3(scope, selector, isRoot).isSome();\n\n    const annotation = constant('mce-annotation');\n    const dataAnnotation = constant('data-mce-annotation');\n    const dataAnnotationId = constant('data-mce-annotation-uid');\n    const dataAnnotationActive = constant('data-mce-annotation-active');\n    const dataAnnotationClasses = constant('data-mce-annotation-classes');\n    const dataAnnotationAttributes = constant('data-mce-annotation-attrs');\n\n    const isRoot$1 = root => node => eq(node, root);\n    const identify = (editor, annotationName) => {\n      const rng = editor.selection.getRng();\n      const start = SugarElement.fromDom(rng.startContainer);\n      const root = SugarElement.fromDom(editor.getBody());\n      const selector = annotationName.fold(() => '.' + annotation(), an => `[${ dataAnnotation() }=\"${ an }\"]`);\n      const newStart = child$1(start, rng.startOffset).getOr(start);\n      const closest = closest$3(newStart, selector, isRoot$1(root));\n      return closest.bind(c => getOpt(c, `${ dataAnnotationId() }`).bind(uid => getOpt(c, `${ dataAnnotation() }`).map(name => {\n        const elements = findMarkers(editor, uid);\n        return {\n          uid,\n          name,\n          elements\n        };\n      })));\n    };\n    const isAnnotation = elem => isElement$7(elem) && has(elem, annotation());\n    const isBogusElement = (elem, root) => has$1(elem, 'data-mce-bogus') || ancestor$1(elem, '[data-mce-bogus=\"all\"]', isRoot$1(root));\n    const findMarkers = (editor, uid) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const descendants$1 = descendants(body, `[${ dataAnnotationId() }=\"${ uid }\"]`);\n      return filter$5(descendants$1, descendant => !isBogusElement(descendant, body));\n    };\n    const findAll = (editor, name) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const markers = descendants(body, `[${ dataAnnotation() }=\"${ name }\"]`);\n      const directory = {};\n      each$e(markers, m => {\n        if (!isBogusElement(m, body)) {\n          const uid = get$9(m, dataAnnotationId());\n          const nodesAlready = get$a(directory, uid).getOr([]);\n          directory[uid] = nodesAlready.concat([m]);\n        }\n      });\n      return directory;\n    };\n\n    const setup$y = (editor, registry) => {\n      const changeCallbacks = Cell({});\n      const initData = () => ({\n        listeners: [],\n        previous: value$2()\n      });\n      const withCallbacks = (name, f) => {\n        updateCallbacks(name, data => {\n          f(data);\n          return data;\n        });\n      };\n      const updateCallbacks = (name, f) => {\n        const callbackMap = changeCallbacks.get();\n        const data = get$a(callbackMap, name).getOrThunk(initData);\n        const outputData = f(data);\n        callbackMap[name] = outputData;\n        changeCallbacks.set(callbackMap);\n      };\n      const fireCallbacks = (name, uid, elements) => {\n        withCallbacks(name, data => {\n          each$e(data.listeners, f => f(true, name, {\n            uid,\n            nodes: map$3(elements, elem => elem.dom)\n          }));\n        });\n      };\n      const fireNoAnnotation = name => {\n        withCallbacks(name, data => {\n          each$e(data.listeners, f => f(false, name));\n        });\n      };\n      const toggleActiveAttr = (uid, state) => {\n        each$e(findMarkers(editor, uid), elem => {\n          if (state) {\n            set$3(elem, dataAnnotationActive(), 'true');\n          } else {\n            remove$9(elem, dataAnnotationActive());\n          }\n        });\n      };\n      const onNodeChange = last(() => {\n        const annotations = sort(registry.getNames());\n        each$e(annotations, name => {\n          updateCallbacks(name, data => {\n            const prev = data.previous.get();\n            identify(editor, Optional.some(name)).fold(() => {\n              prev.each(uid => {\n                fireNoAnnotation(name);\n                data.previous.clear();\n                toggleActiveAttr(uid, false);\n              });\n            }, ({uid, name, elements}) => {\n              if (!is$2(prev, uid)) {\n                prev.each(uid => toggleActiveAttr(uid, false));\n                fireCallbacks(name, uid, elements);\n                data.previous.set(uid);\n                toggleActiveAttr(uid, true);\n              }\n            });\n            return {\n              previous: data.previous,\n              listeners: data.listeners\n            };\n          });\n        });\n      }, 30);\n      editor.on('remove', () => {\n        onNodeChange.cancel();\n      });\n      editor.on('NodeChange', () => {\n        onNodeChange.throttle();\n      });\n      const addListener = (name, f) => {\n        updateCallbacks(name, data => ({\n          previous: data.previous,\n          listeners: data.listeners.concat([f])\n        }));\n      };\n      return { addListener };\n    };\n\n    const setup$x = (editor, registry) => {\n      const dataAnnotation$1 = dataAnnotation();\n      const identifyParserNode = node => Optional.from(node.attr(dataAnnotation$1)).bind(registry.lookup);\n      const removeDirectAnnotation = node => {\n        var _a, _b;\n        node.attr(dataAnnotationId(), null);\n        node.attr(dataAnnotation(), null);\n        node.attr(dataAnnotationActive(), null);\n        const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map(names => names.split(',')).getOr([]);\n        const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map(names => names.split(',')).getOr([]);\n        each$e(customAttrNames, name => node.attr(name, null));\n        const classList = (_b = (_a = node.attr('class')) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];\n        const newClassList = difference(classList, [annotation()].concat(customClasses));\n        node.attr('class', newClassList.length > 0 ? newClassList.join(' ') : null);\n        node.attr(dataAnnotationClasses(), null);\n        node.attr(dataAnnotationAttributes(), null);\n      };\n      editor.serializer.addTempAttr(dataAnnotationActive());\n      editor.serializer.addAttributeFilter(dataAnnotation$1, nodes => {\n        for (const node of nodes) {\n          identifyParserNode(node).each(settings => {\n            if (settings.persistent === false) {\n              if (node.name === 'span') {\n                node.unwrap();\n              } else {\n                removeDirectAnnotation(node);\n              }\n            }\n          });\n        }\n      });\n    };\n\n    const create$b = () => {\n      const annotations = {};\n      const register = (name, settings) => {\n        annotations[name] = {\n          name,\n          settings\n        };\n      };\n      const lookup = name => get$a(annotations, name).map(a => a.settings);\n      const getNames = () => keys(annotations);\n      return {\n        register,\n        lookup,\n        getNames\n      };\n    };\n\n    let unique = 0;\n    const generate$1 = prefix => {\n      const date = new Date();\n      const time = date.getTime();\n      const random = Math.floor(Math.random() * 1000000000);\n      unique++;\n      return prefix + '_' + random + unique + String(time);\n    };\n\n    const add = (element, classes) => {\n      each$e(classes, x => {\n        add$2(element, x);\n      });\n    };\n    const remove$3 = (element, classes) => {\n      each$e(classes, x => {\n        remove$6(element, x);\n      });\n    };\n\n    const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    const shallow$1 = original => clone$2(original, false);\n    const deep$1 = original => clone$2(original, true);\n    const shallowAs = (original, tag) => {\n      const nu = SugarElement.fromTag(tag);\n      const attributes = clone$4(original);\n      setAll$1(nu, attributes);\n      return nu;\n    };\n    const mutate = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      after$4(original, nu);\n      const children = children$1(original);\n      append(nu, children);\n      remove$4(original);\n      return nu;\n    };\n\n    const TextWalker = (startNode, rootNode, isBoundary = never) => {\n      const walker = new DomTreeWalker(startNode, rootNode);\n      const walk = direction => {\n        let next;\n        do {\n          next = walker[direction]();\n        } while (next && !isText$b(next) && !isBoundary(next));\n        return Optional.from(next).filter(isText$b);\n      };\n      return {\n        current: () => Optional.from(walker.current()).filter(isText$b),\n        next: () => walk('next'),\n        prev: () => walk('prev'),\n        prev2: () => walk('prev2')\n      };\n    };\n\n    const TextSeeker = (dom, isBoundary) => {\n      const isBlockBoundary = isBoundary ? isBoundary : node => dom.isBlock(node) || isBr$6(node) || isContentEditableFalse$b(node);\n      const walk = (node, offset, walker, process) => {\n        if (isText$b(node)) {\n          const newOffset = process(node, offset, node.data);\n          if (newOffset !== -1) {\n            return Optional.some({\n              container: node,\n              offset: newOffset\n            });\n          }\n        }\n        return walker().bind(next => walk(next.container, next.offset, walker, process));\n      };\n      const backwards = (node, offset, process, root) => {\n        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\n        return walk(node, offset, () => walker.prev().map(prev => ({\n          container: prev,\n          offset: prev.length\n        })), process).getOrNull();\n      };\n      const forwards = (node, offset, process, root) => {\n        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\n        return walk(node, offset, () => walker.next().map(next => ({\n          container: next,\n          offset: 0\n        })), process).getOrNull();\n      };\n      return {\n        backwards,\n        forwards\n      };\n    };\n\n    const NodeValue = (is, name) => {\n      const get = element => {\n        if (!is(element)) {\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n        }\n        return getOption(element).getOr('');\n      };\n      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n      const set = (element, value) => {\n        if (!is(element)) {\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n        }\n        element.dom.nodeValue = value;\n      };\n      return {\n        get,\n        getOption,\n        set\n      };\n    };\n\n    const api$1 = NodeValue(isText$c, 'text');\n    const get$3 = element => api$1.get(element);\n    const getOption = element => api$1.getOption(element);\n    const set = (element, value) => api$1.set(element, value);\n\n    const tableCells = [\n      'td',\n      'th'\n    ];\n    const tableSections = [\n      'thead',\n      'tbody',\n      'tfoot'\n    ];\n    const textBlocks = [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'p',\n      'div',\n      'address',\n      'pre',\n      'form',\n      'blockquote',\n      'center',\n      'dir',\n      'fieldset',\n      'header',\n      'footer',\n      'article',\n      'section',\n      'hgroup',\n      'aside',\n      'nav',\n      'figure'\n    ];\n    const listItems$1 = [\n      'li',\n      'dd',\n      'dt'\n    ];\n    const lists = [\n      'ul',\n      'ol',\n      'dl'\n    ];\n    const wsElements = [\n      'pre',\n      'script',\n      'textarea',\n      'style'\n    ];\n    const lazyLookup = items => {\n      let lookup;\n      return node => {\n        lookup = lookup ? lookup : mapToObject(items, always);\n        return has$2(lookup, name(node));\n      };\n    };\n    const isTable$1 = node => name(node) === 'table';\n    const isBr$5 = node => isElement$7(node) && name(node) === 'br';\n    const isTextBlock$2 = lazyLookup(textBlocks);\n    const isList = lazyLookup(lists);\n    const isListItem$1 = lazyLookup(listItems$1);\n    const isTableSection = lazyLookup(tableSections);\n    const isTableCell$2 = lazyLookup(tableCells);\n    const isWsPreserveElement = lazyLookup(wsElements);\n\n    const getLastChildren$1 = elm => {\n      const children = [];\n      let rawNode = elm.dom;\n      while (rawNode) {\n        children.push(SugarElement.fromDom(rawNode));\n        rawNode = rawNode.lastChild;\n      }\n      return children;\n    };\n    const removeTrailingBr = elm => {\n      const allBrs = descendants(elm, 'br');\n      const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);\n      if (allBrs.length === brs.length) {\n        each$e(brs, remove$4);\n      }\n    };\n    const createPaddingBr = () => {\n      const br = SugarElement.fromTag('br');\n      set$3(br, 'data-mce-bogus', '1');\n      return br;\n    };\n    const fillWithPaddingBr = elm => {\n      empty(elm);\n      append$1(elm, createPaddingBr());\n    };\n    const trimBlockTrailingBr = (elm, schema) => {\n      lastChild(elm).each(lastChild => {\n        prevSibling(lastChild).each(lastChildPrevSibling => {\n          if (schema.isBlock(name(elm)) && isBr$5(lastChild) && schema.isBlock(name(lastChildPrevSibling))) {\n            remove$4(lastChild);\n          }\n        });\n      });\n    };\n\n    const ZWSP$1 = zeroWidth;\n    const isZwsp = isZwsp$2;\n    const trim$2 = removeZwsp;\n    const insert$5 = editor => editor.insertContent(ZWSP$1, { preserve_zwsp: true });\n\n    const isElement$5 = isElement$6;\n    const isText$9 = isText$b;\n    const isCaretContainerBlock$1 = node => {\n      if (isText$9(node)) {\n        node = node.parentNode;\n      }\n      return isElement$5(node) && node.hasAttribute('data-mce-caret');\n    };\n    const isCaretContainerInline = node => isText$9(node) && isZwsp(node.data);\n    const isCaretContainer$2 = node => isCaretContainerBlock$1(node) || isCaretContainerInline(node);\n    const hasContent = node => node.firstChild !== node.lastChild || !isBr$6(node.firstChild);\n    const insertInline$1 = (node, before) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const textNode = doc.createTextNode(ZWSP$1);\n      const parentNode = node.parentNode;\n      if (!before) {\n        const sibling = node.nextSibling;\n        if (isText$9(sibling)) {\n          if (isCaretContainer$2(sibling)) {\n            return sibling;\n          }\n          if (startsWithCaretContainer$1(sibling)) {\n            sibling.splitText(1);\n            return sibling;\n          }\n        }\n        if (node.nextSibling) {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node.nextSibling);\n        } else {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(textNode);\n        }\n      } else {\n        const sibling = node.previousSibling;\n        if (isText$9(sibling)) {\n          if (isCaretContainer$2(sibling)) {\n            return sibling;\n          }\n          if (endsWithCaretContainer$1(sibling)) {\n            return sibling.splitText(sibling.data.length - 1);\n          }\n        }\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node);\n      }\n      return textNode;\n    };\n    const isBeforeInline = pos => {\n      const container = pos.container();\n      if (!isText$b(container)) {\n        return false;\n      }\n      return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);\n    };\n    const isAfterInline = pos => {\n      const container = pos.container();\n      if (!isText$b(container)) {\n        return false;\n      }\n      return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);\n    };\n    const insertBlock = (blockName, node, before) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const blockNode = doc.createElement(blockName);\n      blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');\n      blockNode.setAttribute('data-mce-bogus', 'all');\n      blockNode.appendChild(createPaddingBr().dom);\n      const parentNode = node.parentNode;\n      if (!before) {\n        if (node.nextSibling) {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node.nextSibling);\n        } else {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(blockNode);\n        }\n      } else {\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node);\n      }\n      return blockNode;\n    };\n    const startsWithCaretContainer$1 = node => isText$9(node) && node.data[0] === ZWSP$1;\n    const endsWithCaretContainer$1 = node => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;\n    const trimBogusBr = elm => {\n      var _a;\n      const brs = elm.getElementsByTagName('br');\n      const lastBr = brs[brs.length - 1];\n      if (isBogus$1(lastBr)) {\n        (_a = lastBr.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(lastBr);\n      }\n    };\n    const showCaretContainerBlock = caretContainer => {\n      if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {\n        trimBogusBr(caretContainer);\n        caretContainer.removeAttribute('data-mce-caret');\n        caretContainer.removeAttribute('data-mce-bogus');\n        caretContainer.removeAttribute('style');\n        caretContainer.removeAttribute('data-mce-style');\n        caretContainer.removeAttribute('_moz_abspos');\n        return caretContainer;\n      }\n      return null;\n    };\n    const isRangeInCaretContainerBlock = range => isCaretContainerBlock$1(range.startContainer);\n\n    const round$2 = Math.round;\n    const clone$1 = rect => {\n      if (!rect) {\n        return {\n          left: 0,\n          top: 0,\n          bottom: 0,\n          right: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      return {\n        left: round$2(rect.left),\n        top: round$2(rect.top),\n        bottom: round$2(rect.bottom),\n        right: round$2(rect.right),\n        width: round$2(rect.width),\n        height: round$2(rect.height)\n      };\n    };\n    const collapse = (rect, toStart) => {\n      rect = clone$1(rect);\n      if (toStart) {\n        rect.right = rect.left;\n      } else {\n        rect.left = rect.left + rect.width;\n        rect.right = rect.left;\n      }\n      rect.width = 0;\n      return rect;\n    };\n    const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;\n    const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;\n    const isAbove$1 = (rect1, rect2) => {\n      const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);\n      if (rect1.bottom - halfHeight < rect2.top) {\n        return true;\n      }\n      if (rect1.top > rect2.bottom) {\n        return false;\n      }\n      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);\n    };\n    const isBelow$1 = (rect1, rect2) => {\n      if (rect1.top > rect2.bottom) {\n        return true;\n      }\n      if (rect1.bottom < rect2.top) {\n        return false;\n      }\n      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);\n    };\n    const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n    const boundingClientRectFromRects = rects => {\n      return foldl(rects, (acc, rect) => {\n        return acc.fold(() => Optional.some(rect), prevRect => {\n          const left = Math.min(rect.left, prevRect.left);\n          const top = Math.min(rect.top, prevRect.top);\n          const right = Math.max(rect.right, prevRect.right);\n          const bottom = Math.max(rect.bottom, prevRect.bottom);\n          return Optional.some({\n            top,\n            right,\n            bottom,\n            left,\n            width: right - left,\n            height: bottom - top\n          });\n        });\n      }, Optional.none());\n    };\n    const distanceToRectEdgeFromXY = (rect, x, y) => {\n      const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);\n      const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);\n      return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));\n    };\n    const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));\n\n    const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);\n\n    const getSelectedNode = range => {\n      const startContainer = range.startContainer, startOffset = range.startOffset;\n      if (startContainer === range.endContainer && startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {\n        return startContainer.childNodes[startOffset];\n      }\n      return null;\n    };\n    const getNode$1 = (container, offset) => {\n      if (isElement$6(container) && container.hasChildNodes()) {\n        const childNodes = container.childNodes;\n        const safeOffset = clamp$2(offset, 0, childNodes.length - 1);\n        return childNodes[safeOffset];\n      } else {\n        return container;\n      }\n    };\n    const getNodeUnsafe = (container, offset) => {\n      if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {\n        return undefined;\n      } else {\n        return getNode$1(container, offset);\n      }\n    };\n\n    const extendingChars = new RegExp('[\\u0300-\\u036f\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1-\\u05c2\\u05c4-\\u05c5\\u05c7\\u0610-\\u061a' + '\\u064b-\\u065f\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7-\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0' + '\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e3-\\u0902\\u093a\\u093c' + '\\u0941-\\u0948\\u094d\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2-\\u09e3' + '\\u0a01-\\u0a02\\u0a3c\\u0a41-\\u0a42\\u0a47-\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70-\\u0a71\\u0a75\\u0a81-\\u0a82\\u0abc' + '\\u0ac1-\\u0ac5\\u0ac7-\\u0ac8\\u0acd\\u0ae2-\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57' + '\\u0b62-\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c00\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55-\\u0c56' + '\\u0c62-\\u0c63\\u0c81\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc-\\u0ccd\\u0cd5-\\u0cd6\\u0ce2-\\u0ce3\\u0d01\\u0d3e\\u0d41-\\u0d44' + '\\u0d4d\\u0d57\\u0d62-\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9' + '\\u0ebb-\\u0ebc\\u0ec8-\\u0ecd\\u0f18-\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97' + '\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039-\\u103a\\u103d-\\u103e\\u1058-\\u1059\\u105e-\\u1060\\u1071-\\u1074' + '\\u1082\\u1085-\\u1086\\u108d\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17b4-\\u17b5' + '\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193b\\u1a17-\\u1a18' + '\\u1a1b\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1ab0-\\u1abd\\u1ABE\\u1b00-\\u1b03\\u1b34' + '\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80-\\u1b81\\u1ba2-\\u1ba5\\u1ba8-\\u1ba9\\u1bab-\\u1bad\\u1be6\\u1be8-\\u1be9' + '\\u1bed\\u1bef-\\u1bf1\\u1c2c-\\u1c33\\u1c36-\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1cf4\\u1cf8-\\u1cf9' + '\\u1dc0-\\u1df5\\u1dfc-\\u1dff\\u200c-\\u200d\\u20d0-\\u20dc\\u20DD-\\u20E0\\u20e1\\u20E2-\\u20E4\\u20e5-\\u20f0\\u2cef-\\u2cf1' + '\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302d\\u302e-\\u302f\\u3099-\\u309a\\ua66f\\uA670-\\uA672\\ua674-\\ua67d\\ua69e-\\ua69f\\ua6f0-\\ua6f1' + '\\ua802\\ua806\\ua80b\\ua825-\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc' + '\\ua9e5\\uaa29-\\uaa2e\\uaa31-\\uaa32\\uaa35-\\uaa36\\uaa43\\uaa4c\\uaa7c\\uaab0\\uaab2-\\uaab4\\uaab7-\\uaab8\\uaabe-\\uaabf\\uaac1' + '\\uaaec-\\uaaed\\uaaf6\\uabe5\\uabe8\\uabed\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\uff9e-\\uff9f]');\n    const isExtendingChar = ch => isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n\n    const or = (...args) => {\n      return x => {\n        for (let i = 0; i < args.length; i++) {\n          if (args[i](x)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const and = (...args) => {\n      return x => {\n        for (let i = 0; i < args.length; i++) {\n          if (!args[i](x)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    };\n\n    const isContentEditableTrue$2 = isContentEditableTrue$3;\n    const isContentEditableFalse$a = isContentEditableFalse$b;\n    const isBr$4 = isBr$6;\n    const isText$8 = isText$b;\n    const isInvalidTextElement = matchNodeNames([\n      'script',\n      'style',\n      'textarea'\n    ]);\n    const isAtomicInline = matchNodeNames([\n      'img',\n      'input',\n      'textarea',\n      'hr',\n      'iframe',\n      'video',\n      'audio',\n      'object',\n      'embed'\n    ]);\n    const isTable = matchNodeNames(['table']);\n    const isCaretContainer$1 = isCaretContainer$2;\n    const isCaretCandidate$3 = node => {\n      if (isCaretContainer$1(node)) {\n        return false;\n      }\n      if (isText$8(node)) {\n        return !isInvalidTextElement(node.parentNode);\n      }\n      return isAtomicInline(node) || isBr$4(node) || isTable(node) || isNonUiContentEditableFalse(node);\n    };\n    const isUnselectable = node => isElement$6(node) && node.getAttribute('unselectable') === 'true';\n    const isNonUiContentEditableFalse = node => !isUnselectable(node) && isContentEditableFalse$a(node);\n    const isInEditable = (node, root) => {\n      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n        if (isNonUiContentEditableFalse(tempNode)) {\n          return false;\n        }\n        if (isContentEditableTrue$2(tempNode)) {\n          return true;\n        }\n      }\n      return true;\n    };\n    const isAtomicContentEditableFalse = node => {\n      if (!isNonUiContentEditableFalse(node)) {\n        return false;\n      }\n      return !foldl(from(node.getElementsByTagName('*')), (result, elm) => {\n        return result || isContentEditableTrue$2(elm);\n      }, false);\n    };\n    const isAtomic$1 = node => isAtomicInline(node) || isAtomicContentEditableFalse(node);\n    const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);\n\n    const isElement$4 = isElement$6;\n    const isCaretCandidate$2 = isCaretCandidate$3;\n    const isBlock$2 = matchStyleValues('display', 'block table');\n    const isFloated = matchStyleValues('float', 'left right');\n    const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));\n    const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));\n    const isText$7 = isText$b;\n    const isBr$3 = isBr$6;\n    const nodeIndex$1 = DOMUtils.nodeIndex;\n    const resolveIndex$1 = getNodeUnsafe;\n    const createRange$1 = doc => doc ? doc.createRange() : DOMUtils.DOM.createRng();\n    const isWhiteSpace$1 = chr => isString(chr) && /[\\r\\n\\t ]/.test(chr);\n    const isRange = rng => !!rng.setStart && !!rng.setEnd;\n    const isHiddenWhiteSpaceRange = range => {\n      const container = range.startContainer;\n      const offset = range.startOffset;\n      if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$b(container)) {\n        const text = container.data;\n        if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const getBrClientRect = brNode => {\n      const doc = brNode.ownerDocument;\n      const rng = createRange$1(doc);\n      const nbsp$1 = doc.createTextNode(nbsp);\n      const parentNode = brNode.parentNode;\n      parentNode.insertBefore(nbsp$1, brNode);\n      rng.setStart(nbsp$1, 0);\n      rng.setEnd(nbsp$1, 1);\n      const clientRect = clone$1(rng.getBoundingClientRect());\n      parentNode.removeChild(nbsp$1);\n      return clientRect;\n    };\n    const getBoundingClientRectWebKitText = rng => {\n      const sc = rng.startContainer;\n      const ec = rng.endContainer;\n      const so = rng.startOffset;\n      const eo = rng.endOffset;\n      if (sc === ec && isText$b(ec) && so === 0 && eo === 1) {\n        const newRng = rng.cloneRange();\n        newRng.setEndAfter(ec);\n        return getBoundingClientRect$1(newRng);\n      } else {\n        return null;\n      }\n    };\n    const isZeroRect = r => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;\n    const getBoundingClientRect$1 = item => {\n      var _a;\n      let clientRect;\n      const clientRects = item.getClientRects();\n      if (clientRects.length > 0) {\n        clientRect = clone$1(clientRects[0]);\n      } else {\n        clientRect = clone$1(item.getBoundingClientRect());\n      }\n      if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {\n        return getBrClientRect(item);\n      }\n      if (isZeroRect(clientRect) && isRange(item)) {\n        return (_a = getBoundingClientRectWebKitText(item)) !== null && _a !== void 0 ? _a : clientRect;\n      }\n      return clientRect;\n    };\n    const collapseAndInflateWidth = (clientRect, toStart) => {\n      const newClientRect = collapse(clientRect, toStart);\n      newClientRect.width = 1;\n      newClientRect.right = newClientRect.left + 1;\n      return newClientRect;\n    };\n    const getCaretPositionClientRects = caretPosition => {\n      const clientRects = [];\n      const addUniqueAndValidRect = clientRect => {\n        if (clientRect.height === 0) {\n          return;\n        }\n        if (clientRects.length > 0) {\n          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {\n            return;\n          }\n        }\n        clientRects.push(clientRect);\n      };\n      const addCharacterOffset = (container, offset) => {\n        const range = createRange$1(container.ownerDocument);\n        if (offset < container.data.length) {\n          if (isExtendingChar(container.data[offset])) {\n            return;\n          }\n          if (isExtendingChar(container.data[offset - 1])) {\n            range.setStart(container, offset);\n            range.setEnd(container, offset + 1);\n            if (!isHiddenWhiteSpaceRange(range)) {\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n              return;\n            }\n          }\n        }\n        if (offset > 0) {\n          range.setStart(container, offset - 1);\n          range.setEnd(container, offset);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n          }\n        }\n        if (offset < container.data.length) {\n          range.setStart(container, offset);\n          range.setEnd(container, offset + 1);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));\n          }\n        }\n      };\n      const container = caretPosition.container();\n      const offset = caretPosition.offset();\n      if (isText$7(container)) {\n        addCharacterOffset(container, offset);\n        return clientRects;\n      }\n      if (isElement$4(container)) {\n        if (caretPosition.isAtEnd()) {\n          const node = resolveIndex$1(container, offset);\n          if (isText$7(node)) {\n            addCharacterOffset(node, node.data.length);\n          }\n          if (isValidElementCaretCandidate(node) && !isBr$3(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n          }\n        } else {\n          const node = resolveIndex$1(container, offset);\n          if (isText$7(node)) {\n            addCharacterOffset(node, 0);\n          }\n          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n            return clientRects;\n          }\n          const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);\n          if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {\n            if (isBlock$2(beforeNode) || isBlock$2(node) || !isValidElementCaretCandidate(node)) {\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));\n            }\n          }\n          if (isValidElementCaretCandidate(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));\n          }\n        }\n      }\n      return clientRects;\n    };\n    const CaretPosition = (container, offset, clientRects) => {\n      const isAtStart = () => {\n        if (isText$7(container)) {\n          return offset === 0;\n        }\n        return offset === 0;\n      };\n      const isAtEnd = () => {\n        if (isText$7(container)) {\n          return offset >= container.data.length;\n        }\n        return offset >= container.childNodes.length;\n      };\n      const toRange = () => {\n        const range = createRange$1(container.ownerDocument);\n        range.setStart(container, offset);\n        range.setEnd(container, offset);\n        return range;\n      };\n      const getClientRects = () => {\n        if (!clientRects) {\n          clientRects = getCaretPositionClientRects(CaretPosition(container, offset));\n        }\n        return clientRects;\n      };\n      const isVisible = () => getClientRects().length > 0;\n      const isEqual = caretPosition => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();\n      const getNode = before => resolveIndex$1(container, before ? offset - 1 : offset);\n      return {\n        container: constant(container),\n        offset: constant(offset),\n        toRange,\n        getClientRects,\n        isVisible,\n        isAtStart,\n        isAtEnd,\n        isEqual,\n        getNode\n      };\n    };\n    CaretPosition.fromRangeStart = range => CaretPosition(range.startContainer, range.startOffset);\n    CaretPosition.fromRangeEnd = range => CaretPosition(range.endContainer, range.endOffset);\n    CaretPosition.after = node => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);\n    CaretPosition.before = node => CaretPosition(node.parentNode, nodeIndex$1(node));\n    CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$2(pos1.getClientRects()), isAbove$1).getOr(false);\n    CaretPosition.isBelow = (pos1, pos2) => lift2(last$2(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);\n    CaretPosition.isAtStart = pos => pos ? pos.isAtStart() : false;\n    CaretPosition.isAtEnd = pos => pos ? pos.isAtEnd() : false;\n    CaretPosition.isTextPosition = pos => pos ? isText$b(pos.container()) : false;\n    CaretPosition.isElementPosition = pos => !CaretPosition.isTextPosition(pos);\n\n    const trimEmptyTextNode$1 = (dom, node) => {\n      if (isText$b(node) && node.data.length === 0) {\n        dom.remove(node);\n      }\n    };\n    const insertNode = (dom, rng, node) => {\n      rng.insertNode(node);\n      trimEmptyTextNode$1(dom, node.previousSibling);\n      trimEmptyTextNode$1(dom, node.nextSibling);\n    };\n    const insertFragment = (dom, rng, frag) => {\n      const firstChild = Optional.from(frag.firstChild);\n      const lastChild = Optional.from(frag.lastChild);\n      rng.insertNode(frag);\n      firstChild.each(child => trimEmptyTextNode$1(dom, child.previousSibling));\n      lastChild.each(child => trimEmptyTextNode$1(dom, child.nextSibling));\n    };\n    const rangeInsertNode = (dom, rng, node) => {\n      if (isDocumentFragment(node)) {\n        insertFragment(dom, rng, node);\n      } else {\n        insertNode(dom, rng, node);\n      }\n    };\n\n    const isText$6 = isText$b;\n    const isBogus = isBogus$1;\n    const nodeIndex = DOMUtils.nodeIndex;\n    const normalizedParent = node => {\n      const parentNode = node.parentNode;\n      if (isBogus(parentNode)) {\n        return normalizedParent(parentNode);\n      }\n      return parentNode;\n    };\n    const getChildNodes = node => {\n      if (!node) {\n        return [];\n      }\n      return reduce(node.childNodes, (result, node) => {\n        if (isBogus(node) && node.nodeName !== 'BR') {\n          result = result.concat(getChildNodes(node));\n        } else {\n          result.push(node);\n        }\n        return result;\n      }, []);\n    };\n    const normalizedTextOffset = (node, offset) => {\n      let tempNode = node;\n      while (tempNode = tempNode.previousSibling) {\n        if (!isText$6(tempNode)) {\n          break;\n        }\n        offset += tempNode.data.length;\n      }\n      return offset;\n    };\n    const equal = a => b => a === b;\n    const normalizedNodeIndex = node => {\n      let nodes, index;\n      nodes = getChildNodes(normalizedParent(node));\n      index = findIndex$1(nodes, equal(node), node);\n      nodes = nodes.slice(0, index + 1);\n      const numTextFragments = reduce(nodes, (result, node, i) => {\n        if (isText$6(node) && isText$6(nodes[i - 1])) {\n          result++;\n        }\n        return result;\n      }, 0);\n      nodes = filter$3(nodes, matchNodeNames([node.nodeName]));\n      index = findIndex$1(nodes, equal(node), node);\n      return index - numTextFragments;\n    };\n    const createPathItem = node => {\n      const name = isText$6(node) ? 'text()' : node.nodeName.toLowerCase();\n      return name + '[' + normalizedNodeIndex(node) + ']';\n    };\n    const parentsUntil$1 = (root, node, predicate) => {\n      const parents = [];\n      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n        if (predicate && predicate(tempNode)) {\n          break;\n        }\n        parents.push(tempNode);\n      }\n      return parents;\n    };\n    const create$a = (root, caretPosition) => {\n      let path = [];\n      let container = caretPosition.container();\n      let offset = caretPosition.offset();\n      let outputOffset;\n      if (isText$6(container)) {\n        outputOffset = normalizedTextOffset(container, offset);\n      } else {\n        const childNodes = container.childNodes;\n        if (offset >= childNodes.length) {\n          outputOffset = 'after';\n          offset = childNodes.length - 1;\n        } else {\n          outputOffset = 'before';\n        }\n        container = childNodes[offset];\n      }\n      path.push(createPathItem(container));\n      let parents = parentsUntil$1(root, container);\n      parents = filter$3(parents, not(isBogus$1));\n      path = path.concat(map$1(parents, node => {\n        return createPathItem(node);\n      }));\n      return path.reverse().join('/') + ',' + outputOffset;\n    };\n    const resolvePathItem = (node, name, index) => {\n      let nodes = getChildNodes(node);\n      nodes = filter$3(nodes, (node, index) => {\n        return !isText$6(node) || !isText$6(nodes[index - 1]);\n      });\n      nodes = filter$3(nodes, matchNodeNames([name]));\n      return nodes[index];\n    };\n    const findTextPosition = (container, offset) => {\n      let node = container;\n      let targetOffset = 0;\n      while (isText$6(node)) {\n        const dataLen = node.data.length;\n        if (offset >= targetOffset && offset <= targetOffset + dataLen) {\n          container = node;\n          offset = offset - targetOffset;\n          break;\n        }\n        if (!isText$6(node.nextSibling)) {\n          container = node;\n          offset = dataLen;\n          break;\n        }\n        targetOffset += dataLen;\n        node = node.nextSibling;\n      }\n      if (isText$6(container) && offset > container.data.length) {\n        offset = container.data.length;\n      }\n      return CaretPosition(container, offset);\n    };\n    const resolve$1 = (root, path) => {\n      if (!path) {\n        return null;\n      }\n      const parts = path.split(',');\n      const paths = parts[0].split('/');\n      const offset = parts.length > 1 ? parts[1] : 'before';\n      const container = reduce(paths, (result, value) => {\n        const match = /([\\w\\-\\(\\)]+)\\[([0-9]+)\\]/.exec(value);\n        if (!match) {\n          return null;\n        }\n        if (match[1] === 'text()') {\n          match[1] = '#text';\n        }\n        return resolvePathItem(result, match[1], parseInt(match[2], 10));\n      }, root);\n      if (!container) {\n        return null;\n      }\n      if (!isText$6(container) && container.parentNode) {\n        let nodeOffset;\n        if (offset === 'after') {\n          nodeOffset = nodeIndex(container) + 1;\n        } else {\n          nodeOffset = nodeIndex(container);\n        }\n        return CaretPosition(container.parentNode, nodeOffset);\n      }\n      return findTextPosition(container, parseInt(offset, 10));\n    };\n\n    const isContentEditableFalse$9 = isContentEditableFalse$b;\n    const getNormalizedTextOffset$1 = (trim, container, offset) => {\n      let trimmedOffset = trim(container.data.slice(0, offset)).length;\n      for (let node = container.previousSibling; node && isText$b(node); node = node.previousSibling) {\n        trimmedOffset += trim(node.data).length;\n      }\n      return trimmedOffset;\n    };\n    const getPoint = (dom, trim, normalized, rng, start) => {\n      const container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      const point = [];\n      const root = dom.getRoot();\n      if (isText$b(container)) {\n        point.push(normalized ? getNormalizedTextOffset$1(trim, container, offset) : offset);\n      } else {\n        let after = 0;\n        const childNodes = container.childNodes;\n        if (offset >= childNodes.length && childNodes.length) {\n          after = 1;\n          offset = Math.max(0, childNodes.length - 1);\n        }\n        point.push(dom.nodeIndex(childNodes[offset], normalized) + after);\n      }\n      for (let node = container; node && node !== root; node = node.parentNode) {\n        point.push(dom.nodeIndex(node, normalized));\n      }\n      return point;\n    };\n    const getLocation = (trim, selection, normalized, rng) => {\n      const dom = selection.dom;\n      const start = getPoint(dom, trim, normalized, rng, true);\n      const forward = selection.isForward();\n      const fakeCaret = isRangeInCaretContainerBlock(rng) ? { isFakeCaret: true } : {};\n      if (!selection.isCollapsed()) {\n        const end = getPoint(dom, trim, normalized, rng, false);\n        return {\n          start,\n          end,\n          forward,\n          ...fakeCaret\n        };\n      } else {\n        return {\n          start,\n          forward,\n          ...fakeCaret\n        };\n      }\n    };\n    const findIndex = (dom, name, element) => {\n      let count = 0;\n      Tools.each(dom.select(name), node => {\n        if (node.getAttribute('data-mce-bogus') === 'all') {\n          return;\n        } else if (node === element) {\n          return false;\n        } else {\n          count++;\n          return;\n        }\n      });\n      return count;\n    };\n    const moveEndPoint$1 = (rng, start) => {\n      let container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      if (isElement$6(container) && container.nodeName === 'TR') {\n        const childNodes = container.childNodes;\n        container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];\n        if (container) {\n          offset = start ? 0 : container.childNodes.length;\n          if (start) {\n            rng.setStart(container, offset);\n          } else {\n            rng.setEnd(container, offset);\n          }\n        }\n      }\n    };\n    const normalizeTableCellSelection = rng => {\n      moveEndPoint$1(rng, true);\n      moveEndPoint$1(rng, false);\n      return rng;\n    };\n    const findSibling = (node, offset) => {\n      if (isElement$6(node)) {\n        node = getNode$1(node, offset);\n        if (isContentEditableFalse$9(node)) {\n          return node;\n        }\n      }\n      if (isCaretContainer$2(node)) {\n        if (isText$b(node) && isCaretContainerBlock$1(node)) {\n          node = node.parentNode;\n        }\n        let sibling = node.previousSibling;\n        if (isContentEditableFalse$9(sibling)) {\n          return sibling;\n        }\n        sibling = node.nextSibling;\n        if (isContentEditableFalse$9(sibling)) {\n          return sibling;\n        }\n      }\n      return undefined;\n    };\n    const findAdjacentContentEditableFalseElm = rng => {\n      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);\n    };\n    const getOffsetBookmark = (trim, normalized, selection) => {\n      const element = selection.getNode();\n      const rng = selection.getRng();\n      if (element.nodeName === 'IMG' || isContentEditableFalse$9(element)) {\n        const name = element.nodeName;\n        return {\n          name,\n          index: findIndex(selection.dom, name, element)\n        };\n      }\n      const sibling = findAdjacentContentEditableFalseElm(rng);\n      if (sibling) {\n        const name = sibling.tagName;\n        return {\n          name,\n          index: findIndex(selection.dom, name, sibling)\n        };\n      }\n      return getLocation(trim, selection, normalized, rng);\n    };\n    const getCaretBookmark = selection => {\n      const rng = selection.getRng();\n      return {\n        start: create$a(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),\n        end: create$a(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),\n        forward: selection.isForward()\n      };\n    };\n    const getRangeBookmark = selection => {\n      return {\n        rng: selection.getRng(),\n        forward: selection.isForward()\n      };\n    };\n    const createBookmarkSpan = (dom, id, filled) => {\n      const args = {\n        'data-mce-type': 'bookmark',\n        id,\n        'style': 'overflow:hidden;line-height:0px'\n      };\n      return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);\n    };\n    const getPersistentBookmark = (selection, filled) => {\n      const dom = selection.dom;\n      let rng = selection.getRng();\n      const id = dom.uniqueId();\n      const collapsed = selection.isCollapsed();\n      const element = selection.getNode();\n      const name = element.nodeName;\n      const forward = selection.isForward();\n      if (name === 'IMG') {\n        return {\n          name,\n          index: findIndex(dom, name, element)\n        };\n      }\n      const rng2 = normalizeTableCellSelection(rng.cloneRange());\n      if (!collapsed) {\n        rng2.collapse(false);\n        const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);\n        rangeInsertNode(dom, rng2, endBookmarkNode);\n      }\n      rng = normalizeTableCellSelection(rng);\n      rng.collapse(true);\n      const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);\n      rangeInsertNode(dom, rng, startBookmarkNode);\n      selection.moveToBookmark({\n        id,\n        keep: true,\n        forward\n      });\n      return {\n        id,\n        forward\n      };\n    };\n    const getBookmark$3 = (selection, type, normalized = false) => {\n      if (type === 2) {\n        return getOffsetBookmark(trim$2, normalized, selection);\n      } else if (type === 3) {\n        return getCaretBookmark(selection);\n      } else if (type) {\n        return getRangeBookmark(selection);\n      } else {\n        return getPersistentBookmark(selection, false);\n      }\n    };\n    const getUndoBookmark = curry(getOffsetBookmark, identity, true);\n\n    const value$1 = value => {\n      const applyHelper = fn => fn(value);\n      const constHelper = constant(value);\n      const outputHelper = () => output;\n      const output = {\n        tag: true,\n        inner: value,\n        fold: (_onError, onValue) => onValue(value),\n        isValue: always,\n        isError: never,\n        map: mapper => Result.value(mapper(value)),\n        mapError: outputHelper,\n        bind: applyHelper,\n        exists: applyHelper,\n        forall: applyHelper,\n        getOr: constHelper,\n        or: outputHelper,\n        getOrThunk: constHelper,\n        orThunk: outputHelper,\n        getOrDie: constHelper,\n        each: fn => {\n          fn(value);\n        },\n        toOptional: () => Optional.some(value)\n      };\n      return output;\n    };\n    const error = error => {\n      const outputHelper = () => output;\n      const output = {\n        tag: false,\n        inner: error,\n        fold: (onError, _onValue) => onError(error),\n        isValue: never,\n        isError: always,\n        map: outputHelper,\n        mapError: mapper => Result.error(mapper(error)),\n        bind: outputHelper,\n        exists: never,\n        forall: always,\n        getOr: identity,\n        or: identity,\n        getOrThunk: apply$1,\n        orThunk: apply$1,\n        getOrDie: die(String(error)),\n        each: noop,\n        toOptional: Optional.none\n      };\n      return output;\n    };\n    const fromOption = (optional, err) => optional.fold(() => error(err), value$1);\n    const Result = {\n      value: value$1,\n      error,\n      fromOption\n    };\n\n    const generate = cases => {\n      if (!isArray$1(cases)) {\n        throw new Error('cases must be an array');\n      }\n      if (cases.length === 0) {\n        throw new Error('there must be at least one case');\n      }\n      const constructors = [];\n      const adt = {};\n      each$e(cases, (acase, count) => {\n        const keys$1 = keys(acase);\n        if (keys$1.length !== 1) {\n          throw new Error('one and only one name per case');\n        }\n        const key = keys$1[0];\n        const value = acase[key];\n        if (adt[key] !== undefined) {\n          throw new Error('duplicate key detected:' + key);\n        } else if (key === 'cata') {\n          throw new Error('cannot have a case named cata (sorry)');\n        } else if (!isArray$1(value)) {\n          throw new Error('case arguments must be an array');\n        }\n        constructors.push(key);\n        adt[key] = (...args) => {\n          const argLength = args.length;\n          if (argLength !== value.length) {\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n          }\n          const match = branches => {\n            const branchKeys = keys(branches);\n            if (constructors.length !== branchKeys.length) {\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n            }\n            const allReqd = forall(constructors, reqKey => {\n              return contains$2(branchKeys, reqKey);\n            });\n            if (!allReqd) {\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n            }\n            return branches[key].apply(null, args);\n          };\n          return {\n            fold: (...foldArgs) => {\n              if (foldArgs.length !== cases.length) {\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n              }\n              const target = foldArgs[count];\n              return target.apply(null, args);\n            },\n            match,\n            log: label => {\n              console.log(label, {\n                constructors,\n                constructor: key,\n                params: args\n              });\n            }\n          };\n        };\n      });\n      return adt;\n    };\n    const Adt = { generate };\n\n    Adt.generate([\n      {\n        bothErrors: [\n          'error1',\n          'error2'\n        ]\n      },\n      {\n        firstError: [\n          'error1',\n          'value2'\n        ]\n      },\n      {\n        secondError: [\n          'value1',\n          'error2'\n        ]\n      },\n      {\n        bothValues: [\n          'value1',\n          'value2'\n        ]\n      }\n    ]);\n    const partition$1 = results => {\n      const errors = [];\n      const values = [];\n      each$e(results, result => {\n        result.fold(err => {\n          errors.push(err);\n        }, value => {\n          values.push(value);\n        });\n      });\n      return {\n        errors,\n        values\n      };\n    };\n\n    const isInlinePattern = pattern => pattern.type === 'inline-command' || pattern.type === 'inline-format';\n    const isBlockPattern = pattern => pattern.type === 'block-command' || pattern.type === 'block-format';\n    const hasBlockTrigger = (pattern, trigger) => (pattern.type === 'block-command' || pattern.type === 'block-format') && pattern.trigger === trigger;\n    const normalizePattern = pattern => {\n      var _a;\n      const err = message => Result.error({\n        message,\n        pattern\n      });\n      const formatOrCmd = (name, onFormat, onCommand) => {\n        if (pattern.format !== undefined) {\n          let formats;\n          if (isArray$1(pattern.format)) {\n            if (!forall(pattern.format, isString)) {\n              return err(name + ' pattern has non-string items in the `format` array');\n            }\n            formats = pattern.format;\n          } else if (isString(pattern.format)) {\n            formats = [pattern.format];\n          } else {\n            return err(name + ' pattern has non-string `format` parameter');\n          }\n          return Result.value(onFormat(formats));\n        } else if (pattern.cmd !== undefined) {\n          if (!isString(pattern.cmd)) {\n            return err(name + ' pattern has non-string `cmd` parameter');\n          }\n          return Result.value(onCommand(pattern.cmd, pattern.value));\n        } else {\n          return err(name + ' pattern is missing both `format` and `cmd` parameters');\n        }\n      };\n      if (!isObject(pattern)) {\n        return err('Raw pattern is not an object');\n      }\n      if (!isString(pattern.start)) {\n        return err('Raw pattern is missing `start` parameter');\n      }\n      if (pattern.end !== undefined) {\n        if (!isString(pattern.end)) {\n          return err('Inline pattern has non-string `end` parameter');\n        }\n        if (pattern.start.length === 0 && pattern.end.length === 0) {\n          return err('Inline pattern has empty `start` and `end` parameters');\n        }\n        let start = pattern.start;\n        let end = pattern.end;\n        if (end.length === 0) {\n          end = start;\n          start = '';\n        }\n        return formatOrCmd('Inline', format => ({\n          type: 'inline-format',\n          start,\n          end,\n          format\n        }), (cmd, value) => ({\n          type: 'inline-command',\n          start,\n          end,\n          cmd,\n          value\n        }));\n      } else if (pattern.replacement !== undefined) {\n        if (!isString(pattern.replacement)) {\n          return err('Replacement pattern has non-string `replacement` parameter');\n        }\n        if (pattern.start.length === 0) {\n          return err('Replacement pattern has empty `start` parameter');\n        }\n        return Result.value({\n          type: 'inline-command',\n          start: '',\n          end: pattern.start,\n          cmd: 'mceInsertContent',\n          value: pattern.replacement\n        });\n      } else {\n        const trigger = (_a = pattern.trigger) !== null && _a !== void 0 ? _a : 'space';\n        if (pattern.start.length === 0) {\n          return err('Block pattern has empty `start` parameter');\n        }\n        return formatOrCmd('Block', formats => ({\n          type: 'block-format',\n          start: pattern.start,\n          format: formats[0],\n          trigger\n        }), (command, commandValue) => ({\n          type: 'block-command',\n          start: pattern.start,\n          cmd: command,\n          value: commandValue,\n          trigger\n        }));\n      }\n    };\n    const getBlockPatterns = patterns => filter$5(patterns, isBlockPattern);\n    const getInlinePatterns = patterns => filter$5(patterns, isInlinePattern);\n    const createPatternSet = (patterns, dynamicPatternsLookup) => ({\n      inlinePatterns: getInlinePatterns(patterns),\n      blockPatterns: getBlockPatterns(patterns),\n      dynamicPatternsLookup\n    });\n    const filterByTrigger = (patterns, trigger) => {\n      return {\n        ...patterns,\n        blockPatterns: filter$5(patterns.blockPatterns, pattern => hasBlockTrigger(pattern, trigger))\n      };\n    };\n    const fromRawPatterns = patterns => {\n      const normalized = partition$1(map$3(patterns, normalizePattern));\n      each$e(normalized.errors, err => console.error(err.message, err.pattern));\n      return normalized.values;\n    };\n    const fromRawPatternsLookup = lookupFn => {\n      return ctx => {\n        const rawPatterns = lookupFn(ctx);\n        return fromRawPatterns(rawPatterns);\n      };\n    };\n\n    const deviceDetection$1 = detect$1().deviceType;\n    const isTouch = deviceDetection$1.isTouch();\n    const DOM$a = DOMUtils.DOM;\n    const getHash = value => {\n      const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');\n      return foldl(items, (output, item) => {\n        const arr = item.split('=');\n        const key = arr[0];\n        const val = arr.length > 1 ? arr[1] : key;\n        output[trim$4(key)] = trim$4(val);\n        return output;\n      }, {});\n    };\n    const isRegExp = x => is$4(x, RegExp);\n    const option = name => editor => editor.options.get(name);\n    const stringOrObjectProcessor = value => isString(value) || isObject(value);\n    const bodyOptionProcessor = (editor, defaultValue = '') => value => {\n      const valid = isString(value);\n      if (valid) {\n        if (value.indexOf('=') !== -1) {\n          const bodyObj = getHash(value);\n          return {\n            value: get$a(bodyObj, editor.id).getOr(defaultValue),\n            valid\n          };\n        } else {\n          return {\n            value,\n            valid\n          };\n        }\n      } else {\n        return {\n          valid: false,\n          message: 'Must be a string.'\n        };\n      }\n    };\n    const register$7 = editor => {\n      const registerOption = editor.options.register;\n      registerOption('id', {\n        processor: 'string',\n        default: editor.id\n      });\n      registerOption('selector', { processor: 'string' });\n      registerOption('target', { processor: 'object' });\n      registerOption('suffix', { processor: 'string' });\n      registerOption('cache_suffix', { processor: 'string' });\n      registerOption('base_url', { processor: 'string' });\n      registerOption('referrer_policy', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('language_load', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('inline', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('iframe_attrs', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('doctype', {\n        processor: 'string',\n        default: '<!DOCTYPE html>'\n      });\n      registerOption('document_base_url', {\n        processor: 'string',\n        default: editor.documentBaseUrl\n      });\n      registerOption('body_id', {\n        processor: bodyOptionProcessor(editor, 'tinymce'),\n        default: 'tinymce'\n      });\n      registerOption('body_class', {\n        processor: bodyOptionProcessor(editor),\n        default: ''\n      });\n      registerOption('content_security_policy', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('br_in_pre', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('forced_root_block', {\n        processor: value => {\n          const valid = isString(value) && isNotEmpty(value);\n          if (valid) {\n            return {\n              value,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a non-empty string.'\n            };\n          }\n        },\n        default: 'p'\n      });\n      registerOption('forced_root_block_attrs', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('newline_behavior', {\n        processor: value => {\n          const valid = contains$2([\n            'block',\n            'linebreak',\n            'invert',\n            'default'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: block, linebreak, invert or default.'\n          };\n        },\n        default: 'default'\n      });\n      registerOption('br_newline_selector', {\n        processor: 'string',\n        default: '.mce-toc h2,figcaption,caption'\n      });\n      registerOption('no_newline_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('keep_styles', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('end_container_on_empty_block', {\n        processor: value => {\n          if (isBoolean(value)) {\n            return {\n              valid: true,\n              value\n            };\n          } else if (isString(value)) {\n            return {\n              valid: true,\n              value\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be boolean or a string'\n            };\n          }\n        },\n        default: 'blockquote'\n      });\n      registerOption('font_size_style_values', {\n        processor: 'string',\n        default: 'xx-small,x-small,small,medium,large,x-large,xx-large'\n      });\n      registerOption('font_size_legacy_values', {\n        processor: 'string',\n        default: 'xx-small,small,medium,large,x-large,xx-large,300%'\n      });\n      registerOption('font_size_classes', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('automatic_uploads', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('images_reuse_filename', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('images_replace_blob_uris', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('icons', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('icons_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_base_path', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_credentials', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('images_upload_handler', { processor: 'function' });\n      registerOption('language', {\n        processor: 'string',\n        default: 'en'\n      });\n      registerOption('language_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('entity_encoding', {\n        processor: 'string',\n        default: 'named'\n      });\n      registerOption('indent', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('indent_before', {\n        processor: 'string',\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n      });\n      registerOption('indent_after', {\n        processor: 'string',\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n      });\n      registerOption('indent_use_margin', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('indentation', {\n        processor: 'string',\n        default: '40px'\n      });\n      registerOption('content_css', {\n        processor: value => {\n          const valid = value === false || isString(value) || isArrayOf(value, isString);\n          if (valid) {\n            if (isString(value)) {\n              return {\n                value: map$3(value.split(','), trim$4),\n                valid\n              };\n            } else if (isArray$1(value)) {\n              return {\n                value,\n                valid\n              };\n            } else if (value === false) {\n              return {\n                value: [],\n                valid\n              };\n            } else {\n              return {\n                value,\n                valid\n              };\n            }\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false, a string or an array of strings.'\n            };\n          }\n        },\n        default: isInline$1(editor) ? [] : ['default']\n      });\n      registerOption('content_style', { processor: 'string' });\n      registerOption('content_css_cors', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('font_css', {\n        processor: value => {\n          const valid = isString(value) || isArrayOf(value, isString);\n          if (valid) {\n            const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$4);\n            return {\n              value: newValue,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a string or an array of strings.'\n            };\n          }\n        },\n        default: []\n      });\n      registerOption('inline_boundaries', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('inline_boundaries_selector', {\n        processor: 'string',\n        default: 'a[href],code,span.mce-annotation'\n      });\n      registerOption('object_resizing', {\n        processor: value => {\n          const valid = isBoolean(value) || isString(value);\n          if (valid) {\n            if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {\n              return {\n                value: '',\n                valid\n              };\n            } else {\n              return {\n                value: value === true ? 'table,img,figure.image,div,video,iframe' : value,\n                valid\n              };\n            }\n          } else {\n            return {\n              valid: false,\n              message: 'Must be boolean or a string'\n            };\n          }\n        },\n        default: !isTouch\n      });\n      registerOption('resize_img_proportional', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('event_root', { processor: 'string' });\n      registerOption('service_message', { processor: 'string' });\n      registerOption('theme', {\n        processor: value => value === false || isString(value) || isFunction(value),\n        default: 'silver'\n      });\n      registerOption('theme_url', { processor: 'string' });\n      registerOption('formats', { processor: 'object' });\n      registerOption('format_empty_lines', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('format_noneditable_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('preview_styles', {\n        processor: value => {\n          const valid = value === false || isString(value);\n          if (valid) {\n            return {\n              value: value === false ? '' : value,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false or a string'\n            };\n          }\n        },\n        default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'\n      });\n      registerOption('custom_ui_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('hidden_input', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('submit_patch', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('encoding', { processor: 'string' });\n      registerOption('add_form_submit_trigger', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('add_unload_trigger', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('custom_undo_redo_levels', {\n        processor: 'number',\n        default: 0\n      });\n      registerOption('disable_nodechange', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('readonly', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('editable_root', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('plugins', {\n        processor: 'string[]',\n        default: []\n      });\n      registerOption('external_plugins', { processor: 'object' });\n      registerOption('forced_plugins', { processor: 'string[]' });\n      registerOption('model', {\n        processor: 'string',\n        default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'\n      });\n      registerOption('model_url', { processor: 'string' });\n      registerOption('block_unsupported_drop', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('visual', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('visual_table_class', {\n        processor: 'string',\n        default: 'mce-item-table'\n      });\n      registerOption('visual_anchor_class', {\n        processor: 'string',\n        default: 'mce-item-anchor'\n      });\n      registerOption('iframe_aria_text', {\n        processor: 'string',\n        default: 'Rich Text Area. Press ALT-0 for help.'\n      });\n      registerOption('setup', { processor: 'function' });\n      registerOption('init_instance_callback', { processor: 'function' });\n      registerOption('url_converter', {\n        processor: 'function',\n        default: editor.convertURL\n      });\n      registerOption('url_converter_scope', {\n        processor: 'object',\n        default: editor\n      });\n      registerOption('urlconverter_callback', { processor: 'function' });\n      registerOption('allow_conditional_comments', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_html_data_urls', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_svg_data_urls', { processor: 'boolean' });\n      registerOption('allow_html_in_named_anchor', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_script_urls', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_unsafe_link_target', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('convert_fonts_to_spans', {\n        processor: 'boolean',\n        default: true,\n        deprecated: true\n      });\n      registerOption('fix_list_elements', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('preserve_cdata', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('remove_trailing_brs', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('pad_empty_with_br', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('inline_styles', {\n        processor: 'boolean',\n        default: true,\n        deprecated: true\n      });\n      registerOption('element_format', {\n        processor: 'string',\n        default: 'html'\n      });\n      registerOption('entities', { processor: 'string' });\n      registerOption('schema', {\n        processor: 'string',\n        default: 'html5'\n      });\n      registerOption('convert_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('relative_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('remove_script_host', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('custom_elements', { processor: stringOrObjectProcessor });\n      registerOption('extended_valid_elements', { processor: 'string' });\n      registerOption('invalid_elements', { processor: 'string' });\n      registerOption('invalid_styles', { processor: stringOrObjectProcessor });\n      registerOption('valid_children', { processor: 'string' });\n      registerOption('valid_classes', { processor: stringOrObjectProcessor });\n      registerOption('valid_elements', { processor: 'string' });\n      registerOption('valid_styles', { processor: stringOrObjectProcessor });\n      registerOption('verify_html', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('auto_focus', { processor: value => isString(value) || value === true });\n      registerOption('browser_spellcheck', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('protect', { processor: 'array' });\n      registerOption('images_file_types', {\n        processor: 'string',\n        default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'\n      });\n      registerOption('deprecation_warnings', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('a11y_advanced_options', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('api_key', { processor: 'string' });\n      registerOption('license_key', { processor: 'string' });\n      registerOption('paste_block_drop', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('paste_data_images', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_preprocess', { processor: 'function' });\n      registerOption('paste_postprocess', { processor: 'function' });\n      registerOption('paste_webkit_styles', {\n        processor: 'string',\n        default: 'none'\n      });\n      registerOption('paste_remove_styles_if_webkit', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_merge_formats', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('smart_paste', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_as_text', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('paste_tab_spaces', {\n        processor: 'number',\n        default: 4\n      });\n      registerOption('text_patterns', {\n        processor: value => {\n          if (isArrayOf(value, isObject) || value === false) {\n            const patterns = value === false ? [] : value;\n            return {\n              value: fromRawPatterns(patterns),\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be an array of objects or false.'\n            };\n          }\n        },\n        default: [\n          {\n            start: '*',\n            end: '*',\n            format: 'italic'\n          },\n          {\n            start: '**',\n            end: '**',\n            format: 'bold'\n          },\n          {\n            start: '#',\n            format: 'h1',\n            trigger: 'space'\n          },\n          {\n            start: '##',\n            format: 'h2',\n            trigger: 'space'\n          },\n          {\n            start: '###',\n            format: 'h3',\n            trigger: 'space'\n          },\n          {\n            start: '####',\n            format: 'h4',\n            trigger: 'space'\n          },\n          {\n            start: '#####',\n            format: 'h5',\n            trigger: 'space'\n          },\n          {\n            start: '######',\n            format: 'h6',\n            trigger: 'space'\n          },\n          {\n            start: '1.',\n            cmd: 'InsertOrderedList',\n            trigger: 'space'\n          },\n          {\n            start: '*',\n            cmd: 'InsertUnorderedList',\n            trigger: 'space'\n          },\n          {\n            start: '-',\n            cmd: 'InsertUnorderedList',\n            trigger: 'space'\n          },\n          {\n            start: '>',\n            cmd: 'mceBlockQuote',\n            trigger: 'space'\n          },\n          {\n            start: '---',\n            cmd: 'InsertHorizontalRule',\n            trigger: 'space'\n          }\n        ]\n      });\n      registerOption('text_patterns_lookup', {\n        processor: value => {\n          if (isFunction(value)) {\n            return {\n              value: fromRawPatternsLookup(value),\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a single function'\n            };\n          }\n        },\n        default: _ctx => []\n      });\n      registerOption('noneditable_class', {\n        processor: 'string',\n        default: 'mceNonEditable'\n      });\n      registerOption('editable_class', {\n        processor: 'string',\n        default: 'mceEditable'\n      });\n      registerOption('noneditable_regexp', {\n        processor: value => {\n          if (isArrayOf(value, isRegExp)) {\n            return {\n              value,\n              valid: true\n            };\n          } else if (isRegExp(value)) {\n            return {\n              value: [value],\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a RegExp or an array of RegExp.'\n            };\n          }\n        },\n        default: []\n      });\n      registerOption('table_tab_navigation', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('highlight_on_focus', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('xss_sanitization', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('details_initial_state', {\n        processor: value => {\n          const valid = contains$2([\n            'inherited',\n            'collapsed',\n            'expanded'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: inherited, collapsed, or expanded.'\n          };\n        },\n        default: 'inherited'\n      });\n      registerOption('details_serialized_state', {\n        processor: value => {\n          const valid = contains$2([\n            'inherited',\n            'collapsed',\n            'expanded'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: inherited, collapsed, or expanded.'\n          };\n        },\n        default: 'inherited'\n      });\n      registerOption('init_content_sync', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('newdocument_content', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('sandbox_iframes', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('sandbox_iframes_exclusions', {\n        processor: 'string[]',\n        default: [\n          'youtube.com',\n          'youtu.be',\n          'vimeo.com',\n          'player.vimeo.com',\n          'dailymotion.com',\n          'embed.music.apple.com',\n          'open.spotify.com',\n          'giphy.com',\n          'dai.ly',\n          'codepen.io'\n        ]\n      });\n      registerOption('convert_unsafe_embeds', {\n        processor: 'boolean',\n        default: true\n      });\n      editor.on('ScriptsLoaded', () => {\n        registerOption('directionality', {\n          processor: 'string',\n          default: I18n.isRtl() ? 'rtl' : undefined\n        });\n        registerOption('placeholder', {\n          processor: 'string',\n          default: DOM$a.getAttrib(editor.getElement(), 'placeholder')\n        });\n      });\n    };\n    const getIframeAttrs = option('iframe_attrs');\n    const getDocType = option('doctype');\n    const getDocumentBaseUrl = option('document_base_url');\n    const getBodyId = option('body_id');\n    const getBodyClass = option('body_class');\n    const getContentSecurityPolicy = option('content_security_policy');\n    const shouldPutBrInPre$1 = option('br_in_pre');\n    const getForcedRootBlock = option('forced_root_block');\n    const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n    const getNewlineBehavior = option('newline_behavior');\n    const getBrNewLineSelector = option('br_newline_selector');\n    const getNoNewLineSelector = option('no_newline_selector');\n    const shouldKeepStyles = option('keep_styles');\n    const shouldEndContainerOnEmptyBlock = option('end_container_on_empty_block');\n    const isAutomaticUploadsEnabled = option('automatic_uploads');\n    const shouldReuseFileName = option('images_reuse_filename');\n    const shouldReplaceBlobUris = option('images_replace_blob_uris');\n    const getIconPackName = option('icons');\n    const getIconsUrl = option('icons_url');\n    const getImageUploadUrl = option('images_upload_url');\n    const getImageUploadBasePath = option('images_upload_base_path');\n    const getImagesUploadCredentials = option('images_upload_credentials');\n    const getImagesUploadHandler = option('images_upload_handler');\n    const shouldUseContentCssCors = option('content_css_cors');\n    const getReferrerPolicy = option('referrer_policy');\n    const getLanguageCode = option('language');\n    const getLanguageUrl = option('language_url');\n    const shouldIndentUseMargin = option('indent_use_margin');\n    const getIndentation = option('indentation');\n    const getContentCss = option('content_css');\n    const getContentStyle = option('content_style');\n    const getFontCss = option('font_css');\n    const getDirectionality = option('directionality');\n    const getInlineBoundarySelector = option('inline_boundaries_selector');\n    const getObjectResizing = option('object_resizing');\n    const getResizeImgProportional = option('resize_img_proportional');\n    const getPlaceholder = option('placeholder');\n    const getEventRoot = option('event_root');\n    const getServiceMessage = option('service_message');\n    const getTheme = option('theme');\n    const getThemeUrl = option('theme_url');\n    const getModel = option('model');\n    const getModelUrl = option('model_url');\n    const isInlineBoundariesEnabled = option('inline_boundaries');\n    const getFormats = option('formats');\n    const getPreviewStyles = option('preview_styles');\n    const canFormatEmptyLines = option('format_empty_lines');\n    const getFormatNoneditableSelector = option('format_noneditable_selector');\n    const getCustomUiSelector = option('custom_ui_selector');\n    const isInline$1 = option('inline');\n    const hasHiddenInput = option('hidden_input');\n    const shouldPatchSubmit = option('submit_patch');\n    const shouldAddFormSubmitTrigger = option('add_form_submit_trigger');\n    const shouldAddUnloadTrigger = option('add_unload_trigger');\n    const getCustomUndoRedoLevels = option('custom_undo_redo_levels');\n    const shouldDisableNodeChange = option('disable_nodechange');\n    const isReadOnly$1 = option('readonly');\n    const hasEditableRoot$1 = option('editable_root');\n    const hasContentCssCors = option('content_css_cors');\n    const getPlugins = option('plugins');\n    const getExternalPlugins$1 = option('external_plugins');\n    const shouldBlockUnsupportedDrop = option('block_unsupported_drop');\n    const isVisualAidsEnabled = option('visual');\n    const getVisualAidsTableClass = option('visual_table_class');\n    const getVisualAidsAnchorClass = option('visual_anchor_class');\n    const getIframeAriaText = option('iframe_aria_text');\n    const getSetupCallback = option('setup');\n    const getInitInstanceCallback = option('init_instance_callback');\n    const getUrlConverterCallback = option('urlconverter_callback');\n    const getAutoFocus = option('auto_focus');\n    const shouldBrowserSpellcheck = option('browser_spellcheck');\n    const getProtect = option('protect');\n    const shouldPasteBlockDrop = option('paste_block_drop');\n    const shouldPasteDataImages = option('paste_data_images');\n    const getPastePreProcess = option('paste_preprocess');\n    const getPastePostProcess = option('paste_postprocess');\n    const getNewDocumentContent = option('newdocument_content');\n    const getPasteWebkitStyles = option('paste_webkit_styles');\n    const shouldPasteRemoveWebKitStyles = option('paste_remove_styles_if_webkit');\n    const shouldPasteMergeFormats = option('paste_merge_formats');\n    const isSmartPasteEnabled = option('smart_paste');\n    const isPasteAsTextEnabled = option('paste_as_text');\n    const getPasteTabSpaces = option('paste_tab_spaces');\n    const shouldAllowHtmlDataUrls = option('allow_html_data_urls');\n    const getTextPatterns = option('text_patterns');\n    const getTextPatternsLookup = option('text_patterns_lookup');\n    const getNonEditableClass = option('noneditable_class');\n    const getEditableClass = option('editable_class');\n    const getNonEditableRegExps = option('noneditable_regexp');\n    const shouldPreserveCData = option('preserve_cdata');\n    const shouldHighlightOnFocus = option('highlight_on_focus');\n    const shouldSanitizeXss = option('xss_sanitization');\n    const shouldUseDocumentWrite = option('init_content_sync');\n    const hasTextPatternsLookup = editor => editor.options.isSet('text_patterns_lookup');\n    const getFontStyleValues = editor => Tools.explode(editor.options.get('font_size_style_values'));\n    const getFontSizeClasses = editor => Tools.explode(editor.options.get('font_size_classes'));\n    const isEncodingXml = editor => editor.options.get('encoding') === 'xml';\n    const getAllowedImageFileTypes = editor => Tools.explode(editor.options.get('images_file_types'));\n    const hasTableTabNavigation = option('table_tab_navigation');\n    const getDetailsInitialState = option('details_initial_state');\n    const getDetailsSerializedState = option('details_serialized_state');\n    const shouldSandboxIframes = option('sandbox_iframes');\n    const getSandboxIframesExclusions = editor => editor.options.get('sandbox_iframes_exclusions');\n    const shouldConvertUnsafeEmbeds = option('convert_unsafe_embeds');\n    const getLicenseKey = option('license_key');\n    const getApiKey = option('api_key');\n\n    const isElement$3 = isElement$6;\n    const isText$5 = isText$b;\n    const removeNode$1 = node => {\n      const parentNode = node.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n    };\n    const trimCount = text => {\n      const trimmedText = trim$2(text);\n      return {\n        count: text.length - trimmedText.length,\n        text: trimmedText\n      };\n    };\n    const deleteZwspChars = caretContainer => {\n      let idx;\n      while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {\n        caretContainer.deleteData(idx, 1);\n      }\n    };\n    const removeUnchanged = (caretContainer, pos) => {\n      remove$2(caretContainer);\n      return pos;\n    };\n    const removeTextAndReposition = (caretContainer, pos) => {\n      const before = trimCount(caretContainer.data.substr(0, pos.offset()));\n      const after = trimCount(caretContainer.data.substr(pos.offset()));\n      const text = before.text + after.text;\n      if (text.length > 0) {\n        deleteZwspChars(caretContainer);\n        return CaretPosition(caretContainer, pos.offset() - before.count);\n      } else {\n        return pos;\n      }\n    };\n    const removeElementAndReposition = (caretContainer, pos) => {\n      const parentNode = pos.container();\n      const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map(index => {\n        return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;\n      }).getOr(pos);\n      remove$2(caretContainer);\n      return newPosition;\n    };\n    const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n    const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n    const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);\n    const remove$2 = caretContainerNode => {\n      if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {\n        if (hasContent(caretContainerNode)) {\n          caretContainerNode.removeAttribute('data-mce-caret');\n        } else {\n          removeNode$1(caretContainerNode);\n        }\n      }\n      if (isText$5(caretContainerNode)) {\n        deleteZwspChars(caretContainerNode);\n        if (caretContainerNode.data.length === 0) {\n          removeNode$1(caretContainerNode);\n        }\n      }\n    };\n\n    const isContentEditableFalse$8 = isContentEditableFalse$b;\n    const isMedia$1 = isMedia$2;\n    const isTableCell$1 = isTableCell$3;\n    const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';\n    const getAbsoluteClientRect = (root, element, before) => {\n      const clientRect = collapse(element.getBoundingClientRect(), before);\n      let scrollX;\n      let scrollY;\n      if (root.tagName === 'BODY') {\n        const docElm = root.ownerDocument.documentElement;\n        scrollX = root.scrollLeft || docElm.scrollLeft;\n        scrollY = root.scrollTop || docElm.scrollTop;\n      } else {\n        const rootRect = root.getBoundingClientRect();\n        scrollX = root.scrollLeft - rootRect.left;\n        scrollY = root.scrollTop - rootRect.top;\n      }\n      clientRect.left += scrollX;\n      clientRect.right += scrollX;\n      clientRect.top += scrollY;\n      clientRect.bottom += scrollY;\n      clientRect.width = 1;\n      let margin = element.offsetWidth - element.clientWidth;\n      if (margin > 0) {\n        if (before) {\n          margin *= -1;\n        }\n        clientRect.left += margin;\n        clientRect.right += margin;\n      }\n      return clientRect;\n    };\n    const trimInlineCaretContainers = root => {\n      var _a, _b;\n      const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);\n      for (let i = 0; i < fakeCaretTargetNodes.length; i++) {\n        const node = fakeCaretTargetNodes[i].dom;\n        let sibling = node.previousSibling;\n        if (endsWithCaretContainer$1(sibling)) {\n          const data = sibling.data;\n          if (data.length === 1) {\n            (_a = sibling.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(sibling);\n          } else {\n            sibling.deleteData(data.length - 1, 1);\n          }\n        }\n        sibling = node.nextSibling;\n        if (startsWithCaretContainer$1(sibling)) {\n          const data = sibling.data;\n          if (data.length === 1) {\n            (_b = sibling.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(sibling);\n          } else {\n            sibling.deleteData(0, 1);\n          }\n        }\n      }\n    };\n    const FakeCaret = (editor, root, isBlock, hasFocus) => {\n      const lastVisualCaret = value$2();\n      let cursorInterval;\n      let caretContainerNode;\n      const caretBlock = getForcedRootBlock(editor);\n      const dom = editor.dom;\n      const show = (before, element) => {\n        let rng;\n        hide();\n        if (isTableCell$1(element)) {\n          return null;\n        }\n        if (isBlock(element)) {\n          const caretContainer = insertBlock(caretBlock, element, before);\n          const clientRect = getAbsoluteClientRect(root, element, before);\n          dom.setStyle(caretContainer, 'top', clientRect.top);\n          dom.setStyle(caretContainer, 'caret-color', 'transparent');\n          caretContainerNode = caretContainer;\n          const caret = dom.create('div', {\n            'class': 'mce-visual-caret',\n            'data-mce-bogus': 'all'\n          });\n          dom.setStyles(caret, { ...clientRect });\n          dom.add(root, caret);\n          lastVisualCaret.set({\n            caret,\n            element,\n            before\n          });\n          if (before) {\n            dom.addClass(caret, 'mce-visual-caret-before');\n          }\n          startBlink();\n          rng = element.ownerDocument.createRange();\n          rng.setStart(caretContainer, 0);\n          rng.setEnd(caretContainer, 0);\n        } else {\n          caretContainerNode = insertInline$1(element, before);\n          rng = element.ownerDocument.createRange();\n          if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {\n            rng.setStart(caretContainerNode, 0);\n            rng.setEnd(caretContainerNode, 0);\n          } else {\n            rng.setStart(caretContainerNode, 1);\n            rng.setEnd(caretContainerNode, 1);\n          }\n          return rng;\n        }\n        return rng;\n      };\n      const hide = () => {\n        trimInlineCaretContainers(root);\n        if (caretContainerNode) {\n          remove$2(caretContainerNode);\n          caretContainerNode = null;\n        }\n        lastVisualCaret.on(caretState => {\n          dom.remove(caretState.caret);\n          lastVisualCaret.clear();\n        });\n        if (cursorInterval) {\n          clearInterval(cursorInterval);\n          cursorInterval = undefined;\n        }\n      };\n      const startBlink = () => {\n        cursorInterval = setInterval(() => {\n          lastVisualCaret.on(caretState => {\n            if (hasFocus()) {\n              dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');\n            } else {\n              dom.addClass(caretState.caret, 'mce-visual-caret-hidden');\n            }\n          });\n        }, 500);\n      };\n      const reposition = () => {\n        lastVisualCaret.on(caretState => {\n          const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);\n          dom.setStyles(caretState.caret, { ...clientRect });\n        });\n      };\n      const destroy = () => clearInterval(cursorInterval);\n      const getCss = () => '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';\n      return {\n        show,\n        hide,\n        getCss,\n        reposition,\n        destroy\n      };\n    };\n    const isFakeCaretTableBrowser = () => Env.browser.isFirefox();\n    const isInlineFakeCaretTarget = node => isContentEditableFalse$8(node) || isMedia$1(node);\n    const isFakeCaretTarget = node => {\n      const isTarget = isInlineFakeCaretTarget(node) || isTable$2(node) && isFakeCaretTableBrowser();\n      return isTarget && parentElement(SugarElement.fromDom(node)).exists(isEditable$2);\n    };\n\n    const isContentEditableTrue$1 = isContentEditableTrue$3;\n    const isContentEditableFalse$7 = isContentEditableFalse$b;\n    const isMedia = isMedia$2;\n    const isBlockLike = matchStyleValues('display', 'block table table-cell table-caption list-item');\n    const isCaretContainer = isCaretContainer$2;\n    const isCaretContainerBlock = isCaretContainerBlock$1;\n    const isElement$2 = isElement$6;\n    const isText$4 = isText$b;\n    const isCaretCandidate$1 = isCaretCandidate$3;\n    const isForwards = direction => direction > 0;\n    const isBackwards = direction => direction < 0;\n    const skipCaretContainers = (walk, shallow) => {\n      let node;\n      while (node = walk(shallow)) {\n        if (!isCaretContainerBlock(node)) {\n          return node;\n        }\n      }\n      return null;\n    };\n    const findNode = (node, direction, predicateFn, rootNode, shallow) => {\n      const walker = new DomTreeWalker(node, rootNode);\n      const isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);\n      let tempNode;\n      if (isBackwards(direction)) {\n        if (isCefOrCaretContainer) {\n          tempNode = skipCaretContainers(walker.prev.bind(walker), true);\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n        while (tempNode = skipCaretContainers(walker.prev.bind(walker), shallow)) {\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      if (isForwards(direction)) {\n        if (isCefOrCaretContainer) {\n          tempNode = skipCaretContainers(walker.next.bind(walker), true);\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n        while (tempNode = skipCaretContainers(walker.next.bind(walker), shallow)) {\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      return null;\n    };\n    const getEditingHost = (node, rootNode) => {\n      const isCETrue = node => isContentEditableTrue$1(node.dom);\n      const isRoot = node => node.dom === rootNode;\n      return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot).map(elm => elm.dom).getOr(rootNode);\n    };\n    const getParentBlock$3 = (node, rootNode) => {\n      while (node && node !== rootNode) {\n        if (isBlockLike(node)) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n    const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);\n    const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {\n      if (!caretPosition) {\n        return Optional.none();\n      }\n      const container = caretPosition.container();\n      const offset = caretPosition.offset();\n      if (!isElement$2(container)) {\n        return Optional.none();\n      }\n      return Optional.from(container.childNodes[offset + relativeOffset]);\n    };\n    const beforeAfter = (before, node) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const range = doc.createRange();\n      if (before) {\n        range.setStartBefore(node);\n        range.setEndBefore(node);\n      } else {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n      return range;\n    };\n    const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);\n    const lean = (left, root, node) => {\n      const siblingName = left ? 'previousSibling' : 'nextSibling';\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        let sibling = tempNode[siblingName];\n        if (sibling && isCaretContainer(sibling)) {\n          sibling = sibling[siblingName];\n        }\n        if (isContentEditableFalse$7(sibling) || isMedia(sibling)) {\n          if (isNodesInSameBlock(root, sibling, tempNode)) {\n            return sibling;\n          }\n          break;\n        }\n        if (isCaretCandidate$1(sibling)) {\n          break;\n        }\n        tempNode = tempNode.parentNode;\n      }\n      return null;\n    };\n    const before$2 = curry(beforeAfter, true);\n    const after$2 = curry(beforeAfter, false);\n    const normalizeRange = (direction, root, range) => {\n      let node;\n      const leanLeft = curry(lean, true, root);\n      const leanRight = curry(lean, false, root);\n      const container = range.startContainer;\n      const offset = range.startOffset;\n      if (isCaretContainerBlock$1(container)) {\n        const block = isText$4(container) ? container.parentNode : container;\n        const location = block.getAttribute('data-mce-caret');\n        if (location === 'before') {\n          node = block.nextSibling;\n          if (isFakeCaretTarget(node)) {\n            return before$2(node);\n          }\n        }\n        if (location === 'after') {\n          node = block.previousSibling;\n          if (isFakeCaretTarget(node)) {\n            return after$2(node);\n          }\n        }\n      }\n      if (!range.collapsed) {\n        return range;\n      }\n      if (isText$b(container)) {\n        if (isCaretContainer(container)) {\n          if (direction === 1) {\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n          }\n          if (direction === -1) {\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n          }\n          return range;\n        }\n        if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {\n          if (direction === 1) {\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n          }\n          return range;\n        }\n        if (startsWithCaretContainer$1(container) && offset <= 1) {\n          if (direction === -1) {\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n          }\n          return range;\n        }\n        if (offset === container.data.length) {\n          node = leanRight(container);\n          if (node) {\n            return before$2(node);\n          }\n          return range;\n        }\n        if (offset === 0) {\n          node = leanLeft(container);\n          if (node) {\n            return after$2(node);\n          }\n          return range;\n        }\n      }\n      return range;\n    };\n    const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$7);\n    const getNormalizedRangeEndPoint = (direction, root, range) => {\n      const normalizedRange = normalizeRange(direction, root, range);\n      return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);\n    };\n    const getElementFromPosition = pos => Optional.from(pos.getNode()).map(SugarElement.fromDom);\n    const getElementFromPrevPosition = pos => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);\n    const getVisualCaretPosition = (walkFn, caretPosition) => {\n      let pos = caretPosition;\n      while (pos = walkFn(pos)) {\n        if (pos.isVisible()) {\n          return pos;\n        }\n      }\n      return pos;\n    };\n    const isMoveInsideSameBlock = (from, to) => {\n      const inSameBlock = isInSameBlock(from, to);\n      if (!inSameBlock && isBr$6(from.getNode())) {\n        return true;\n      }\n      return inSameBlock;\n    };\n\n    var HDirection;\n    (function (HDirection) {\n      HDirection[HDirection['Backwards'] = -1] = 'Backwards';\n      HDirection[HDirection['Forwards'] = 1] = 'Forwards';\n    }(HDirection || (HDirection = {})));\n    const isContentEditableFalse$6 = isContentEditableFalse$b;\n    const isText$3 = isText$b;\n    const isElement$1 = isElement$6;\n    const isBr$2 = isBr$6;\n    const isCaretCandidate = isCaretCandidate$3;\n    const isAtomic = isAtomic$1;\n    const isEditableCaretCandidate = isEditableCaretCandidate$1;\n    const getParents$3 = (node, root) => {\n      const parents = [];\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        parents.push(tempNode);\n        tempNode = tempNode.parentNode;\n      }\n      return parents;\n    };\n    const nodeAtIndex = (container, offset) => {\n      if (container.hasChildNodes() && offset < container.childNodes.length) {\n        return container.childNodes[offset];\n      }\n      return null;\n    };\n    const getCaretCandidatePosition = (direction, node) => {\n      if (isForwards(direction)) {\n        if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) {\n          return CaretPosition.before(node);\n        }\n        if (isText$3(node)) {\n          return CaretPosition(node, 0);\n        }\n      }\n      if (isBackwards(direction)) {\n        if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {\n          return CaretPosition.after(node);\n        }\n        if (isText$3(node)) {\n          return CaretPosition(node, node.data.length);\n        }\n      }\n      if (isBackwards(direction)) {\n        if (isBr$2(node)) {\n          return CaretPosition.before(node);\n        }\n        return CaretPosition.after(node);\n      }\n      return CaretPosition.before(node);\n    };\n    const moveForwardFromBr = (root, nextNode) => {\n      const nextSibling = nextNode.nextSibling;\n      if (nextSibling && isCaretCandidate(nextSibling)) {\n        if (isText$3(nextSibling)) {\n          return CaretPosition(nextSibling, 0);\n        } else {\n          return CaretPosition.before(nextSibling);\n        }\n      } else {\n        return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);\n      }\n    };\n    const findCaretPosition$1 = (direction, startPos, root) => {\n      let node;\n      let nextNode;\n      let innerNode;\n      let caretPosition;\n      if (!isElement$1(root) || !startPos) {\n        return null;\n      }\n      if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {\n        caretPosition = CaretPosition.after(root.lastChild);\n        if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {\n          return isBr$2(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;\n        }\n      } else {\n        caretPosition = startPos;\n      }\n      const container = caretPosition.container();\n      let offset = caretPosition.offset();\n      if (isText$3(container)) {\n        if (isBackwards(direction) && offset > 0) {\n          return CaretPosition(container, --offset);\n        }\n        if (isForwards(direction) && offset < container.length) {\n          return CaretPosition(container, ++offset);\n        }\n        node = container;\n      } else {\n        if (isBackwards(direction) && offset > 0) {\n          nextNode = nodeAtIndex(container, offset - 1);\n          if (isCaretCandidate(nextNode)) {\n            if (!isAtomic(nextNode)) {\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n              if (innerNode) {\n                if (isText$3(innerNode)) {\n                  return CaretPosition(innerNode, innerNode.data.length);\n                }\n                return CaretPosition.after(innerNode);\n              }\n            }\n            if (isText$3(nextNode)) {\n              return CaretPosition(nextNode, nextNode.data.length);\n            }\n            return CaretPosition.before(nextNode);\n          }\n        }\n        if (isForwards(direction) && offset < container.childNodes.length) {\n          nextNode = nodeAtIndex(container, offset);\n          if (isCaretCandidate(nextNode)) {\n            if (isBr$2(nextNode)) {\n              return moveForwardFromBr(root, nextNode);\n            }\n            if (!isAtomic(nextNode)) {\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n              if (innerNode) {\n                if (isText$3(innerNode)) {\n                  return CaretPosition(innerNode, 0);\n                }\n                return CaretPosition.before(innerNode);\n              }\n            }\n            if (isText$3(nextNode)) {\n              return CaretPosition(nextNode, 0);\n            }\n            return CaretPosition.after(nextNode);\n          }\n        }\n        node = nextNode ? nextNode : caretPosition.getNode();\n      }\n      if (node && (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart())) {\n        node = findNode(node, direction, always, root, true);\n        if (isEditableCaretCandidate(node, root)) {\n          return getCaretCandidatePosition(direction, node);\n        }\n      }\n      nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root) : node;\n      const rootContentEditableFalseElm = last$1(filter$5(getParents$3(container, root), isContentEditableFalse$6));\n      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {\n        if (isForwards(direction)) {\n          caretPosition = CaretPosition.after(rootContentEditableFalseElm);\n        } else {\n          caretPosition = CaretPosition.before(rootContentEditableFalseElm);\n        }\n        return caretPosition;\n      }\n      if (nextNode) {\n        return getCaretCandidatePosition(direction, nextNode);\n      }\n      return null;\n    };\n    const CaretWalker = root => ({\n      next: caretPosition => {\n        return findCaretPosition$1(HDirection.Forwards, caretPosition, root);\n      },\n      prev: caretPosition => {\n        return findCaretPosition$1(HDirection.Backwards, caretPosition, root);\n      }\n    });\n\n    const walkToPositionIn = (forward, root, start) => {\n      const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);\n      return fromPosition(forward, root, position);\n    };\n    const afterElement = node => isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);\n    const isBeforeOrStart = position => {\n      if (CaretPosition.isTextPosition(position)) {\n        return position.offset() === 0;\n      } else {\n        return isCaretCandidate$3(position.getNode());\n      }\n    };\n    const isAfterOrEnd = position => {\n      if (CaretPosition.isTextPosition(position)) {\n        const container = position.container();\n        return position.offset() === container.data.length;\n      } else {\n        return isCaretCandidate$3(position.getNode(true));\n      }\n    };\n    const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);\n    const isAtBr = position => !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());\n    const shouldSkipPosition = (forward, from, to) => {\n      if (forward) {\n        return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);\n      } else {\n        return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);\n      }\n    };\n    const fromPosition = (forward, root, pos) => {\n      const walker = CaretWalker(root);\n      return Optional.from(forward ? walker.next(pos) : walker.prev(pos));\n    };\n    const navigate = (forward, root, from) => fromPosition(forward, root, from).bind(to => {\n      if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {\n        return fromPosition(forward, root, to);\n      } else {\n        return Optional.some(to);\n      }\n    });\n    const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from).bind(pos => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));\n    const positionIn = (forward, element) => {\n      const startNode = forward ? element.firstChild : element.lastChild;\n      if (isText$b(startNode)) {\n        return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));\n      } else if (startNode) {\n        if (isCaretCandidate$3(startNode)) {\n          return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));\n        } else {\n          return walkToPositionIn(forward, element, startNode);\n        }\n      } else {\n        return Optional.none();\n      }\n    };\n    const nextPosition = curry(fromPosition, true);\n    const prevPosition = curry(fromPosition, false);\n    const firstPositionIn = curry(positionIn, true);\n    const lastPositionIn = curry(positionIn, false);\n\n    const CARET_ID = '_mce_caret';\n    const isCaretNode = node => isElement$6(node) && node.id === CARET_ID;\n    const getParentCaretContainer = (body, node) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== body) {\n        if (isCaretNode(currentNode)) {\n          return currentNode;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return null;\n    };\n\n    const isStringPathBookmark = bookmark => isString(bookmark.start);\n    const isRangeBookmark = bookmark => has$2(bookmark, 'rng');\n    const isIdBookmark = bookmark => has$2(bookmark, 'id');\n    const isIndexBookmark = bookmark => has$2(bookmark, 'name');\n    const isPathBookmark = bookmark => Tools.isArray(bookmark.start);\n\n    const isForwardBookmark = bookmark => !isIndexBookmark(bookmark) && isBoolean(bookmark.forward) ? bookmark.forward : true;\n    const addBogus = (dom, node) => {\n      if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {\n        node.innerHTML = '<br data-mce-bogus=\"1\" />';\n      }\n      return node;\n    };\n    const resolveCaretPositionBookmark = (dom, bookmark) => {\n      const startPos = Optional.from(resolve$1(dom.getRoot(), bookmark.start));\n      const endPos = Optional.from(resolve$1(dom.getRoot(), bookmark.end));\n      return lift2(startPos, endPos, (start, end) => {\n        const range = dom.createRng();\n        range.setStart(start.container(), start.offset());\n        range.setEnd(end.container(), end.offset());\n        return {\n          range,\n          forward: isForwardBookmark(bookmark)\n        };\n      });\n    };\n    const insertZwsp = (node, rng) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const textNode = doc.createTextNode(ZWSP$1);\n      node.appendChild(textNode);\n      rng.setStart(textNode, 0);\n      rng.setEnd(textNode, 0);\n    };\n    const isEmpty$1 = node => !node.hasChildNodes();\n    const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, pos => {\n      rng.setStart(pos.container(), pos.offset());\n      rng.setEnd(pos.container(), pos.offset());\n      return true;\n    });\n    const padEmptyCaretContainer = (root, node, rng) => {\n      if (isEmpty$1(node) && getParentCaretContainer(root, node)) {\n        insertZwsp(node, rng);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const setEndPoint = (dom, start, bookmark, rng) => {\n      const point = bookmark[start ? 'start' : 'end'];\n      const root = dom.getRoot();\n      if (point) {\n        let node = root;\n        let offset = point[0];\n        for (let i = point.length - 1; node && i >= 1; i--) {\n          const children = node.childNodes;\n          if (padEmptyCaretContainer(root, node, rng)) {\n            return true;\n          }\n          if (point[i] > children.length - 1) {\n            if (padEmptyCaretContainer(root, node, rng)) {\n              return true;\n            }\n            return tryFindRangePosition(node, rng);\n          }\n          node = children[point[i]];\n        }\n        if (isText$b(node)) {\n          offset = Math.min(point[0], node.data.length);\n        }\n        if (isElement$6(node)) {\n          offset = Math.min(point[0], node.childNodes.length);\n        }\n        if (start) {\n          rng.setStart(node, offset);\n        } else {\n          rng.setEnd(node, offset);\n        }\n      }\n      return true;\n    };\n    const isValidTextNode = node => isText$b(node) && node.data.length > 0;\n    const restoreEndPoint = (dom, suffix, bookmark) => {\n      const marker = dom.get(bookmark.id + '_' + suffix);\n      const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;\n      const keep = bookmark.keep;\n      if (marker && markerParent) {\n        let container;\n        let offset;\n        if (suffix === 'start') {\n          if (!keep) {\n            container = markerParent;\n            offset = dom.nodeIndex(marker);\n          } else {\n            if (marker.hasChildNodes()) {\n              container = marker.firstChild;\n              offset = 1;\n            } else if (isValidTextNode(marker.nextSibling)) {\n              container = marker.nextSibling;\n              offset = 0;\n            } else if (isValidTextNode(marker.previousSibling)) {\n              container = marker.previousSibling;\n              offset = marker.previousSibling.data.length;\n            } else {\n              container = markerParent;\n              offset = dom.nodeIndex(marker) + 1;\n            }\n          }\n        } else {\n          if (!keep) {\n            container = markerParent;\n            offset = dom.nodeIndex(marker);\n          } else {\n            if (marker.hasChildNodes()) {\n              container = marker.firstChild;\n              offset = 1;\n            } else if (isValidTextNode(marker.previousSibling)) {\n              container = marker.previousSibling;\n              offset = marker.previousSibling.data.length;\n            } else {\n              container = markerParent;\n              offset = dom.nodeIndex(marker);\n            }\n          }\n        }\n        if (!keep) {\n          const prev = marker.previousSibling;\n          const next = marker.nextSibling;\n          Tools.each(Tools.grep(marker.childNodes), node => {\n            if (isText$b(node)) {\n              node.data = node.data.replace(/\\uFEFF/g, '');\n            }\n          });\n          let otherMarker;\n          while (otherMarker = dom.get(bookmark.id + '_' + suffix)) {\n            dom.remove(otherMarker, true);\n          }\n          if (isText$b(next) && isText$b(prev) && !Env.browser.isOpera()) {\n            const idx = prev.data.length;\n            prev.appendData(next.data);\n            dom.remove(next);\n            container = prev;\n            offset = idx;\n          }\n        }\n        return Optional.some(CaretPosition(container, offset));\n      } else {\n        return Optional.none();\n      }\n    };\n    const resolvePaths = (dom, bookmark) => {\n      const range = dom.createRng();\n      if (setEndPoint(dom, true, bookmark, range) && setEndPoint(dom, false, bookmark, range)) {\n        return Optional.some({\n          range,\n          forward: isForwardBookmark(bookmark)\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const resolveId = (dom, bookmark) => {\n      const startPos = restoreEndPoint(dom, 'start', bookmark);\n      const endPos = restoreEndPoint(dom, 'end', bookmark);\n      return lift2(startPos, endPos.or(startPos), (spos, epos) => {\n        const range = dom.createRng();\n        range.setStart(addBogus(dom, spos.container()), spos.offset());\n        range.setEnd(addBogus(dom, epos.container()), epos.offset());\n        return {\n          range,\n          forward: isForwardBookmark(bookmark)\n        };\n      });\n    };\n    const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map(elm => {\n      const range = dom.createRng();\n      range.selectNode(elm);\n      return {\n        range,\n        forward: true\n      };\n    });\n    const resolve = (selection, bookmark) => {\n      const dom = selection.dom;\n      if (bookmark) {\n        if (isPathBookmark(bookmark)) {\n          return resolvePaths(dom, bookmark);\n        } else if (isStringPathBookmark(bookmark)) {\n          return resolveCaretPositionBookmark(dom, bookmark);\n        } else if (isIdBookmark(bookmark)) {\n          return resolveId(dom, bookmark);\n        } else if (isIndexBookmark(bookmark)) {\n          return resolveIndex(dom, bookmark);\n        } else if (isRangeBookmark(bookmark)) {\n          return Optional.some({\n            range: bookmark.rng,\n            forward: isForwardBookmark(bookmark)\n          });\n        }\n      }\n      return Optional.none();\n    };\n\n    const getBookmark$2 = (selection, type, normalized) => {\n      return getBookmark$3(selection, type, normalized);\n    };\n    const moveToBookmark = (selection, bookmark) => {\n      resolve(selection, bookmark).each(({range, forward}) => {\n        selection.setRng(range, forward);\n      });\n    };\n    const isBookmarkNode$1 = node => {\n      return isElement$6(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';\n    };\n\n    const is = expected => actual => expected === actual;\n    const isNbsp = is(nbsp);\n    const isWhiteSpace = chr => chr !== '' && ' \\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n    const isContent = chr => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$2(chr);\n\n    const getRanges$1 = selection => {\n      const ranges = [];\n      if (selection) {\n        for (let i = 0; i < selection.rangeCount; i++) {\n          ranges.push(selection.getRangeAt(i));\n        }\n      }\n      return ranges;\n    };\n    const getSelectedNodes = ranges => {\n      return bind$3(ranges, range => {\n        const node = getSelectedNode(range);\n        return node ? [SugarElement.fromDom(node)] : [];\n      });\n    };\n    const hasMultipleRanges = selection => {\n      return getRanges$1(selection).length > 1;\n    };\n\n    const getCellsFromRanges = ranges => filter$5(getSelectedNodes(ranges), isTableCell$2);\n    const getCellsFromElement = elm => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');\n    const getCellsFromElementOrRanges = (ranges, element) => {\n      const selectedCells = getCellsFromElement(element);\n      return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);\n    };\n    const getCellsFromEditor = editor => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));\n    const getClosestTable = (cell, isRoot) => ancestor$3(cell, 'table', isRoot);\n\n    const getStartNode = rng => {\n      const sc = rng.startContainer, so = rng.startOffset;\n      if (isText$b(sc)) {\n        return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();\n      } else {\n        return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);\n      }\n    };\n    const getEndNode = rng => {\n      const ec = rng.endContainer, eo = rng.endOffset;\n      if (isText$b(ec)) {\n        return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();\n      } else {\n        return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);\n      }\n    };\n    const getFirstChildren = node => {\n      return firstChild(node).fold(constant([node]), child => {\n        return [node].concat(getFirstChildren(child));\n      });\n    };\n    const getLastChildren = node => {\n      return lastChild(node).fold(constant([node]), child => {\n        if (name(child) === 'br') {\n          return prevSibling(child).map(sibling => {\n            return [node].concat(getLastChildren(sibling));\n          }).getOr([]);\n        } else {\n          return [node].concat(getLastChildren(child));\n        }\n      });\n    };\n    const hasAllContentsSelected = (elm, rng) => {\n      return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {\n        const start = find$2(getFirstChildren(elm), curry(eq, startNode));\n        const end = find$2(getLastChildren(elm), curry(eq, endNode));\n        return start.isSome() && end.isSome();\n      }).getOr(false);\n    };\n    const moveEndPoint = (dom, rng, node, start) => {\n      const root = node;\n      const walker = new DomTreeWalker(node, root);\n      const moveCaretBeforeOnEnterElementsMap = filter$4(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2([\n        'td',\n        'th',\n        'table'\n      ], name.toLowerCase()));\n      let currentNode = node;\n      do {\n        if (isText$b(currentNode) && Tools.trim(currentNode.data).length !== 0) {\n          if (start) {\n            rng.setStart(currentNode, 0);\n          } else {\n            rng.setEnd(currentNode, currentNode.data.length);\n          }\n          return;\n        }\n        if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {\n          if (start) {\n            rng.setStartBefore(currentNode);\n          } else {\n            if (currentNode.nodeName === 'BR') {\n              rng.setEndBefore(currentNode);\n            } else {\n              rng.setEndAfter(currentNode);\n            }\n          }\n          return;\n        }\n      } while (currentNode = start ? walker.next() : walker.prev());\n      if (root.nodeName === 'BODY') {\n        if (start) {\n          rng.setStart(root, 0);\n        } else {\n          rng.setEnd(root, root.childNodes.length);\n        }\n      }\n    };\n    const hasAnyRanges = editor => {\n      const sel = editor.selection.getSel();\n      return isNonNullable(sel) && sel.rangeCount > 0;\n    };\n    const runOnRanges = (editor, executor) => {\n      const fakeSelectionNodes = getCellsFromEditor(editor);\n      if (fakeSelectionNodes.length > 0) {\n        each$e(fakeSelectionNodes, elem => {\n          const node = elem.dom;\n          const fakeNodeRng = editor.dom.createRng();\n          fakeNodeRng.setStartBefore(node);\n          fakeNodeRng.setEndAfter(node);\n          executor(fakeNodeRng, true);\n        });\n      } else {\n        executor(editor.selection.getRng(), false);\n      }\n    };\n    const preserve = (selection, fillBookmark, executor) => {\n      const bookmark = getPersistentBookmark(selection, fillBookmark);\n      executor(bookmark);\n      selection.moveToBookmark(bookmark);\n    };\n\n    const isNode = node => isNumber(node === null || node === void 0 ? void 0 : node.nodeType);\n    const isElementNode$1 = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$1(node);\n    const isElementDirectlySelected = (dom, node) => {\n      if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {\n        const selectedAttr = dom.getAttrib(node, 'data-mce-selected');\n        const value = parseInt(selectedAttr, 10);\n        return !isNaN(value) && value > 0;\n      } else {\n        return false;\n      }\n    };\n    const preserveSelection = (editor, action, shouldMoveStart) => {\n      const {selection, dom} = editor;\n      const selectedNodeBeforeAction = selection.getNode();\n      const isSelectedBeforeNodeNoneditable = isContentEditableFalse$b(selectedNodeBeforeAction);\n      preserve(selection, true, () => {\n        action();\n      });\n      const isBeforeNodeStillNoneditable = isSelectedBeforeNodeNoneditable && isContentEditableFalse$b(selectedNodeBeforeAction);\n      if (isBeforeNodeStillNoneditable && dom.isChildOf(selectedNodeBeforeAction, editor.getBody())) {\n        editor.selection.select(selectedNodeBeforeAction);\n      } else if (shouldMoveStart(selection.getStart())) {\n        moveStartToNearestText(dom, selection);\n      }\n    };\n    const moveStartToNearestText = (dom, selection) => {\n      var _a, _b;\n      const rng = selection.getRng();\n      const {startContainer, startOffset} = rng;\n      const selectedNode = selection.getNode();\n      if (isElementDirectlySelected(dom, selectedNode)) {\n        return;\n      }\n      if (isElement$6(startContainer)) {\n        const nodes = startContainer.childNodes;\n        const root = dom.getRoot();\n        let walker;\n        if (startOffset < nodes.length) {\n          const startNode = nodes[startOffset];\n          walker = new DomTreeWalker(startNode, (_a = dom.getParent(startNode, dom.isBlock)) !== null && _a !== void 0 ? _a : root);\n        } else {\n          const startNode = nodes[nodes.length - 1];\n          walker = new DomTreeWalker(startNode, (_b = dom.getParent(startNode, dom.isBlock)) !== null && _b !== void 0 ? _b : root);\n          walker.next(true);\n        }\n        for (let node = walker.current(); node; node = walker.next()) {\n          if (dom.getContentEditable(node) === 'false') {\n            return;\n          } else if (isText$b(node) && !isWhiteSpaceNode$1(node)) {\n            rng.setStart(node, 0);\n            selection.setRng(rng);\n            return;\n          }\n        }\n      }\n    };\n    const getNonWhiteSpaceSibling = (node, next, inc) => {\n      if (node) {\n        const nextName = next ? 'nextSibling' : 'previousSibling';\n        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {\n          if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {\n            return node;\n          }\n        }\n      }\n      return undefined;\n    };\n    const isTextBlock$1 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);\n    const isValid = (ed, parent, child) => {\n      return ed.schema.isValidChild(parent, child);\n    };\n    const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {\n      if (isNonNullable(node) && isText$b(node)) {\n        const data = allowSpaces ? node.data.replace(/ /g, '\\xA0') : node.data;\n        return isWhitespaceText(data);\n      } else {\n        return false;\n      }\n    };\n    const isEmptyTextNode$1 = node => {\n      return isNonNullable(node) && isText$b(node) && node.length === 0;\n    };\n    const isWrapNoneditableTarget = (editor, node) => {\n      const baseDataSelector = '[data-mce-cef-wrappable]';\n      const formatNoneditableSelector = getFormatNoneditableSelector(editor);\n      const selector = isEmpty$3(formatNoneditableSelector) ? baseDataSelector : `${ baseDataSelector },${ formatNoneditableSelector }`;\n      return is$1(SugarElement.fromDom(node), selector);\n    };\n    const isWrappableNoneditable = (editor, node) => {\n      const dom = editor.dom;\n      return isElementNode$1(node) && dom.getContentEditable(node) === 'false' && isWrapNoneditableTarget(editor, node) && dom.select('[contenteditable=\"true\"]', node).length === 0;\n    };\n    const replaceVars = (value, vars) => {\n      if (isFunction(value)) {\n        return value(vars);\n      } else if (isNonNullable(vars)) {\n        value = value.replace(/%(\\w+)/g, (str, name) => {\n          return vars[name] || str;\n        });\n      }\n      return value;\n    };\n    const isEq$5 = (str1, str2) => {\n      str1 = str1 || '';\n      str2 = str2 || '';\n      str1 = '' + (str1.nodeName || str1);\n      str2 = '' + (str2.nodeName || str2);\n      return str1.toLowerCase() === str2.toLowerCase();\n    };\n    const normalizeStyleValue = (value, name) => {\n      if (isNullable(value)) {\n        return null;\n      } else {\n        let strValue = String(value);\n        if (name === 'color' || name === 'backgroundColor') {\n          strValue = rgbaToHexString(strValue);\n        }\n        if (name === 'fontWeight' && value === 700) {\n          strValue = 'bold';\n        }\n        if (name === 'fontFamily') {\n          strValue = strValue.replace(/[\\'\\\"]/g, '').replace(/,\\s+/g, ',');\n        }\n        return strValue;\n      }\n    };\n    const getStyle = (dom, node, name) => {\n      const style = dom.getStyle(node, name);\n      return normalizeStyleValue(style, name);\n    };\n    const getTextDecoration = (dom, node) => {\n      let decoration;\n      dom.getParent(node, n => {\n        if (isElement$6(n)) {\n          decoration = dom.getStyle(n, 'text-decoration');\n          return !!decoration && decoration !== 'none';\n        } else {\n          return false;\n        }\n      });\n      return decoration;\n    };\n    const getParents$2 = (dom, node, selector) => {\n      return dom.getParents(node, selector, dom.getRoot());\n    };\n    const isFormatPredicate = (editor, formatName, predicate) => {\n      const formats = editor.formatter.get(formatName);\n      return isNonNullable(formats) && exists(formats, predicate);\n    };\n    const isVariableFormatName = (editor, formatName) => {\n      const hasVariableValues = format => {\n        const isVariableValue = val => isFunction(val) || val.length > 1 && val.charAt(0) === '%';\n        return exists([\n          'styles',\n          'attributes'\n        ], key => get$a(format, key).exists(field => {\n          const fieldValues = isArray$1(field) ? field : values(field);\n          return exists(fieldValues, isVariableValue);\n        }));\n      };\n      return isFormatPredicate(editor, formatName, hasVariableValues);\n    };\n    const areSimilarFormats = (editor, formatName, otherFormatName) => {\n      const validKeys = [\n        'inline',\n        'block',\n        'selector',\n        'attributes',\n        'styles',\n        'classes'\n      ];\n      const filterObj = format => filter$4(format, (_, key) => exists(validKeys, validKey => validKey === key));\n      return isFormatPredicate(editor, formatName, fmt1 => {\n        const filteredFmt1 = filterObj(fmt1);\n        return isFormatPredicate(editor, otherFormatName, fmt2 => {\n          const filteredFmt2 = filterObj(fmt2);\n          return equal$1(filteredFmt1, filteredFmt2);\n        });\n      });\n    };\n    const isBlockFormat = format => hasNonNullableKey(format, 'block');\n    const isWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper === true;\n    const isNonWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper !== true;\n    const isSelectorFormat = format => hasNonNullableKey(format, 'selector');\n    const isInlineFormat = format => hasNonNullableKey(format, 'inline');\n    const isMixedFormat = format => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, 'mixed'), true);\n    const shouldExpandToSelector = format => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);\n    const getEmptyCaretContainers = node => {\n      const nodes = [];\n      let tempNode = node;\n      while (tempNode) {\n        if (isText$b(tempNode) && tempNode.data !== ZWSP$1 || tempNode.childNodes.length > 1) {\n          return [];\n        }\n        if (isElement$6(tempNode)) {\n          nodes.push(tempNode);\n        }\n        tempNode = tempNode.firstChild;\n      }\n      return nodes;\n    };\n    const isCaretContainerEmpty = node => {\n      return getEmptyCaretContainers(node).length > 0;\n    };\n    const isEmptyCaretFormatElement = element => {\n      return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);\n    };\n\n    const isBookmarkNode = isBookmarkNode$1;\n    const getParents$1 = getParents$2;\n    const isWhiteSpaceNode = isWhiteSpaceNode$1;\n    const isTextBlock = isTextBlock$1;\n    const isBogusBr = node => {\n      return isBr$6(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;\n    };\n    const findParentContentEditable = (dom, node) => {\n      let parent = node;\n      while (parent) {\n        if (isElement$6(parent) && dom.getContentEditable(parent)) {\n          return dom.getContentEditable(parent) === 'false' ? parent : node;\n        }\n        parent = parent.parentNode;\n      }\n      return node;\n    };\n    const walkText = (start, node, offset, predicate) => {\n      const str = node.data;\n      if (start) {\n        for (let i = offset; i > 0; i--) {\n          if (predicate(str.charAt(i - 1))) {\n            return i;\n          }\n        }\n      } else {\n        for (let i = offset; i < str.length; i++) {\n          if (predicate(str.charAt(i))) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    const findSpace = (start, node, offset) => walkText(start, node, offset, c => isNbsp(c) || isWhiteSpace(c));\n    const findContent = (start, node, offset) => walkText(start, node, offset, isContent);\n    const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {\n      let lastTextNode;\n      const rootNode = dom.getParent(container, dom.isBlock) || body;\n      const walk = (container, offset, pred) => {\n        const textSeeker = TextSeeker(dom);\n        const walker = start ? textSeeker.backwards : textSeeker.forwards;\n        return Optional.from(walker(container, offset, (text, textOffset) => {\n          if (isBookmarkNode(text.parentNode)) {\n            return -1;\n          } else {\n            lastTextNode = text;\n            return pred(start, text, textOffset);\n          }\n        }, rootNode));\n      };\n      const spaceResult = walk(container, offset, findSpace);\n      return spaceResult.bind(result => includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({\n        container: lastTextNode,\n        offset: start ? 0 : lastTextNode.length\n      }) : Optional.none());\n    };\n    const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {\n      const sibling = container[siblingName];\n      if (isText$b(container) && isEmpty$3(container.data) && sibling) {\n        container = sibling;\n      }\n      const parents = getParents$1(dom, container);\n      for (let i = 0; i < parents.length; i++) {\n        for (let y = 0; y < formatList.length; y++) {\n          const curFormat = formatList[y];\n          if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {\n            continue;\n          }\n          if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {\n            return parents[i];\n          }\n        }\n      }\n      return container;\n    };\n    const findBlockEndPoint = (dom, formatList, container, siblingName) => {\n      var _a;\n      let node = container;\n      const root = dom.getRoot();\n      const format = formatList[0];\n      if (isBlockFormat(format)) {\n        node = format.wrapper ? null : dom.getParent(container, format.block, root);\n      }\n      if (!node) {\n        const scopeRoot = (_a = dom.getParent(container, 'LI,TD,TH,SUMMARY')) !== null && _a !== void 0 ? _a : root;\n        node = dom.getParent(isText$b(container) ? container.parentNode : container, node => node !== root && isTextBlock(dom.schema, node), scopeRoot);\n      }\n      if (node && isBlockFormat(format) && format.wrapper) {\n        node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;\n      }\n      if (!node) {\n        node = container;\n        while (node && node[siblingName] && !dom.isBlock(node[siblingName])) {\n          node = node[siblingName];\n          if (isEq$5(node, 'br')) {\n            break;\n          }\n        }\n      }\n      return node || container;\n    };\n    const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {\n      const parent = container.parentNode;\n      if (isNonNullable(container[siblingName])) {\n        return false;\n      } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {\n        return true;\n      } else {\n        return isAtBlockBoundary$1(dom, root, parent, siblingName);\n      }\n    };\n    const findParentContainer = (dom, formatList, container, offset, start) => {\n      let parent = container;\n      const siblingName = start ? 'previousSibling' : 'nextSibling';\n      const root = dom.getRoot();\n      if (isText$b(container) && !isWhiteSpaceNode(container)) {\n        if (start ? offset > 0 : offset < container.data.length) {\n          return container;\n        }\n      }\n      while (parent) {\n        if (!formatList[0].block_expand && dom.isBlock(parent)) {\n          return parent;\n        }\n        for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\n          const allowSpaces = isText$b(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);\n          if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {\n            return parent;\n          }\n        }\n        if (parent === root || parent.parentNode === root) {\n          container = parent;\n          break;\n        }\n        parent = parent.parentNode;\n      }\n      return container;\n    };\n    const isSelfOrParentBookmark = container => isBookmarkNode(container.parentNode) || isBookmarkNode(container);\n    const expandRng = (dom, rng, formatList, includeTrailingSpace = false) => {\n      let {startContainer, startOffset, endContainer, endOffset} = rng;\n      const format = formatList[0];\n      if (isElement$6(startContainer) && startContainer.hasChildNodes()) {\n        startContainer = getNode$1(startContainer, startOffset);\n        if (isText$b(startContainer)) {\n          startOffset = 0;\n        }\n      }\n      if (isElement$6(endContainer) && endContainer.hasChildNodes()) {\n        endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);\n        if (isText$b(endContainer)) {\n          endOffset = endContainer.data.length;\n        }\n      }\n      startContainer = findParentContentEditable(dom, startContainer);\n      endContainer = findParentContentEditable(dom, endContainer);\n      if (isSelfOrParentBookmark(startContainer)) {\n        startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\n        if (rng.collapsed) {\n          startContainer = startContainer.previousSibling || startContainer;\n        } else {\n          startContainer = startContainer.nextSibling || startContainer;\n        }\n        if (isText$b(startContainer)) {\n          startOffset = rng.collapsed ? startContainer.length : 0;\n        }\n      }\n      if (isSelfOrParentBookmark(endContainer)) {\n        endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\n        if (rng.collapsed) {\n          endContainer = endContainer.nextSibling || endContainer;\n        } else {\n          endContainer = endContainer.previousSibling || endContainer;\n        }\n        if (isText$b(endContainer)) {\n          endOffset = rng.collapsed ? 0 : endContainer.length;\n        }\n      }\n      if (rng.collapsed) {\n        const startPoint = findWordEndPoint(dom, dom.getRoot(), startContainer, startOffset, true, includeTrailingSpace);\n        startPoint.each(({container, offset}) => {\n          startContainer = container;\n          startOffset = offset;\n        });\n        const endPoint = findWordEndPoint(dom, dom.getRoot(), endContainer, endOffset, false, includeTrailingSpace);\n        endPoint.each(({container, offset}) => {\n          endContainer = container;\n          endOffset = offset;\n        });\n      }\n      if (isInlineFormat(format) || format.block_expand) {\n        if (!isInlineFormat(format) || (!isText$b(startContainer) || startOffset === 0)) {\n          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n        }\n        if (!isInlineFormat(format) || (!isText$b(endContainer) || endOffset === endContainer.data.length)) {\n          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n        }\n      }\n      if (shouldExpandToSelector(format)) {\n        startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');\n        endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');\n      }\n      if (isBlockFormat(format) || isSelectorFormat(format)) {\n        startContainer = findBlockEndPoint(dom, formatList, startContainer, 'previousSibling');\n        endContainer = findBlockEndPoint(dom, formatList, endContainer, 'nextSibling');\n        if (isBlockFormat(format)) {\n          if (!dom.isBlock(startContainer)) {\n            startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n            if (isText$b(startContainer)) {\n              startOffset = 0;\n            }\n          }\n          if (!dom.isBlock(endContainer)) {\n            endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n            if (isText$b(endContainer)) {\n              endOffset = endContainer.data.length;\n            }\n          }\n        }\n      }\n      if (isElement$6(startContainer) && startContainer.parentNode) {\n        startOffset = dom.nodeIndex(startContainer);\n        startContainer = startContainer.parentNode;\n      }\n      if (isElement$6(endContainer) && endContainer.parentNode) {\n        endOffset = dom.nodeIndex(endContainer) + 1;\n        endContainer = endContainer.parentNode;\n      }\n      return {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      };\n    };\n\n    const walk$3 = (dom, rng, callback) => {\n      var _a;\n      const startOffset = rng.startOffset;\n      const startContainer = getNode$1(rng.startContainer, startOffset);\n      const endOffset = rng.endOffset;\n      const endContainer = getNode$1(rng.endContainer, endOffset - 1);\n      const exclude = nodes => {\n        const firstNode = nodes[0];\n        if (isText$b(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {\n          nodes.splice(0, 1);\n        }\n        const lastNode = nodes[nodes.length - 1];\n        if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$b(lastNode)) {\n          nodes.splice(nodes.length - 1, 1);\n        }\n        return nodes;\n      };\n      const collectSiblings = (node, name, endNode) => {\n        const siblings = [];\n        for (; node && node !== endNode; node = node[name]) {\n          siblings.push(node);\n        }\n        return siblings;\n      };\n      const findEndPoint = (node, root) => dom.getParent(node, node => node.parentNode === root, root);\n      const walkBoundary = (startNode, endNode, next) => {\n        const siblingName = next ? 'nextSibling' : 'previousSibling';\n        for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {\n          parent = node.parentNode;\n          const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);\n          if (siblings.length) {\n            if (!next) {\n              siblings.reverse();\n            }\n            callback(exclude(siblings));\n          }\n        }\n      };\n      if (startContainer === endContainer) {\n        return callback(exclude([startContainer]));\n      }\n      const ancestor = (_a = dom.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      if (dom.isChildOf(startContainer, endContainer)) {\n        return walkBoundary(startContainer, ancestor, true);\n      }\n      if (dom.isChildOf(endContainer, startContainer)) {\n        return walkBoundary(endContainer, ancestor);\n      }\n      const startPoint = findEndPoint(startContainer, ancestor) || startContainer;\n      const endPoint = findEndPoint(endContainer, ancestor) || endContainer;\n      walkBoundary(startContainer, startPoint, true);\n      const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);\n      if (siblings.length) {\n        callback(exclude(siblings));\n      }\n      walkBoundary(endContainer, endPoint);\n    };\n\n    const validBlocks = [\n      'pre[class*=language-][contenteditable=\"false\"]',\n      'figure.image',\n      'div[data-ephox-embed-iri]',\n      'div.tiny-pageembed',\n      'div.mce-toc',\n      'div[data-mce-toc]'\n    ];\n    const isZeroWidth = elem => isText$c(elem) && get$3(elem) === ZWSP$1;\n    const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => 'skipping', parent => {\n      if (nodeName === 'br' || isZeroWidth(elem)) {\n        return 'valid';\n      } else if (isAnnotation(elem)) {\n        return 'existing';\n      } else if (isCaretNode(elem.dom)) {\n        return 'caret';\n      } else if (exists(validBlocks, selector => is$1(elem, selector))) {\n        return 'valid-block';\n      } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {\n        return 'invalid-child';\n      } else {\n        return 'valid';\n      }\n    });\n\n    const applyWordGrab = (editor, rng) => {\n      const r = expandRng(editor.dom, rng, [{ inline: 'span' }]);\n      rng.setStart(r.startContainer, r.startOffset);\n      rng.setEnd(r.endContainer, r.endOffset);\n      editor.selection.setRng(rng);\n    };\n    const applyAnnotation = (elem, masterUId, data, annotationName, decorate, directAnnotation) => {\n      const {uid = masterUId, ...otherData} = data;\n      add$2(elem, annotation());\n      set$3(elem, `${ dataAnnotationId() }`, uid);\n      set$3(elem, `${ dataAnnotation() }`, annotationName);\n      const {attributes = {}, classes = []} = decorate(uid, otherData);\n      setAll$1(elem, attributes);\n      add(elem, classes);\n      if (directAnnotation) {\n        if (classes.length > 0) {\n          set$3(elem, `${ dataAnnotationClasses() }`, classes.join(','));\n        }\n        const attributeNames = keys(attributes);\n        if (attributeNames.length > 0) {\n          set$3(elem, `${ dataAnnotationAttributes() }`, attributeNames.join(','));\n        }\n      }\n    };\n    const removeDirectAnnotation = elem => {\n      remove$6(elem, annotation());\n      remove$9(elem, `${ dataAnnotationId() }`);\n      remove$9(elem, `${ dataAnnotation() }`);\n      remove$9(elem, `${ dataAnnotationActive() }`);\n      const customAttrNames = getOpt(elem, `${ dataAnnotationAttributes() }`).map(names => names.split(',')).getOr([]);\n      const customClasses = getOpt(elem, `${ dataAnnotationClasses() }`).map(names => names.split(',')).getOr([]);\n      each$e(customAttrNames, name => remove$9(elem, name));\n      remove$3(elem, customClasses);\n      remove$9(elem, `${ dataAnnotationClasses() }`);\n      remove$9(elem, `${ dataAnnotationAttributes() }`);\n    };\n    const makeAnnotation = (eDoc, uid, data, annotationName, decorate) => {\n      const master = SugarElement.fromTag('span', eDoc);\n      applyAnnotation(master, uid, data, annotationName, decorate, false);\n      return master;\n    };\n    const annotate = (editor, rng, uid, annotationName, decorate, data) => {\n      const newWrappers = [];\n      const master = makeAnnotation(editor.getDoc(), uid, data, annotationName, decorate);\n      const wrapper = value$2();\n      const finishWrapper = () => {\n        wrapper.clear();\n      };\n      const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {\n        const nu = shallow$1(master);\n        newWrappers.push(nu);\n        wrapper.set(nu);\n        return nu;\n      });\n      const processElements = elems => {\n        each$e(elems, processElement);\n      };\n      const processElement = elem => {\n        const ctx = context(editor, elem, 'span', name(elem));\n        switch (ctx) {\n        case 'invalid-child': {\n            finishWrapper();\n            const children = children$1(elem);\n            processElements(children);\n            finishWrapper();\n            break;\n          }\n        case 'valid-block': {\n            finishWrapper();\n            applyAnnotation(elem, uid, data, annotationName, decorate, true);\n            break;\n          }\n        case 'valid': {\n            const w = getOrOpenWrapper();\n            wrap$2(elem, w);\n            break;\n          }\n        }\n      };\n      const processNodes = nodes => {\n        const elems = map$3(nodes, SugarElement.fromDom);\n        processElements(elems);\n      };\n      walk$3(editor.dom, rng, nodes => {\n        finishWrapper();\n        processNodes(nodes);\n      });\n      return newWrappers;\n    };\n    const annotateWithBookmark = (editor, name, settings, data) => {\n      editor.undoManager.transact(() => {\n        const selection = editor.selection;\n        const initialRng = selection.getRng();\n        const hasFakeSelection = getCellsFromEditor(editor).length > 0;\n        const masterUid = generate$1('mce-annotation');\n        if (initialRng.collapsed && !hasFakeSelection) {\n          applyWordGrab(editor, initialRng);\n        }\n        if (selection.getRng().collapsed && !hasFakeSelection) {\n          const wrapper = makeAnnotation(editor.getDoc(), masterUid, data, name, settings.decorate);\n          set$1(wrapper, nbsp);\n          selection.getRng().insertNode(wrapper.dom);\n          selection.select(wrapper.dom);\n        } else {\n          preserve(selection, false, () => {\n            runOnRanges(editor, selectionRng => {\n              annotate(editor, selectionRng, masterUid, name, settings.decorate, data);\n            });\n          });\n        }\n      });\n    };\n\n    const Annotator = editor => {\n      const registry = create$b();\n      setup$x(editor, registry);\n      const changes = setup$y(editor, registry);\n      const isSpan = isTag('span');\n      const removeAnnotations = elements => {\n        each$e(elements, element => {\n          if (isSpan(element)) {\n            unwrap(element);\n          } else {\n            removeDirectAnnotation(element);\n          }\n        });\n      };\n      return {\n        register: (name, settings) => {\n          registry.register(name, settings);\n        },\n        annotate: (name, data) => {\n          registry.lookup(name).each(settings => {\n            annotateWithBookmark(editor, name, settings, data);\n          });\n        },\n        annotationChanged: (name, callback) => {\n          changes.addListener(name, callback);\n        },\n        remove: name => {\n          identify(editor, Optional.some(name)).each(({elements}) => {\n            const bookmark = editor.selection.getBookmark();\n            removeAnnotations(elements);\n            editor.selection.moveToBookmark(bookmark);\n          });\n        },\n        removeAll: name => {\n          const bookmark = editor.selection.getBookmark();\n          each$d(findAll(editor, name), (elements, _) => {\n            removeAnnotations(elements);\n          });\n          editor.selection.moveToBookmark(bookmark);\n        },\n        getAll: name => {\n          const directory = findAll(editor, name);\n          return map$2(directory, elems => map$3(elems, elem => elem.dom));\n        }\n      };\n    };\n\n    const BookmarkManager = selection => {\n      return {\n        getBookmark: curry(getBookmark$2, selection),\n        moveToBookmark: curry(moveToBookmark, selection)\n      };\n    };\n    BookmarkManager.isBookmarkNode = isBookmarkNode$1;\n\n    const isXYWithinRange = (clientX, clientY, range) => {\n      if (range.collapsed) {\n        return false;\n      } else {\n        return exists(range.getClientRects(), rect => containsXY(rect, clientX, clientY));\n      }\n    };\n\n    const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);\n    const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);\n    const fireRemove = editor => {\n      editor.dispatch('remove');\n    };\n    const fireDetach = editor => {\n      editor.dispatch('detach');\n    };\n    const fireSwitchMode = (editor, mode) => {\n      editor.dispatch('SwitchMode', { mode });\n    };\n    const fireObjectResizeStart = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResizeStart', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const fireObjectResized = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResized', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const firePreInit = editor => {\n      editor.dispatch('PreInit');\n    };\n    const firePostRender = editor => {\n      editor.dispatch('PostRender');\n    };\n    const fireInit = editor => {\n      editor.dispatch('Init');\n    };\n    const firePlaceholderToggle = (editor, state) => {\n      editor.dispatch('PlaceholderToggle', { state });\n    };\n    const fireError = (editor, errorType, error) => {\n      editor.dispatch(errorType, error);\n    };\n    const fireFormatApply = (editor, format, node, vars) => {\n      editor.dispatch('FormatApply', {\n        format,\n        node,\n        vars\n      });\n    };\n    const fireFormatRemove = (editor, format, node, vars) => {\n      editor.dispatch('FormatRemove', {\n        format,\n        node,\n        vars\n      });\n    };\n    const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);\n    const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);\n    const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);\n    const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);\n    const fireAutocompleterStart = (editor, args) => {\n      editor.dispatch('AutocompleterStart', args);\n    };\n    const fireAutocompleterUpdate = (editor, args) => {\n      editor.dispatch('AutocompleterUpdate', args);\n    };\n    const fireAutocompleterUpdateActiveRange = (editor, args) => {\n      editor.dispatch('AutocompleterUpdateActiveRange', args);\n    };\n    const fireAutocompleterEnd = editor => {\n      editor.dispatch('AutocompleterEnd');\n    };\n    const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', {\n      content: html,\n      internal\n    });\n    const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', {\n      node,\n      internal\n    });\n    const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', { state });\n    const fireEditableRootStateChange = (editor, state) => editor.dispatch('EditableRootStateChange', { state });\n\n    const VK = {\n      BACKSPACE: 8,\n      DELETE: 46,\n      DOWN: 40,\n      ENTER: 13,\n      ESC: 27,\n      LEFT: 37,\n      RIGHT: 39,\n      SPACEBAR: 32,\n      TAB: 9,\n      UP: 38,\n      PAGE_UP: 33,\n      PAGE_DOWN: 34,\n      END: 35,\n      HOME: 36,\n      modifierPressed: e => {\n        return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);\n      },\n      metaKeyPressed: e => {\n        return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n      }\n    };\n\n    const elementSelectionAttr = 'data-mce-selected';\n    const controlElmSelector = 'table,img,figure.image,hr,video,span.mce-preview-object,details';\n    const abs = Math.abs;\n    const round$1 = Math.round;\n    const resizeHandles = {\n      nw: [\n        0,\n        0,\n        -1,\n        -1\n      ],\n      ne: [\n        1,\n        0,\n        1,\n        -1\n      ],\n      se: [\n        1,\n        1,\n        1,\n        1\n      ],\n      sw: [\n        0,\n        1,\n        -1,\n        1\n      ]\n    };\n    const isTouchEvent = evt => evt.type === 'longpress' || evt.type.indexOf('touch') === 0;\n    const ControlSelection = (selection, editor) => {\n      const dom = editor.dom;\n      const editableDoc = editor.getDoc();\n      const rootDocument = document;\n      const rootElement = editor.getBody();\n      let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;\n      let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;\n      let width;\n      let height;\n      let startScrollWidth;\n      let startScrollHeight;\n      const isImage = elm => isNonNullable(elm) && (isImg(elm) || dom.is(elm, 'figure.image'));\n      const isMedia = elm => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');\n      const isEventOnImageOutsideRange = (evt, range) => {\n        if (isTouchEvent(evt)) {\n          const touch = evt.touches[0];\n          return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);\n        } else {\n          return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);\n        }\n      };\n      const contextMenuSelectImage = evt => {\n        const target = evt.target;\n        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {\n          editor.selection.select(target);\n        }\n      };\n      const getResizeTargets = elm => {\n        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n          return [\n            elm,\n            elm.firstElementChild\n          ];\n        } else if (dom.is(elm, 'figure.image')) {\n          return [elm.querySelector('img')];\n        } else {\n          return [elm];\n        }\n      };\n      const isResizable = elm => {\n        const selector = getObjectResizing(editor);\n        if (!selector) {\n          return false;\n        }\n        if (elm.getAttribute('data-mce-resize') === 'false') {\n          return false;\n        }\n        if (elm === editor.getBody()) {\n          return false;\n        }\n        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n          return is$1(SugarElement.fromDom(elm.firstElementChild), selector);\n        } else {\n          return is$1(SugarElement.fromDom(elm), selector);\n        }\n      };\n      const createGhostElement = (dom, elm) => {\n        if (isMedia(elm)) {\n          return dom.create('img', { src: Env.transparentSrc });\n        } else if (isTable$2(elm)) {\n          const isNorth = startsWith(selectedHandle.name, 'n');\n          const rowSelect = isNorth ? head : last$2;\n          const tableElm = elm.cloneNode(true);\n          rowSelect(dom.select('tr', tableElm)).each(tr => {\n            const cells = dom.select('td,th', tr);\n            dom.setStyle(tr, 'height', null);\n            each$e(cells, cell => dom.setStyle(cell, 'height', null));\n          });\n          return tableElm;\n        } else {\n          return elm.cloneNode(true);\n        }\n      };\n      const setSizeProp = (element, name, value) => {\n        if (isNonNullable(value)) {\n          const targets = getResizeTargets(element);\n          each$e(targets, target => {\n            if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {\n              dom.setStyle(target, name, value);\n            } else {\n              dom.setAttrib(target, name, '' + value);\n            }\n          });\n        }\n      };\n      const setGhostElmSize = (ghostElm, width, height) => {\n        setSizeProp(ghostElm, 'width', width);\n        setSizeProp(ghostElm, 'height', height);\n      };\n      const resizeGhostElement = e => {\n        let deltaX, deltaY, proportional;\n        let resizeHelperX, resizeHelperY;\n        deltaX = e.screenX - startX;\n        deltaY = e.screenY - startY;\n        width = deltaX * selectedHandle[2] + startW;\n        height = deltaY * selectedHandle[3] + startH;\n        width = width < 5 ? 5 : width;\n        height = height < 5 ? 5 : height;\n        if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {\n          proportional = !VK.modifierPressed(e);\n        } else {\n          proportional = VK.modifierPressed(e);\n        }\n        if (proportional) {\n          if (abs(deltaX) > abs(deltaY)) {\n            height = round$1(width * ratio);\n            width = round$1(height / ratio);\n          } else {\n            width = round$1(height / ratio);\n            height = round$1(width * ratio);\n          }\n        }\n        setGhostElmSize(selectedElmGhost, width, height);\n        resizeHelperX = selectedHandle.startPos.x + deltaX;\n        resizeHelperY = selectedHandle.startPos.y + deltaY;\n        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;\n        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;\n        dom.setStyles(resizeHelper, {\n          left: resizeHelperX,\n          top: resizeHelperY,\n          display: 'block'\n        });\n        resizeHelper.innerHTML = width + ' &times; ' + height;\n        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {\n          dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));\n        }\n        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {\n          dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));\n        }\n        deltaX = rootElement.scrollWidth - startScrollWidth;\n        deltaY = rootElement.scrollHeight - startScrollHeight;\n        if (deltaX + deltaY !== 0) {\n          dom.setStyles(resizeHelper, {\n            left: resizeHelperX - deltaX,\n            top: resizeHelperY - deltaY\n          });\n        }\n        if (!resizeStarted) {\n          fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);\n          resizeStarted = true;\n        }\n      };\n      const endGhostResize = () => {\n        const wasResizeStarted = resizeStarted;\n        resizeStarted = false;\n        if (wasResizeStarted) {\n          setSizeProp(selectedElm, 'width', width);\n          setSizeProp(selectedElm, 'height', height);\n        }\n        dom.unbind(editableDoc, 'mousemove', resizeGhostElement);\n        dom.unbind(editableDoc, 'mouseup', endGhostResize);\n        if (rootDocument !== editableDoc) {\n          dom.unbind(rootDocument, 'mousemove', resizeGhostElement);\n          dom.unbind(rootDocument, 'mouseup', endGhostResize);\n        }\n        dom.remove(selectedElmGhost);\n        dom.remove(resizeHelper);\n        dom.remove(resizeBackdrop);\n        showResizeRect(selectedElm);\n        if (wasResizeStarted) {\n          fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);\n          dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));\n        }\n        editor.nodeChanged();\n      };\n      const showResizeRect = targetElm => {\n        unbindResizeHandleEvents();\n        const position = dom.getPos(targetElm, rootElement);\n        const selectedElmX = position.x;\n        const selectedElmY = position.y;\n        const rect = targetElm.getBoundingClientRect();\n        const targetWidth = rect.width || rect.right - rect.left;\n        const targetHeight = rect.height || rect.bottom - rect.top;\n        if (selectedElm !== targetElm) {\n          hideResizeRect();\n          selectedElm = targetElm;\n          width = height = 0;\n        }\n        const e = editor.dispatch('ObjectSelected', { target: targetElm });\n        if (isResizable(targetElm) && !e.isDefaultPrevented()) {\n          each$d(resizeHandles, (handle, name) => {\n            const startDrag = e => {\n              const target = getResizeTargets(selectedElm)[0];\n              startX = e.screenX;\n              startY = e.screenY;\n              startW = target.clientWidth;\n              startH = target.clientHeight;\n              ratio = startH / startW;\n              selectedHandle = handle;\n              selectedHandle.name = name;\n              selectedHandle.startPos = {\n                x: targetWidth * handle[0] + selectedElmX,\n                y: targetHeight * handle[1] + selectedElmY\n              };\n              startScrollWidth = rootElement.scrollWidth;\n              startScrollHeight = rootElement.scrollHeight;\n              resizeBackdrop = dom.add(rootElement, 'div', {\n                'class': 'mce-resize-backdrop',\n                'data-mce-bogus': 'all'\n              });\n              dom.setStyles(resizeBackdrop, {\n                position: 'fixed',\n                left: '0',\n                top: '0',\n                width: '100%',\n                height: '100%'\n              });\n              selectedElmGhost = createGhostElement(dom, selectedElm);\n              dom.addClass(selectedElmGhost, 'mce-clonedresizable');\n              dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');\n              selectedElmGhost.contentEditable = 'false';\n              dom.setStyles(selectedElmGhost, {\n                left: selectedElmX,\n                top: selectedElmY,\n                margin: 0\n              });\n              setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);\n              selectedElmGhost.removeAttribute(elementSelectionAttr);\n              rootElement.appendChild(selectedElmGhost);\n              dom.bind(editableDoc, 'mousemove', resizeGhostElement);\n              dom.bind(editableDoc, 'mouseup', endGhostResize);\n              if (rootDocument !== editableDoc) {\n                dom.bind(rootDocument, 'mousemove', resizeGhostElement);\n                dom.bind(rootDocument, 'mouseup', endGhostResize);\n              }\n              resizeHelper = dom.add(rootElement, 'div', {\n                'class': 'mce-resize-helper',\n                'data-mce-bogus': 'all'\n              }, startW + ' &times; ' + startH);\n            };\n            let handleElm = dom.get('mceResizeHandle' + name);\n            if (handleElm) {\n              dom.remove(handleElm);\n            }\n            handleElm = dom.add(rootElement, 'div', {\n              'id': 'mceResizeHandle' + name,\n              'data-mce-bogus': 'all',\n              'class': 'mce-resizehandle',\n              'unselectable': true,\n              'style': 'cursor:' + name + '-resize; margin:0; padding:0'\n            });\n            dom.bind(handleElm, 'mousedown', e => {\n              e.stopImmediatePropagation();\n              e.preventDefault();\n              startDrag(e);\n            });\n            handle.elm = handleElm;\n            dom.setStyles(handleElm, {\n              left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,\n              top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2\n            });\n          });\n        } else {\n          hideResizeRect(false);\n        }\n      };\n      const throttledShowResizeRect = first$1(showResizeRect, 0);\n      const hideResizeRect = (removeSelected = true) => {\n        throttledShowResizeRect.cancel();\n        unbindResizeHandleEvents();\n        if (selectedElm && removeSelected) {\n          selectedElm.removeAttribute(elementSelectionAttr);\n        }\n        each$d(resizeHandles, (value, name) => {\n          const handleElm = dom.get('mceResizeHandle' + name);\n          if (handleElm) {\n            dom.unbind(handleElm);\n            dom.remove(handleElm);\n          }\n        });\n      };\n      const isChildOrEqual = (node, parent) => dom.isChildOf(node, parent);\n      const updateResizeRect = e => {\n        if (resizeStarted || editor.removed || editor.composing) {\n          return;\n        }\n        const targetElm = e.type === 'mousedown' ? e.target : selection.getNode();\n        const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector).map(e => e.dom).filter(e => dom.isEditable(e.parentElement) || e.nodeName === 'IMG' && dom.isEditable(e)).getOrUndefined();\n        const selectedValue = isNonNullable(controlElm) ? dom.getAttrib(controlElm, elementSelectionAttr, '1') : '1';\n        each$e(dom.select(`img[${ elementSelectionAttr }],hr[${ elementSelectionAttr }]`), img => {\n          img.removeAttribute(elementSelectionAttr);\n        });\n        if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement) && editor.hasFocus()) {\n          disableGeckoResize();\n          const startElm = selection.getStart(true);\n          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {\n            dom.setAttrib(controlElm, elementSelectionAttr, selectedValue);\n            throttledShowResizeRect.throttle(controlElm);\n            return;\n          }\n        }\n        hideResizeRect();\n      };\n      const unbindResizeHandleEvents = () => {\n        each$d(resizeHandles, handle => {\n          if (handle.elm) {\n            dom.unbind(handle.elm);\n            delete handle.elm;\n          }\n        });\n      };\n      const disableGeckoResize = () => {\n        try {\n          editor.getDoc().execCommand('enableObjectResizing', false, 'false');\n        } catch (ex) {\n        }\n      };\n      editor.on('init', () => {\n        disableGeckoResize();\n        editor.on('NodeChange ResizeEditor ResizeWindow ResizeContent drop', updateResizeRect);\n        editor.on('keyup compositionend', e => {\n          if (selectedElm && selectedElm.nodeName === 'TABLE') {\n            updateResizeRect(e);\n          }\n        });\n        editor.on('hide blur', hideResizeRect);\n        editor.on('contextmenu longpress', contextMenuSelectImage, true);\n      });\n      editor.on('remove', unbindResizeHandleEvents);\n      const destroy = () => {\n        throttledShowResizeRect.cancel();\n        selectedElm = selectedElmGhost = resizeBackdrop = null;\n      };\n      return {\n        isResizable,\n        showResizeRect,\n        hideResizeRect,\n        updateResizeRect,\n        destroy\n      };\n    };\n\n    const setStart = (rng, situ) => {\n      situ.fold(e => {\n        rng.setStartBefore(e.dom);\n      }, (e, o) => {\n        rng.setStart(e.dom, o);\n      }, e => {\n        rng.setStartAfter(e.dom);\n      });\n    };\n    const setFinish = (rng, situ) => {\n      situ.fold(e => {\n        rng.setEndBefore(e.dom);\n      }, (e, o) => {\n        rng.setEnd(e.dom, o);\n      }, e => {\n        rng.setEndAfter(e.dom);\n      });\n    };\n    const relativeToNative = (win, startSitu, finishSitu) => {\n      const range = win.document.createRange();\n      setStart(range, startSitu);\n      setFinish(range, finishSitu);\n      return range;\n    };\n    const exactToNative = (win, start, soffset, finish, foffset) => {\n      const rng = win.document.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n\n    const adt$3 = Adt.generate([\n      {\n        ltr: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      },\n      {\n        rtl: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n    const getRanges = (win, selection) => selection.match({\n      domRange: rng => {\n        return {\n          ltr: constant(rng),\n          rtl: Optional.none\n        };\n      },\n      relative: (startSitu, finishSitu) => {\n        return {\n          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\n          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\n        };\n      },\n      exact: (start, soffset, finish, foffset) => {\n        return {\n          ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\n          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\n        };\n      }\n    });\n    const doDiagnose = (win, ranges) => {\n      const rng = ranges.ltr();\n      if (rng.collapsed) {\n        const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\n        return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));\n      } else {\n        return fromRange(win, adt$3.ltr, rng);\n      }\n    };\n    const diagnose = (win, selection) => {\n      const ranges = getRanges(win, selection);\n      return doDiagnose(win, ranges);\n    };\n    adt$3.ltr;\n    adt$3.rtl;\n\n    const create$9 = (start, soffset, finish, foffset) => ({\n      start,\n      soffset,\n      finish,\n      foffset\n    });\n    const SimRange = { create: create$9 };\n\n    const caretPositionFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(pos => {\n        if (pos.offsetNode === null) {\n          return Optional.none();\n        }\n        const r = doc.dom.createRange();\n        r.setStart(pos.offsetNode, pos.offset);\n        r.collapse();\n        return Optional.some(r);\n      });\n    };\n    const caretRangeFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));\n    };\n    const availableSearch = (() => {\n      if (document.caretPositionFromPoint) {\n        return caretPositionFromPoint;\n      } else if (document.caretRangeFromPoint) {\n        return caretRangeFromPoint;\n      } else {\n        return Optional.none;\n      }\n    })();\n    const fromPoint$1 = (win, x, y) => {\n      const doc = SugarElement.fromDom(win.document);\n      return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n    };\n\n    const adt$2 = Adt.generate([\n      { before: ['element'] },\n      {\n        on: [\n          'element',\n          'offset'\n        ]\n      },\n      { after: ['element'] }\n    ]);\n    const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\n    const getStart$2 = situ => situ.fold(identity, identity, identity);\n    const before$1 = adt$2.before;\n    const on = adt$2.on;\n    const after$1 = adt$2.after;\n    const Situ = {\n      before: before$1,\n      on,\n      after: after$1,\n      cata,\n      getStart: getStart$2\n    };\n\n    const adt$1 = Adt.generate([\n      { domRange: ['rng'] },\n      {\n        relative: [\n          'startSitu',\n          'finishSitu'\n        ]\n      },\n      {\n        exact: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const exactFromRange = simRange => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n    const getStart$1 = selection => selection.match({\n      domRange: rng => SugarElement.fromDom(rng.startContainer),\n      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\n      exact: (start, _soffset, _finish, _foffset) => start\n    });\n    const domRange = adt$1.domRange;\n    const relative = adt$1.relative;\n    const exact = adt$1.exact;\n    const getWin = selection => {\n      const start = getStart$1(selection);\n      return defaultView(start);\n    };\n    const range = SimRange.create;\n    const SimSelection = {\n      domRange,\n      relative,\n      exact,\n      exactFromRange,\n      getWin,\n      range\n    };\n\n    const beforeSpecial = (element, offset) => {\n      const name$1 = name(element);\n      if ('input' === name$1) {\n        return Situ.after(element);\n      } else if (!contains$2([\n          'br',\n          'img'\n        ], name$1)) {\n        return Situ.on(element, offset);\n      } else {\n        return offset === 0 ? Situ.before(element) : Situ.after(element);\n      }\n    };\n    const preprocessRelative = (startSitu, finishSitu) => {\n      const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      return SimSelection.relative(start, finish);\n    };\n    const preprocessExact = (start, soffset, finish, foffset) => {\n      const startSitu = beforeSpecial(start, soffset);\n      const finishSitu = beforeSpecial(finish, foffset);\n      return SimSelection.relative(startSitu, finishSitu);\n    };\n    const preprocess = selection => selection.match({\n      domRange: rng => {\n        const start = SugarElement.fromDom(rng.startContainer);\n        const finish = SugarElement.fromDom(rng.endContainer);\n        return preprocessExact(start, rng.startOffset, finish, rng.endOffset);\n      },\n      relative: preprocessRelative,\n      exact: preprocessExact\n    });\n\n    const fromElements = (elements, scope) => {\n      const doc = scope || document;\n      const fragment = doc.createDocumentFragment();\n      each$e(elements, element => {\n        fragment.appendChild(element.dom);\n      });\n      return SugarElement.fromDom(fragment);\n    };\n\n    const toNative = selection => {\n      const win = SimSelection.getWin(selection).dom;\n      const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);\n      const filtered = preprocess(selection);\n      return diagnose(win, filtered).match({\n        ltr: getDomRange,\n        rtl: getDomRange\n      });\n    };\n    const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);\n\n    const fromPoint = (clientX, clientY, doc) => {\n      const win = defaultView(SugarElement.fromDom(doc));\n      return getAtPoint(win.dom, clientX, clientY).map(simRange => {\n        const rng = doc.createRange();\n        rng.setStart(simRange.start.dom, simRange.soffset);\n        rng.setEnd(simRange.finish.dom, simRange.foffset);\n        return rng;\n      }).getOrUndefined();\n    };\n\n    const isEq$4 = (rng1, rng2) => {\n      return isNonNullable(rng1) && isNonNullable(rng2) && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);\n    };\n\n    const findParent = (node, rootNode, predicate) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== rootNode) {\n        if (predicate(currentNode)) {\n          return currentNode;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return null;\n    };\n    const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;\n    const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, node => node.nodeName === name);\n    const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);\n    const hasBrBeforeAfter = (dom, node, left) => {\n      const parentNode = node.parentNode;\n      if (parentNode) {\n        const walker = new DomTreeWalker(node, dom.getParent(parentNode, dom.isBlock) || dom.getRoot());\n        let currentNode;\n        while (currentNode = walker[left ? 'prev' : 'next']()) {\n          if (isBr$6(currentNode)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const isPrevNode = (node, name) => {\n      var _a;\n      return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name;\n    };\n    const hasContentEditableFalseParent = (root, node) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== root) {\n        if (isContentEditableFalse$b(currentNode)) {\n          return true;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return false;\n    };\n    const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {\n      const body = dom.getRoot();\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n      const parentNode = startNode.parentNode;\n      let lastInlineElement;\n      let node;\n      if (!parentNode) {\n        return Optional.none();\n      }\n      const parentBlockContainer = dom.getParent(parentNode, dom.isBlock) || body;\n      if (left && isBr$6(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {\n        return Optional.some(CaretPosition(parentNode, dom.nodeIndex(startNode)));\n      }\n      const walker = new DomTreeWalker(startNode, parentBlockContainer);\n      while (node = walker[left ? 'prev' : 'next']()) {\n        if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {\n          return Optional.none();\n        }\n        if (isText$b(node) && node.data.length > 0) {\n          if (!hasParentWithName(node, body, 'A')) {\n            return Optional.some(CaretPosition(node, left ? node.data.length : 0));\n          }\n          return Optional.none();\n        }\n        if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n          return Optional.none();\n        }\n        lastInlineElement = node;\n      }\n      if (isComment(lastInlineElement)) {\n        return Optional.none();\n      }\n      if (collapsed && lastInlineElement) {\n        return Optional.some(CaretPosition(lastInlineElement, 0));\n      }\n      return Optional.none();\n    };\n    const normalizeEndPoint = (dom, collapsed, start, rng) => {\n      const body = dom.getRoot();\n      let node;\n      let normalized = false;\n      let container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      const isAfterNode = isElement$6(container) && offset === container.childNodes.length;\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n      let directionLeft = start;\n      if (isCaretContainer$2(container)) {\n        return Optional.none();\n      }\n      if (isElement$6(container) && offset > container.childNodes.length - 1) {\n        directionLeft = false;\n      }\n      if (isDocument$1(container)) {\n        container = body;\n        offset = 0;\n      }\n      if (container === body) {\n        if (directionLeft) {\n          node = container.childNodes[offset > 0 ? offset - 1 : 0];\n          if (node) {\n            if (isCaretContainer$2(node)) {\n              return Optional.none();\n            }\n            if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {\n              return Optional.none();\n            }\n          }\n        }\n        if (container.hasChildNodes()) {\n          offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);\n          container = container.childNodes[offset];\n          offset = isText$b(container) && isAfterNode ? container.data.length : 0;\n          if (!collapsed && container === body.lastChild && isTable$2(container)) {\n            return Optional.none();\n          }\n          if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {\n            return Optional.none();\n          }\n          if (isDetails(container)) {\n            return Optional.none();\n          }\n          if (container.hasChildNodes() && !isTable$2(container)) {\n            node = container;\n            const walker = new DomTreeWalker(container, body);\n            do {\n              if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {\n                normalized = false;\n                break;\n              }\n              if (isText$b(node) && node.data.length > 0) {\n                offset = directionLeft ? 0 : node.data.length;\n                container = node;\n                normalized = true;\n                break;\n              }\n              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {\n                offset = dom.nodeIndex(node);\n                container = node.parentNode;\n                if (!directionLeft) {\n                  offset++;\n                }\n                normalized = true;\n                break;\n              }\n            } while (node = directionLeft ? walker.next() : walker.prev());\n          }\n        }\n      }\n      if (collapsed) {\n        if (isText$b(container) && offset === 0) {\n          findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(pos => {\n            container = pos.container();\n            offset = pos.offset();\n            normalized = true;\n          });\n        }\n        if (isElement$6(container)) {\n          node = container.childNodes[offset];\n          if (!node) {\n            node = container.childNodes[offset - 1];\n          }\n          if (node && isBr$6(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {\n            findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(pos => {\n              container = pos.container();\n              offset = pos.offset();\n              normalized = true;\n            });\n          }\n        }\n      }\n      if (directionLeft && !collapsed && isText$b(container) && offset === container.data.length) {\n        findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(pos => {\n          container = pos.container();\n          offset = pos.offset();\n          normalized = true;\n        });\n      }\n      return normalized && container ? Optional.some(CaretPosition(container, offset)) : Optional.none();\n    };\n    const normalize$2 = (dom, rng) => {\n      const collapsed = rng.collapsed, normRng = rng.cloneRange();\n      const startPos = CaretPosition.fromRangeStart(rng);\n      normalizeEndPoint(dom, collapsed, true, normRng).each(pos => {\n        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {\n          normRng.setStart(pos.container(), pos.offset());\n        }\n      });\n      if (!collapsed) {\n        normalizeEndPoint(dom, collapsed, false, normRng).each(pos => {\n          normRng.setEnd(pos.container(), pos.offset());\n        });\n      }\n      if (collapsed) {\n        normRng.collapse(true);\n      }\n      return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);\n    };\n\n    const splitText = (node, offset) => {\n      return node.splitText(offset);\n    };\n    const split = rng => {\n      let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;\n      if (startContainer === endContainer && isText$b(startContainer)) {\n        if (startOffset > 0 && startOffset < startContainer.data.length) {\n          endContainer = splitText(startContainer, startOffset);\n          startContainer = endContainer.previousSibling;\n          if (endOffset > startOffset) {\n            endOffset = endOffset - startOffset;\n            const newContainer = splitText(endContainer, endOffset).previousSibling;\n            startContainer = endContainer = newContainer;\n            endOffset = newContainer.data.length;\n            startOffset = 0;\n          } else {\n            endOffset = 0;\n          }\n        }\n      } else {\n        if (isText$b(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {\n          startContainer = splitText(startContainer, startOffset);\n          startOffset = 0;\n        }\n        if (isText$b(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {\n          const newContainer = splitText(endContainer, endOffset).previousSibling;\n          endContainer = newContainer;\n          endOffset = newContainer.data.length;\n        }\n      }\n      return {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      };\n    };\n\n    const RangeUtils = dom => {\n      const walk = (rng, callback) => {\n        return walk$3(dom, rng, callback);\n      };\n      const split$1 = split;\n      const normalize = rng => {\n        return normalize$2(dom, rng).fold(never, normalizedRng => {\n          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);\n          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);\n          return true;\n        });\n      };\n      const expand = (rng, options = { type: 'word' }) => {\n        if (options.type === 'word') {\n          const rangeLike = expandRng(dom, rng, [{ inline: 'span' }]);\n          const newRange = dom.createRng();\n          newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);\n          newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);\n          return newRange;\n        }\n        return rng;\n      };\n      return {\n        walk,\n        split: split$1,\n        expand,\n        normalize\n      };\n    };\n    RangeUtils.compareRanges = isEq$4;\n    RangeUtils.getCaretRangeFromPoint = fromPoint;\n    RangeUtils.getSelectedNode = getSelectedNode;\n    RangeUtils.getNode = getNode$1;\n\n    const Dimension = (name, getOffset) => {\n      const set = (element, h) => {\n        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n        }\n        const dom = element.dom;\n        if (isSupported(dom)) {\n          dom.style[name] = h + 'px';\n        }\n      };\n      const get = element => {\n        const r = getOffset(element);\n        if (r <= 0 || r === null) {\n          const css = get$7(element, name);\n          return parseFloat(css) || 0;\n        }\n        return r;\n      };\n      const getOuter = get;\n      const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n        const val = get$7(element, property);\n        const value = val === undefined ? 0 : parseInt(val, 10);\n        return isNaN(value) ? acc : acc + value;\n      }, 0);\n      const max = (element, value, properties) => {\n        const cumulativeInclusions = aggregate(element, properties);\n        const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n        return absoluteMax;\n      };\n      return {\n        set,\n        get,\n        getOuter,\n        aggregate,\n        max\n      };\n    };\n\n    const api = Dimension('height', element => {\n      const dom = element.dom;\n      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n    });\n    const get$2 = element => api.get(element);\n\n    const getDocument = () => SugarElement.fromDom(document);\n\n    const walkUp = (navigation, doc) => {\n      const frame = navigation.view(doc);\n      return frame.fold(constant([]), f => {\n        const parent = navigation.owner(f);\n        const rest = walkUp(navigation, parent);\n        return [f].concat(rest);\n      });\n    };\n    const pathTo = (element, navigation) => {\n      const d = navigation.owner(element);\n      return walkUp(navigation, d);\n    };\n\n    const view = doc => {\n      var _a;\n      const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\n      return element.map(SugarElement.fromDom);\n    };\n    const owner = element => documentOrOwner(element);\n\n    var Navigation = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        view: view,\n        owner: owner\n    });\n\n    const find = element => {\n      const doc = getDocument();\n      const scroll = get$5(doc);\n      const frames = pathTo(element, Navigation);\n      const offset = viewport(element);\n      const r = foldr(frames, (b, a) => {\n        const loc = viewport(a);\n        return {\n          left: b.left + loc.left,\n          top: b.top + loc.top\n        };\n      }, {\n        left: 0,\n        top: 0\n      });\n      return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\n    };\n\n    const excludeFromDescend = element => name(element) === 'textarea';\n    const fireScrollIntoViewEvent = (editor, data) => {\n      const scrollEvent = editor.dispatch('ScrollIntoView', data);\n      return scrollEvent.isDefaultPrevented();\n    };\n    const fireAfterScrollIntoViewEvent = (editor, data) => {\n      editor.dispatch('AfterScrollIntoView', data);\n    };\n    const descend = (element, offset) => {\n      const children = children$1(element);\n      if (children.length === 0 || excludeFromDescend(element)) {\n        return {\n          element,\n          offset\n        };\n      } else if (offset < children.length && !excludeFromDescend(children[offset])) {\n        return {\n          element: children[offset],\n          offset: 0\n        };\n      } else {\n        const last = children[children.length - 1];\n        if (excludeFromDescend(last)) {\n          return {\n            element,\n            offset\n          };\n        } else {\n          if (name(last) === 'img') {\n            return {\n              element: last,\n              offset: 1\n            };\n          } else if (isText$c(last)) {\n            return {\n              element: last,\n              offset: get$3(last).length\n            };\n          } else {\n            return {\n              element: last,\n              offset: children$1(last).length\n            };\n          }\n        }\n      }\n    };\n    const markerInfo = (element, cleanupFun) => {\n      const pos = absolute(element);\n      const height = get$2(element);\n      return {\n        element,\n        bottom: pos.top + height,\n        height,\n        pos,\n        cleanup: cleanupFun\n      };\n    };\n    const createMarker$1 = (element, offset) => {\n      const startPoint = descend(element, offset);\n      const span = SugarElement.fromHtml('<span data-mce-bogus=\"all\" style=\"display: inline-block;\">' + ZWSP$1 + '</span>');\n      before$3(startPoint.element, span);\n      return markerInfo(span, () => remove$4(span));\n    };\n    const elementMarker = element => markerInfo(SugarElement.fromDom(element), noop);\n    const withMarker = (editor, f, rng, alignToTop) => {\n      preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);\n    };\n    const withScrollEvents = (editor, doc, f, marker, alignToTop) => {\n      const data = {\n        elm: marker.element.dom,\n        alignToTop\n      };\n      if (fireScrollIntoViewEvent(editor, data)) {\n        return;\n      }\n      const scrollTop = get$5(doc).top;\n      f(editor, doc, scrollTop, marker, alignToTop);\n      fireAfterScrollIntoViewEvent(editor, data);\n    };\n    const applyWithMarker = (editor, f, rng, alignToTop) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const doc = SugarElement.fromDom(editor.getDoc());\n      reflow(body);\n      const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);\n      withScrollEvents(editor, doc, f, marker, alignToTop);\n      marker.cleanup();\n    };\n    const withElement = (editor, element, f, alignToTop) => {\n      const doc = SugarElement.fromDom(editor.getDoc());\n      withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);\n    };\n    const preserveWith = (editor, f, rng) => {\n      const startElement = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endElement = rng.endContainer;\n      const endOffset = rng.endOffset;\n      f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));\n      const newRng = editor.dom.createRng();\n      newRng.setStart(startElement, startOffset);\n      newRng.setEnd(endElement, endOffset);\n      editor.selection.setRng(rng);\n    };\n    const scrollToMarker = (editor, marker, viewHeight, alignToTop, doc) => {\n      const pos = marker.pos;\n      if (alignToTop) {\n        to(pos.left, pos.top, doc);\n      } else {\n        const y = pos.top - viewHeight + marker.height;\n        to(-editor.getBody().getBoundingClientRect().left, y, doc);\n      }\n    };\n    const intoWindowIfNeeded = (editor, doc, scrollTop, viewHeight, marker, alignToTop) => {\n      const viewportBottom = viewHeight + scrollTop;\n      const markerTop = marker.pos.top;\n      const markerBottom = marker.bottom;\n      const largerThanViewport = markerBottom - markerTop >= viewHeight;\n      if (markerTop < scrollTop) {\n        scrollToMarker(editor, marker, viewHeight, alignToTop !== false, doc);\n      } else if (markerTop > viewportBottom) {\n        const align = largerThanViewport ? alignToTop !== false : alignToTop === true;\n        scrollToMarker(editor, marker, viewHeight, align, doc);\n      } else if (markerBottom > viewportBottom && !largerThanViewport) {\n        scrollToMarker(editor, marker, viewHeight, alignToTop === true, doc);\n      }\n    };\n    const intoWindow = (editor, doc, scrollTop, marker, alignToTop) => {\n      const viewHeight = defaultView(doc).dom.innerHeight;\n      intoWindowIfNeeded(editor, doc, scrollTop, viewHeight, marker, alignToTop);\n    };\n    const intoFrame = (editor, doc, scrollTop, marker, alignToTop) => {\n      const frameViewHeight = defaultView(doc).dom.innerHeight;\n      intoWindowIfNeeded(editor, doc, scrollTop, frameViewHeight, marker, alignToTop);\n      const op = find(marker.element);\n      const viewportBounds = getBounds(window);\n      if (op.top < viewportBounds.y) {\n        intoView(marker.element, alignToTop !== false);\n      } else if (op.top > viewportBounds.bottom) {\n        intoView(marker.element, alignToTop === true);\n      }\n    };\n    const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);\n    const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);\n    const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);\n    const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);\n    const scrollElementIntoView = (editor, element, alignToTop) => {\n      const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;\n      scroller(editor, element, alignToTop);\n    };\n    const scrollRangeIntoView = (editor, rng, alignToTop) => {\n      const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;\n      scroller(editor, rng, alignToTop);\n    };\n\n    const focus$1 = (element, preventScroll = false) => element.dom.focus({ preventScroll });\n    const hasFocus$1 = element => {\n      const root = getRootNode(element).dom;\n      return element.dom === root.activeElement;\n    };\n    const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\n    const search = element => active$1(getRootNode(element)).filter(e => element.dom.contains(e.dom));\n\n    const clamp$1 = (offset, element) => {\n      const max = isText$c(element) ? get$3(element).length : children$1(element).length + 1;\n      if (offset > max) {\n        return max;\n      } else if (offset < 0) {\n        return 0;\n      }\n      return offset;\n    };\n    const normalizeRng = rng => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));\n    const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));\n    const isRngInRoot = root => rng => isOrContains(root, rng.start) && isOrContains(root, rng.finish);\n    const shouldStore = editor => editor.inline || Env.browser.isFirefox();\n    const nativeRangeToSelectionRange = r => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);\n    const readRange = win => {\n      const selection = win.getSelection();\n      const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));\n      return rng.map(nativeRangeToSelectionRange);\n    };\n    const getBookmark$1 = root => {\n      const win = defaultView(root);\n      return readRange(win.dom).filter(isRngInRoot(root));\n    };\n    const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);\n    const bookmarkToNativeRng = bookmark => {\n      const rng = document.createRange();\n      try {\n        rng.setStart(bookmark.start.dom, bookmark.soffset);\n        rng.setEnd(bookmark.finish.dom, bookmark.foffset);\n        return Optional.some(rng);\n      } catch (_) {\n        return Optional.none();\n      }\n    };\n    const store = editor => {\n      const newBookmark = shouldStore(editor) ? getBookmark$1(SugarElement.fromDom(editor.getBody())) : Optional.none();\n      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;\n    };\n    const getRng = editor => {\n      const bookmark = editor.bookmark ? editor.bookmark : Optional.none();\n      return bookmark.bind(x => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);\n    };\n    const restore = editor => {\n      getRng(editor).each(rng => editor.selection.setRng(rng));\n    };\n\n    const isEditorUIElement$1 = elm => {\n      const className = elm.className.toString();\n      return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;\n    };\n    const FocusManager = { isEditorUIElement: isEditorUIElement$1 };\n\n    const wrappedSetTimeout = (callback, time) => {\n      if (!isNumber(time)) {\n        time = 0;\n      }\n      return setTimeout(callback, time);\n    };\n    const wrappedSetInterval = (callback, time) => {\n      if (!isNumber(time)) {\n        time = 0;\n      }\n      return setInterval(callback, time);\n    };\n    const Delay = {\n      setEditorTimeout: (editor, callback, time) => {\n        return wrappedSetTimeout(() => {\n          if (!editor.removed) {\n            callback();\n          }\n        }, time);\n      },\n      setEditorInterval: (editor, callback, time) => {\n        const timer = wrappedSetInterval(() => {\n          if (!editor.removed) {\n            callback();\n          } else {\n            clearInterval(timer);\n          }\n        }, time);\n        return timer;\n      }\n    };\n\n    const isManualNodeChange = e => {\n      return e.type === 'nodechange' && e.selectionChange;\n    };\n    const registerPageMouseUp = (editor, throttledStore) => {\n      const mouseUpPage = () => {\n        throttledStore.throttle();\n      };\n      DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);\n      editor.on('remove', () => {\n        DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);\n      });\n    };\n    const registerMouseUp = (editor, throttledStore) => {\n      editor.on('mouseup touchend', _e => {\n        throttledStore.throttle();\n      });\n    };\n    const registerEditorEvents = (editor, throttledStore) => {\n      registerMouseUp(editor, throttledStore);\n      editor.on('keyup NodeChange AfterSetSelectionRange', e => {\n        if (!isManualNodeChange(e)) {\n          store(editor);\n        }\n      });\n    };\n    const register$6 = editor => {\n      const throttledStore = first$1(() => {\n        store(editor);\n      }, 0);\n      editor.on('init', () => {\n        if (editor.inline) {\n          registerPageMouseUp(editor, throttledStore);\n        }\n        registerEditorEvents(editor, throttledStore);\n      });\n      editor.on('remove', () => {\n        throttledStore.cancel();\n      });\n    };\n\n    let documentFocusInHandler;\n    const DOM$9 = DOMUtils.DOM;\n    const isEditorUIElement = elm => {\n      return isElement$6(elm) && FocusManager.isEditorUIElement(elm);\n    };\n    const isEditorContentAreaElement = elm => {\n      const classList = elm.classList;\n      if (classList !== undefined) {\n        return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');\n      } else {\n        return false;\n      }\n    };\n    const isUIElement = (editor, elm) => {\n      const customSelector = getCustomUiSelector(editor);\n      const parent = DOM$9.getParent(elm, elm => {\n        return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);\n      });\n      return parent !== null;\n    };\n    const getActiveElement = editor => {\n      try {\n        const root = getRootNode(SugarElement.fromDom(editor.getElement()));\n        return active$1(root).fold(() => document.body, x => x.dom);\n      } catch (ex) {\n        return document.body;\n      }\n    };\n    const registerEvents$1 = (editorManager, e) => {\n      const editor = e.editor;\n      register$6(editor);\n      const toggleContentAreaOnFocus = (editor, fn) => {\n        if (shouldHighlightOnFocus(editor) && editor.inline !== true) {\n          const contentArea = SugarElement.fromDom(editor.getContainer());\n          fn(contentArea, 'tox-edit-focus');\n        }\n      };\n      editor.on('focusin', () => {\n        const focusedEditor = editorManager.focusedEditor;\n        if (isEditorContentAreaElement(getActiveElement(editor))) {\n          toggleContentAreaOnFocus(editor, add$2);\n        }\n        if (focusedEditor !== editor) {\n          if (focusedEditor) {\n            focusedEditor.dispatch('blur', { focusedEditor: editor });\n          }\n          editorManager.setActive(editor);\n          editorManager.focusedEditor = editor;\n          editor.dispatch('focus', { blurredEditor: focusedEditor });\n          editor.focus(true);\n        }\n      });\n      editor.on('focusout', () => {\n        Delay.setEditorTimeout(editor, () => {\n          const focusedEditor = editorManager.focusedEditor;\n          if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) {\n            toggleContentAreaOnFocus(editor, remove$6);\n          }\n          if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {\n            editor.dispatch('blur', { focusedEditor: null });\n            editorManager.focusedEditor = null;\n          }\n        });\n      });\n      if (!documentFocusInHandler) {\n        documentFocusInHandler = e => {\n          const activeEditor = editorManager.activeEditor;\n          if (activeEditor) {\n            getOriginalEventTarget(e).each(target => {\n              const elem = target;\n              if (elem.ownerDocument === document) {\n                if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {\n                  activeEditor.dispatch('blur', { focusedEditor: null });\n                  editorManager.focusedEditor = null;\n                }\n              }\n            });\n          }\n        };\n        DOM$9.bind(document, 'focusin', documentFocusInHandler);\n      }\n    };\n    const unregisterDocumentEvents = (editorManager, e) => {\n      if (editorManager.focusedEditor === e.editor) {\n        editorManager.focusedEditor = null;\n      }\n      if (!editorManager.activeEditor && documentFocusInHandler) {\n        DOM$9.unbind(document, 'focusin', documentFocusInHandler);\n        documentFocusInHandler = null;\n      }\n    };\n    const setup$w = editorManager => {\n      editorManager.on('AddEditor', curry(registerEvents$1, editorManager));\n      editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));\n    };\n\n    const getContentEditableHost = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'true');\n    const getCollapsedNode = rng => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();\n    const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind(node => {\n      if (isTableSection(node)) {\n        return Optional.some(node);\n      } else if (!contains(root, node)) {\n        return Optional.some(root);\n      } else {\n        return Optional.none();\n      }\n    });\n    const normalizeSelection = (editor, rng) => {\n      getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(elm => {\n        return firstPositionIn(elm.dom);\n      }).fold(() => {\n        editor.selection.normalize();\n      }, caretPos => editor.selection.setRng(caretPos.toRange()));\n    };\n    const focusBody = body => {\n      if (body.setActive) {\n        try {\n          body.setActive();\n        } catch (ex) {\n          body.focus();\n        }\n      } else {\n        body.focus();\n      }\n    };\n    const hasElementFocus = elm => hasFocus$1(elm) || search(elm).isSome();\n    const hasIframeFocus = editor => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));\n    const hasInlineFocus = editor => {\n      const rawBody = editor.getBody();\n      return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));\n    };\n    const hasUiFocus = editor => {\n      const dos = getRootNode(SugarElement.fromDom(editor.getElement()));\n      return active$1(dos).filter(elem => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();\n    };\n    const hasFocus = editor => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);\n    const hasEditorOrUiFocus = editor => hasFocus(editor) || hasUiFocus(editor);\n    const focusEditor = editor => {\n      const selection = editor.selection;\n      const body = editor.getBody();\n      let rng = selection.getRng();\n      editor.quirks.refreshContentEditable();\n      const restoreBookmark = editor => {\n        getRng(editor).each(bookmarkRng => {\n          editor.selection.setRng(bookmarkRng);\n          rng = bookmarkRng;\n        });\n      };\n      if (!hasFocus(editor) && editor.hasEditableRoot()) {\n        restoreBookmark(editor);\n      }\n      const contentEditableHost = getContentEditableHost(editor, selection.getNode());\n      if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {\n        focusBody(contentEditableHost);\n        if (!editor.hasEditableRoot()) {\n          restoreBookmark(editor);\n        }\n        normalizeSelection(editor, rng);\n        activateEditor(editor);\n        return;\n      }\n      if (!editor.inline) {\n        if (!Env.browser.isOpera()) {\n          focusBody(body);\n        }\n        editor.getWin().focus();\n      }\n      if (Env.browser.isFirefox() || editor.inline) {\n        focusBody(body);\n        normalizeSelection(editor, rng);\n      }\n      activateEditor(editor);\n    };\n    const activateEditor = editor => editor.editorManager.setActive(editor);\n    const focus = (editor, skipFocus) => {\n      if (editor.removed) {\n        return;\n      }\n      if (skipFocus) {\n        activateEditor(editor);\n      } else {\n        focusEditor(editor);\n      }\n    };\n\n    const isEditableRange = (dom, rng) => {\n      if (rng.collapsed) {\n        return dom.isEditable(rng.startContainer);\n      } else {\n        return dom.isEditable(rng.startContainer) && dom.isEditable(rng.endContainer);\n      }\n    };\n\n    const getEndpointElement = (root, rng, start, real, resolve) => {\n      const container = start ? rng.startContainer : rng.endContainer;\n      const offset = start ? rng.startOffset : rng.endOffset;\n      return Optional.from(container).map(SugarElement.fromDom).map(elm => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm).bind(elm => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map(elm => elm.dom).getOr(root);\n    };\n    const getStart = (root, rng, real = false) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));\n    const getEnd = (root, rng, real = false) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);\n    const skipEmptyTextNodes = (node, forwards) => {\n      const orig = node;\n      while (node && isText$b(node) && node.length === 0) {\n        node = forwards ? node.nextSibling : node.previousSibling;\n      }\n      return node || orig;\n    };\n    const getNode = (root, rng) => {\n      if (!rng) {\n        return root;\n      }\n      let startContainer = rng.startContainer;\n      let endContainer = rng.endContainer;\n      const startOffset = rng.startOffset;\n      const endOffset = rng.endOffset;\n      let node = rng.commonAncestorContainer;\n      if (!rng.collapsed) {\n        if (startContainer === endContainer) {\n          if (endOffset - startOffset < 2) {\n            if (startContainer.hasChildNodes()) {\n              node = startContainer.childNodes[startOffset];\n            }\n          }\n        }\n        if (isText$b(startContainer) && isText$b(endContainer)) {\n          if (startContainer.length === startOffset) {\n            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);\n          } else {\n            startContainer = startContainer.parentNode;\n          }\n          if (endOffset === 0) {\n            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);\n          } else {\n            endContainer = endContainer.parentNode;\n          }\n          if (startContainer && startContainer === endContainer) {\n            node = startContainer;\n          }\n        }\n      }\n      const elm = isText$b(node) ? node.parentNode : node;\n      return isHTMLElement(elm) ? elm : root;\n    };\n    const getSelectedBlocks = (dom, rng, startElm, endElm) => {\n      const selectedBlocks = [];\n      const root = dom.getRoot();\n      const start = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);\n      const end = dom.getParent(endElm || getEnd(root, rng, rng.collapsed), dom.isBlock);\n      if (start && start !== root) {\n        selectedBlocks.push(start);\n      }\n      if (start && end && start !== end) {\n        let node;\n        const walker = new DomTreeWalker(start, root);\n        while ((node = walker.next()) && node !== end) {\n          if (dom.isBlock(node)) {\n            selectedBlocks.push(node);\n          }\n        }\n      }\n      if (end && start !== end && end !== root) {\n        selectedBlocks.push(end);\n      }\n      return selectedBlocks;\n    };\n    const select = (dom, node, content) => Optional.from(node).bind(node => Optional.from(node.parentNode).map(parent => {\n      const idx = dom.nodeIndex(node);\n      const rng = dom.createRng();\n      rng.setStart(parent, idx);\n      rng.setEnd(parent, idx + 1);\n      if (content) {\n        moveEndPoint(dom, rng, node, true);\n        moveEndPoint(dom, rng, node, false);\n      }\n      return rng;\n    }));\n\n    const processRanges = (editor, ranges) => map$3(ranges, range => {\n      const evt = editor.dispatch('GetSelectionRange', { range });\n      return evt.range !== range ? evt.range : range;\n    });\n\n    const typeLookup = {\n      '#text': 3,\n      '#comment': 8,\n      '#cdata': 4,\n      '#pi': 7,\n      '#doctype': 10,\n      '#document-fragment': 11\n    };\n    const walk$2 = (node, root, prev) => {\n      const startName = prev ? 'lastChild' : 'firstChild';\n      const siblingName = prev ? 'prev' : 'next';\n      if (node[startName]) {\n        return node[startName];\n      }\n      if (node !== root) {\n        let sibling = node[siblingName];\n        if (sibling) {\n          return sibling;\n        }\n        for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {\n          sibling = parent[siblingName];\n          if (sibling) {\n            return sibling;\n          }\n        }\n      }\n      return undefined;\n    };\n    const isEmptyTextNode = node => {\n      var _a;\n      const text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n      if (!isWhitespaceText(text)) {\n        return false;\n      }\n      const parentNode = node.parent;\n      if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(text)) {\n        return false;\n      }\n      return true;\n    };\n    const isNonEmptyElement = node => {\n      const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');\n      return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;\n    };\n    class AstNode {\n      static create(name, attrs) {\n        const node = new AstNode(name, typeLookup[name] || 1);\n        if (attrs) {\n          each$d(attrs, (value, attrName) => {\n            node.attr(attrName, value);\n          });\n        }\n        return node;\n      }\n      constructor(name, type) {\n        this.name = name;\n        this.type = type;\n        if (type === 1) {\n          this.attributes = [];\n          this.attributes.map = {};\n        }\n      }\n      replace(node) {\n        const self = this;\n        if (node.parent) {\n          node.remove();\n        }\n        self.insert(node, self);\n        self.remove();\n        return self;\n      }\n      attr(name, value) {\n        const self = this;\n        if (!isString(name)) {\n          if (isNonNullable(name)) {\n            each$d(name, (value, key) => {\n              self.attr(key, value);\n            });\n          }\n          return self;\n        }\n        const attrs = self.attributes;\n        if (attrs) {\n          if (value !== undefined) {\n            if (value === null) {\n              if (name in attrs.map) {\n                delete attrs.map[name];\n                let i = attrs.length;\n                while (i--) {\n                  if (attrs[i].name === name) {\n                    attrs.splice(i, 1);\n                    return self;\n                  }\n                }\n              }\n              return self;\n            }\n            if (name in attrs.map) {\n              let i = attrs.length;\n              while (i--) {\n                if (attrs[i].name === name) {\n                  attrs[i].value = value;\n                  break;\n                }\n              }\n            } else {\n              attrs.push({\n                name,\n                value\n              });\n            }\n            attrs.map[name] = value;\n            return self;\n          }\n          return attrs.map[name];\n        }\n        return undefined;\n      }\n      clone() {\n        const self = this;\n        const clone = new AstNode(self.name, self.type);\n        const selfAttrs = self.attributes;\n        if (selfAttrs) {\n          const cloneAttrs = [];\n          cloneAttrs.map = {};\n          for (let i = 0, l = selfAttrs.length; i < l; i++) {\n            const selfAttr = selfAttrs[i];\n            if (selfAttr.name !== 'id') {\n              cloneAttrs[cloneAttrs.length] = {\n                name: selfAttr.name,\n                value: selfAttr.value\n              };\n              cloneAttrs.map[selfAttr.name] = selfAttr.value;\n            }\n          }\n          clone.attributes = cloneAttrs;\n        }\n        clone.value = self.value;\n        return clone;\n      }\n      wrap(wrapper) {\n        const self = this;\n        if (self.parent) {\n          self.parent.insert(wrapper, self);\n          wrapper.append(self);\n        }\n        return self;\n      }\n      unwrap() {\n        const self = this;\n        for (let node = self.firstChild; node;) {\n          const next = node.next;\n          self.insert(node, self, true);\n          node = next;\n        }\n        self.remove();\n      }\n      remove() {\n        const self = this, parent = self.parent, next = self.next, prev = self.prev;\n        if (parent) {\n          if (parent.firstChild === self) {\n            parent.firstChild = next;\n            if (next) {\n              next.prev = null;\n            }\n          } else if (prev) {\n            prev.next = next;\n          }\n          if (parent.lastChild === self) {\n            parent.lastChild = prev;\n            if (prev) {\n              prev.next = null;\n            }\n          } else if (next) {\n            next.prev = prev;\n          }\n          self.parent = self.next = self.prev = null;\n        }\n        return self;\n      }\n      append(node) {\n        const self = this;\n        if (node.parent) {\n          node.remove();\n        }\n        const last = self.lastChild;\n        if (last) {\n          last.next = node;\n          node.prev = last;\n          self.lastChild = node;\n        } else {\n          self.lastChild = self.firstChild = node;\n        }\n        node.parent = self;\n        return node;\n      }\n      insert(node, refNode, before) {\n        if (node.parent) {\n          node.remove();\n        }\n        const parent = refNode.parent || this;\n        if (before) {\n          if (refNode === parent.firstChild) {\n            parent.firstChild = node;\n          } else if (refNode.prev) {\n            refNode.prev.next = node;\n          }\n          node.prev = refNode.prev;\n          node.next = refNode;\n          refNode.prev = node;\n        } else {\n          if (refNode === parent.lastChild) {\n            parent.lastChild = node;\n          } else if (refNode.next) {\n            refNode.next.prev = node;\n          }\n          node.next = refNode.next;\n          node.prev = refNode;\n          refNode.next = node;\n        }\n        node.parent = parent;\n        return node;\n      }\n      getAll(name) {\n        const self = this;\n        const collection = [];\n        for (let node = self.firstChild; node; node = walk$2(node, self)) {\n          if (node.name === name) {\n            collection.push(node);\n          }\n        }\n        return collection;\n      }\n      children() {\n        const self = this;\n        const collection = [];\n        for (let node = self.firstChild; node; node = node.next) {\n          collection.push(node);\n        }\n        return collection;\n      }\n      empty() {\n        const self = this;\n        if (self.firstChild) {\n          const nodes = [];\n          for (let node = self.firstChild; node; node = walk$2(node, self)) {\n            nodes.push(node);\n          }\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;\n          }\n        }\n        self.firstChild = self.lastChild = null;\n        return self;\n      }\n      isEmpty(elements, whitespace = {}, predicate) {\n        var _a;\n        const self = this;\n        let node = self.firstChild;\n        if (isNonEmptyElement(self)) {\n          return false;\n        }\n        if (node) {\n          do {\n            if (node.type === 1) {\n              if (node.attr('data-mce-bogus')) {\n                continue;\n              }\n              if (elements[node.name]) {\n                return false;\n              }\n              if (isNonEmptyElement(node)) {\n                return false;\n              }\n            }\n            if (node.type === 8) {\n              return false;\n            }\n            if (node.type === 3 && !isEmptyTextNode(node)) {\n              return false;\n            }\n            if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : '')) {\n              return false;\n            }\n            if (predicate && predicate(node)) {\n              return false;\n            }\n          } while (node = walk$2(node, self));\n        }\n        return true;\n      }\n      walk(prev) {\n        return walk$2(this, null, prev);\n      }\n    }\n\n    const unescapedTextParents = Tools.makeMap('NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT', ' ');\n    const containsZwsp = node => isString(node.nodeValue) && node.nodeValue.includes(ZWSP$1);\n    const getTemporaryNodeSelector = tempAttrs => `${ tempAttrs.length === 0 ? '' : `${ map$3(tempAttrs, attr => `[${ attr }]`).join(',') },` }[data-mce-bogus=\"all\"]`;\n    const getTemporaryNodes = (tempAttrs, body) => body.querySelectorAll(getTemporaryNodeSelector(tempAttrs));\n    const createZwspCommentWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_COMMENT, node => containsZwsp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);\n    const createUnescapedZwspTextWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_TEXT, node => {\n      if (containsZwsp(node)) {\n        const parent = node.parentNode;\n        return parent && has$2(unescapedTextParents, parent.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n      } else {\n        return NodeFilter.FILTER_SKIP;\n      }\n    });\n    const hasZwspComment = body => createZwspCommentWalker(body).nextNode() !== null;\n    const hasUnescapedZwspText = body => createUnescapedZwspTextWalker(body).nextNode() !== null;\n    const hasTemporaryNode = (tempAttrs, body) => body.querySelector(getTemporaryNodeSelector(tempAttrs)) !== null;\n    const trimTemporaryNodes = (tempAttrs, body) => {\n      each$e(getTemporaryNodes(tempAttrs, body), elm => {\n        const element = SugarElement.fromDom(elm);\n        if (get$9(element, 'data-mce-bogus') === 'all') {\n          remove$4(element);\n        } else {\n          each$e(tempAttrs, attr => {\n            if (has$1(element, attr)) {\n              remove$9(element, attr);\n            }\n          });\n        }\n      });\n    };\n    const emptyAllNodeValuesInWalker = walker => {\n      let curr = walker.nextNode();\n      while (curr !== null) {\n        curr.nodeValue = null;\n        curr = walker.nextNode();\n      }\n    };\n    const emptyZwspComments = compose(emptyAllNodeValuesInWalker, createZwspCommentWalker);\n    const emptyUnescapedZwspTexts = compose(emptyAllNodeValuesInWalker, createUnescapedZwspTextWalker);\n    const trim$1 = (body, tempAttrs) => {\n      const conditionalTrims = [\n        {\n          condition: curry(hasTemporaryNode, tempAttrs),\n          action: curry(trimTemporaryNodes, tempAttrs)\n        },\n        {\n          condition: hasZwspComment,\n          action: emptyZwspComments\n        },\n        {\n          condition: hasUnescapedZwspText,\n          action: emptyUnescapedZwspTexts\n        }\n      ];\n      let trimmed = body;\n      let cloned = false;\n      each$e(conditionalTrims, ({condition, action}) => {\n        if (condition(trimmed)) {\n          if (!cloned) {\n            trimmed = body.cloneNode(true);\n            cloned = true;\n          }\n          action(trimmed);\n        }\n      });\n      return trimmed;\n    };\n\n    const cleanupBogusElements = parent => {\n      const bogusElements = descendants(parent, '[data-mce-bogus]');\n      each$e(bogusElements, elem => {\n        const bogusValue = get$9(elem, 'data-mce-bogus');\n        if (bogusValue === 'all') {\n          remove$4(elem);\n        } else if (isBr$5(elem)) {\n          before$3(elem, SugarElement.fromText(zeroWidth));\n          remove$4(elem);\n        } else {\n          unwrap(elem);\n        }\n      });\n    };\n    const cleanupInputNames = parent => {\n      const inputs = descendants(parent, 'input');\n      each$e(inputs, input => {\n        remove$9(input, 'name');\n      });\n    };\n\n    const trimEmptyContents = (editor, html) => {\n      const blockName = getForcedRootBlock(editor);\n      const emptyRegExp = new RegExp(`^(<${ blockName }[^>]*>(&nbsp;|&#160;|\\\\s|\\u00a0|<br \\\\/>|)<\\\\/${ blockName }>[\\r\\n]*|<br \\\\/>[\\r\\n]*)$`);\n      return html.replace(emptyRegExp, '');\n    };\n    const getPlainTextContent = (editor, body) => {\n      const doc = editor.getDoc();\n      const dos = getRootNode(SugarElement.fromDom(editor.getBody()));\n      const offscreenDiv = SugarElement.fromTag('div', doc);\n      set$3(offscreenDiv, 'data-mce-bogus', 'all');\n      setAll(offscreenDiv, {\n        position: 'fixed',\n        left: '-9999999px',\n        top: '0'\n      });\n      set$1(offscreenDiv, body.innerHTML);\n      cleanupBogusElements(offscreenDiv);\n      cleanupInputNames(offscreenDiv);\n      const root = getContentContainer(dos);\n      append$1(root, offscreenDiv);\n      const content = trim$2(offscreenDiv.dom.innerText);\n      remove$4(offscreenDiv);\n      return content;\n    };\n    const getContentFromBody = (editor, args, body) => {\n      let content;\n      if (args.format === 'raw') {\n        content = Tools.trim(trim$2(trim$1(body, editor.serializer.getTempAttrs()).innerHTML));\n      } else if (args.format === 'text') {\n        content = getPlainTextContent(editor, body);\n      } else if (args.format === 'tree') {\n        content = editor.serializer.serialize(body, args);\n      } else {\n        content = trimEmptyContents(editor, editor.serializer.serialize(body, args));\n      }\n      const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));\n      return shouldTrim && isString(content) ? Tools.trim(content) : content;\n    };\n    const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), body => getContentFromBody(editor, args, body));\n\n    const makeMap$1 = Tools.makeMap;\n    const Writer = settings => {\n      const html = [];\n      settings = settings || {};\n      const indent = settings.indent;\n      const indentBefore = makeMap$1(settings.indent_before || '');\n      const indentAfter = makeMap$1(settings.indent_after || '');\n      const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);\n      const htmlOutput = settings.element_format !== 'xhtml';\n      return {\n        start: (name, attrs, empty) => {\n          if (indent && indentBefore[name] && html.length > 0) {\n            const value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n          html.push('<', name);\n          if (attrs) {\n            for (let i = 0, l = attrs.length; i < l; i++) {\n              const attr = attrs[i];\n              html.push(' ', attr.name, '=\"', encode(attr.value, true), '\"');\n            }\n          }\n          if (!empty || htmlOutput) {\n            html[html.length] = '>';\n          } else {\n            html[html.length] = ' />';\n          }\n          if (empty && indent && indentAfter[name] && html.length > 0) {\n            const value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n        },\n        end: name => {\n          let value;\n          html.push('</', name, '>');\n          if (indent && indentAfter[name] && html.length > 0) {\n            value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n        },\n        text: (text, raw) => {\n          if (text.length > 0) {\n            html[html.length] = raw ? text : encode(text);\n          }\n        },\n        cdata: text => {\n          html.push('<![CDATA[', text, ']]>');\n        },\n        comment: text => {\n          html.push('<!--', text, '-->');\n        },\n        pi: (name, text) => {\n          if (text) {\n            html.push('<?', name, ' ', encode(text), '?>');\n          } else {\n            html.push('<?', name, '?>');\n          }\n          if (indent) {\n            html.push('\\n');\n          }\n        },\n        doctype: text => {\n          html.push('<!DOCTYPE', text, '>', indent ? '\\n' : '');\n        },\n        reset: () => {\n          html.length = 0;\n        },\n        getContent: () => {\n          return html.join('').replace(/\\n$/, '');\n        }\n      };\n    };\n\n    const HtmlSerializer = (settings = {}, schema = Schema()) => {\n      const writer = Writer(settings);\n      settings.validate = 'validate' in settings ? settings.validate : true;\n      const serialize = node => {\n        const validate = settings.validate;\n        const handlers = {\n          3: node => {\n            var _a;\n            writer.text((_a = node.value) !== null && _a !== void 0 ? _a : '', node.raw);\n          },\n          8: node => {\n            var _a;\n            writer.comment((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          7: node => {\n            writer.pi(node.name, node.value);\n          },\n          10: node => {\n            var _a;\n            writer.doctype((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          4: node => {\n            var _a;\n            writer.cdata((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          11: node => {\n            let tempNode = node;\n            if (tempNode = tempNode.firstChild) {\n              do {\n                walk(tempNode);\n              } while (tempNode = tempNode.next);\n            }\n          }\n        };\n        writer.reset();\n        const walk = node => {\n          var _a;\n          const handler = handlers[node.type];\n          if (!handler) {\n            const name = node.name;\n            const isEmpty = name in schema.getVoidElements();\n            let attrs = node.attributes;\n            if (validate && attrs && attrs.length > 1) {\n              const sortedAttrs = [];\n              sortedAttrs.map = {};\n              const elementRule = schema.getElementRule(node.name);\n              if (elementRule) {\n                for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {\n                  const attrName = elementRule.attributesOrder[i];\n                  if (attrName in attrs.map) {\n                    const attrValue = attrs.map[attrName];\n                    sortedAttrs.map[attrName] = attrValue;\n                    sortedAttrs.push({\n                      name: attrName,\n                      value: attrValue\n                    });\n                  }\n                }\n                for (let i = 0, l = attrs.length; i < l; i++) {\n                  const attrName = attrs[i].name;\n                  if (!(attrName in sortedAttrs.map)) {\n                    const attrValue = attrs.map[attrName];\n                    sortedAttrs.map[attrName] = attrValue;\n                    sortedAttrs.push({\n                      name: attrName,\n                      value: attrValue\n                    });\n                  }\n                }\n                attrs = sortedAttrs;\n              }\n            }\n            writer.start(name, attrs, isEmpty);\n            if (isNonHtmlElementRootName(name)) {\n              if (isString(node.value)) {\n                writer.text(node.value, true);\n              }\n              writer.end(name);\n            } else {\n              if (!isEmpty) {\n                let child = node.firstChild;\n                if (child) {\n                  if ((name === 'pre' || name === 'textarea') && child.type === 3 && ((_a = child.value) === null || _a === void 0 ? void 0 : _a[0]) === '\\n') {\n                    writer.text('\\n', true);\n                  }\n                  do {\n                    walk(child);\n                  } while (child = child.next);\n                }\n                writer.end(name);\n              }\n            }\n          } else {\n            handler(node);\n          }\n        };\n        if (node.type === 1 && !settings.inner) {\n          walk(node);\n        } else if (node.type === 3) {\n          handlers[3](node);\n        } else {\n          handlers[11](node);\n        }\n        return writer.getContent();\n      };\n      return { serialize };\n    };\n\n    const nonInheritableStyles = new Set();\n    (() => {\n      const nonInheritableStylesArr = [\n        'margin',\n        'margin-left',\n        'margin-right',\n        'margin-top',\n        'margin-bottom',\n        'padding',\n        'padding-left',\n        'padding-right',\n        'padding-top',\n        'padding-bottom',\n        'border',\n        'border-width',\n        'border-style',\n        'border-color',\n        'background',\n        'background-attachment',\n        'background-clip',\n        'background-image',\n        'background-origin',\n        'background-position',\n        'background-repeat',\n        'background-size',\n        'float',\n        'position',\n        'left',\n        'right',\n        'top',\n        'bottom',\n        'z-index',\n        'display',\n        'transform',\n        'width',\n        'max-width',\n        'min-width',\n        'height',\n        'max-height',\n        'min-height',\n        'overflow',\n        'overflow-x',\n        'overflow-y',\n        'text-overflow',\n        'vertical-align',\n        'transition',\n        'transition-delay',\n        'transition-duration',\n        'transition-property',\n        'transition-timing-function'\n      ];\n      each$e(nonInheritableStylesArr, style => {\n        nonInheritableStyles.add(style);\n      });\n    })();\n    const conditionalNonInheritableStyles = new Set();\n    (() => {\n      const conditionalNonInheritableStylesArr = ['background-color'];\n      each$e(conditionalNonInheritableStylesArr, style => {\n        conditionalNonInheritableStyles.add(style);\n      });\n    })();\n    const shorthandStyleProps = [\n      'font',\n      'text-decoration',\n      'text-emphasis'\n    ];\n    const getStyles$1 = (dom, node) => dom.parseStyle(dom.getAttrib(node, 'style'));\n    const getStyleProps = (dom, node) => keys(getStyles$1(dom, node));\n    const isNonInheritableStyle = style => nonInheritableStyles.has(style);\n    const isConditionalNonInheritableStyle = style => conditionalNonInheritableStyles.has(style);\n    const hasNonInheritableStyles = (dom, node) => exists(getStyleProps(dom, node), style => isNonInheritableStyle(style));\n    const hasConditionalNonInheritableStyles = (dom, node) => hasNonInheritableStyles(dom, node) && exists(getStyleProps(dom, node), style => isConditionalNonInheritableStyle(style));\n    const getLonghandStyleProps = styles => filter$5(styles, style => exists(shorthandStyleProps, prop => startsWith(style, prop)));\n    const hasStyleConflict = (dom, node, parentNode) => {\n      const nodeStyleProps = getStyleProps(dom, node);\n      const parentNodeStyleProps = getStyleProps(dom, parentNode);\n      const valueMismatch = prop => {\n        var _a, _b;\n        const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';\n        const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';\n        return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;\n      };\n      return exists(nodeStyleProps, nodeStyleProp => {\n        const propExists = props => exists(props, prop => prop === nodeStyleProp);\n        if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {\n          const longhandProps = getLonghandStyleProps(parentNodeStyleProps);\n          return exists(longhandProps, valueMismatch);\n        } else {\n          return valueMismatch(nodeStyleProp);\n        }\n      });\n    };\n\n    const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$b).exists(text => {\n      const delta = forward ? 0 : -1;\n      return predicate(text.data.charAt(pos.offset() + delta));\n    });\n    const isBeforeSpace = curry(isChar, true, isWhiteSpace);\n    const isAfterSpace = curry(isChar, false, isWhiteSpace);\n    const isEmptyText = pos => {\n      const container = pos.container();\n      return isText$b(container) && (container.data.length === 0 || isZwsp(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));\n    };\n    const matchesElementPosition = (before, predicate) => pos => getChildNodeAtRelativeOffset(before ? 0 : -1, pos).filter(predicate).isSome();\n    const isImageBlock = node => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';\n    const isCefNode = node => isContentEditableFalse$b(node) && !isBogusAll(node);\n    const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);\n    const isAfterImageBlock = matchesElementPosition(false, isImageBlock);\n    const isBeforeMedia = matchesElementPosition(true, isMedia$2);\n    const isAfterMedia = matchesElementPosition(false, isMedia$2);\n    const isBeforeTable = matchesElementPosition(true, isTable$2);\n    const isAfterTable = matchesElementPosition(false, isTable$2);\n    const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);\n    const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);\n\n    const dropLast = xs => xs.slice(0, -1);\n    const parentsUntil = (start, root, predicate) => {\n      if (contains(root, start)) {\n        return dropLast(parents$1(start, elm => {\n          return predicate(elm) || eq(elm, root);\n        }));\n      } else {\n        return [];\n      }\n    };\n    const parents = (start, root) => parentsUntil(start, root, never);\n    const parentsAndSelf = (start, root) => [start].concat(parents(start, root));\n\n    const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);\n    const isBlock$1 = schema => el => schema.isBlock(name(el));\n    const getClosestBlock$1 = (root, pos, schema) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$1(schema));\n    const isAtBeforeAfterBlockBoundary = (forward, root, pos, schema) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => getClosestBlock$1(root, pos, schema).fold(() => !isInSameBlock(newPos, pos, root.dom), fromBlock => !isInSameBlock(newPos, pos, root.dom) && contains(fromBlock, SugarElement.fromDom(newPos.container()))));\n    const isAtBlockBoundary = (forward, root, pos, schema) => getClosestBlock$1(root, pos, schema).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => !isInSameBlock(newPos, pos, root.dom)), parent => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());\n    const isAtStartOfBlock = curry(isAtBlockBoundary, false);\n    const isAtEndOfBlock = curry(isAtBlockBoundary, true);\n    const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);\n    const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);\n\n    const isBr$1 = pos => getElementFromPosition(pos).exists(isBr$5);\n    const findBr = (forward, root, pos, schema) => {\n      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\n      const scope = head(parentBlocks).getOr(root);\n      return fromPosition(forward, scope.dom, pos).filter(isBr$1);\n    };\n    const isBeforeBr$1 = (root, pos, schema) => getElementFromPosition(pos).exists(isBr$5) || findBr(true, root, pos, schema).isSome();\n    const isAfterBr = (root, pos, schema) => getElementFromPrevPosition(pos).exists(isBr$5) || findBr(false, root, pos, schema).isSome();\n    const findPreviousBr = curry(findBr, false);\n    const findNextBr = curry(findBr, true);\n\n    const isInMiddleOfText = pos => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();\n    const getClosestBlock = (root, pos, schema) => {\n      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\n      return head(parentBlocks).getOr(root);\n    };\n    const hasSpaceBefore = (root, pos, schema) => {\n      if (isInMiddleOfText(pos)) {\n        return isAfterSpace(pos);\n      } else {\n        return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isAfterSpace);\n      }\n    };\n    const hasSpaceAfter = (root, pos, schema) => {\n      if (isInMiddleOfText(pos)) {\n        return isBeforeSpace(pos);\n      } else {\n        return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isBeforeSpace);\n      }\n    };\n    const isPreValue = value => contains$2([\n      'pre',\n      'pre-wrap'\n    ], value);\n    const isInPre = pos => getElementFromPosition(pos).bind(elm => closest$4(elm, isElement$7)).exists(elm => isPreValue(get$7(elm, 'white-space')));\n    const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();\n    const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();\n    const isAtLineBoundary = (root, pos, schema) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos, schema) || isAtEndOfBlock(root, pos, schema) || isAfterBr(root, pos, schema) || isBeforeBr$1(root, pos, schema);\n    const isCefBlock = node => isNonNullable(node) && isContentEditableFalse$b(node) && isBlockLike(node);\n    const isSiblingCefBlock = (root, direction) => container => {\n      return isCefBlock(new DomTreeWalker(container, root)[direction]());\n    };\n    const isBeforeCefBlock = (root, pos) => {\n      const nextPos = nextPosition(root.dom, pos).getOr(pos);\n      const isNextCefBlock = isSiblingCefBlock(root.dom, 'next');\n      return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));\n    };\n    const isAfterCefBlock = (root, pos) => {\n      const prevPos = prevPosition(root.dom, pos).getOr(pos);\n      const isPrevCefBlock = isSiblingCefBlock(root.dom, 'prev');\n      return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));\n    };\n    const needsToHaveNbsp = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtLineBoundary(root, pos, schema) || hasSpaceBefore(root, pos, schema) || hasSpaceAfter(root, pos, schema);\n      }\n    };\n    const needsToBeNbspLeft = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtStartOfBlock(root, pos, schema) || isBeforeBlock(root, pos, schema) || isAfterBr(root, pos, schema) || hasSpaceBefore(root, pos, schema) || isAfterCefBlock(root, pos);\n      }\n    };\n    const leanRight = pos => {\n      const container = pos.container();\n      const offset = pos.offset();\n      if (isText$b(container) && offset < container.data.length) {\n        return CaretPosition(container, offset + 1);\n      } else {\n        return pos;\n      }\n    };\n    const needsToBeNbspRight = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtEndOfBlock(root, pos, schema) || isAfterBlock(root, pos, schema) || isBeforeBr$1(root, pos, schema) || hasSpaceAfter(root, pos, schema) || isBeforeCefBlock(root, pos);\n      }\n    };\n    const needsToBeNbsp = (root, pos, schema) => needsToBeNbspLeft(root, pos, schema) || needsToBeNbspRight(root, leanRight(pos), schema);\n    const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));\n    const isWhiteSpaceAt = (text, offset) => isWhiteSpace(text.charAt(offset));\n    const hasNbsp = pos => {\n      const container = pos.container();\n      return isText$b(container) && contains$1(container.data, nbsp);\n    };\n    const normalizeNbspMiddle = text => {\n      const chars = text.split('');\n      return map$3(chars, (chr, i) => {\n        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {\n          return ' ';\n        } else {\n          return chr;\n        }\n      }).join('');\n    };\n    const normalizeNbspAtStart = (root, node, makeNbsp, schema) => {\n      const text = node.data;\n      const firstPos = CaretPosition(node, 0);\n      if (!makeNbsp && isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos, schema)) {\n        node.data = ' ' + text.slice(1);\n        return true;\n      } else if (makeNbsp && isWhiteSpaceAt(text, 0) && needsToBeNbspLeft(root, firstPos, schema)) {\n        node.data = nbsp + text.slice(1);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbspInMiddleOfTextNode = node => {\n      const text = node.data;\n      const newText = normalizeNbspMiddle(text);\n      if (newText !== text) {\n        node.data = newText;\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbspAtEnd = (root, node, makeNbsp, schema) => {\n      const text = node.data;\n      const lastPos = CaretPosition(node, text.length - 1);\n      if (!makeNbsp && isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos, schema)) {\n        node.data = text.slice(0, -1) + ' ';\n        return true;\n      } else if (makeNbsp && isWhiteSpaceAt(text, text.length - 1) && needsToBeNbspRight(root, lastPos, schema)) {\n        node.data = text.slice(0, -1) + nbsp;\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbsps = (root, pos, schema) => {\n      const container = pos.container();\n      if (!isText$b(container)) {\n        return Optional.none();\n      }\n      if (hasNbsp(pos)) {\n        const normalized = normalizeNbspAtStart(root, container, false, schema) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container, false, schema);\n        return someIf(normalized, pos);\n      } else if (needsToBeNbsp(root, pos, schema)) {\n        const normalized = normalizeNbspAtStart(root, container, true, schema) || normalizeNbspAtEnd(root, container, true, schema);\n        return someIf(normalized, pos);\n      } else {\n        return Optional.none();\n      }\n    };\n    const normalizeNbspsInEditor = editor => {\n      const root = SugarElement.fromDom(editor.getBody());\n      if (editor.selection.isCollapsed()) {\n        normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng()), editor.schema).each(pos => {\n          editor.selection.setRng(pos.toRange());\n        });\n      }\n    };\n\n    const normalize$1 = (node, offset, count, schema) => {\n      if (count === 0) {\n        return;\n      }\n      const elm = SugarElement.fromDom(node);\n      const root = ancestor$4(elm, el => schema.isBlock(name(el))).getOr(elm);\n      const whitespace = node.data.slice(offset, offset + count);\n      const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length), schema);\n      const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0), schema);\n      node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));\n    };\n    const normalizeWhitespaceAfter = (node, offset, schema) => {\n      const content = node.data.slice(offset);\n      const whitespaceCount = content.length - lTrim(content).length;\n      normalize$1(node, offset, whitespaceCount, schema);\n    };\n    const normalizeWhitespaceBefore = (node, offset, schema) => {\n      const content = node.data.slice(0, offset);\n      const whitespaceCount = content.length - rTrim(content).length;\n      normalize$1(node, offset - whitespaceCount, whitespaceCount, schema);\n    };\n    const mergeTextNodes = (prevNode, nextNode, schema, normalizeWhitespace, mergeToPrev = true) => {\n      const whitespaceOffset = rTrim(prevNode.data).length;\n      const newNode = mergeToPrev ? prevNode : nextNode;\n      const removeNode = mergeToPrev ? nextNode : prevNode;\n      if (mergeToPrev) {\n        newNode.appendData(removeNode.data);\n      } else {\n        newNode.insertData(0, removeNode.data);\n      }\n      remove$4(SugarElement.fromDom(removeNode));\n      if (normalizeWhitespace) {\n        normalizeWhitespaceAfter(newNode, whitespaceOffset, schema);\n      }\n      return newNode;\n    };\n\n    const needsReposition = (pos, elm) => {\n      const container = pos.container();\n      const offset = pos.offset();\n      return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset > CaretPosition.before(elm).offset();\n    };\n    const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;\n    const beforeOrStartOf = node => isText$b(node) ? CaretPosition(node, 0) : CaretPosition.before(node);\n    const afterOrEndOf = node => isText$b(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);\n    const getPreviousSiblingCaretPosition = elm => {\n      if (isCaretCandidate$3(elm.previousSibling)) {\n        return Optional.some(afterOrEndOf(elm.previousSibling));\n      } else {\n        return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();\n      }\n    };\n    const getNextSiblingCaretPosition = elm => {\n      if (isCaretCandidate$3(elm.nextSibling)) {\n        return Optional.some(beforeOrStartOf(elm.nextSibling));\n      } else {\n        return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();\n      }\n    };\n    const findCaretPositionBackwardsFromElm = (rootElement, elm) => {\n      return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode).bind(node => prevPosition(rootElement, CaretPosition.before(node))).orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));\n    };\n    const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));\n    const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));\n    const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));\n    const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);\n    const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));\n    const setSelection$1 = (editor, forward, pos) => {\n      pos.fold(() => {\n        editor.focus();\n      }, pos => {\n        editor.selection.setRng(pos.toRange(), forward);\n      });\n    };\n    const eqRawNode = rawNode => elm => elm.dom === rawNode;\n    const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));\n    const paddEmptyBlock = (schema, elm, preserveEmptyCaret) => {\n      if (isEmpty$2(schema, elm)) {\n        const br = SugarElement.fromHtml('<br data-mce-bogus=\"1\">');\n        if (preserveEmptyCaret) {\n          each$e(children$1(elm), node => {\n            if (!isEmptyCaretFormatElement(node)) {\n              remove$4(node);\n            }\n          });\n        } else {\n          empty(elm);\n        }\n        append$1(elm, br);\n        return Optional.some(CaretPosition.before(br.dom));\n      } else {\n        return Optional.none();\n      }\n    };\n    const deleteNormalized = (elm, afterDeletePosOpt, schema, normalizeWhitespace) => {\n      const prevTextOpt = prevSibling(elm).filter(isText$c);\n      const nextTextOpt = nextSibling(elm).filter(isText$c);\n      remove$4(elm);\n      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {\n        const prevNode = prev.dom, nextNode = next.dom;\n        const offset = prevNode.data.length;\n        mergeTextNodes(prevNode, nextNode, schema, normalizeWhitespace);\n        return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;\n      }).orThunk(() => {\n        if (normalizeWhitespace) {\n          prevTextOpt.each(elm => normalizeWhitespaceBefore(elm.dom, elm.dom.length, schema));\n          nextTextOpt.each(elm => normalizeWhitespaceAfter(elm.dom, 0, schema));\n        }\n        return afterDeletePosOpt;\n      });\n    };\n    const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));\n    const deleteElement$2 = (editor, forward, elm, moveCaret = true, preserveEmptyCaret = false) => {\n      const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);\n      const parentBlock = ancestor$4(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));\n      const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, editor.schema, isInlineElement(editor, elm));\n      if (editor.dom.isEmpty(editor.getBody())) {\n        editor.setContent('');\n        editor.selection.setCursorLocation();\n      } else {\n        parentBlock.bind(elm => paddEmptyBlock(editor.schema, elm, preserveEmptyCaret)).fold(() => {\n          if (moveCaret) {\n            setSelection$1(editor, forward, normalizedAfterDeletePos);\n          }\n        }, paddPos => {\n          if (moveCaret) {\n            setSelection$1(editor, forward, Optional.some(paddPos));\n          }\n        });\n      }\n    };\n\n    const strongRtl = /[\\u0591-\\u07FF\\uFB1D-\\uFDFF\\uFE70-\\uFEFC]/;\n    const hasStrongRtl = text => strongRtl.test(text);\n\n    const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor)) && !isTransparentBlock(editor.schema, elm) && editor.dom.isEditable(elm);\n    const isRtl = element => {\n      var _a;\n      return DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : '');\n    };\n    const findInlineParents = (isInlineTarget, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);\n    const findRootInline = (isInlineTarget, rootNode, pos) => {\n      const parents = findInlineParents(isInlineTarget, rootNode, pos);\n      return Optional.from(parents[parents.length - 1]);\n    };\n    const hasSameParentBlock = (rootNode, node1, node2) => {\n      const block1 = getParentBlock$3(node1, rootNode);\n      const block2 = getParentBlock$3(node2, rootNode);\n      return isNonNullable(block1) && block1 === block2;\n    };\n    const isAtZwsp = pos => isBeforeInline(pos) || isAfterInline(pos);\n    const normalizePosition = (forward, pos) => {\n      const container = pos.container(), offset = pos.offset();\n      if (forward) {\n        if (isCaretContainerInline(container)) {\n          if (isText$b(container.nextSibling)) {\n            return CaretPosition(container.nextSibling, 0);\n          } else {\n            return CaretPosition.after(container);\n          }\n        } else {\n          return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;\n        }\n      } else {\n        if (isCaretContainerInline(container)) {\n          if (isText$b(container.previousSibling)) {\n            return CaretPosition(container.previousSibling, container.previousSibling.data.length);\n          } else {\n            return CaretPosition.before(container);\n          }\n        } else {\n          return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;\n        }\n      }\n    };\n    const normalizeForwards = curry(normalizePosition, true);\n    const normalizeBackwards = curry(normalizePosition, false);\n\n    const execCommandIgnoreInputEvents = (editor, command) => {\n      const inputBlocker = e => e.stopImmediatePropagation();\n      editor.on('beforeinput input', inputBlocker, true);\n      editor.getDoc().execCommand(command);\n      editor.off('beforeinput input', inputBlocker);\n    };\n    const execEditorDeleteCommand = editor => {\n      editor.execCommand('delete');\n    };\n    const execNativeDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'Delete');\n    const execNativeForwardDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'ForwardDelete');\n    const isBeforeRoot = rootNode => elm => is$2(parent(elm), rootNode, eq);\n    const isTextBlockOrListItem = element => isTextBlock$2(element) || isListItem$1(element);\n    const getParentBlock$2 = (rootNode, elm) => {\n      if (contains(rootNode, elm)) {\n        return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));\n      } else {\n        return Optional.none();\n      }\n    };\n    const paddEmptyBody = (editor, moveSelection = true) => {\n      if (editor.dom.isEmpty(editor.getBody())) {\n        editor.setContent('', { no_selection: !moveSelection });\n      }\n    };\n    const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n      const normalizedFirstPos = normalizePosition(true, firstPos);\n      const normalizedLastPos = normalizePosition(false, lastPos);\n      const normalizedFromPos = normalizePosition(false, fromPos);\n      if (forward) {\n        return nextPosition(elm, normalizedFromPos).exists(nextPos => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));\n      } else {\n        return prevPosition(elm, normalizedFromPos).exists(prevPos => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));\n      }\n    }).getOr(true);\n    const freefallRtl = root => {\n      const child = isComment$1(root) ? prevSibling(root) : lastChild(root);\n      return child.bind(freefallRtl).orThunk(() => Optional.some(root));\n    };\n    const deleteRangeContents = (editor, rng, root, moveSelection = true) => {\n      var _a;\n      rng.deleteContents();\n      const lastNode = freefallRtl(root).getOr(root);\n      const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root.dom);\n      if (lastBlock.dom === editor.getBody()) {\n        paddEmptyBody(editor, moveSelection);\n      } else if (isEmpty$2(editor.schema, lastBlock, { checkRootAsContent: false })) {\n        fillWithPaddingBr(lastBlock);\n        if (moveSelection) {\n          editor.selection.setCursorLocation(lastBlock.dom, 0);\n        }\n      }\n      if (!eq(root, lastBlock)) {\n        const additionalCleanupNodes = is$2(parent(lastBlock), root) ? [] : siblings(lastBlock);\n        each$e(additionalCleanupNodes.concat(children$1(root)), node => {\n          if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(editor.schema, node)) {\n            remove$4(node);\n          }\n        });\n      }\n    };\n\n    const isRootFromElement = root => cur => eq(root, cur);\n    const getTableCells = table => descendants(table, 'td,th');\n    const getTable$1 = (node, isRoot) => getClosestTable(SugarElement.fromDom(node), isRoot);\n    const selectionInTableWithNestedTable = details => {\n      return lift2(details.startTable, details.endTable, (startTable, endTable) => {\n        const isStartTableParentOfEndTable = descendant(startTable, t => eq(t, endTable));\n        const isEndTableParentOfStartTable = descendant(endTable, t => eq(t, startTable));\n        return !isStartTableParentOfEndTable && !isEndTableParentOfStartTable ? details : {\n          ...details,\n          startTable: isStartTableParentOfEndTable ? Optional.none() : details.startTable,\n          endTable: isEndTableParentOfStartTable ? Optional.none() : details.endTable,\n          isSameTable: false,\n          isMultiTable: false\n        };\n      }).getOr(details);\n    };\n    const adjustQuirksInDetails = details => {\n      return selectionInTableWithNestedTable(details);\n    };\n    const getTableDetailsFromRange = (rng, isRoot) => {\n      const startTable = getTable$1(rng.startContainer, isRoot);\n      const endTable = getTable$1(rng.endContainer, isRoot);\n      const isStartInTable = startTable.isSome();\n      const isEndInTable = endTable.isSome();\n      const isSameTable = lift2(startTable, endTable, eq).getOr(false);\n      const isMultiTable = !isSameTable && isStartInTable && isEndInTable;\n      return adjustQuirksInDetails({\n        startTable,\n        endTable,\n        isStartInTable,\n        isEndInTable,\n        isSameTable,\n        isMultiTable\n      });\n    };\n\n    const tableCellRng = (start, end) => ({\n      start,\n      end\n    });\n    const tableSelection = (rng, table, cells) => ({\n      rng,\n      table,\n      cells\n    });\n    const deleteAction = Adt.generate([\n      {\n        singleCellTable: [\n          'rng',\n          'cell'\n        ]\n      },\n      { fullTable: ['table'] },\n      {\n        partialTable: [\n          'cells',\n          'outsideDetails'\n        ]\n      },\n      {\n        multiTable: [\n          'startTableCells',\n          'endTableCells',\n          'betweenRng'\n        ]\n      }\n    ]);\n    const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);\n    const isExpandedCellRng = cellRng => !eq(cellRng.start, cellRng.end);\n    const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot).bind(startParentTable => getClosestTable(cellRng.end, isRoot).bind(endParentTable => someIf(eq(startParentTable, endParentTable), startParentTable)));\n    const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(table => {\n      const rows = table.dom.rows;\n      return rows.length === 1 && rows[0].cells.length === 1;\n    });\n    const getCellRng = (rng, isRoot) => {\n      const startCell = getClosestCell$1(rng.startContainer, isRoot);\n      const endCell = getClosestCell$1(rng.endContainer, isRoot);\n      return lift2(startCell, endCell, tableCellRng);\n    };\n    const getCellRangeFromStartTable = isRoot => startCell => getClosestTable(startCell, isRoot).bind(table => last$2(getTableCells(table)).map(endCell => tableCellRng(startCell, endCell)));\n    const getCellRangeFromEndTable = isRoot => endCell => getClosestTable(endCell, isRoot).bind(table => head(getTableCells(table)).map(startCell => tableCellRng(startCell, endCell)));\n    const getTableSelectionFromCellRng = isRoot => cellRng => getTableFromCellRng(cellRng, isRoot).map(table => tableSelection(cellRng, table, getTableCells(table)));\n    const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {\n      if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {\n        return Optional.none();\n      } else if (selectionDetails.isSameTable) {\n        const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));\n        return Optional.some({\n          start: sameTableSelection,\n          end: sameTableSelection\n        });\n      } else {\n        const startCell = getClosestCell$1(rng.startContainer, isRoot);\n        const endCell = getClosestCell$1(rng.endContainer, isRoot);\n        const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n        const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n        return Optional.some({\n          start: startTableSelection,\n          end: endTableSelection\n        });\n      }\n    };\n    const getCellIndex = (cells, cell) => findIndex$2(cells, x => eq(x, cell));\n    const getSelectedCells = tableSelection => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));\n    const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists(cellRng => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));\n    const unselectCells = (rng, selectionDetails) => {\n      const {startTable, endTable} = selectionDetails;\n      const otherContentRng = rng.cloneRange();\n      startTable.each(table => otherContentRng.setStartAfter(table.dom));\n      endTable.each(table => otherContentRng.setEndBefore(table.dom));\n      return otherContentRng;\n    };\n    const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => start.or(end)).bind(tableSelection => {\n      const {isSameTable} = selectionDetails;\n      const selectedCells = getSelectedCells(tableSelection).getOr([]);\n      if (isSameTable && tableSelection.cells.length === selectedCells.length) {\n        return Optional.some(deleteAction.fullTable(tableSelection.table));\n      } else if (selectedCells.length > 0) {\n        if (isSameTable) {\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));\n        } else {\n          const otherContentRng = unselectCells(rng, selectionDetails);\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({\n            ...selectionDetails,\n            rng: otherContentRng\n          })));\n        }\n      } else {\n        return Optional.none();\n      }\n    });\n    const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => {\n      const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);\n      const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);\n      if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {\n        const otherContentRng = unselectCells(rng, selectionDetails);\n        return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));\n      } else {\n        return Optional.none();\n      }\n    });\n    const getActionFromRange = (root, rng) => {\n      const isRoot = isRootFromElement(root);\n      const optCellRng = getCellRng(rng, isRoot);\n      const selectionDetails = getTableDetailsFromRange(rng, isRoot);\n      if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {\n        return optCellRng.map(cellRng => deleteAction.singleCellTable(rng, cellRng.start));\n      } else if (selectionDetails.isMultiTable) {\n        return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);\n      } else {\n        return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);\n      }\n    };\n\n    const cleanCells = cells => each$e(cells, cell => {\n      remove$9(cell, 'contenteditable');\n      fillWithPaddingBr(cell);\n    });\n    const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);\n    const handleEmptyBlock = (editor, startInTable, emptyBlock) => {\n      emptyBlock.each(block => {\n        if (startInTable) {\n          remove$4(block);\n        } else {\n          fillWithPaddingBr(block);\n          editor.selection.setCursorLocation(block.dom, 0);\n        }\n      });\n    };\n    const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {\n      const insideTableRng = rng.cloneRange();\n      if (isFirstCellInSelection) {\n        insideTableRng.setStart(rng.startContainer, rng.startOffset);\n        insideTableRng.setEndAfter(cell.dom.lastChild);\n      } else {\n        insideTableRng.setStartBefore(cell.dom.firstChild);\n        insideTableRng.setEnd(rng.endContainer, rng.endOffset);\n      }\n      deleteCellContents(editor, insideTableRng, cell, false).each(action => action());\n    };\n    const collapseAndRestoreCellSelection = editor => {\n      const selectedCells = getCellsFromEditor(editor);\n      const selectedNode = SugarElement.fromDom(editor.selection.getNode());\n      if (isTableCell$3(selectedNode.dom) && isEmpty$2(editor.schema, selectedNode)) {\n        editor.selection.setCursorLocation(selectedNode.dom, 0);\n      } else {\n        editor.selection.collapse(true);\n      }\n      if (selectedCells.length > 1 && exists(selectedCells, cell => eq(cell, selectedNode))) {\n        set$3(selectedNode, 'data-mce-selected', '1');\n      }\n    };\n    const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {\n      const editorRng = editor.selection.getRng();\n      const cellsToClean = outsideDetails.bind(({rng, isStartInTable}) => {\n        const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);\n        rng.deleteContents();\n        handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(curry(isEmpty$2, editor.schema)));\n        const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];\n        deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);\n        if (!isEmpty$2(editor.schema, endPointCell)) {\n          return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));\n        } else {\n          return Optional.none();\n        }\n      }).getOr(cells);\n      cleanCells(cellsToClean);\n      collapseAndRestoreCellSelection(editor);\n    });\n    const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {\n      const rng = editor.selection.getRng();\n      const startCell = startTableCells[0];\n      const endCell = endTableCells[endTableCells.length - 1];\n      deleteContentInsideCell(editor, startCell, rng, true);\n      deleteContentInsideCell(editor, endCell, rng, false);\n      const startTableCellsToClean = isEmpty$2(editor.schema, startCell) ? startTableCells : startTableCells.slice(1);\n      const endTableCellsToClean = isEmpty$2(editor.schema, endCell) ? endTableCells : endTableCells.slice(0, -1);\n      cleanCells(startTableCellsToClean.concat(endTableCellsToClean));\n      betweenRng.deleteContents();\n      collapseAndRestoreCellSelection(editor);\n    });\n    const deleteCellContents = (editor, rng, cell, moveSelection = true) => Optional.some(() => {\n      deleteRangeContents(editor, rng, cell, moveSelection);\n    });\n    const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));\n    const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind(action => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));\n    const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);\n    const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), caption => deleteCaptionRange(editor, caption));\n    const deleteRange$3 = (editor, startElm, selectedCells) => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const rng = editor.selection.getRng();\n      return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);\n    };\n    const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);\n    const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));\n    const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => navigate(forward, editor.getBody(), from).bind(to => getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind(toCell => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));\n    const emptyElement = (editor, elm) => Optional.some(() => {\n      fillWithPaddingBr(elm);\n      editor.selection.setCursorLocation(elm.dom, 0);\n    });\n    const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind(first => lastPositionIn(fromCaption.dom).map(last => forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first))).getOr(true);\n    const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);\n    const validateCaretCaption = (rootElm, fromCaption, to) => getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(() => Optional.some(noop), toCaption => someIf(!eq(toCaption, fromCaption), noop));\n    const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), to => isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to));\n    const deleteCaretCells = (editor, forward, rootElm, startElm) => {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return getParentCell(rootElm, startElm).bind(fromCell => isEmpty$2(editor.schema, fromCell, { checkRootAsContent: false }) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from));\n    };\n    const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return isEmpty$2(editor.schema, fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);\n    };\n    const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);\n    const isBeforeOrAfterTable = (editor, forward) => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(pos => isNearTable(forward, pos));\n    };\n    const deleteCaret$3 = (editor, forward, startElm) => {\n      const rootElm = SugarElement.fromDom(editor.getBody());\n      return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), fromCaption => deleteCaretCaption(editor, forward, rootElm, fromCaption));\n    };\n    const backspaceDelete$b = (editor, forward) => {\n      const startElm = SugarElement.fromDom(editor.selection.getStart(true));\n      const cells = getCellsFromEditor(editor);\n      return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$3(editor, startElm, cells);\n    };\n\n    const getContentEditableRoot$1 = (root, node) => {\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$b(tempNode)) {\n          return tempNode;\n        }\n        tempNode = tempNode.parentNode;\n      }\n      return null;\n    };\n\n    const internalAttributesPrefixes = [\n      'data-ephox-',\n      'data-mce-',\n      'data-alloy-',\n      'data-snooker-',\n      '_'\n    ];\n    const each$9 = Tools.each;\n    const ElementUtils = editor => {\n      const dom = editor.dom;\n      const internalAttributes = new Set(editor.serializer.getTempAttrs());\n      const compare = (node1, node2) => {\n        if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) {\n          return false;\n        }\n        const getAttribs = node => {\n          const attribs = {};\n          each$9(dom.getAttribs(node), attr => {\n            const name = attr.nodeName.toLowerCase();\n            if (name !== 'style' && !isAttributeInternal(name)) {\n              attribs[name] = dom.getAttrib(node, name);\n            }\n          });\n          return attribs;\n        };\n        const compareObjects = (obj1, obj2) => {\n          for (const name in obj1) {\n            if (has$2(obj1, name)) {\n              const value = obj2[name];\n              if (isUndefined(value)) {\n                return false;\n              }\n              if (obj1[name] !== value) {\n                return false;\n              }\n              delete obj2[name];\n            }\n          }\n          for (const name in obj2) {\n            if (has$2(obj2, name)) {\n              return false;\n            }\n          }\n          return true;\n        };\n        if (isElement$6(node1) && isElement$6(node2)) {\n          if (!compareObjects(getAttribs(node1), getAttribs(node2))) {\n            return false;\n          }\n          if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {\n            return false;\n          }\n        }\n        return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);\n      };\n      const isAttributeInternal = attributeName => exists(internalAttributesPrefixes, value => startsWith(attributeName, value)) || internalAttributes.has(attributeName);\n      return {\n        compare,\n        isAttributeInternal\n      };\n    };\n\n    const isHeading = node => [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6'\n    ].includes(node.name);\n    const isSummary = node => node.name === 'summary';\n\n    const traverse = (root, fn) => {\n      let node = root;\n      while (node = node.walk()) {\n        fn(node);\n      }\n    };\n    const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {\n      const name = node.name;\n      for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {\n        const filter = nodeFilters[ni];\n        if (filter.name === name) {\n          const match = matches.nodes[name];\n          if (match) {\n            match.nodes.push(node);\n          } else {\n            matches.nodes[name] = {\n              filter,\n              nodes: [node]\n            };\n          }\n        }\n      }\n      if (node.attributes) {\n        for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {\n          const filter = attributeFilters[ai];\n          const attrName = filter.name;\n          if (attrName in node.attributes.map) {\n            const match = matches.attributes[attrName];\n            if (match) {\n              match.nodes.push(node);\n            } else {\n              matches.attributes[attrName] = {\n                filter,\n                nodes: [node]\n              };\n            }\n          }\n        }\n      }\n    };\n    const findMatchingNodes = (nodeFilters, attributeFilters, node) => {\n      const matches = {\n        nodes: {},\n        attributes: {}\n      };\n      if (node.firstChild) {\n        traverse(node, childNode => {\n          matchNode$1(nodeFilters, attributeFilters, childNode, matches);\n        });\n      }\n      return matches;\n    };\n    const runFilters = (matches, args) => {\n      const run = (matchRecord, filteringAttributes) => {\n        each$d(matchRecord, match => {\n          const nodes = from(match.nodes);\n          each$e(match.filter.callbacks, callback => {\n            for (let i = nodes.length - 1; i >= 0; i--) {\n              const node = nodes[i];\n              const valueMatches = filteringAttributes ? node.attr(match.filter.name) !== undefined : node.name === match.filter.name;\n              if (!valueMatches || isNullable(node.parent)) {\n                nodes.splice(i, 1);\n              }\n            }\n            if (nodes.length > 0) {\n              callback(nodes, match.filter.name, args);\n            }\n          });\n        });\n      };\n      run(matches.nodes, false);\n      run(matches.attributes, true);\n    };\n    const filter$2 = (nodeFilters, attributeFilters, node, args = {}) => {\n      const matches = findMatchingNodes(nodeFilters, attributeFilters, node);\n      runFilters(matches, args);\n    };\n\n    const paddEmptyNode = (settings, args, isBlock, node) => {\n      const brPreferred = settings.pad_empty_with_br || args.insert;\n      if (brPreferred && isBlock(node)) {\n        const astNode = new AstNode('br', 1);\n        if (args.insert) {\n          astNode.attr('data-mce-bogus', '1');\n        }\n        node.empty().append(astNode);\n      } else {\n        node.empty().append(new AstNode('#text', 3)).value = nbsp;\n      }\n    };\n    const isPaddedWithNbsp = node => {\n      var _a;\n      return hasOnlyChild(node, '#text') && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp;\n    };\n    const hasOnlyChild = (node, name) => {\n      const firstChild = node === null || node === void 0 ? void 0 : node.firstChild;\n      return isNonNullable(firstChild) && firstChild === node.lastChild && firstChild.name === name;\n    };\n    const isPadded = (schema, node) => {\n      const rule = schema.getElementRule(node.name);\n      return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;\n    };\n    const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, node => isPadded(schema, node));\n    const isLineBreakNode = (node, isBlock) => isNonNullable(node) && (isBlock(node) || node.name === 'br');\n    const findClosestEditingHost = scope => {\n      let editableNode;\n      for (let node = scope; node; node = node.parent) {\n        const contentEditable = node.attr('contenteditable');\n        if (contentEditable === 'false') {\n          break;\n        } else if (contentEditable === 'true') {\n          editableNode = node;\n        }\n      }\n      return Optional.from(editableNode);\n    };\n\n    const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {\n      if (schema.getSpecialElements()[node.name]) {\n        node.empty().remove();\n      } else {\n        const children = node.children();\n        for (const childNode of children) {\n          if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) {\n            removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);\n          }\n        }\n        node.unwrap();\n      }\n    };\n    const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop) => {\n      const textBlockElements = schema.getTextBlockElements();\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table,summary');\n      const fixed = new Set();\n      const isSplittableElement = node => node !== rootNode && !nonSplittableElements[node.name];\n      for (let ni = 0; ni < nodes.length; ni++) {\n        const node = nodes[ni];\n        let parent;\n        let newParent;\n        let tempNode;\n        if (!node.parent || fixed.has(node)) {\n          continue;\n        }\n        if (textBlockElements[node.name] && node.parent.name === 'li') {\n          let sibling = node.next;\n          while (sibling) {\n            if (textBlockElements[sibling.name]) {\n              sibling.name = 'li';\n              fixed.add(sibling);\n              node.parent.insert(sibling, node.parent);\n            } else {\n              break;\n            }\n            sibling = sibling.next;\n          }\n          node.unwrap();\n          continue;\n        }\n        const parents = [node];\n        for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && isSplittableElement(parent); parent = parent.parent) {\n          parents.push(parent);\n        }\n        if (parent && parents.length > 1) {\n          if (!isInvalid(schema, node, parent)) {\n            parents.reverse();\n            newParent = parents[0].clone();\n            onCreate(newParent);\n            let currentNode = newParent;\n            for (let i = 0; i < parents.length - 1; i++) {\n              if (schema.isValidChild(currentNode.name, parents[i].name) && i > 0) {\n                tempNode = parents[i].clone();\n                onCreate(tempNode);\n                currentNode.append(tempNode);\n              } else {\n                tempNode = currentNode;\n              }\n              for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {\n                const nextNode = childNode.next;\n                tempNode.append(childNode);\n                childNode = nextNode;\n              }\n              currentNode = tempNode;\n            }\n            if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {\n              parent.insert(newParent, parents[0], true);\n              parent.insert(node, newParent);\n            } else {\n              parent.insert(node, parents[0], true);\n            }\n            parent = parents[0];\n            if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {\n              parent.empty().remove();\n            }\n          } else {\n            removeOrUnwrapInvalidNode(node, schema);\n          }\n        } else if (node.parent) {\n          if (node.name === 'li') {\n            let sibling = node.prev;\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\n              sibling.append(node);\n              continue;\n            }\n            sibling = node.next;\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol') && sibling.firstChild) {\n              sibling.insert(node, sibling.firstChild, true);\n              continue;\n            }\n            const wrapper = new AstNode('ul', 1);\n            onCreate(wrapper);\n            node.wrap(wrapper);\n            continue;\n          }\n          if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {\n            const wrapper = new AstNode('div', 1);\n            onCreate(wrapper);\n            node.wrap(wrapper);\n          } else {\n            removeOrUnwrapInvalidNode(node, schema);\n          }\n        }\n      }\n    };\n    const hasClosest = (node, parentName) => {\n      let tempNode = node;\n      while (tempNode) {\n        if (tempNode.name === parentName) {\n          return true;\n        }\n        tempNode = tempNode.parent;\n      }\n      return false;\n    };\n    const isInvalid = (schema, node, parent = node.parent) => {\n      if (!parent) {\n        return false;\n      }\n      if (schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {\n        return true;\n      }\n      if (node.name === 'a' && hasClosest(parent, 'a')) {\n        return true;\n      }\n      if (isSummary(parent) && isHeading(node)) {\n        return !((parent === null || parent === void 0 ? void 0 : parent.firstChild) === node && (parent === null || parent === void 0 ? void 0 : parent.lastChild) === node);\n      }\n      return false;\n    };\n\n    const createRange = (sc, so, ec, eo) => {\n      const rng = document.createRange();\n      rng.setStart(sc, so);\n      rng.setEnd(ec, eo);\n      return rng;\n    };\n    const normalizeBlockSelectionRange = rng => {\n      const startPos = CaretPosition.fromRangeStart(rng);\n      const endPos = CaretPosition.fromRangeEnd(rng);\n      const rootNode = rng.commonAncestorContainer;\n      return fromPosition(false, rootNode, endPos).map(newEndPos => {\n        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {\n          return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());\n        } else {\n          return rng;\n        }\n      }).getOr(rng);\n    };\n    const normalize = rng => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);\n\n    const hasOnlyOneChild$1 = node => {\n      return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;\n    };\n    const isPaddingNode = node => {\n      return node.name === 'br' || node.value === nbsp;\n    };\n    const isPaddedEmptyBlock = (schema, node) => {\n      const blockElements = schema.getBlockElements();\n      return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);\n    };\n    const isEmptyFragmentElement = (schema, node) => {\n      const nonEmptyElements = schema.getNonEmptyElements();\n      return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));\n    };\n    const isListFragment = (schema, fragment) => {\n      let firstChild = fragment.firstChild;\n      let lastChild = fragment.lastChild;\n      if (firstChild && firstChild.name === 'meta') {\n        firstChild = firstChild.next;\n      }\n      if (lastChild && lastChild.attr('id') === 'mce_marker') {\n        lastChild = lastChild.prev;\n      }\n      if (isEmptyFragmentElement(schema, lastChild)) {\n        lastChild = lastChild === null || lastChild === void 0 ? void 0 : lastChild.prev;\n      }\n      if (!firstChild || firstChild !== lastChild) {\n        return false;\n      }\n      return firstChild.name === 'ul' || firstChild.name === 'ol';\n    };\n    const cleanupDomFragment = domFragment => {\n      var _a, _b;\n      const firstChild = domFragment.firstChild;\n      const lastChild = domFragment.lastChild;\n      if (firstChild && firstChild.nodeName === 'META') {\n        (_a = firstChild.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(firstChild);\n      }\n      if (lastChild && lastChild.id === 'mce_marker') {\n        (_b = lastChild.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(lastChild);\n      }\n      return domFragment;\n    };\n    const toDomFragment = (dom, serializer, fragment) => {\n      const html = serializer.serialize(fragment);\n      const domFragment = dom.createFragment(html);\n      return cleanupDomFragment(domFragment);\n    };\n    const listItems = elm => {\n      var _a;\n      return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], child => {\n        return child.nodeName === 'LI';\n      });\n    };\n    const isPadding = node => {\n      return node.data === nbsp || isBr$6(node);\n    };\n    const isListItemPadded = node => {\n      return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);\n    };\n    const isEmptyOrPadded = elm => {\n      return !elm.firstChild || isListItemPadded(elm);\n    };\n    const trimListItems = elms => {\n      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;\n    };\n    const getParentLi = (dom, node) => {\n      const parentBlock = dom.getParent(node, dom.isBlock);\n      return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;\n    };\n    const isParentBlockLi = (dom, node) => {\n      return !!getParentLi(dom, node);\n    };\n    const getSplit = (parentNode, rng) => {\n      const beforeRng = rng.cloneRange();\n      const afterRng = rng.cloneRange();\n      beforeRng.setStartBefore(parentNode);\n      afterRng.setEndAfter(parentNode);\n      return [\n        beforeRng.cloneContents(),\n        afterRng.cloneContents()\n      ];\n    };\n    const findFirstIn = (node, rootNode) => {\n      const caretPos = CaretPosition.before(node);\n      const caretWalker = CaretWalker(rootNode);\n      const newCaretPos = caretWalker.next(caretPos);\n      return newCaretPos ? newCaretPos.toRange() : null;\n    };\n    const findLastOf = (node, rootNode) => {\n      const caretPos = CaretPosition.after(node);\n      const caretWalker = CaretWalker(rootNode);\n      const newCaretPos = caretWalker.prev(caretPos);\n      return newCaretPos ? newCaretPos.toRange() : null;\n    };\n    const insertMiddle = (target, elms, rootNode, rng) => {\n      const parts = getSplit(target, rng);\n      const parentElm = target.parentNode;\n      if (parentElm) {\n        parentElm.insertBefore(parts[0], target);\n        Tools.each(elms, li => {\n          parentElm.insertBefore(li, target);\n        });\n        parentElm.insertBefore(parts[1], target);\n        parentElm.removeChild(target);\n      }\n      return findLastOf(elms[elms.length - 1], rootNode);\n    };\n    const insertBefore$2 = (target, elms, rootNode) => {\n      const parentElm = target.parentNode;\n      if (parentElm) {\n        Tools.each(elms, elm => {\n          parentElm.insertBefore(elm, target);\n        });\n      }\n      return findFirstIn(target, rootNode);\n    };\n    const insertAfter$2 = (target, elms, rootNode, dom) => {\n      dom.insertAfter(elms.reverse(), target);\n      return findLastOf(elms[0], rootNode);\n    };\n    const insertAtCaret$1 = (serializer, dom, rng, fragment) => {\n      const domFragment = toDomFragment(dom, serializer, fragment);\n      const liTarget = getParentLi(dom, rng.startContainer);\n      const liElms = trimListItems(listItems(domFragment.firstChild));\n      const BEGINNING = 1, END = 2;\n      const rootNode = dom.getRoot();\n      const isAt = location => {\n        const caretPos = CaretPosition.fromRangeStart(rng);\n        const caretWalker = CaretWalker(dom.getRoot());\n        const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);\n        const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();\n        return newPosNode ? getParentLi(dom, newPosNode) !== liTarget : true;\n      };\n      if (!liTarget) {\n        return null;\n      } else if (isAt(BEGINNING)) {\n        return insertBefore$2(liTarget, liElms, rootNode);\n      } else if (isAt(END)) {\n        return insertAfter$2(liTarget, liElms, rootNode, dom);\n      } else {\n        return insertMiddle(liTarget, liElms, rootNode, rng);\n      }\n    };\n\n    const mergeableWrappedElements = ['pre'];\n    const shouldPasteContentOnly = (dom, fragment, parentNode, root) => {\n      var _a;\n      const firstNode = fragment.firstChild;\n      const lastNode = fragment.lastChild;\n      const last = lastNode.attr('data-mce-type') === 'bookmark' ? lastNode.prev : lastNode;\n      const isPastingSingleElement = firstNode === last;\n      const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);\n      if (isPastingSingleElement && isWrappedElement) {\n        const isContentEditable = firstNode.attr('contenteditable') !== 'false';\n        const isPastingInTheSameBlockTag = ((_a = dom.getParent(parentNode, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;\n        const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root, parentNode)).forall(isContentEditableTrue$3);\n        return isContentEditable && isPastingInTheSameBlockTag && isPastingInContentEditable;\n      } else {\n        return false;\n      }\n    };\n    const isTableCell = isTableCell$3;\n    const isTableCellContentSelected = (dom, rng, cell) => {\n      if (isNonNullable(cell)) {\n        const endCell = dom.getParent(rng.endContainer, isTableCell);\n        return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);\n      } else {\n        return false;\n      }\n    };\n    const validInsertion = (editor, value, parentNode) => {\n      var _a;\n      if (parentNode.getAttribute('data-mce-bogus') === 'all') {\n        (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(editor.dom.createFragment(value), parentNode);\n      } else {\n        const node = parentNode.firstChild;\n        const node2 = parentNode.lastChild;\n        if (!node || node === node2 && node.nodeName === 'BR') {\n          editor.dom.setHTML(parentNode, value);\n        } else {\n          editor.selection.setContent(value, { no_events: true });\n        }\n      }\n    };\n    const trimBrsFromTableCell = (dom, elm, schema) => {\n      Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(el => trimBlockTrailingBr(el, schema));\n    };\n    const reduceInlineTextElements = (editor, merge) => {\n      const textInlineElements = editor.schema.getTextInlineElements();\n      const dom = editor.dom;\n      if (merge) {\n        const root = editor.getBody();\n        const elementUtils = ElementUtils(editor);\n        const fragmentSelector = '*[data-mce-fragment]';\n        const fragments = dom.select(fragmentSelector);\n        Tools.each(fragments, node => {\n          const isInline = currentNode => isNonNullable(textInlineElements[currentNode.nodeName.toLowerCase()]);\n          const hasOneChild = currentNode => currentNode.childNodes.length === 1;\n          const hasNoNonInheritableStyles = currentNode => !(hasNonInheritableStyles(dom, currentNode) || hasConditionalNonInheritableStyles(dom, currentNode));\n          if (hasNoNonInheritableStyles(node) && isInline(node) && hasOneChild(node)) {\n            const styles = getStyleProps(dom, node);\n            const isOverridden = (oldStyles, newStyles) => forall(oldStyles, style => contains$2(newStyles, style));\n            const overriddenByAllChildren = childNode => hasOneChild(node) && dom.is(childNode, fragmentSelector) && isInline(childNode) && (childNode.nodeName === node.nodeName && isOverridden(styles, getStyleProps(dom, childNode)) || overriddenByAllChildren(childNode.children[0]));\n            const identicalToParent = parentNode => isNonNullable(parentNode) && parentNode !== root && (elementUtils.compare(node, parentNode) || identicalToParent(parentNode.parentElement));\n            const conflictWithInsertedParent = parentNode => isNonNullable(parentNode) && parentNode !== root && dom.is(parentNode, fragmentSelector) && (hasStyleConflict(dom, node, parentNode) || conflictWithInsertedParent(parentNode.parentElement));\n            if (overriddenByAllChildren(node.children[0]) || identicalToParent(node.parentElement) && !conflictWithInsertedParent(node.parentElement)) {\n              dom.remove(node, true);\n            }\n          }\n        });\n      }\n    };\n    const markFragmentElements = fragment => {\n      let node = fragment;\n      while (node = node.walk()) {\n        if (node.type === 1) {\n          node.attr('data-mce-fragment', '1');\n        }\n      }\n    };\n    const unmarkFragmentElements = elm => {\n      Tools.each(elm.getElementsByTagName('*'), elm => {\n        elm.removeAttribute('data-mce-fragment');\n      });\n    };\n    const isPartOfFragment = node => {\n      return !!node.getAttribute('data-mce-fragment');\n    };\n    const canHaveChildren = (editor, node) => {\n      return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];\n    };\n    const moveSelectionToMarker = (editor, marker) => {\n      var _a, _b, _c;\n      let nextRng;\n      const dom = editor.dom;\n      const selection = editor.selection;\n      if (!marker) {\n        return;\n      }\n      selection.scrollIntoView(marker);\n      const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);\n      if (parentEditableElm && dom.getContentEditable(parentEditableElm) === 'false') {\n        dom.remove(marker);\n        selection.select(parentEditableElm);\n        return;\n      }\n      let rng = dom.createRng();\n      const node = marker.previousSibling;\n      if (isText$b(node)) {\n        rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n        const node2 = marker.nextSibling;\n        if (isText$b(node2)) {\n          node.appendData(node2.data);\n          (_c = node2.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node2);\n        }\n      } else {\n        rng.setStartBefore(marker);\n        rng.setEndBefore(marker);\n      }\n      const findNextCaretRng = rng => {\n        let caretPos = CaretPosition.fromRangeStart(rng);\n        const caretWalker = CaretWalker(editor.getBody());\n        caretPos = caretWalker.next(caretPos);\n        return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();\n      };\n      const parentBlock = dom.getParent(marker, dom.isBlock);\n      dom.remove(marker);\n      if (parentBlock && dom.isEmpty(parentBlock)) {\n        const isCell = isTableCell(parentBlock);\n        empty(SugarElement.fromDom(parentBlock));\n        rng.setStart(parentBlock, 0);\n        rng.setEnd(parentBlock, 0);\n        if (!isCell && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {\n          rng = nextRng;\n          dom.remove(parentBlock);\n        } else {\n          dom.add(parentBlock, dom.create('br', isCell ? {} : { 'data-mce-bogus': '1' }));\n        }\n      }\n      selection.setRng(rng);\n    };\n    const deleteSelectedContent = editor => {\n      const dom = editor.dom;\n      const rng = normalize(editor.selection.getRng());\n      editor.selection.setRng(rng);\n      const startCell = dom.getParent(rng.startContainer, isTableCell);\n      if (isTableCellContentSelected(dom, rng, startCell)) {\n        deleteCellContents(editor, rng, SugarElement.fromDom(startCell));\n      } else if (rng.startContainer === rng.endContainer && rng.endOffset - rng.startOffset === 1 && isText$b(rng.startContainer.childNodes[rng.startOffset])) {\n        rng.deleteContents();\n      } else {\n        editor.getDoc().execCommand('Delete', false);\n      }\n    };\n    const findMarkerNode = scope => {\n      for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {\n        if (markerNode.attr('id') === 'mce_marker') {\n          return Optional.some(markerNode);\n        }\n      }\n      return Optional.none();\n    };\n    const notHeadingsInSummary = (dom, node, fragment) => {\n      var _a;\n      return exists(fragment.children(), isHeading) && ((_a = dom.getParent(node, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName) === 'SUMMARY';\n    };\n    const insertHtmlAtCaret = (editor, value, details) => {\n      var _a, _b;\n      const selection = editor.selection;\n      const dom = editor.dom;\n      const parser = editor.parser;\n      const merge = details.merge;\n      const serializer = HtmlSerializer({ validate: true }, editor.schema);\n      const bookmarkHtml = '<span id=\"mce_marker\" data-mce-type=\"bookmark\">&#xFEFF;</span>';\n      if (!details.preserve_zwsp) {\n        value = trim$2(value);\n      }\n      if (value.indexOf('{$caret}') === -1) {\n        value += '{$caret}';\n      }\n      value = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\n      let rng = selection.getRng();\n      const caretElement = rng.startContainer;\n      const body = editor.getBody();\n      if (caretElement === body && selection.isCollapsed()) {\n        if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {\n          rng = dom.createRng();\n          rng.setStart(body.firstChild, 0);\n          rng.setEnd(body.firstChild, 0);\n          selection.setRng(rng);\n        }\n      }\n      if (!selection.isCollapsed()) {\n        deleteSelectedContent(editor);\n      }\n      const parentNode = selection.getNode();\n      const parserArgs = {\n        context: parentNode.nodeName.toLowerCase(),\n        data: details.data,\n        insert: true\n      };\n      const fragment = parser.parse(value, parserArgs);\n      if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {\n        rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);\n        if (rng) {\n          selection.setRng(rng);\n        }\n        return value;\n      }\n      if (details.paste === true && shouldPasteContentOnly(dom, fragment, parentNode, editor.getBody())) {\n        (_a = fragment.firstChild) === null || _a === void 0 ? void 0 : _a.unwrap();\n      }\n      markFragmentElements(fragment);\n      let node = fragment.lastChild;\n      if (node && node.attr('id') === 'mce_marker') {\n        const marker = node;\n        for (node = node.prev; node; node = node.walk(true)) {\n          if (node.type === 3 || !dom.isBlock(node.name)) {\n            if (node.parent && editor.schema.isValidChild(node.parent.name, 'span')) {\n              node.parent.insert(marker, node, node.name === 'br');\n            }\n            break;\n          }\n        }\n      }\n      editor._selectionOverrides.showBlockCaretContainer(parentNode);\n      if (!parserArgs.invalid && !notHeadingsInSummary(dom, parentNode, fragment)) {\n        value = serializer.serialize(fragment);\n        validInsertion(editor, value, parentNode);\n      } else {\n        editor.selection.setContent(bookmarkHtml);\n        let parentNode = selection.getNode();\n        let tempNode;\n        const rootNode = editor.getBody();\n        if (isDocument$1(parentNode)) {\n          parentNode = tempNode = rootNode;\n        } else {\n          tempNode = parentNode;\n        }\n        while (tempNode && tempNode !== rootNode) {\n          parentNode = tempNode;\n          tempNode = tempNode.parentNode;\n        }\n        value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\n        const root = parser.parse(value);\n        const markerNode = findMarkerNode(root);\n        const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);\n        markerNode.each(marker => marker.replace(fragment));\n        const toExtract = fragment.children();\n        const parent = (_b = fragment.parent) !== null && _b !== void 0 ? _b : root;\n        fragment.unwrap();\n        const invalidChildren = filter$5(toExtract, node => isInvalid(editor.schema, node, parent));\n        cleanInvalidNodes(invalidChildren, editor.schema, editingHost);\n        filter$2(parser.getNodeFilters(), parser.getAttributeFilters(), root);\n        value = serializer.serialize(root);\n        if (parentNode === rootNode) {\n          dom.setHTML(rootNode, value);\n        } else {\n          dom.setOuterHTML(parentNode, value);\n        }\n      }\n      reduceInlineTextElements(editor, merge);\n      moveSelectionToMarker(editor, dom.get('mce_marker'));\n      unmarkFragmentElements(editor.getBody());\n      trimBrsFromTableCell(dom, selection.getStart(), editor.schema);\n      updateCaret(editor.schema, editor.getBody(), selection.getStart());\n      return value;\n    };\n\n    const isTreeNode = content => content instanceof AstNode;\n\n    const moveSelection = editor => {\n      if (hasFocus(editor)) {\n        firstPositionIn(editor.getBody()).each(pos => {\n          const node = pos.getNode();\n          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\n          editor.selection.setRng(caretPos.toRange());\n        });\n      }\n    };\n    const setEditorHtml = (editor, html, noSelection) => {\n      editor.dom.setHTML(editor.getBody(), html);\n      if (noSelection !== true) {\n        moveSelection(editor);\n      }\n    };\n    const setContentString = (editor, body, content, args) => {\n      content = trim$2(content);\n      if (content.length === 0 || /^\\s+$/.test(content)) {\n        const padd = '<br data-mce-bogus=\"1\">';\n        if (body.nodeName === 'TABLE') {\n          content = '<tr><td>' + padd + '</td></tr>';\n        } else if (/^(UL|OL)$/.test(body.nodeName)) {\n          content = '<li>' + padd + '</li>';\n        }\n        const forcedRootBlockName = getForcedRootBlock(editor);\n        if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {\n          content = padd;\n          content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);\n        } else if (!content) {\n          content = padd;\n        }\n        setEditorHtml(editor, content, args.no_selection);\n        return {\n          content,\n          html: content\n        };\n      } else {\n        if (args.format !== 'raw') {\n          content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, {\n            isRootContent: true,\n            insert: true\n          }));\n        }\n        const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);\n        setEditorHtml(editor, trimmedHtml, args.no_selection);\n        return {\n          content: trimmedHtml,\n          html: trimmedHtml\n        };\n      }\n    };\n    const setContentTree = (editor, body, content, args) => {\n      filter$2(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);\n      const html = HtmlSerializer({ validate: false }, editor.schema).serialize(content);\n      const trimmedHtml = trim$2(isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html));\n      setEditorHtml(editor, trimmedHtml, args.no_selection);\n      return {\n        content,\n        html: trimmedHtml\n      };\n    };\n    const setContentInternal = (editor, content, args) => {\n      return Optional.from(editor.getBody()).map(body => {\n        if (isTreeNode(content)) {\n          return setContentTree(editor, body, content, args);\n        } else {\n          return setContentString(editor, body, content, args);\n        }\n      }).getOr({\n        content,\n        html: isTreeNode(args.content) ? '' : args.content\n      });\n    };\n\n    const ensureIsRoot = isRoot => isFunction(isRoot) ? isRoot : never;\n    const ancestor = (scope, transform, isRoot) => {\n      let element = scope.dom;\n      const stop = ensureIsRoot(isRoot);\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        const transformed = transform(el);\n        if (transformed.isSome()) {\n          return transformed;\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$1 = (scope, transform, isRoot) => {\n      const current = transform(scope);\n      const stop = ensureIsRoot(isRoot);\n      return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));\n    };\n\n    const isEq$3 = isEq$5;\n    const matchesUnInheritedFormatSelector = (ed, node, name) => {\n      const formatList = ed.formatter.get(name);\n      if (formatList) {\n        for (let i = 0; i < formatList.length; i++) {\n          const format = formatList[i];\n          if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const matchParents = (editor, node, name, vars, similar) => {\n      const root = editor.dom.getRoot();\n      if (node === root) {\n        return false;\n      }\n      const matchedNode = editor.dom.getParent(node, elm => {\n        if (matchesUnInheritedFormatSelector(editor, elm, name)) {\n          return true;\n        }\n        return elm.parentNode === root || !!matchNode(editor, elm, name, vars, true);\n      });\n      return !!matchNode(editor, matchedNode, name, vars, similar);\n    };\n    const matchName = (dom, node, format) => {\n      if (isInlineFormat(format) && isEq$3(node, format.inline)) {\n        return true;\n      }\n      if (isBlockFormat(format) && isEq$3(node, format.block)) {\n        return true;\n      }\n      if (isSelectorFormat(format)) {\n        return isElement$6(node) && dom.is(node, format.selector);\n      }\n      return false;\n    };\n    const matchItems = (dom, node, format, itemName, similar, vars) => {\n      const items = format[itemName];\n      const matchAttributes = itemName === 'attributes';\n      if (isFunction(format.onmatch)) {\n        return format.onmatch(node, format, itemName);\n      }\n      if (items) {\n        if (!isArrayLike(items)) {\n          for (const key in items) {\n            if (has$2(items, key)) {\n              const value = matchAttributes ? dom.getAttrib(node, key) : getStyle(dom, node, key);\n              const expectedValue = replaceVars(items[key], vars);\n              const isEmptyValue = isNullable(value) || isEmpty$3(value);\n              if (isEmptyValue && isNullable(expectedValue)) {\n                continue;\n              }\n              if (similar && isEmptyValue && !format.exact) {\n                return false;\n              }\n              if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {\n                return false;\n              }\n            }\n          }\n        } else {\n          for (let i = 0; i < items.length; i++) {\n            if (matchAttributes ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {\n              return true;\n            }\n          }\n        }\n      }\n      return true;\n    };\n    const matchNode = (ed, node, name, vars, similar) => {\n      const formatList = ed.formatter.get(name);\n      const dom = ed.dom;\n      if (formatList && isElement$6(node)) {\n        for (let i = 0; i < formatList.length; i++) {\n          const format = formatList[i];\n          if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {\n            const classes = format.classes;\n            if (classes) {\n              for (let x = 0; x < classes.length; x++) {\n                if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {\n                  return;\n                }\n              }\n            }\n            return format;\n          }\n        }\n      }\n      return undefined;\n    };\n    const match$2 = (editor, name, vars, node, similar) => {\n      if (node) {\n        return matchParents(editor, node, name, vars, similar);\n      }\n      node = editor.selection.getNode();\n      if (matchParents(editor, node, name, vars, similar)) {\n        return true;\n      }\n      const startNode = editor.selection.getStart();\n      if (startNode !== node) {\n        if (matchParents(editor, startNode, name, vars, similar)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const matchAll = (editor, names, vars) => {\n      const matchedFormatNames = [];\n      const checkedMap = {};\n      const startElement = editor.selection.getStart();\n      editor.dom.getParent(startElement, node => {\n        for (let i = 0; i < names.length; i++) {\n          const name = names[i];\n          if (!checkedMap[name] && matchNode(editor, node, name, vars)) {\n            checkedMap[name] = true;\n            matchedFormatNames.push(name);\n          }\n        }\n      }, editor.dom.getRoot());\n      return matchedFormatNames;\n    };\n    const closest = (editor, names) => {\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n      const match = (elm, name) => matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();\n      return Optional.from(editor.selection.getStart(true)).bind(rawElm => closest$1(SugarElement.fromDom(rawElm), elm => findMap(names, name => match(elm, name)), isRoot)).getOrNull();\n    };\n    const canApply = (editor, name) => {\n      const formatList = editor.formatter.get(name);\n      const dom = editor.dom;\n      if (formatList && editor.selection.isEditable()) {\n        const startNode = editor.selection.getStart();\n        const parents = getParents$2(dom, startNode);\n        for (let x = formatList.length - 1; x >= 0; x--) {\n          const format = formatList[x];\n          if (!isSelectorFormat(format)) {\n            return true;\n          }\n          for (let i = parents.length - 1; i >= 0; i--) {\n            if (dom.is(parents[i], format.selector)) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n    const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {\n      const matchSimilar = isVariableFormatName(editor, name);\n      if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {\n        return acc.concat([name]);\n      } else {\n        return acc;\n      }\n    }, []);\n\n    const ZWSP = ZWSP$1;\n    const importNode = (ownerDocument, node) => {\n      return ownerDocument.importNode(node, true);\n    };\n    const findFirstTextNode = node => {\n      if (node) {\n        const walker = new DomTreeWalker(node, node);\n        for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) {\n          if (isText$b(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      return null;\n    };\n    const createCaretContainer = fill => {\n      const caretContainer = SugarElement.fromTag('span');\n      setAll$1(caretContainer, {\n        'id': CARET_ID,\n        'data-mce-bogus': '1',\n        'data-mce-type': 'format-caret'\n      });\n      if (fill) {\n        append$1(caretContainer, SugarElement.fromText(ZWSP));\n      }\n      return caretContainer;\n    };\n    const trimZwspFromCaretContainer = caretContainerNode => {\n      const textNode = findFirstTextNode(caretContainerNode);\n      if (textNode && textNode.data.charAt(0) === ZWSP) {\n        textNode.deleteData(0, 1);\n      }\n      return textNode;\n    };\n    const removeCaretContainerNode = (editor, node, moveCaret) => {\n      const dom = editor.dom, selection = editor.selection;\n      if (isCaretContainerEmpty(node)) {\n        deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret, true);\n      } else {\n        const rng = selection.getRng();\n        const block = dom.getParent(node, dom.isBlock);\n        const startContainer = rng.startContainer;\n        const startOffset = rng.startOffset;\n        const endContainer = rng.endContainer;\n        const endOffset = rng.endOffset;\n        const textNode = trimZwspFromCaretContainer(node);\n        dom.remove(node, true);\n        if (startContainer === textNode && startOffset > 0) {\n          rng.setStart(textNode, startOffset - 1);\n        }\n        if (endContainer === textNode && endOffset > 0) {\n          rng.setEnd(textNode, endOffset - 1);\n        }\n        if (block && dom.isEmpty(block)) {\n          fillWithPaddingBr(SugarElement.fromDom(block));\n        }\n        selection.setRng(rng);\n      }\n    };\n    const removeCaretContainer = (editor, node, moveCaret) => {\n      const dom = editor.dom, selection = editor.selection;\n      if (!node) {\n        node = getParentCaretContainer(editor.getBody(), selection.getStart());\n        if (!node) {\n          while (node = dom.get(CARET_ID)) {\n            removeCaretContainerNode(editor, node, moveCaret);\n          }\n        }\n      } else {\n        removeCaretContainerNode(editor, node, moveCaret);\n      }\n    };\n    const insertCaretContainerNode = (editor, caretContainer, formatNode) => {\n      var _a, _b;\n      const dom = editor.dom;\n      const block = dom.getParent(formatNode, curry(isTextBlock$1, editor.schema));\n      if (block && dom.isEmpty(block)) {\n        (_a = formatNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(caretContainer, formatNode);\n      } else {\n        removeTrailingBr(SugarElement.fromDom(formatNode));\n        if (dom.isEmpty(formatNode)) {\n          (_b = formatNode.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(caretContainer, formatNode);\n        } else {\n          dom.insertAfter(caretContainer, formatNode);\n        }\n      }\n    };\n    const appendNode = (parentNode, node) => {\n      parentNode.appendChild(node);\n      return node;\n    };\n    const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {\n      var _a;\n      const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {\n        return appendNode(parentNode, formatNode.cloneNode(false));\n      }, caretContainer);\n      const doc = (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));\n    };\n    const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {\n      const formatter = editor.formatter;\n      const dom = editor.dom;\n      const validFormats = filter$5(keys(formatter.get()), formatName => formatName !== name && !contains$1(formatName, 'removeformat'));\n      const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);\n      const uniqueFormats = filter$5(matchedFormats, fmtName => !areSimilarFormats(editor, fmtName, name));\n      if (uniqueFormats.length > 0) {\n        const clonedFormatNode = formatNode.cloneNode(false);\n        dom.add(caretContainer, clonedFormatNode);\n        formatter.remove(name, vars, clonedFormatNode, similar);\n        dom.remove(clonedFormatNode);\n        return Optional.some(clonedFormatNode);\n      } else {\n        return Optional.none();\n      }\n    };\n    const applyCaretFormat = (editor, name, vars) => {\n      let caretContainer;\n      const selection = editor.selection;\n      const formatList = editor.formatter.get(name);\n      if (!formatList) {\n        return;\n      }\n      const selectionRng = selection.getRng();\n      let offset = selectionRng.startOffset;\n      const container = selectionRng.startContainer;\n      const text = container.nodeValue;\n      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());\n      const wordcharRegex = /[^\\s\\u00a0\\u00ad\\u200b\\ufeff]/;\n      if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {\n        const bookmark = selection.getBookmark();\n        selectionRng.collapse(true);\n        let rng = expandRng(editor.dom, selectionRng, formatList);\n        rng = split(rng);\n        editor.formatter.apply(name, vars, rng);\n        selection.moveToBookmark(bookmark);\n      } else {\n        let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;\n        if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {\n          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);\n          textNode = caretContainer.firstChild;\n          selectionRng.insertNode(caretContainer);\n          offset = 1;\n          editor.formatter.apply(name, vars, caretContainer);\n        } else {\n          editor.formatter.apply(name, vars, caretContainer);\n        }\n        selection.setCursorLocation(textNode, offset);\n      }\n    };\n    const removeCaretFormat = (editor, name, vars, similar) => {\n      const dom = editor.dom;\n      const selection = editor.selection;\n      let hasContentAfter = false;\n      const formatList = editor.formatter.get(name);\n      if (!formatList) {\n        return;\n      }\n      const rng = selection.getRng();\n      const container = rng.startContainer;\n      const offset = rng.startOffset;\n      let node = container;\n      if (isText$b(container)) {\n        if (offset !== container.data.length) {\n          hasContentAfter = true;\n        }\n        node = node.parentNode;\n      }\n      const parents = [];\n      let formatNode;\n      while (node) {\n        if (matchNode(editor, node, name, vars, similar)) {\n          formatNode = node;\n          break;\n        }\n        if (node.nextSibling) {\n          hasContentAfter = true;\n        }\n        parents.push(node);\n        node = node.parentNode;\n      }\n      if (!formatNode) {\n        return;\n      }\n      if (hasContentAfter) {\n        const bookmark = selection.getBookmark();\n        rng.collapse(true);\n        let expandedRng = expandRng(dom, rng, formatList, true);\n        expandedRng = split(expandedRng);\n        editor.formatter.remove(name, vars, expandedRng, similar);\n        selection.moveToBookmark(bookmark);\n      } else {\n        const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);\n        const parentsAfter = isNonNullable(caretContainer) ? dom.getParents(formatNode.parentNode, always, caretContainer) : [];\n        const newCaretContainer = createCaretContainer(false).dom;\n        insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);\n        const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);\n        const caretTextNode = insertFormatNodesIntoCaretContainer([\n          ...parents,\n          ...cleanedFormatNode.toArray(),\n          ...parentsAfter\n        ], newCaretContainer);\n        if (caretContainer) {\n          removeCaretContainerNode(editor, caretContainer, isNonNullable(caretContainer));\n        }\n        selection.setCursorLocation(caretTextNode, 1);\n        if (dom.isEmpty(formatNode)) {\n          dom.remove(formatNode);\n        }\n      }\n    };\n    const disableCaretContainer = (editor, keyCode, moveCaret) => {\n      const selection = editor.selection, body = editor.getBody();\n      removeCaretContainer(editor, null, moveCaret);\n      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\n      }\n      if (keyCode === 37 || keyCode === 39) {\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\n      }\n    };\n    const endsWithNbsp = element => isText$b(element) && endsWith(element.data, nbsp);\n    const setup$v = editor => {\n      editor.on('mouseup keydown', e => {\n        disableCaretContainer(editor, e.keyCode, endsWithNbsp(editor.selection.getRng().endContainer));\n      });\n    };\n    const createCaretFormat = formatNodes => {\n      const caretContainer = createCaretContainer(false);\n      const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);\n      return {\n        caretContainer,\n        caretPosition: CaretPosition(innerMost, 0)\n      };\n    };\n    const replaceWithCaretFormat = (targetNode, formatNodes) => {\n      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);\n      before$3(SugarElement.fromDom(targetNode), caretContainer);\n      remove$4(SugarElement.fromDom(targetNode));\n      return caretPosition;\n    };\n    const createCaretFormatAtStart$1 = (rng, formatNodes) => {\n      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);\n      rng.insertNode(caretContainer.dom);\n      return caretPosition;\n    };\n    const isFormatElement = (editor, element) => {\n      if (isCaretNode(element.dom)) {\n        return false;\n      }\n      const inlineElements = editor.schema.getTextInlineElements();\n      return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$1(element.dom);\n    };\n\n    const postProcessHooks = {};\n    const isPre = matchNodeNames(['pre']);\n    const addPostProcessHook = (name, hook) => {\n      const hooks = postProcessHooks[name];\n      if (!hooks) {\n        postProcessHooks[name] = [];\n      }\n      postProcessHooks[name].push(hook);\n    };\n    const postProcess$1 = (name, editor) => {\n      if (has$2(postProcessHooks, name)) {\n        each$e(postProcessHooks[name], hook => {\n          hook(editor);\n        });\n      }\n    };\n    addPostProcessHook('pre', editor => {\n      const rng = editor.selection.getRng();\n      const hasPreSibling = blocks => pre => {\n        const prev = pre.previousSibling;\n        return isPre(prev) && contains$2(blocks, prev);\n      };\n      const joinPre = (pre1, pre2) => {\n        const sPre2 = SugarElement.fromDom(pre2);\n        const doc = documentOrOwner(sPre2).dom;\n        remove$4(sPre2);\n        append(SugarElement.fromDom(pre1), [\n          SugarElement.fromTag('br', doc),\n          SugarElement.fromTag('br', doc),\n          ...children$1(sPre2)\n        ]);\n      };\n      if (!rng.collapsed) {\n        const blocks = editor.selection.getSelectedBlocks();\n        const preBlocks = filter$5(filter$5(blocks, isPre), hasPreSibling(blocks));\n        each$e(preBlocks, pre => {\n          joinPre(pre.previousSibling, pre);\n        });\n      }\n    });\n\n    const listItemStyles = [\n      'fontWeight',\n      'fontStyle',\n      'color',\n      'fontSize',\n      'fontFamily'\n    ];\n    const hasListStyles = fmt => isObject(fmt.styles) && exists(keys(fmt.styles), name => contains$2(listItemStyles, name));\n    const findExpandedListItemFormat = formats => find$2(formats, fmt => isInlineFormat(fmt) && fmt.inline === 'span' && hasListStyles(fmt));\n    const getExpandedListItemFormat = (formatter, format) => {\n      const formatList = formatter.get(format);\n      return isArray$1(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();\n    };\n    const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();\n    const isRngEndAtEndOfElement = (rng, elm) => {\n      return nextPosition(elm, CaretPosition.fromRangeEnd(rng)).exists(pos => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;\n    };\n    const isEditableListItem = dom => elm => isListItem$2(elm) && dom.isEditable(elm);\n    const getFullySelectedBlocks = selection => {\n      const blocks = selection.getSelectedBlocks();\n      const rng = selection.getRng();\n      if (selection.isCollapsed()) {\n        return [];\n      }\n      if (blocks.length === 1) {\n        return isRngStartAtStartOfElement(rng, blocks[0]) && isRngEndAtEndOfElement(rng, blocks[0]) ? blocks : [];\n      } else {\n        const first = head(blocks).filter(elm => isRngStartAtStartOfElement(rng, elm)).toArray();\n        const last = last$2(blocks).filter(elm => isRngEndAtEndOfElement(rng, elm)).toArray();\n        const middle = blocks.slice(1, -1);\n        return first.concat(middle).concat(last);\n      }\n    };\n    const getFullySelectedListItems = selection => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));\n    const getPartiallySelectedListItems = selection => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));\n\n    const each$8 = Tools.each;\n    const isElementNode = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$1(node);\n    const findElementSibling = (node, siblingName) => {\n      for (let sibling = node; sibling; sibling = sibling[siblingName]) {\n        if (isText$b(sibling) && isNotEmpty(sibling.data)) {\n          return node;\n        }\n        if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {\n          return sibling;\n        }\n      }\n      return node;\n    };\n    const mergeSiblingsNodes = (editor, prev, next) => {\n      const elementUtils = ElementUtils(editor);\n      const isPrevEditable = isHTMLElement(prev) && editor.dom.isEditable(prev);\n      const isNextEditable = isHTMLElement(next) && editor.dom.isEditable(next);\n      if (isPrevEditable && isNextEditable) {\n        const prevSibling = findElementSibling(prev, 'previousSibling');\n        const nextSibling = findElementSibling(next, 'nextSibling');\n        if (elementUtils.compare(prevSibling, nextSibling)) {\n          for (let sibling = prevSibling.nextSibling; sibling && sibling !== nextSibling;) {\n            const tmpSibling = sibling;\n            sibling = sibling.nextSibling;\n            prevSibling.appendChild(tmpSibling);\n          }\n          editor.dom.remove(nextSibling);\n          Tools.each(Tools.grep(nextSibling.childNodes), node => {\n            prevSibling.appendChild(node);\n          });\n          return prevSibling;\n        }\n      }\n      return next;\n    };\n    const mergeSiblings = (editor, format, vars, node) => {\n      var _a;\n      if (node && format.merge_siblings !== false) {\n        const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;\n        mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));\n      }\n    };\n    const clearChildStyles = (dom, format, node) => {\n      if (format.clear_child_styles) {\n        const selector = format.links ? '*:not(a)' : '*';\n        each$8(dom.select(selector, node), childNode => {\n          if (isElementNode(childNode) && dom.isEditable(childNode)) {\n            each$8(format.styles, (_value, name) => {\n              dom.setStyle(childNode, name, '');\n            });\n          }\n        });\n      }\n    };\n    const processChildElements = (node, filter, process) => {\n      each$8(node.childNodes, node => {\n        if (isElementNode(node)) {\n          if (filter(node)) {\n            process(node);\n          }\n          if (node.hasChildNodes()) {\n            processChildElements(node, filter, process);\n          }\n        }\n      });\n    };\n    const unwrapEmptySpan = (dom, node) => {\n      if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {\n        dom.remove(node, true);\n      }\n    };\n    const hasStyle = (dom, name) => node => !!(node && getStyle(dom, node, name));\n    const applyStyle = (dom, name, value) => node => {\n      dom.setStyle(node, name, value);\n      if (node.getAttribute('style') === '') {\n        node.removeAttribute('style');\n      }\n      unwrapEmptySpan(dom, node);\n    };\n\n    const removeResult = Adt.generate([\n      { keep: [] },\n      { rename: ['name'] },\n      { removed: [] }\n    ]);\n    const MCE_ATTR_RE = /^(src|href|style)$/;\n    const each$7 = Tools.each;\n    const isEq$2 = isEq$5;\n    const isTableCellOrRow = node => /^(TR|TH|TD)$/.test(node.nodeName);\n    const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);\n    const getContainer = (ed, rng, start) => {\n      let container = rng[start ? 'startContainer' : 'endContainer'];\n      let offset = rng[start ? 'startOffset' : 'endOffset'];\n      if (isElement$6(container)) {\n        const lastIdx = container.childNodes.length - 1;\n        if (!start && offset) {\n          offset--;\n        }\n        container = container.childNodes[offset > lastIdx ? lastIdx : offset];\n      }\n      if (isText$b(container) && start && offset >= container.data.length) {\n        container = new DomTreeWalker(container, ed.getBody()).next() || container;\n      }\n      if (isText$b(container) && !start && offset === 0) {\n        container = new DomTreeWalker(container, ed.getBody()).prev() || container;\n      }\n      return container;\n    };\n    const normalizeTableSelection = (node, start) => {\n      const prop = start ? 'firstChild' : 'lastChild';\n      const childNode = node[prop];\n      if (isTableCellOrRow(node) && childNode) {\n        if (node.nodeName === 'TR') {\n          return childNode[prop] || childNode;\n        } else {\n          return childNode;\n        }\n      }\n      return node;\n    };\n    const wrap$1 = (dom, node, name, attrs) => {\n      var _a;\n      const wrapper = dom.create(name, attrs);\n      (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n      return wrapper;\n    };\n    const wrapWithSiblings = (dom, node, next, name, attrs) => {\n      const start = SugarElement.fromDom(node);\n      const wrapper = SugarElement.fromDom(dom.create(name, attrs));\n      const siblings = next ? nextSiblings(start) : prevSiblings(start);\n      append(wrapper, siblings);\n      if (next) {\n        before$3(start, wrapper);\n        prepend(wrapper, start);\n      } else {\n        after$4(start, wrapper);\n        append$1(wrapper, start);\n      }\n      return wrapper.dom;\n    };\n    const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';\n    const removeNode = (ed, node, format) => {\n      const parentNode = node.parentNode;\n      let rootBlockElm;\n      const dom = ed.dom;\n      const forcedRootBlock = getForcedRootBlock(ed);\n      if (isBlockFormat(format)) {\n        if (parentNode === dom.getRoot()) {\n          if (!format.list_block || !isEq$2(node, format.list_block)) {\n            each$e(from(node.childNodes), node => {\n              if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {\n                if (!rootBlockElm) {\n                  rootBlockElm = wrap$1(dom, node, forcedRootBlock);\n                  dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));\n                } else {\n                  rootBlockElm.appendChild(node);\n                }\n              } else {\n                rootBlockElm = null;\n              }\n            });\n          }\n        }\n      }\n      if (isMixedFormat(format) && !isEq$2(format.inline, node)) {\n        return;\n      }\n      dom.remove(node, true);\n    };\n    const processFormatAttrOrStyle = (name, value, vars) => {\n      if (isNumber(name)) {\n        return {\n          name: value,\n          value: null\n        };\n      } else {\n        return {\n          name,\n          value: replaceVars(value, vars)\n        };\n      }\n    };\n    const removeEmptyStyleAttributeIfNeeded = (dom, elm) => {\n      if (dom.getAttrib(elm, 'style') === '') {\n        elm.removeAttribute('style');\n        elm.removeAttribute('data-mce-style');\n      }\n    };\n    const removeStyles = (dom, elm, format, vars, compareNode) => {\n      let stylesModified = false;\n      each$7(format.styles, (value, name) => {\n        const {\n          name: styleName,\n          value: styleValue\n        } = processFormatAttrOrStyle(name, value, vars);\n        const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);\n        if (format.remove_similar || isNull(styleValue) || !isElement$6(compareNode) || isEq$2(getStyle(dom, compareNode, styleName), normalizedStyleValue)) {\n          dom.setStyle(elm, styleName, '');\n        }\n        stylesModified = true;\n      });\n      if (stylesModified) {\n        removeEmptyStyleAttributeIfNeeded(dom, elm);\n      }\n    };\n    const removeListStyleFormats = (editor, name, vars) => {\n      if (name === 'removeformat') {\n        each$e(getPartiallySelectedListItems(editor.selection), li => {\n          each$e(listItemStyles, name => editor.dom.setStyle(li, name, ''));\n          removeEmptyStyleAttributeIfNeeded(editor.dom, li);\n        });\n      } else {\n        getExpandedListItemFormat(editor.formatter, name).each(liFmt => {\n          each$e(getPartiallySelectedListItems(editor.selection), li => removeStyles(editor.dom, li, liFmt, vars, null));\n        });\n      }\n    };\n    const removeNodeFormatInternal = (ed, format, vars, node, compareNode) => {\n      const dom = ed.dom;\n      const elementUtils = ElementUtils(ed);\n      const schema = ed.schema;\n      if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {\n        removeNode(ed, node, format);\n        return removeResult.removed();\n      }\n      if (!format.ceFalseOverride && node && dom.getContentEditableParent(node) === 'false') {\n        return removeResult.keep();\n      }\n      if (node && !matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {\n        return removeResult.keep();\n      }\n      const elm = node;\n      const preserveAttributes = format.preserve_attributes;\n      if (isInlineFormat(format) && format.remove === 'all' && isArray$1(preserveAttributes)) {\n        const attrsToPreserve = filter$5(dom.getAttribs(elm), attr => contains$2(preserveAttributes, attr.name.toLowerCase()));\n        dom.removeAllAttribs(elm);\n        each$e(attrsToPreserve, attr => dom.setAttrib(elm, attr.name, attr.value));\n        if (attrsToPreserve.length > 0) {\n          return removeResult.rename('span');\n        }\n      }\n      if (format.remove !== 'all') {\n        removeStyles(dom, elm, format, vars, compareNode);\n        each$7(format.attributes, (value, name) => {\n          const {\n            name: attrName,\n            value: attrValue\n          } = processFormatAttrOrStyle(name, value, vars);\n          if (format.remove_similar || isNull(attrValue) || !isElement$6(compareNode) || isEq$2(dom.getAttrib(compareNode, attrName), attrValue)) {\n            if (attrName === 'class') {\n              const currentValue = dom.getAttrib(elm, attrName);\n              if (currentValue) {\n                let valueOut = '';\n                each$e(currentValue.split(/\\s+/), cls => {\n                  if (/mce\\-\\w+/.test(cls)) {\n                    valueOut += (valueOut ? ' ' : '') + cls;\n                  }\n                });\n                if (valueOut) {\n                  dom.setAttrib(elm, attrName, valueOut);\n                  return;\n                }\n              }\n            }\n            if (MCE_ATTR_RE.test(attrName)) {\n              elm.removeAttribute('data-mce-' + attrName);\n            }\n            if (attrName === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {\n              elm.removeAttribute(attrName);\n              dom.setStyle(elm, 'list-style-type', 'none');\n              return;\n            }\n            if (attrName === 'class') {\n              elm.removeAttribute('className');\n            }\n            elm.removeAttribute(attrName);\n          }\n        });\n        each$7(format.classes, value => {\n          value = replaceVars(value, vars);\n          if (!isElement$6(compareNode) || dom.hasClass(compareNode, value)) {\n            dom.removeClass(elm, value);\n          }\n        });\n        const attrs = dom.getAttribs(elm);\n        for (let i = 0; i < attrs.length; i++) {\n          const attrName = attrs[i].nodeName;\n          if (!elementUtils.isAttributeInternal(attrName)) {\n            return removeResult.keep();\n          }\n        }\n      }\n      if (format.remove !== 'none') {\n        removeNode(ed, elm, format);\n        return removeResult.removed();\n      }\n      return removeResult.keep();\n    };\n    const findFormatRoot = (editor, container, name, vars, similar) => {\n      let formatRoot;\n      if (container.parentNode) {\n        each$e(getParents$2(editor.dom, container.parentNode).reverse(), parent => {\n          if (!formatRoot && isElement$6(parent) && parent.id !== '_start' && parent.id !== '_end') {\n            const format = matchNode(editor, parent, name, vars, similar);\n            if (format && format.split !== false) {\n              formatRoot = parent;\n            }\n          }\n        });\n      }\n      return formatRoot;\n    };\n    const removeNodeFormatFromClone = (editor, format, vars, clone) => removeNodeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), newName => {\n      const fragment = editor.dom.createFragment();\n      fragment.appendChild(clone);\n      return editor.dom.rename(clone, newName);\n    }, constant(null));\n    const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {\n      var _a, _b;\n      let lastClone;\n      let firstClone;\n      const dom = editor.dom;\n      if (formatRoot) {\n        const formatRootParent = formatRoot.parentNode;\n        for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {\n          let clone = dom.clone(parent, false);\n          for (let i = 0; i < formatList.length; i++) {\n            clone = removeNodeFormatFromClone(editor, formatList[i], vars, clone);\n            if (clone === null) {\n              break;\n            }\n          }\n          if (clone) {\n            if (lastClone) {\n              clone.appendChild(lastClone);\n            }\n            if (!firstClone) {\n              firstClone = clone;\n            }\n            lastClone = clone;\n          }\n        }\n        if (split && (!format.mixed || !dom.isBlock(formatRoot))) {\n          container = (_a = dom.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;\n        }\n        if (lastClone && firstClone) {\n          (_b = target.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(lastClone, target);\n          firstClone.appendChild(target);\n          if (isInlineFormat(format)) {\n            mergeSiblings(editor, format, vars, lastClone);\n          }\n        }\n      }\n      return container;\n    };\n    const removeFormatInternal = (ed, name, vars, node, similar) => {\n      const formatList = ed.formatter.get(name);\n      const format = formatList[0];\n      const dom = ed.dom;\n      const selection = ed.selection;\n      const splitToFormatRoot = container => {\n        const formatRoot = findFormatRoot(ed, container, name, vars, similar);\n        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);\n      };\n      const isRemoveBookmarkNode = node => isBookmarkNode$1(node) && isElement$6(node) && (node.id === '_start' || node.id === '_end');\n      const removeFormatOnNode = node => exists(formatList, fmt => removeNodeFormat(ed, fmt, vars, node, node));\n      const process = node => {\n        const children = from(node.childNodes);\n        const removed = removeFormatOnNode(node);\n        const currentNodeMatches = removed || exists(formatList, f => matchName(dom, node, f));\n        const parentNode = node.parentNode;\n        if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n          removeFormatOnNode(parentNode);\n        }\n        if (format.deep) {\n          if (children.length) {\n            for (let i = 0; i < children.length; i++) {\n              process(children[i]);\n            }\n          }\n        }\n        const textDecorations = [\n          'underline',\n          'line-through',\n          'overline'\n        ];\n        each$e(textDecorations, decoration => {\n          if (isElement$6(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {\n            removeNodeFormat(ed, {\n              deep: false,\n              exact: true,\n              inline: 'span',\n              styles: { textDecoration: decoration }\n            }, undefined, node);\n          }\n        });\n      };\n      const unwrap = start => {\n        const node = dom.get(start ? '_start' : '_end');\n        if (node) {\n          let out = node[start ? 'firstChild' : 'lastChild'];\n          if (isRemoveBookmarkNode(out)) {\n            out = out[start ? 'firstChild' : 'lastChild'];\n          }\n          if (isText$b(out) && out.data.length === 0) {\n            out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;\n          }\n          dom.remove(node, true);\n          return out;\n        } else {\n          return null;\n        }\n      };\n      const removeRngStyle = rng => {\n        let startContainer;\n        let endContainer;\n        let expandedRng = expandRng(dom, rng, formatList, rng.collapsed);\n        if (format.split) {\n          expandedRng = split(expandedRng);\n          startContainer = getContainer(ed, expandedRng, true);\n          endContainer = getContainer(ed, expandedRng);\n          if (startContainer !== endContainer) {\n            startContainer = normalizeTableSelection(startContainer, true);\n            endContainer = normalizeTableSelection(endContainer, false);\n            if (isChildOfInlineParent(dom, startContainer, endContainer)) {\n              const marker = Optional.from(startContainer.firstChild).getOr(startContainer);\n              splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {\n                'id': '_start',\n                'data-mce-type': 'bookmark'\n              }));\n              unwrap(true);\n              return;\n            }\n            if (isChildOfInlineParent(dom, endContainer, startContainer)) {\n              const marker = Optional.from(endContainer.lastChild).getOr(endContainer);\n              splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {\n                'id': '_end',\n                'data-mce-type': 'bookmark'\n              }));\n              unwrap(false);\n              return;\n            }\n            startContainer = wrap$1(dom, startContainer, 'span', {\n              'id': '_start',\n              'data-mce-type': 'bookmark'\n            });\n            endContainer = wrap$1(dom, endContainer, 'span', {\n              'id': '_end',\n              'data-mce-type': 'bookmark'\n            });\n            const newRng = dom.createRng();\n            newRng.setStartAfter(startContainer);\n            newRng.setEndBefore(endContainer);\n            walk$3(dom, newRng, nodes => {\n              each$e(nodes, n => {\n                if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {\n                  splitToFormatRoot(n);\n                }\n              });\n            });\n            splitToFormatRoot(startContainer);\n            splitToFormatRoot(endContainer);\n            startContainer = unwrap(true);\n            endContainer = unwrap();\n          } else {\n            startContainer = endContainer = splitToFormatRoot(startContainer);\n          }\n          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;\n          expandedRng.startOffset = dom.nodeIndex(startContainer);\n          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;\n          expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;\n        }\n        walk$3(dom, expandedRng, nodes => {\n          each$e(nodes, process);\n        });\n      };\n      if (node) {\n        if (isNode(node)) {\n          const rng = dom.createRng();\n          rng.setStartBefore(node);\n          rng.setEndAfter(node);\n          removeRngStyle(rng);\n        } else {\n          removeRngStyle(node);\n        }\n        fireFormatRemove(ed, name, node, vars);\n        return;\n      }\n      if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n        preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), startNode => isInlineFormat(format) && match$2(ed, name, vars, startNode));\n        ed.nodeChanged();\n      } else {\n        removeCaretFormat(ed, name, vars, similar);\n      }\n      removeListStyleFormats(ed, name, vars);\n      fireFormatRemove(ed, name, node, vars);\n    };\n    const removeFormat$1 = (ed, name, vars, node, similar) => {\n      if (node || ed.selection.isEditable()) {\n        removeFormatInternal(ed, name, vars, node, similar);\n      }\n    };\n    const removeNodeFormat = (editor, format, vars, node, compareNode) => {\n      return removeNodeFormatInternal(editor, format, vars, node, compareNode).fold(never, newName => {\n        editor.dom.rename(node, newName);\n        return true;\n      }, always);\n    };\n\n    const each$6 = Tools.each;\n    const mergeTextDecorationsAndColor = (dom, format, vars, node) => {\n      const processTextDecorationsAndColor = n => {\n        if (isHTMLElement(n) && isElement$6(n.parentNode) && dom.isEditable(n)) {\n          const parentTextDecoration = getTextDecoration(dom, n.parentNode);\n          if (dom.getStyle(n, 'color') && parentTextDecoration) {\n            dom.setStyle(n, 'text-decoration', parentTextDecoration);\n          } else if (dom.getStyle(n, 'text-decoration') === parentTextDecoration) {\n            dom.setStyle(n, 'text-decoration', null);\n          }\n        }\n      };\n      if (format.styles && (format.styles.color || format.styles.textDecoration)) {\n        Tools.walk(node, processTextDecorationsAndColor, 'childNodes');\n        processTextDecorationsAndColor(node);\n      }\n    };\n    const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {\n      if (format.styles && format.styles.backgroundColor) {\n        const hasFontSize = hasStyle(dom, 'fontSize');\n        processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));\n      }\n    };\n    const mergeSubSup = (dom, format, vars, node) => {\n      if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {\n        const hasFontSize = hasStyle(dom, 'fontSize');\n        processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'fontSize', ''));\n        const inverseTagDescendants = filter$5(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), dom.isEditable);\n        dom.remove(inverseTagDescendants, true);\n      }\n    };\n    const mergeWithChildren = (editor, formatList, vars, node) => {\n      each$6(formatList, format => {\n        if (isInlineFormat(format)) {\n          each$6(editor.dom.select(format.inline, node), child => {\n            if (isElementNode(child)) {\n              removeNodeFormat(editor, format, vars, child, format.exact ? child : null);\n            }\n          });\n        }\n        clearChildStyles(editor.dom, format, node);\n      });\n    };\n    const mergeWithParents = (editor, format, name, vars, node) => {\n      const parentNode = node.parentNode;\n      if (matchNode(editor, parentNode, name, vars)) {\n        if (removeNodeFormat(editor, format, vars, node)) {\n          return;\n        }\n      }\n      if (format.merge_with_parents && parentNode) {\n        editor.dom.getParent(parentNode, parent => {\n          if (matchNode(editor, parent, name, vars)) {\n            removeNodeFormat(editor, format, vars, node);\n            return true;\n          } else {\n            return false;\n          }\n        });\n      }\n    };\n\n    const each$5 = Tools.each;\n    const canFormatBR = (editor, format, node, parentName) => {\n      if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {\n        const validBRParentElements = getTextRootBlockElements(editor.schema);\n        const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), sibling => isCaretNode(sibling.dom));\n        return hasNonNullableKey(validBRParentElements, parentName) && isEmptyNode(editor.schema, node.parentNode, {\n          skipBogus: false,\n          includeZwsp: true\n        }) && !hasCaretNodeSibling;\n      } else {\n        return false;\n      }\n    };\n    const applyStyles = (dom, elm, format, vars) => {\n      each$5(format.styles, (value, name) => {\n        dom.setStyle(elm, name, replaceVars(value, vars));\n      });\n      if (format.styles) {\n        const styleVal = dom.getAttrib(elm, 'style');\n        if (styleVal) {\n          dom.setAttrib(elm, 'data-mce-style', styleVal);\n        }\n      }\n    };\n    const applyFormatAction = (ed, name, vars, node) => {\n      const formatList = ed.formatter.get(name);\n      const format = formatList[0];\n      const isCollapsed = !node && ed.selection.isCollapsed();\n      const dom = ed.dom;\n      const selection = ed.selection;\n      const setElementFormat = (elm, fmt = format) => {\n        if (isFunction(fmt.onformat)) {\n          fmt.onformat(elm, fmt, vars, node);\n        }\n        applyStyles(dom, elm, fmt, vars);\n        each$5(fmt.attributes, (value, name) => {\n          dom.setAttrib(elm, name, replaceVars(value, vars));\n        });\n        each$5(fmt.classes, value => {\n          const newValue = replaceVars(value, vars);\n          if (!dom.hasClass(elm, newValue)) {\n            dom.addClass(elm, newValue);\n          }\n        });\n      };\n      const applyNodeStyle = (formatList, node) => {\n        let found = false;\n        each$5(formatList, format => {\n          if (!isSelectorFormat(format)) {\n            return false;\n          }\n          if (dom.getContentEditable(node) === 'false' && !format.ceFalseOverride) {\n            return true;\n          }\n          if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {\n            return true;\n          }\n          if (dom.is(node, format.selector) && !isCaretNode(node)) {\n            setElementFormat(node, format);\n            found = true;\n            return false;\n          }\n          return true;\n        });\n        return found;\n      };\n      const createWrapElement = wrapName => {\n        if (isString(wrapName)) {\n          const wrapElm = dom.create(wrapName);\n          setElementFormat(wrapElm);\n          return wrapElm;\n        } else {\n          return null;\n        }\n      };\n      const applyRngStyle = (dom, rng, nodeSpecific) => {\n        const newWrappers = [];\n        let contentEditable = true;\n        const wrapName = format.inline || format.block;\n        const wrapElm = createWrapElement(wrapName);\n        const isMatchingWrappingBlock = node => isWrappingBlockFormat(format) && matchNode(ed, node, name, vars);\n        const canRenameBlock = (node, parentName, isEditableDescendant) => {\n          const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) && isTextBlock$1(ed.schema, node) && isValid(ed, parentName, wrapName);\n          return isEditableDescendant && isValidBlockFormatForNode;\n        };\n        const canWrapNode = (node, parentName, isEditableDescendant, isWrappableNoneditableElm) => {\n          const nodeName = node.nodeName.toLowerCase();\n          const isValidWrapNode = isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName);\n          const isZwsp$1 = !nodeSpecific && isText$b(node) && isZwsp(node.data);\n          const isCaret = isCaretNode(node);\n          const isCorrectFormatForNode = !isInlineFormat(format) || !dom.isBlock(node);\n          return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp$1 && !isCaret && isCorrectFormatForNode;\n        };\n        walk$3(dom, rng, nodes => {\n          let currentWrapElm;\n          const process = node => {\n            let hasContentEditableState = false;\n            let lastContentEditable = contentEditable;\n            let isWrappableNoneditableElm = false;\n            const parentNode = node.parentNode;\n            const parentName = parentNode.nodeName.toLowerCase();\n            const contentEditableValue = dom.getContentEditable(node);\n            if (isNonNullable(contentEditableValue)) {\n              lastContentEditable = contentEditable;\n              contentEditable = contentEditableValue === 'true';\n              hasContentEditableState = true;\n              isWrappableNoneditableElm = isWrappableNoneditable(ed, node);\n            }\n            const isEditableDescendant = contentEditable && !hasContentEditableState;\n            if (isBr$6(node) && !canFormatBR(ed, format, node, parentName)) {\n              currentWrapElm = null;\n              if (isBlockFormat(format)) {\n                dom.remove(node);\n              }\n              return;\n            }\n            if (isMatchingWrappingBlock(node)) {\n              currentWrapElm = null;\n              return;\n            }\n            if (canRenameBlock(node, parentName, isEditableDescendant)) {\n              const elm = dom.rename(node, wrapName);\n              setElementFormat(elm);\n              newWrappers.push(elm);\n              currentWrapElm = null;\n              return;\n            }\n            if (isSelectorFormat(format)) {\n              let found = applyNodeStyle(formatList, node);\n              if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n                found = applyNodeStyle(formatList, parentNode);\n              }\n              if (!isInlineFormat(format) || found) {\n                currentWrapElm = null;\n                return;\n              }\n            }\n            if (isNonNullable(wrapElm) && canWrapNode(node, parentName, isEditableDescendant, isWrappableNoneditableElm)) {\n              if (!currentWrapElm) {\n                currentWrapElm = dom.clone(wrapElm, false);\n                parentNode.insertBefore(currentWrapElm, node);\n                newWrappers.push(currentWrapElm);\n              }\n              if (isWrappableNoneditableElm && hasContentEditableState) {\n                contentEditable = lastContentEditable;\n              }\n              currentWrapElm.appendChild(node);\n            } else {\n              currentWrapElm = null;\n              each$e(from(node.childNodes), process);\n              if (hasContentEditableState) {\n                contentEditable = lastContentEditable;\n              }\n              currentWrapElm = null;\n            }\n          };\n          each$e(nodes, process);\n        });\n        if (format.links === true) {\n          each$e(newWrappers, node => {\n            const process = node => {\n              if (node.nodeName === 'A') {\n                setElementFormat(node, format);\n              }\n              each$e(from(node.childNodes), process);\n            };\n            process(node);\n          });\n        }\n        each$e(newWrappers, node => {\n          const getChildCount = node => {\n            let count = 0;\n            each$e(node.childNodes, node => {\n              if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {\n                count++;\n              }\n            });\n            return count;\n          };\n          const mergeStyles = node => {\n            const childElement = find$2(node.childNodes, isElementNode$1).filter(child => dom.getContentEditable(child) !== 'false' && matchName(dom, child, format));\n            return childElement.map(child => {\n              const clone = dom.clone(child, false);\n              setElementFormat(clone);\n              dom.replace(clone, node, true);\n              dom.remove(child, true);\n              return clone;\n            }).getOr(node);\n          };\n          const childCount = getChildCount(node);\n          if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {\n            dom.remove(node, true);\n            return;\n          }\n          if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {\n            if (!format.exact && childCount === 1) {\n              node = mergeStyles(node);\n            }\n            mergeWithChildren(ed, formatList, vars, node);\n            mergeWithParents(ed, format, name, vars, node);\n            mergeBackgroundColorAndFontSize(dom, format, vars, node);\n            mergeTextDecorationsAndColor(dom, format, vars, node);\n            mergeSubSup(dom, format, vars, node);\n            mergeSiblings(ed, format, vars, node);\n          }\n        });\n      };\n      const targetNode = isNode(node) ? node : selection.getNode();\n      if (dom.getContentEditable(targetNode) === 'false' && !isWrappableNoneditable(ed, targetNode)) {\n        node = targetNode;\n        applyNodeStyle(formatList, node);\n        fireFormatApply(ed, name, node, vars);\n        return;\n      }\n      if (format) {\n        if (node) {\n          if (isNode(node)) {\n            if (!applyNodeStyle(formatList, node)) {\n              const rng = dom.createRng();\n              rng.setStartBefore(node);\n              rng.setEndAfter(node);\n              applyRngStyle(dom, expandRng(dom, rng, formatList), true);\n            }\n          } else {\n            applyRngStyle(dom, node, true);\n          }\n        } else {\n          if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n            selection.setRng(normalize(selection.getRng()));\n            preserveSelection(ed, () => {\n              runOnRanges(ed, (selectionRng, fake) => {\n                const expandedRng = fake ? selectionRng : expandRng(dom, selectionRng, formatList);\n                applyRngStyle(dom, expandedRng, false);\n              });\n            }, always);\n            ed.nodeChanged();\n          } else {\n            applyCaretFormat(ed, name, vars);\n          }\n          getExpandedListItemFormat(ed.formatter, name).each(liFmt => {\n            each$e(getFullySelectedListItems(ed.selection), li => applyStyles(dom, li, liFmt, vars));\n          });\n        }\n        postProcess$1(name, ed);\n      }\n      fireFormatApply(ed, name, node, vars);\n    };\n    const applyFormat$1 = (editor, name, vars, node) => {\n      if (node || editor.selection.isEditable()) {\n        applyFormatAction(editor, name, vars, node);\n      }\n    };\n\n    const hasVars = value => has$2(value, 'vars');\n    const setup$u = (registeredFormatListeners, editor) => {\n      registeredFormatListeners.set({});\n      editor.on('NodeChange', e => {\n        updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());\n      });\n      editor.on('FormatApply FormatRemove', e => {\n        const element = Optional.from(e.node).map(nodeOrRange => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind(node => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));\n        updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());\n      });\n    };\n    const fallbackElement = editor => editor.selection.getStart();\n    const matchingNode = (editor, parents, format, similar, vars) => {\n      const isMatchingNode = node => {\n        const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);\n        return !isUndefined(matchingFormat);\n      };\n      const isUnableToMatch = node => {\n        if (matchesUnInheritedFormatSelector(editor, node, format)) {\n          return true;\n        } else {\n          if (!similar) {\n            return isNonNullable(editor.formatter.matchNode(node, format, vars, true));\n          } else {\n            return false;\n          }\n        }\n      };\n      return findUntil$1(parents, isMatchingNode, isUnableToMatch);\n    };\n    const getParents = (editor, elm) => {\n      const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);\n      return filter$5(getParents$2(editor.dom, element), node => isElement$6(node) && !isBogus$1(node));\n    };\n    const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {\n      const parents = getParents(editor, elm);\n      each$d(registeredCallbacks, (data, format) => {\n        const runIfChanged = spec => {\n          const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);\n          const isSet = match.isSome();\n          if (spec.state.get() !== isSet) {\n            spec.state.set(isSet);\n            const node = match.getOr(elm);\n            if (hasVars(spec)) {\n              spec.callback(isSet, {\n                node,\n                format,\n                parents\n              });\n            } else {\n              each$e(spec.callbacks, callback => callback(isSet, {\n                node,\n                format,\n                parents\n              }));\n            }\n          }\n        };\n        each$e([\n          data.withSimilar,\n          data.withoutSimilar\n        ], runIfChanged);\n        each$e(data.withVars, runIfChanged);\n      });\n    };\n    const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n      const formatChangeItems = registeredFormatListeners.get();\n      each$e(formats.split(','), format => {\n        const group = get$a(formatChangeItems, format).getOrThunk(() => {\n          const base = {\n            withSimilar: {\n              state: Cell(false),\n              similar: true,\n              callbacks: []\n            },\n            withoutSimilar: {\n              state: Cell(false),\n              similar: false,\n              callbacks: []\n            },\n            withVars: []\n          };\n          formatChangeItems[format] = base;\n          return base;\n        });\n        const getCurrent = () => {\n          const parents = getParents(editor);\n          return matchingNode(editor, parents, format, similar, vars).isSome();\n        };\n        if (isUndefined(vars)) {\n          const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;\n          toAppendTo.callbacks.push(callback);\n          if (toAppendTo.callbacks.length === 1) {\n            toAppendTo.state.set(getCurrent());\n          }\n        } else {\n          group.withVars.push({\n            state: Cell(getCurrent()),\n            similar,\n            vars,\n            callback\n          });\n        }\n      });\n      registeredFormatListeners.set(formatChangeItems);\n    };\n    const removeListeners = (registeredFormatListeners, formats, callback) => {\n      const formatChangeItems = registeredFormatListeners.get();\n      each$e(formats.split(','), format => get$a(formatChangeItems, format).each(group => {\n        formatChangeItems[format] = {\n          withSimilar: {\n            ...group.withSimilar,\n            callbacks: filter$5(group.withSimilar.callbacks, cb => cb !== callback)\n          },\n          withoutSimilar: {\n            ...group.withoutSimilar,\n            callbacks: filter$5(group.withoutSimilar.callbacks, cb => cb !== callback)\n          },\n          withVars: filter$5(group.withVars, item => item.callback !== callback)\n        };\n      }));\n      registeredFormatListeners.set(formatChangeItems);\n    };\n    const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n      addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);\n      return { unbind: () => removeListeners(registeredFormatListeners, formats, callback) };\n    };\n\n    const toggle = (editor, name, vars, node) => {\n      const fmt = editor.formatter.get(name);\n      if (fmt) {\n        if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {\n          removeFormat$1(editor, name, vars, node);\n        } else {\n          applyFormat$1(editor, name, vars, node);\n        }\n      }\n    };\n\n    const explode$1 = Tools.explode;\n    const create$8 = () => {\n      const filters = {};\n      const addFilter = (name, callback) => {\n        each$e(explode$1(name), name => {\n          if (!has$2(filters, name)) {\n            filters[name] = {\n              name,\n              callbacks: []\n            };\n          }\n          filters[name].callbacks.push(callback);\n        });\n      };\n      const getFilters = () => values(filters);\n      const removeFilter = (name, callback) => {\n        each$e(explode$1(name), name => {\n          if (has$2(filters, name)) {\n            if (isNonNullable(callback)) {\n              const filter = filters[name];\n              const newCallbacks = filter$5(filter.callbacks, c => c !== callback);\n              if (newCallbacks.length > 0) {\n                filter.callbacks = newCallbacks;\n              } else {\n                delete filters[name];\n              }\n            } else {\n              delete filters[name];\n            }\n          }\n        });\n      };\n      return {\n        addFilter,\n        getFilters,\n        removeFilter\n      };\n    };\n\n    const removeAttrs = (node, names) => {\n      each$e(names, name => {\n        node.attr(name, null);\n      });\n    };\n    const addFontToSpansFilter = (domParser, styles, fontSizes) => {\n      domParser.addNodeFilter('font', nodes => {\n        each$e(nodes, node => {\n          const props = styles.parse(node.attr('style'));\n          const color = node.attr('color');\n          const face = node.attr('face');\n          const size = node.attr('size');\n          if (color) {\n            props.color = color;\n          }\n          if (face) {\n            props['font-family'] = face;\n          }\n          if (size) {\n            toInt(size).each(num => {\n              props['font-size'] = fontSizes[num - 1];\n            });\n          }\n          node.name = 'span';\n          node.attr('style', styles.serialize(props));\n          removeAttrs(node, [\n            'color',\n            'face',\n            'size'\n          ]);\n        });\n      });\n    };\n    const addStrikeFilter = (domParser, schema, styles) => {\n      domParser.addNodeFilter('strike', nodes => {\n        const convertToSTag = schema.type !== 'html4';\n        each$e(nodes, node => {\n          if (convertToSTag) {\n            node.name = 's';\n          } else {\n            const props = styles.parse(node.attr('style'));\n            props['text-decoration'] = 'line-through';\n            node.name = 'span';\n            node.attr('style', styles.serialize(props));\n          }\n        });\n      });\n    };\n    const addFilters = (domParser, settings, schema) => {\n      var _a;\n      const styles = Styles();\n      if (settings.convert_fonts_to_spans) {\n        addFontToSpansFilter(domParser, styles, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ''));\n      }\n      addStrikeFilter(domParser, schema, styles);\n    };\n    const register$5 = (domParser, settings, schema) => {\n      if (settings.inline_styles) {\n        addFilters(domParser, settings, schema);\n      }\n    };\n\n    const blobUriToBlob = url => fetch(url).then(res => res.ok ? res.blob() : Promise.reject()).catch(() => Promise.reject({\n      message: `Cannot convert ${ url } to Blob. Resource might not exist or is inaccessible.`,\n      uriType: 'blob'\n    }));\n    const extractBase64Data = data => {\n      const matches = /([a-z0-9+\\/=\\s]+)/i.exec(data);\n      return matches ? matches[1] : '';\n    };\n    const parseDataUri = uri => {\n      const [type, ...rest] = uri.split(',');\n      const data = rest.join(',');\n      const matches = /data:([^/]+\\/[^;]+)(;.+)?/.exec(type);\n      if (matches) {\n        const base64Encoded = matches[2] === ';base64';\n        const extractedData = base64Encoded ? extractBase64Data(data) : decodeURIComponent(data);\n        return Optional.some({\n          type: matches[1],\n          data: extractedData,\n          base64Encoded\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const buildBlob = (type, data, base64Encoded = true) => {\n      let str = data;\n      if (base64Encoded) {\n        try {\n          str = atob(data);\n        } catch (e) {\n          return Optional.none();\n        }\n      }\n      const arr = new Uint8Array(str.length);\n      for (let i = 0; i < arr.length; i++) {\n        arr[i] = str.charCodeAt(i);\n      }\n      return Optional.some(new Blob([arr], { type }));\n    };\n    const dataUriToBlob = uri => {\n      return new Promise((resolve, reject) => {\n        parseDataUri(uri).bind(({type, data, base64Encoded}) => buildBlob(type, data, base64Encoded)).fold(() => reject('Invalid data URI'), resolve);\n      });\n    };\n    const uriToBlob = url => {\n      if (startsWith(url, 'blob:')) {\n        return blobUriToBlob(url);\n      } else if (startsWith(url, 'data:')) {\n        return dataUriToBlob(url);\n      } else {\n        return Promise.reject('Unknown URI format');\n      }\n    };\n    const blobToDataUri = blob => {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = () => {\n          resolve(reader.result);\n        };\n        reader.onerror = () => {\n          var _a;\n          reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);\n        };\n        reader.readAsDataURL(blob);\n      });\n    };\n\n    let count$1 = 0;\n    const uniqueId$1 = prefix => {\n      return (prefix || 'blobid') + count$1++;\n    };\n    const processDataUri = (dataUri, base64Only, generateBlobInfo) => {\n      return parseDataUri(dataUri).bind(({data, type, base64Encoded}) => {\n        if (base64Only && !base64Encoded) {\n          return Optional.none();\n        } else {\n          const base64 = base64Encoded ? data : btoa(data);\n          return generateBlobInfo(base64, type);\n        }\n      });\n    };\n    const createBlobInfo$1 = (blobCache, blob, base64) => {\n      const blobInfo = blobCache.create(uniqueId$1(), blob, base64);\n      blobCache.add(blobInfo);\n      return blobInfo;\n    };\n    const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {\n      return processDataUri(dataUri, base64Only, (base64, type) => Optional.from(blobCache.getByData(base64, type)).orThunk(() => buildBlob(type, base64).map(blob => createBlobInfo$1(blobCache, blob, base64))));\n    };\n    const imageToBlobInfo = (blobCache, imageSrc) => {\n      const invalidDataUri = () => Promise.reject('Invalid data URI');\n      if (startsWith(imageSrc, 'blob:')) {\n        const blobInfo = blobCache.getByUri(imageSrc);\n        if (isNonNullable(blobInfo)) {\n          return Promise.resolve(blobInfo);\n        } else {\n          return uriToBlob(imageSrc).then(blob => {\n            return blobToDataUri(blob).then(dataUri => {\n              return processDataUri(dataUri, false, base64 => {\n                return Optional.some(createBlobInfo$1(blobCache, blob, base64));\n              }).getOrThunk(invalidDataUri);\n            });\n          });\n        }\n      } else if (startsWith(imageSrc, 'data:')) {\n        return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, blobInfo => Promise.resolve(blobInfo));\n      } else {\n        return Promise.reject('Unknown image data format');\n      }\n    };\n\n    const hostCaptureRegex = /^(?:(?:(?:[A-Za-z][A-Za-z\\d.+-]{0,14}:\\/\\/(?:[-.~*+=!&;:'%@?^${}(),\\w]+@)?|www\\.|[-;:&=+$,.\\w]+@)([A-Za-z\\d-]+(?:\\.[A-Za-z\\d-]+)*))(?::\\d+)?(?:\\/(?:[-.~*+=!;:'%@$(),\\/\\w]*[-~*+=%@$()\\/\\w])?)?(?:\\?(?:[-.~*+=!&;:'%@?^${}(),\\/\\w]+)?)?(?:#(?:[-.~*+=!&;:'%@?^${}(),\\/\\w]+)?)?)$/;\n    const extractHost = url => Optional.from(url.match(hostCaptureRegex)).bind(ms => get$b(ms, 1)).map(h => startsWith(h, 'www.') ? h.substring(4) : h);\n\n    const sandboxIframe = (iframeNode, exclusions) => {\n      if (Optional.from(iframeNode.attr('src')).bind(extractHost).forall(host => !contains$2(exclusions, host))) {\n        iframeNode.attr('sandbox', '');\n      }\n    };\n    const isMimeType = (mime, type) => startsWith(mime, `${ type }/`);\n    const getEmbedType = type => {\n      if (isUndefined(type)) {\n        return 'iframe';\n      } else if (isMimeType(type, 'image')) {\n        return 'img';\n      } else if (isMimeType(type, 'video')) {\n        return 'video';\n      } else if (isMimeType(type, 'audio')) {\n        return 'audio';\n      } else {\n        return 'iframe';\n      }\n    };\n    const createSafeEmbed = ({type, src, width, height} = {}, sandboxIframes, sandboxIframesExclusions) => {\n      const name = getEmbedType(type);\n      const embed = new AstNode(name, 1);\n      embed.attr(name === 'audio' ? { src } : {\n        src,\n        width,\n        height\n      });\n      if (name === 'audio' || name === 'video') {\n        embed.attr('controls', '');\n      }\n      if (name === 'iframe' && sandboxIframes) {\n        sandboxIframe(embed, sandboxIframesExclusions);\n      }\n      return embed;\n    };\n\n    const isBogusImage = img => isNonNullable(img.attr('data-mce-bogus'));\n    const isInternalImageSource = img => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));\n    const registerBase64ImageFilter = (parser, settings) => {\n      const {blob_cache: blobCache} = settings;\n      if (blobCache) {\n        const processImage = img => {\n          const inputSrc = img.attr('src');\n          if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) {\n            return;\n          }\n          dataUriToBlobInfo(blobCache, inputSrc, true).each(blobInfo => {\n            img.attr('src', blobInfo.blobUri());\n          });\n        };\n        parser.addAttributeFilter('src', nodes => each$e(nodes, processImage));\n      }\n    };\n    const register$4 = (parser, settings) => {\n      var _a, _b;\n      const schema = parser.schema;\n      parser.addAttributeFilter('href', nodes => {\n        let i = nodes.length;\n        const appendRel = rel => {\n          const parts = rel.split(' ').filter(p => p.length > 0);\n          return parts.concat(['noopener']).sort().join(' ');\n        };\n        const addNoOpener = rel => {\n          const newRel = rel ? Tools.trim(rel) : '';\n          if (!/\\b(noopener)\\b/g.test(newRel)) {\n            return appendRel(newRel);\n          } else {\n            return newRel;\n          }\n        };\n        if (!settings.allow_unsafe_link_target) {\n          while (i--) {\n            const node = nodes[i];\n            if (node.name === 'a' && node.attr('target') === '_blank') {\n              node.attr('rel', addNoOpener(node.attr('rel')));\n            }\n          }\n        }\n      });\n      if (!settings.allow_html_in_named_anchor) {\n        parser.addAttributeFilter('id,name', nodes => {\n          let i = nodes.length, sibling, prevSibling, parent, node;\n          while (i--) {\n            node = nodes[i];\n            if (node.name === 'a' && node.firstChild && !node.attr('href')) {\n              parent = node.parent;\n              sibling = node.lastChild;\n              while (sibling && parent) {\n                prevSibling = sibling.prev;\n                parent.insert(sibling, node);\n                sibling = prevSibling;\n              }\n            }\n          }\n        });\n      }\n      if (settings.fix_list_elements) {\n        parser.addNodeFilter('ul,ol', nodes => {\n          let i = nodes.length, node, parentNode;\n          while (i--) {\n            node = nodes[i];\n            parentNode = node.parent;\n            if (parentNode && (parentNode.name === 'ul' || parentNode.name === 'ol')) {\n              if (node.prev && node.prev.name === 'li') {\n                node.prev.append(node);\n              } else {\n                const li = new AstNode('li', 1);\n                li.attr('style', 'list-style-type: none');\n                node.wrap(li);\n              }\n            }\n          }\n        });\n      }\n      const validClasses = schema.getValidClasses();\n      if (settings.validate && validClasses) {\n        parser.addAttributeFilter('class', nodes => {\n          var _a;\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            const clazz = (_a = node.attr('class')) !== null && _a !== void 0 ? _a : '';\n            const classList = Tools.explode(clazz, ' ');\n            let classValue = '';\n            for (let ci = 0; ci < classList.length; ci++) {\n              const className = classList[ci];\n              let valid = false;\n              let validClassesMap = validClasses['*'];\n              if (validClassesMap && validClassesMap[className]) {\n                valid = true;\n              }\n              validClassesMap = validClasses[node.name];\n              if (!valid && validClassesMap && validClassesMap[className]) {\n                valid = true;\n              }\n              if (valid) {\n                if (classValue) {\n                  classValue += ' ';\n                }\n                classValue += className;\n              }\n            }\n            if (!classValue.length) {\n              classValue = null;\n            }\n            node.attr('class', classValue);\n          }\n        });\n      }\n      registerBase64ImageFilter(parser, settings);\n      const shouldSandboxIframes = (_a = settings.sandbox_iframes) !== null && _a !== void 0 ? _a : false;\n      const sandboxIframesExclusions = unique$1((_b = settings.sandbox_iframes_exclusions) !== null && _b !== void 0 ? _b : []);\n      if (settings.convert_unsafe_embeds) {\n        parser.addNodeFilter('object,embed', nodes => each$e(nodes, node => {\n          node.replace(createSafeEmbed({\n            type: node.attr('type'),\n            src: node.name === 'object' ? node.attr('data') : node.attr('src'),\n            width: node.attr('width'),\n            height: node.attr('height')\n          }, shouldSandboxIframes, sandboxIframesExclusions));\n        }));\n      }\n      if (shouldSandboxIframes) {\n        parser.addNodeFilter('iframe', nodes => each$e(nodes, node => sandboxIframe(node, sandboxIframesExclusions)));\n      }\n    };\n\n    const {entries, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor} = Object;\n    let {freeze, seal, create: create$7} = Object;\n    let {apply, construct} = typeof Reflect !== 'undefined' && Reflect;\n    if (!apply) {\n      apply = function apply(fun, thisValue, args) {\n        return fun.apply(thisValue, args);\n      };\n    }\n    if (!freeze) {\n      freeze = function freeze(x) {\n        return x;\n      };\n    }\n    if (!seal) {\n      seal = function seal(x) {\n        return x;\n      };\n    }\n    if (!construct) {\n      construct = function construct(Func, args) {\n        return new Func(...args);\n      };\n    }\n    const arrayForEach = unapply(Array.prototype.forEach);\n    const arrayPop = unapply(Array.prototype.pop);\n    const arrayPush = unapply(Array.prototype.push);\n    const stringToLowerCase = unapply(String.prototype.toLowerCase);\n    const stringToString = unapply(String.prototype.toString);\n    const stringMatch = unapply(String.prototype.match);\n    const stringReplace = unapply(String.prototype.replace);\n    const stringIndexOf = unapply(String.prototype.indexOf);\n    const stringTrim = unapply(String.prototype.trim);\n    const regExpTest = unapply(RegExp.prototype.test);\n    const typeErrorCreate = unconstruct(TypeError);\n    function unapply(func) {\n      return function (thisArg) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        return apply(func, thisArg, args);\n      };\n    }\n    function unconstruct(func) {\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return construct(func, args);\n      };\n    }\n    function addToSet(set, array, transformCaseFunc) {\n      var _transformCaseFunc;\n      transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;\n      if (setPrototypeOf) {\n        setPrototypeOf(set, null);\n      }\n      let l = array.length;\n      while (l--) {\n        let element = array[l];\n        if (typeof element === 'string') {\n          const lcElement = transformCaseFunc(element);\n          if (lcElement !== element) {\n            if (!isFrozen(array)) {\n              array[l] = lcElement;\n            }\n            element = lcElement;\n          }\n        }\n        set[element] = true;\n      }\n      return set;\n    }\n    function clone(object) {\n      const newObject = create$7(null);\n      for (const [property, value] of entries(object)) {\n        newObject[property] = value;\n      }\n      return newObject;\n    }\n    function lookupGetter(object, prop) {\n      while (object !== null) {\n        const desc = getOwnPropertyDescriptor(object, prop);\n        if (desc) {\n          if (desc.get) {\n            return unapply(desc.get);\n          }\n          if (typeof desc.value === 'function') {\n            return unapply(desc.value);\n          }\n        }\n        object = getPrototypeOf(object);\n      }\n      function fallbackValue(element) {\n        console.warn('fallback value for', element);\n        return null;\n      }\n      return fallbackValue;\n    }\n    const html$1 = freeze([\n      'a',\n      'abbr',\n      'acronym',\n      'address',\n      'area',\n      'article',\n      'aside',\n      'audio',\n      'b',\n      'bdi',\n      'bdo',\n      'big',\n      'blink',\n      'blockquote',\n      'body',\n      'br',\n      'button',\n      'canvas',\n      'caption',\n      'center',\n      'cite',\n      'code',\n      'col',\n      'colgroup',\n      'content',\n      'data',\n      'datalist',\n      'dd',\n      'decorator',\n      'del',\n      'details',\n      'dfn',\n      'dialog',\n      'dir',\n      'div',\n      'dl',\n      'dt',\n      'element',\n      'em',\n      'fieldset',\n      'figcaption',\n      'figure',\n      'font',\n      'footer',\n      'form',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'head',\n      'header',\n      'hgroup',\n      'hr',\n      'html',\n      'i',\n      'img',\n      'input',\n      'ins',\n      'kbd',\n      'label',\n      'legend',\n      'li',\n      'main',\n      'map',\n      'mark',\n      'marquee',\n      'menu',\n      'menuitem',\n      'meter',\n      'nav',\n      'nobr',\n      'ol',\n      'optgroup',\n      'option',\n      'output',\n      'p',\n      'picture',\n      'pre',\n      'progress',\n      'q',\n      'rp',\n      'rt',\n      'ruby',\n      's',\n      'samp',\n      'section',\n      'select',\n      'shadow',\n      'small',\n      'source',\n      'spacer',\n      'span',\n      'strike',\n      'strong',\n      'style',\n      'sub',\n      'summary',\n      'sup',\n      'table',\n      'tbody',\n      'td',\n      'template',\n      'textarea',\n      'tfoot',\n      'th',\n      'thead',\n      'time',\n      'tr',\n      'track',\n      'tt',\n      'u',\n      'ul',\n      'var',\n      'video',\n      'wbr'\n    ]);\n    const svg$1 = freeze([\n      'svg',\n      'a',\n      'altglyph',\n      'altglyphdef',\n      'altglyphitem',\n      'animatecolor',\n      'animatemotion',\n      'animatetransform',\n      'circle',\n      'clippath',\n      'defs',\n      'desc',\n      'ellipse',\n      'filter',\n      'font',\n      'g',\n      'glyph',\n      'glyphref',\n      'hkern',\n      'image',\n      'line',\n      'lineargradient',\n      'marker',\n      'mask',\n      'metadata',\n      'mpath',\n      'path',\n      'pattern',\n      'polygon',\n      'polyline',\n      'radialgradient',\n      'rect',\n      'stop',\n      'style',\n      'switch',\n      'symbol',\n      'text',\n      'textpath',\n      'title',\n      'tref',\n      'tspan',\n      'view',\n      'vkern'\n    ]);\n    const svgFilters = freeze([\n      'feBlend',\n      'feColorMatrix',\n      'feComponentTransfer',\n      'feComposite',\n      'feConvolveMatrix',\n      'feDiffuseLighting',\n      'feDisplacementMap',\n      'feDistantLight',\n      'feDropShadow',\n      'feFlood',\n      'feFuncA',\n      'feFuncB',\n      'feFuncG',\n      'feFuncR',\n      'feGaussianBlur',\n      'feImage',\n      'feMerge',\n      'feMergeNode',\n      'feMorphology',\n      'feOffset',\n      'fePointLight',\n      'feSpecularLighting',\n      'feSpotLight',\n      'feTile',\n      'feTurbulence'\n    ]);\n    const svgDisallowed = freeze([\n      'animate',\n      'color-profile',\n      'cursor',\n      'discard',\n      'font-face',\n      'font-face-format',\n      'font-face-name',\n      'font-face-src',\n      'font-face-uri',\n      'foreignobject',\n      'hatch',\n      'hatchpath',\n      'mesh',\n      'meshgradient',\n      'meshpatch',\n      'meshrow',\n      'missing-glyph',\n      'script',\n      'set',\n      'solidcolor',\n      'unknown',\n      'use'\n    ]);\n    const mathMl$1 = freeze([\n      'math',\n      'menclose',\n      'merror',\n      'mfenced',\n      'mfrac',\n      'mglyph',\n      'mi',\n      'mlabeledtr',\n      'mmultiscripts',\n      'mn',\n      'mo',\n      'mover',\n      'mpadded',\n      'mphantom',\n      'mroot',\n      'mrow',\n      'ms',\n      'mspace',\n      'msqrt',\n      'mstyle',\n      'msub',\n      'msup',\n      'msubsup',\n      'mtable',\n      'mtd',\n      'mtext',\n      'mtr',\n      'munder',\n      'munderover',\n      'mprescripts'\n    ]);\n    const mathMlDisallowed = freeze([\n      'maction',\n      'maligngroup',\n      'malignmark',\n      'mlongdiv',\n      'mscarries',\n      'mscarry',\n      'msgroup',\n      'mstack',\n      'msline',\n      'msrow',\n      'semantics',\n      'annotation',\n      'annotation-xml',\n      'mprescripts',\n      'none'\n    ]);\n    const text = freeze(['#text']);\n    const html = freeze([\n      'accept',\n      'action',\n      'align',\n      'alt',\n      'autocapitalize',\n      'autocomplete',\n      'autopictureinpicture',\n      'autoplay',\n      'background',\n      'bgcolor',\n      'border',\n      'capture',\n      'cellpadding',\n      'cellspacing',\n      'checked',\n      'cite',\n      'class',\n      'clear',\n      'color',\n      'cols',\n      'colspan',\n      'controls',\n      'controlslist',\n      'coords',\n      'crossorigin',\n      'datetime',\n      'decoding',\n      'default',\n      'dir',\n      'disabled',\n      'disablepictureinpicture',\n      'disableremoteplayback',\n      'download',\n      'draggable',\n      'enctype',\n      'enterkeyhint',\n      'face',\n      'for',\n      'headers',\n      'height',\n      'hidden',\n      'high',\n      'href',\n      'hreflang',\n      'id',\n      'inputmode',\n      'integrity',\n      'ismap',\n      'kind',\n      'label',\n      'lang',\n      'list',\n      'loading',\n      'loop',\n      'low',\n      'max',\n      'maxlength',\n      'media',\n      'method',\n      'min',\n      'minlength',\n      'multiple',\n      'muted',\n      'name',\n      'nonce',\n      'noshade',\n      'novalidate',\n      'nowrap',\n      'open',\n      'optimum',\n      'pattern',\n      'placeholder',\n      'playsinline',\n      'poster',\n      'preload',\n      'pubdate',\n      'radiogroup',\n      'readonly',\n      'rel',\n      'required',\n      'rev',\n      'reversed',\n      'role',\n      'rows',\n      'rowspan',\n      'spellcheck',\n      'scope',\n      'selected',\n      'shape',\n      'size',\n      'sizes',\n      'span',\n      'srclang',\n      'start',\n      'src',\n      'srcset',\n      'step',\n      'style',\n      'summary',\n      'tabindex',\n      'title',\n      'translate',\n      'type',\n      'usemap',\n      'valign',\n      'value',\n      'width',\n      'xmlns',\n      'slot'\n    ]);\n    const svg = freeze([\n      'accent-height',\n      'accumulate',\n      'additive',\n      'alignment-baseline',\n      'ascent',\n      'attributename',\n      'attributetype',\n      'azimuth',\n      'basefrequency',\n      'baseline-shift',\n      'begin',\n      'bias',\n      'by',\n      'class',\n      'clip',\n      'clippathunits',\n      'clip-path',\n      'clip-rule',\n      'color',\n      'color-interpolation',\n      'color-interpolation-filters',\n      'color-profile',\n      'color-rendering',\n      'cx',\n      'cy',\n      'd',\n      'dx',\n      'dy',\n      'diffuseconstant',\n      'direction',\n      'display',\n      'divisor',\n      'dur',\n      'edgemode',\n      'elevation',\n      'end',\n      'fill',\n      'fill-opacity',\n      'fill-rule',\n      'filter',\n      'filterunits',\n      'flood-color',\n      'flood-opacity',\n      'font-family',\n      'font-size',\n      'font-size-adjust',\n      'font-stretch',\n      'font-style',\n      'font-variant',\n      'font-weight',\n      'fx',\n      'fy',\n      'g1',\n      'g2',\n      'glyph-name',\n      'glyphref',\n      'gradientunits',\n      'gradienttransform',\n      'height',\n      'href',\n      'id',\n      'image-rendering',\n      'in',\n      'in2',\n      'k',\n      'k1',\n      'k2',\n      'k3',\n      'k4',\n      'kerning',\n      'keypoints',\n      'keysplines',\n      'keytimes',\n      'lang',\n      'lengthadjust',\n      'letter-spacing',\n      'kernelmatrix',\n      'kernelunitlength',\n      'lighting-color',\n      'local',\n      'marker-end',\n      'marker-mid',\n      'marker-start',\n      'markerheight',\n      'markerunits',\n      'markerwidth',\n      'maskcontentunits',\n      'maskunits',\n      'max',\n      'mask',\n      'media',\n      'method',\n      'mode',\n      'min',\n      'name',\n      'numoctaves',\n      'offset',\n      'operator',\n      'opacity',\n      'order',\n      'orient',\n      'orientation',\n      'origin',\n      'overflow',\n      'paint-order',\n      'path',\n      'pathlength',\n      'patterncontentunits',\n      'patterntransform',\n      'patternunits',\n      'points',\n      'preservealpha',\n      'preserveaspectratio',\n      'primitiveunits',\n      'r',\n      'rx',\n      'ry',\n      'radius',\n      'refx',\n      'refy',\n      'repeatcount',\n      'repeatdur',\n      'restart',\n      'result',\n      'rotate',\n      'scale',\n      'seed',\n      'shape-rendering',\n      'specularconstant',\n      'specularexponent',\n      'spreadmethod',\n      'startoffset',\n      'stddeviation',\n      'stitchtiles',\n      'stop-color',\n      'stop-opacity',\n      'stroke-dasharray',\n      'stroke-dashoffset',\n      'stroke-linecap',\n      'stroke-linejoin',\n      'stroke-miterlimit',\n      'stroke-opacity',\n      'stroke',\n      'stroke-width',\n      'style',\n      'surfacescale',\n      'systemlanguage',\n      'tabindex',\n      'targetx',\n      'targety',\n      'transform',\n      'transform-origin',\n      'text-anchor',\n      'text-decoration',\n      'text-rendering',\n      'textlength',\n      'type',\n      'u1',\n      'u2',\n      'unicode',\n      'values',\n      'viewbox',\n      'visibility',\n      'version',\n      'vert-adv-y',\n      'vert-origin-x',\n      'vert-origin-y',\n      'width',\n      'word-spacing',\n      'wrap',\n      'writing-mode',\n      'xchannelselector',\n      'ychannelselector',\n      'x',\n      'x1',\n      'x2',\n      'xmlns',\n      'y',\n      'y1',\n      'y2',\n      'z',\n      'zoomandpan'\n    ]);\n    const mathMl = freeze([\n      'accent',\n      'accentunder',\n      'align',\n      'bevelled',\n      'close',\n      'columnsalign',\n      'columnlines',\n      'columnspan',\n      'denomalign',\n      'depth',\n      'dir',\n      'display',\n      'displaystyle',\n      'encoding',\n      'fence',\n      'frame',\n      'height',\n      'href',\n      'id',\n      'largeop',\n      'length',\n      'linethickness',\n      'lspace',\n      'lquote',\n      'mathbackground',\n      'mathcolor',\n      'mathsize',\n      'mathvariant',\n      'maxsize',\n      'minsize',\n      'movablelimits',\n      'notation',\n      'numalign',\n      'open',\n      'rowalign',\n      'rowlines',\n      'rowspacing',\n      'rowspan',\n      'rspace',\n      'rquote',\n      'scriptlevel',\n      'scriptminsize',\n      'scriptsizemultiplier',\n      'selection',\n      'separator',\n      'separators',\n      'stretchy',\n      'subscriptshift',\n      'supscriptshift',\n      'symmetric',\n      'voffset',\n      'width',\n      'xmlns'\n    ]);\n    const xml = freeze([\n      'xlink:href',\n      'xml:id',\n      'xlink:title',\n      'xml:space',\n      'xmlns:xlink'\n    ]);\n    const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm);\n    const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n    const TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\n    const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/);\n    const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/);\n    const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i);\n    const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n    const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g);\n    const DOCTYPE_NAME = seal(/^html$/i);\n    var EXPRESSIONS = Object.freeze({\n      __proto__: null,\n      MUSTACHE_EXPR: MUSTACHE_EXPR,\n      ERB_EXPR: ERB_EXPR,\n      TMPLIT_EXPR: TMPLIT_EXPR,\n      DATA_ATTR: DATA_ATTR,\n      ARIA_ATTR: ARIA_ATTR,\n      IS_ALLOWED_URI: IS_ALLOWED_URI,\n      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE: ATTR_WHITESPACE,\n      DOCTYPE_NAME: DOCTYPE_NAME\n    });\n    const getGlobal = () => typeof window === 'undefined' ? null : window;\n    const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n      if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n        return null;\n      }\n      let suffix = null;\n      const ATTR_NAME = 'data-tt-policy-suffix';\n      if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n        suffix = purifyHostElement.getAttribute(ATTR_NAME);\n      }\n      const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n      try {\n        return trustedTypes.createPolicy(policyName, {\n          createHTML(html) {\n            return html;\n          },\n          createScriptURL(scriptUrl) {\n            return scriptUrl;\n          }\n        });\n      } catch (_) {\n        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n        return null;\n      }\n    };\n    function createDOMPurify() {\n      let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n      const DOMPurify = root => createDOMPurify(root);\n      DOMPurify.version = '3.0.5';\n      DOMPurify.removed = [];\n      if (!window || !window.document || window.document.nodeType !== 9) {\n        DOMPurify.isSupported = false;\n        return DOMPurify;\n      }\n      const originalDocument = window.document;\n      const currentScript = originalDocument.currentScript;\n      let {document} = window;\n      const {DocumentFragment, HTMLTemplateElement, Node, Element, NodeFilter, NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap, HTMLFormElement, DOMParser, trustedTypes} = window;\n      const ElementPrototype = Element.prototype;\n      const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n      const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n      const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n      const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n      if (typeof HTMLTemplateElement === 'function') {\n        const template = document.createElement('template');\n        if (template.content && template.content.ownerDocument) {\n          document = template.content.ownerDocument;\n        }\n      }\n      let trustedTypesPolicy;\n      let emptyHTML = '';\n      const {implementation, createNodeIterator, createDocumentFragment, getElementsByTagName} = document;\n      const {importNode} = originalDocument;\n      let hooks = {};\n      DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n      const {MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR, DATA_ATTR, ARIA_ATTR, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE} = EXPRESSIONS;\n      let {IS_ALLOWED_URI: IS_ALLOWED_URI$1} = EXPRESSIONS;\n      let ALLOWED_TAGS = null;\n      const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n        ...html$1,\n        ...svg$1,\n        ...svgFilters,\n        ...mathMl$1,\n        ...text\n      ]);\n      let ALLOWED_ATTR = null;\n      const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n        ...html,\n        ...svg,\n        ...mathMl,\n        ...xml\n      ]);\n      let CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\n        tagNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        attributeNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        allowCustomizedBuiltInElements: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: false\n        }\n      }));\n      let FORBID_TAGS = null;\n      let FORBID_ATTR = null;\n      let ALLOW_ARIA_ATTR = true;\n      let ALLOW_DATA_ATTR = true;\n      let ALLOW_UNKNOWN_PROTOCOLS = false;\n      let ALLOW_SELF_CLOSE_IN_ATTR = true;\n      let SAFE_FOR_TEMPLATES = false;\n      let WHOLE_DOCUMENT = false;\n      let SET_CONFIG = false;\n      let FORCE_BODY = false;\n      let RETURN_DOM = false;\n      let RETURN_DOM_FRAGMENT = false;\n      let RETURN_TRUSTED_TYPE = false;\n      let SANITIZE_DOM = true;\n      let SANITIZE_NAMED_PROPS = false;\n      const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n      let KEEP_CONTENT = true;\n      let IN_PLACE = false;\n      let USE_PROFILES = {};\n      let FORBID_CONTENTS = null;\n      const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n        'annotation-xml',\n        'audio',\n        'colgroup',\n        'desc',\n        'foreignobject',\n        'head',\n        'iframe',\n        'math',\n        'mi',\n        'mn',\n        'mo',\n        'ms',\n        'mtext',\n        'noembed',\n        'noframes',\n        'noscript',\n        'plaintext',\n        'script',\n        'style',\n        'svg',\n        'template',\n        'thead',\n        'title',\n        'video',\n        'xmp'\n      ]);\n      let DATA_URI_TAGS = null;\n      const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n        'audio',\n        'video',\n        'img',\n        'source',\n        'image',\n        'track'\n      ]);\n      let URI_SAFE_ATTRIBUTES = null;\n      const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n        'alt',\n        'class',\n        'for',\n        'id',\n        'label',\n        'name',\n        'pattern',\n        'placeholder',\n        'role',\n        'summary',\n        'title',\n        'value',\n        'style',\n        'xmlns'\n      ]);\n      const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n      const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n      const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n      let NAMESPACE = HTML_NAMESPACE;\n      let IS_EMPTY_INPUT = false;\n      let ALLOWED_NAMESPACES = null;\n      const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [\n        MATHML_NAMESPACE,\n        SVG_NAMESPACE,\n        HTML_NAMESPACE\n      ], stringToString);\n      let PARSER_MEDIA_TYPE;\n      const SUPPORTED_PARSER_MEDIA_TYPES = [\n        'application/xhtml+xml',\n        'text/html'\n      ];\n      const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n      let transformCaseFunc;\n      let CONFIG = null;\n      const formElement = document.createElement('form');\n      const isRegexOrFunction = function isRegexOrFunction(testValue) {\n        return testValue instanceof RegExp || testValue instanceof Function;\n      };\n      const _parseConfig = function _parseConfig(cfg) {\n        if (CONFIG && CONFIG === cfg) {\n          return;\n        }\n        if (!cfg || typeof cfg !== 'object') {\n          cfg = {};\n        }\n        cfg = clone(cfg);\n        PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n        ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n        URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\n        DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\n        FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n        FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n        FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n        USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;\n        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;\n        RETURN_DOM = cfg.RETURN_DOM || false;\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;\n        FORCE_BODY = cfg.FORCE_BODY || false;\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false;\n        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false;\n        IN_PLACE = cfg.IN_PLACE || false;\n        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n          ALLOW_DATA_ATTR = false;\n        }\n        if (RETURN_DOM_FRAGMENT) {\n          RETURN_DOM = true;\n        }\n        if (USE_PROFILES) {\n          ALLOWED_TAGS = addToSet({}, [...text]);\n          ALLOWED_ATTR = [];\n          if (USE_PROFILES.html === true) {\n            addToSet(ALLOWED_TAGS, html$1);\n            addToSet(ALLOWED_ATTR, html);\n          }\n          if (USE_PROFILES.svg === true) {\n            addToSet(ALLOWED_TAGS, svg$1);\n            addToSet(ALLOWED_ATTR, svg);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.svgFilters === true) {\n            addToSet(ALLOWED_TAGS, svgFilters);\n            addToSet(ALLOWED_ATTR, svg);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.mathMl === true) {\n            addToSet(ALLOWED_TAGS, mathMl$1);\n            addToSet(ALLOWED_ATTR, mathMl);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n        }\n        if (cfg.ADD_TAGS) {\n          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n            ALLOWED_TAGS = clone(ALLOWED_TAGS);\n          }\n          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n        }\n        if (cfg.ADD_ATTR) {\n          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n            ALLOWED_ATTR = clone(ALLOWED_ATTR);\n          }\n          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n        }\n        if (cfg.ADD_URI_SAFE_ATTR) {\n          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n        }\n        if (cfg.FORBID_CONTENTS) {\n          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n            FORBID_CONTENTS = clone(FORBID_CONTENTS);\n          }\n          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n        }\n        if (KEEP_CONTENT) {\n          ALLOWED_TAGS['#text'] = true;\n        }\n        if (WHOLE_DOCUMENT) {\n          addToSet(ALLOWED_TAGS, [\n            'html',\n            'head',\n            'body'\n          ]);\n        }\n        if (ALLOWED_TAGS.table) {\n          addToSet(ALLOWED_TAGS, ['tbody']);\n          delete FORBID_TAGS.tbody;\n        }\n        if (cfg.TRUSTED_TYPES_POLICY) {\n          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n          }\n          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n          }\n          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n          emptyHTML = trustedTypesPolicy.createHTML('');\n        } else {\n          if (trustedTypesPolicy === undefined) {\n            trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n          }\n          if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n            emptyHTML = trustedTypesPolicy.createHTML('');\n          }\n        }\n        if (freeze) {\n          freeze(cfg);\n        }\n        CONFIG = cfg;\n      };\n      const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n        'mi',\n        'mo',\n        'mn',\n        'ms',\n        'mtext'\n      ]);\n      const HTML_INTEGRATION_POINTS = addToSet({}, [\n        'foreignobject',\n        'desc',\n        'title',\n        'annotation-xml'\n      ]);\n      const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n        'title',\n        'style',\n        'font',\n        'a',\n        'script'\n      ]);\n      const ALL_SVG_TAGS = addToSet({}, svg$1);\n      addToSet(ALL_SVG_TAGS, svgFilters);\n      addToSet(ALL_SVG_TAGS, svgDisallowed);\n      const ALL_MATHML_TAGS = addToSet({}, mathMl$1);\n      addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n      const _checkValidNamespace = function _checkValidNamespace(element) {\n        let parent = getParentNode(element);\n        if (!parent || !parent.tagName) {\n          parent = {\n            namespaceURI: NAMESPACE,\n            tagName: 'template'\n          };\n        }\n        const tagName = stringToLowerCase(element.tagName);\n        const parentTagName = stringToLowerCase(parent.tagName);\n        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n          return false;\n        }\n        if (element.namespaceURI === SVG_NAMESPACE) {\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'svg';\n          }\n          if (parent.namespaceURI === MATHML_NAMESPACE) {\n            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n          }\n          return Boolean(ALL_SVG_TAGS[tagName]);\n        }\n        if (element.namespaceURI === MATHML_NAMESPACE) {\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'math';\n          }\n          if (parent.namespaceURI === SVG_NAMESPACE) {\n            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n          }\n          return Boolean(ALL_MATHML_TAGS[tagName]);\n        }\n        if (element.namespaceURI === HTML_NAMESPACE) {\n          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n        }\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n          return true;\n        }\n        return false;\n      };\n      const _forceRemove = function _forceRemove(node) {\n        arrayPush(DOMPurify.removed, { element: node });\n        try {\n          node.parentNode.removeChild(node);\n        } catch (_) {\n          node.remove();\n        }\n      };\n      const _removeAttribute = function _removeAttribute(name, node) {\n        try {\n          arrayPush(DOMPurify.removed, {\n            attribute: node.getAttributeNode(name),\n            from: node\n          });\n        } catch (_) {\n          arrayPush(DOMPurify.removed, {\n            attribute: null,\n            from: node\n          });\n        }\n        node.removeAttribute(name);\n        if (name === 'is' && !ALLOWED_ATTR[name]) {\n          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n            try {\n              _forceRemove(node);\n            } catch (_) {\n            }\n          } else {\n            try {\n              node.setAttribute(name, '');\n            } catch (_) {\n            }\n          }\n        }\n      };\n      const _initDocument = function _initDocument(dirty) {\n        let doc;\n        let leadingWhitespace;\n        if (FORCE_BODY) {\n          dirty = '<remove></remove>' + dirty;\n        } else {\n          const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n          leadingWhitespace = matches && matches[0];\n        }\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n          dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n        }\n        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        if (NAMESPACE === HTML_NAMESPACE) {\n          try {\n            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n          } catch (_) {\n          }\n        }\n        if (!doc || !doc.documentElement) {\n          doc = implementation.createDocument(NAMESPACE, 'template', null);\n          try {\n            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n          } catch (_) {\n          }\n        }\n        const body = doc.body || doc.documentElement;\n        if (dirty && leadingWhitespace) {\n          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n        }\n        if (NAMESPACE === HTML_NAMESPACE) {\n          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n        }\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\n      };\n      const _createIterator = function _createIterator(root) {\n        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n      };\n      const _isClobbered = function _isClobbered(elm) {\n        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');\n      };\n      const _isNode = function _isNode(object) {\n        return typeof Node === 'object' ? object instanceof Node : object && typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n      };\n      const _executeHook = function _executeHook(entryPoint, currentNode, data) {\n        if (!hooks[entryPoint]) {\n          return;\n        }\n        arrayForEach(hooks[entryPoint], hook => {\n          hook.call(DOMPurify, currentNode, data, CONFIG);\n        });\n      };\n      const _sanitizeElements = function _sanitizeElements(currentNode) {\n        let content;\n        _executeHook('beforeSanitizeElements', currentNode, null);\n        if (_isClobbered(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        const tagName = transformCaseFunc(currentNode.nodeName);\n        _executeHook('uponSanitizeElement', currentNode, {\n          tagName,\n          allowedTags: ALLOWED_TAGS\n        });\n        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))\n              return false;\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))\n              return false;\n          }\n          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n            const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n            const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n            if (childNodes && parentNode) {\n              const childCount = childNodes.length;\n              for (let i = childCount - 1; i >= 0; --i) {\n                parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n              }\n            }\n          }\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n          content = currentNode.textContent;\n          content = stringReplace(content, MUSTACHE_EXPR, ' ');\n          content = stringReplace(content, ERB_EXPR, ' ');\n          content = stringReplace(content, TMPLIT_EXPR, ' ');\n          if (currentNode.textContent !== content) {\n            arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n            currentNode.textContent = content;\n          }\n        }\n        _executeHook('afterSanitizeElements', currentNode, null);\n        return false;\n      };\n      const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n          return false;\n        }\n        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName));\n        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName));\n        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n          if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)));\n          else {\n            return false;\n          }\n        } else if (URI_SAFE_ATTRIBUTES[lcName]);\n        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, '')));\n        else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]);\n        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, '')));\n        else if (value) {\n          return false;\n        } else ;\n        return true;\n      };\n      const _basicCustomElementTest = function _basicCustomElementTest(tagName) {\n        return tagName.indexOf('-') > 0;\n      };\n      const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n        let attr;\n        let value;\n        let lcName;\n        let l;\n        _executeHook('beforeSanitizeAttributes', currentNode, null);\n        const {attributes} = currentNode;\n        if (!attributes) {\n          return;\n        }\n        const hookEvent = {\n          attrName: '',\n          attrValue: '',\n          keepAttr: true,\n          allowedAttributes: ALLOWED_ATTR\n        };\n        l = attributes.length;\n        while (l--) {\n          attr = attributes[l];\n          const {name, namespaceURI} = attr;\n          value = name === 'value' ? attr.value : stringTrim(attr.value);\n          const initValue = value;\n          lcName = transformCaseFunc(name);\n          hookEvent.attrName = lcName;\n          hookEvent.attrValue = value;\n          hookEvent.keepAttr = true;\n          hookEvent.forceKeepAttr = undefined;\n          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n          value = hookEvent.attrValue;\n          if (hookEvent.forceKeepAttr) {\n            continue;\n          }\n          if (!hookEvent.keepAttr) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (SAFE_FOR_TEMPLATES) {\n            value = stringReplace(value, MUSTACHE_EXPR, ' ');\n            value = stringReplace(value, ERB_EXPR, ' ');\n            value = stringReplace(value, TMPLIT_EXPR, ' ');\n          }\n          const lcTag = transformCaseFunc(currentNode.nodeName);\n          if (!_isValidAttribute(lcTag, lcName, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n            _removeAttribute(name, currentNode);\n            value = SANITIZE_NAMED_PROPS_PREFIX + value;\n          }\n          if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n            if (namespaceURI);\n            else {\n              switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n              case 'TrustedHTML': {\n                  value = trustedTypesPolicy.createHTML(value);\n                  break;\n                }\n              case 'TrustedScriptURL': {\n                  value = trustedTypesPolicy.createScriptURL(value);\n                  break;\n                }\n              }\n            }\n          }\n          if (value !== initValue) {\n            try {\n              if (namespaceURI) {\n                currentNode.setAttributeNS(namespaceURI, name, value);\n              } else {\n                currentNode.setAttribute(name, value);\n              }\n            } catch (_) {\n              _removeAttribute(name, currentNode);\n            }\n          }\n        }\n        _executeHook('afterSanitizeAttributes', currentNode, null);\n      };\n      const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n        let shadowNode;\n        const shadowIterator = _createIterator(fragment);\n        _executeHook('beforeSanitizeShadowDOM', fragment, null);\n        while (shadowNode = shadowIterator.nextNode()) {\n          _executeHook('uponSanitizeShadowNode', shadowNode, null);\n          if (_sanitizeElements(shadowNode)) {\n            continue;\n          }\n          if (shadowNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(shadowNode.content);\n          }\n          _sanitizeAttributes(shadowNode);\n        }\n        _executeHook('afterSanitizeShadowDOM', fragment, null);\n      };\n      DOMPurify.sanitize = function (dirty) {\n        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let body;\n        let importedNode;\n        let currentNode;\n        let returnNode;\n        IS_EMPTY_INPUT = !dirty;\n        if (IS_EMPTY_INPUT) {\n          dirty = '<!-->';\n        }\n        if (typeof dirty !== 'string' && !_isNode(dirty)) {\n          if (typeof dirty.toString === 'function') {\n            dirty = dirty.toString();\n            if (typeof dirty !== 'string') {\n              throw typeErrorCreate('dirty is not a string, aborting');\n            }\n          } else {\n            throw typeErrorCreate('toString is not a function');\n          }\n        }\n        if (!DOMPurify.isSupported) {\n          return dirty;\n        }\n        if (!SET_CONFIG) {\n          _parseConfig(cfg);\n        }\n        DOMPurify.removed = [];\n        if (typeof dirty === 'string') {\n          IN_PLACE = false;\n        }\n        if (IN_PLACE) {\n          if (dirty.nodeName) {\n            const tagName = transformCaseFunc(dirty.nodeName);\n            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n            }\n          }\n        } else if (dirty instanceof Node) {\n          body = _initDocument('<!---->');\n          importedNode = body.ownerDocument.importNode(dirty, true);\n          if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n            body = importedNode;\n          } else if (importedNode.nodeName === 'HTML') {\n            body = importedNode;\n          } else {\n            body.appendChild(importedNode);\n          }\n        } else {\n          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {\n            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n          }\n          body = _initDocument(dirty);\n          if (!body) {\n            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n          }\n        }\n        if (body && FORCE_BODY) {\n          _forceRemove(body.firstChild);\n        }\n        const nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n        while (currentNode = nodeIterator.nextNode()) {\n          if (_sanitizeElements(currentNode)) {\n            continue;\n          }\n          if (currentNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(currentNode.content);\n          }\n          _sanitizeAttributes(currentNode);\n        }\n        if (IN_PLACE) {\n          return dirty;\n        }\n        if (RETURN_DOM) {\n          if (RETURN_DOM_FRAGMENT) {\n            returnNode = createDocumentFragment.call(body.ownerDocument);\n            while (body.firstChild) {\n              returnNode.appendChild(body.firstChild);\n            }\n          } else {\n            returnNode = body;\n          }\n          if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n            returnNode = importNode.call(originalDocument, returnNode, true);\n          }\n          return returnNode;\n        }\n        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n          serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR, ' ');\n          serializedHTML = stringReplace(serializedHTML, ERB_EXPR, ' ');\n          serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR, ' ');\n        }\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n      };\n      DOMPurify.setConfig = function (cfg) {\n        _parseConfig(cfg);\n        SET_CONFIG = true;\n      };\n      DOMPurify.clearConfig = function () {\n        CONFIG = null;\n        SET_CONFIG = false;\n      };\n      DOMPurify.isValidAttribute = function (tag, attr, value) {\n        if (!CONFIG) {\n          _parseConfig({});\n        }\n        const lcTag = transformCaseFunc(tag);\n        const lcName = transformCaseFunc(attr);\n        return _isValidAttribute(lcTag, lcName, value);\n      };\n      DOMPurify.addHook = function (entryPoint, hookFunction) {\n        if (typeof hookFunction !== 'function') {\n          return;\n        }\n        hooks[entryPoint] = hooks[entryPoint] || [];\n        arrayPush(hooks[entryPoint], hookFunction);\n      };\n      DOMPurify.removeHook = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          return arrayPop(hooks[entryPoint]);\n        }\n      };\n      DOMPurify.removeHooks = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          hooks[entryPoint] = [];\n        }\n      };\n      DOMPurify.removeAllHooks = function () {\n        hooks = {};\n      };\n      return DOMPurify;\n    }\n    var purify = createDOMPurify();\n\n    const each$4 = Tools.each, trim = Tools.trim;\n    const queryParts = [\n      'source',\n      'protocol',\n      'authority',\n      'userInfo',\n      'user',\n      'password',\n      'host',\n      'port',\n      'relative',\n      'path',\n      'directory',\n      'file',\n      'query',\n      'anchor'\n    ];\n    const DEFAULT_PORTS = {\n      ftp: 21,\n      http: 80,\n      https: 443,\n      mailto: 25\n    };\n    const safeSvgDataUrlElements = [\n      'img',\n      'video'\n    ];\n    const blockSvgDataUris = (allowSvgDataUrls, tagName) => {\n      if (isNonNullable(allowSvgDataUrls)) {\n        return !allowSvgDataUrls;\n      } else {\n        return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;\n      }\n    };\n    const decodeUri = encodedUri => {\n      try {\n        return decodeURIComponent(encodedUri);\n      } catch (ex) {\n        return unescape(encodedUri);\n      }\n    };\n    const isInvalidUri = (settings, uri, tagName) => {\n      const decodedUri = decodeUri(uri).replace(/\\s/g, '');\n      if (settings.allow_script_urls) {\n        return false;\n      } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {\n        return true;\n      } else if (settings.allow_html_data_urls) {\n        return false;\n      } else if (/^data:image\\//i.test(decodedUri)) {\n        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\\/svg\\+xml/i.test(decodedUri);\n      } else {\n        return /^data:/i.test(decodedUri);\n      }\n    };\n    class URI {\n      static parseDataUri(uri) {\n        let type;\n        const uriComponents = decodeURIComponent(uri).split(',');\n        const matches = /data:([^;]+)/.exec(uriComponents[0]);\n        if (matches) {\n          type = matches[1];\n        }\n        return {\n          type,\n          data: uriComponents[1]\n        };\n      }\n      static isDomSafe(uri, context, options = {}) {\n        if (options.allow_script_urls) {\n          return true;\n        } else {\n          const decodedUri = Entities.decode(uri).replace(/[\\s\\u0000-\\u001F]+/g, '');\n          return !isInvalidUri(options, decodedUri, context);\n        }\n      }\n      static getDocumentBaseUrl(loc) {\n        var _a;\n        let baseUrl;\n        if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {\n          baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : '';\n        } else {\n          baseUrl = loc.protocol + '//' + loc.host + loc.pathname;\n        }\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(baseUrl)) {\n          baseUrl = baseUrl.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n          if (!/[\\/\\\\]$/.test(baseUrl)) {\n            baseUrl += '/';\n          }\n        }\n        return baseUrl;\n      }\n      constructor(url, settings = {}) {\n        this.path = '';\n        this.directory = '';\n        url = trim(url);\n        this.settings = settings;\n        const baseUri = settings.base_uri;\n        const self = this;\n        if (/^([\\w\\-]+):([^\\/]{2})/i.test(url) || /^\\s*#/.test(url)) {\n          self.source = url;\n          return;\n        }\n        const isProtocolRelative = url.indexOf('//') === 0;\n        if (url.indexOf('/') === 0 && !isProtocolRelative) {\n          url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;\n        }\n        if (!/^[\\w\\-]*:?\\/\\//.test(url)) {\n          const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;\n          if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === '') {\n            url = '//mce_host' + self.toAbsPath(baseUrl, url);\n          } else {\n            const match = /([^#?]*)([#?]?.*)/.exec(url);\n            if (match) {\n              url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];\n            }\n          }\n        }\n        url = url.replace(/@@/g, '(mce_at)');\n        const urlMatch = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@\\/]*):?([^:@\\/]*))?@)?(\\[[a-zA-Z0-9:.%]+\\]|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/.exec(url);\n        if (urlMatch) {\n          each$4(queryParts, (v, i) => {\n            let part = urlMatch[i];\n            if (part) {\n              part = part.replace(/\\(mce_at\\)/g, '@@');\n            }\n            self[v] = part;\n          });\n        }\n        if (baseUri) {\n          if (!self.protocol) {\n            self.protocol = baseUri.protocol;\n          }\n          if (!self.userInfo) {\n            self.userInfo = baseUri.userInfo;\n          }\n          if (!self.port && self.host === 'mce_host') {\n            self.port = baseUri.port;\n          }\n          if (!self.host || self.host === 'mce_host') {\n            self.host = baseUri.host;\n          }\n          self.source = '';\n        }\n        if (isProtocolRelative) {\n          self.protocol = '';\n        }\n      }\n      setPath(path) {\n        const pathMatch = /^(.*?)\\/?(\\w+)?$/.exec(path);\n        if (pathMatch) {\n          this.path = pathMatch[0];\n          this.directory = pathMatch[1];\n          this.file = pathMatch[2];\n        }\n        this.source = '';\n        this.getURI();\n      }\n      toRelative(uri) {\n        if (uri === './') {\n          return uri;\n        }\n        const relativeUri = new URI(uri, { base_uri: this });\n        if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {\n          return relativeUri.getURI();\n        }\n        const tu = this.getURI(), uu = relativeUri.getURI();\n        if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {\n          return tu;\n        }\n        let output = this.toRelPath(this.path, relativeUri.path);\n        if (relativeUri.query) {\n          output += '?' + relativeUri.query;\n        }\n        if (relativeUri.anchor) {\n          output += '#' + relativeUri.anchor;\n        }\n        return output;\n      }\n      toAbsolute(uri, noHost) {\n        const absoluteUri = new URI(uri, { base_uri: this });\n        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));\n      }\n      isSameOrigin(uri) {\n        if (this.host == uri.host && this.protocol == uri.protocol) {\n          if (this.port == uri.port) {\n            return true;\n          }\n          const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;\n          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      toRelPath(base, path) {\n        let breakPoint = 0, out = '', i, l;\n        const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');\n        const items = path.split('/');\n        if (normalizedBase.length >= items.length) {\n          for (i = 0, l = normalizedBase.length; i < l; i++) {\n            if (i >= items.length || normalizedBase[i] !== items[i]) {\n              breakPoint = i + 1;\n              break;\n            }\n          }\n        }\n        if (normalizedBase.length < items.length) {\n          for (i = 0, l = items.length; i < l; i++) {\n            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {\n              breakPoint = i + 1;\n              break;\n            }\n          }\n        }\n        if (breakPoint === 1) {\n          return path;\n        }\n        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {\n          out += '../';\n        }\n        for (i = breakPoint - 1, l = items.length; i < l; i++) {\n          if (i !== breakPoint - 1) {\n            out += '/' + items[i];\n          } else {\n            out += items[i];\n          }\n        }\n        return out;\n      }\n      toAbsPath(base, path) {\n        let nb = 0;\n        const tr = /\\/$/.test(path) ? '/' : '';\n        const normalizedBase = base.split('/');\n        const normalizedPath = path.split('/');\n        const baseParts = [];\n        each$4(normalizedBase, k => {\n          if (k) {\n            baseParts.push(k);\n          }\n        });\n        const pathParts = [];\n        for (let i = normalizedPath.length - 1; i >= 0; i--) {\n          if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {\n            continue;\n          }\n          if (normalizedPath[i] === '..') {\n            nb++;\n            continue;\n          }\n          if (nb > 0) {\n            nb--;\n            continue;\n          }\n          pathParts.push(normalizedPath[i]);\n        }\n        const i = baseParts.length - nb;\n        let outPath;\n        if (i <= 0) {\n          outPath = reverse(pathParts).join('/');\n        } else {\n          outPath = baseParts.slice(0, i).join('/') + '/' + reverse(pathParts).join('/');\n        }\n        if (outPath.indexOf('/') !== 0) {\n          outPath = '/' + outPath;\n        }\n        if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {\n          outPath += tr;\n        }\n        return outPath;\n      }\n      getURI(noProtoHost = false) {\n        let s;\n        if (!this.source || noProtoHost) {\n          s = '';\n          if (!noProtoHost) {\n            if (this.protocol) {\n              s += this.protocol + '://';\n            } else {\n              s += '//';\n            }\n            if (this.userInfo) {\n              s += this.userInfo + '@';\n            }\n            if (this.host) {\n              s += this.host;\n            }\n            if (this.port) {\n              s += ':' + this.port;\n            }\n          }\n          if (this.path) {\n            s += this.path;\n          }\n          if (this.query) {\n            s += '?' + this.query;\n          }\n          if (this.anchor) {\n            s += '#' + this.anchor;\n          }\n          this.source = s;\n        }\n        return this.source;\n      }\n    }\n\n    const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');\n    const internalElementAttr = 'data-mce-type';\n    let uid = 0;\n    const processNode = (node, settings, schema, scope, evt) => {\n      var _a, _b, _c, _d;\n      const validate = settings.validate;\n      const specialElements = schema.getSpecialElements();\n      if (node.nodeType === COMMENT && !settings.allow_conditional_comments && /^\\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : '')) {\n        node.nodeValue = ' ' + node.nodeValue;\n      }\n      const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();\n      if (scope !== 'html' && schema.isValid(scope)) {\n        if (isNonNullable(evt)) {\n          evt.allowedTags[lcTagName] = true;\n        }\n        return;\n      }\n      if (node.nodeType !== ELEMENT || lcTagName === 'body') {\n        return;\n      }\n      const element = SugarElement.fromDom(node);\n      const isInternalElement = has$1(element, internalElementAttr);\n      const bogus = get$9(element, 'data-mce-bogus');\n      if (!isInternalElement && isString(bogus)) {\n        if (bogus === 'all') {\n          remove$4(element);\n        } else {\n          unwrap(element);\n        }\n        return;\n      }\n      const rule = schema.getElementRule(lcTagName);\n      if (validate && !rule) {\n        if (has$2(specialElements, lcTagName)) {\n          remove$4(element);\n        } else {\n          unwrap(element);\n        }\n        return;\n      } else {\n        if (isNonNullable(evt)) {\n          evt.allowedTags[lcTagName] = true;\n        }\n      }\n      if (validate && rule && !isInternalElement) {\n        each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], attr => {\n          set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\n        });\n        each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], attr => {\n          if (!has$1(element, attr.name)) {\n            set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\n          }\n        });\n        if (rule.attributesRequired && !exists(rule.attributesRequired, attr => has$1(element, attr))) {\n          unwrap(element);\n          return;\n        }\n        if (rule.removeEmptyAttrs && hasNone(element)) {\n          unwrap(element);\n          return;\n        }\n        if (rule.outputName && rule.outputName !== lcTagName) {\n          mutate(element, rule.outputName);\n        }\n      }\n    };\n    const processAttr = (ele, settings, schema, scope, evt) => {\n      const tagName = ele.tagName.toLowerCase();\n      const {attrName, attrValue} = evt;\n      evt.keepAttr = shouldKeepAttribute(settings, schema, scope, tagName, attrName, attrValue);\n      if (evt.keepAttr) {\n        evt.allowedAttributes[attrName] = true;\n        if (isBooleanAttribute(attrName, schema)) {\n          evt.attrValue = attrName;\n        }\n        if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {\n          evt.forceKeepAttr = true;\n        }\n      } else if (isRequiredAttributeOfInternalElement(ele, attrName)) {\n        evt.forceKeepAttr = true;\n      }\n    };\n    const shouldKeepAttribute = (settings, schema, scope, tagName, attrName, attrValue) => {\n      if (scope !== 'html' && !isNonHtmlElementRootName(tagName)) {\n        return true;\n      }\n      return !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) && (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-'));\n    };\n    const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style');\n    const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();\n    const filterAttributes = (ele, settings, schema, scope) => {\n      const {attributes} = ele;\n      for (let i = attributes.length - 1; i >= 0; i--) {\n        const attr = attributes[i];\n        const attrName = attr.name;\n        const attrValue = attr.value;\n        if (!shouldKeepAttribute(settings, schema, scope, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) {\n          ele.removeAttribute(attrName);\n        } else if (isBooleanAttribute(attrName, schema)) {\n          ele.setAttribute(attrName, attrName);\n        }\n      }\n    };\n    const setupPurify = (settings, schema, namespaceTracker) => {\n      const purify$1 = purify();\n      purify$1.addHook('uponSanitizeElement', (ele, evt) => {\n        processNode(ele, settings, schema, namespaceTracker.track(ele), evt);\n      });\n      purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {\n        processAttr(ele, settings, schema, namespaceTracker.current(), evt);\n      });\n      return purify$1;\n    };\n    const getPurifyConfig = (settings, mimeType) => {\n      const basePurifyConfig = {\n        IN_PLACE: true,\n        ALLOW_UNKNOWN_PROTOCOLS: true,\n        ALLOWED_TAGS: [\n          '#comment',\n          '#cdata-section',\n          'body'\n        ],\n        ALLOWED_ATTR: []\n      };\n      const config = { ...basePurifyConfig };\n      config.PARSER_MEDIA_TYPE = mimeType;\n      if (settings.allow_script_urls) {\n        config.ALLOWED_URI_REGEXP = /.*/;\n      } else if (settings.allow_html_data_urls) {\n        config.ALLOWED_URI_REGEXP = /^(?!(\\w+script|mhtml):)/i;\n      }\n      return config;\n    };\n    const sanitizeNamespaceElement = ele => {\n      const namespaceType = toScopeType(ele);\n      if (namespaceType === 'svg') {\n        const xlinkAttrs = [\n          'type',\n          'href',\n          'role',\n          'arcrole',\n          'title',\n          'show',\n          'actuate',\n          'label',\n          'from',\n          'to'\n        ].map(name => `xlink:${ name }`);\n        const config = {\n          IN_PLACE: true,\n          USE_PROFILES: {\n            html: true,\n            svg: true,\n            svgFilters: true\n          },\n          ALLOWED_ATTR: xlinkAttrs\n        };\n        purify().sanitize(ele, config);\n      } else if (namespaceType === 'math') {\n        const config = {\n          IN_PLACE: true,\n          USE_PROFILES: { mathMl: true }\n        };\n        purify().sanitize(ele, config);\n      } else {\n        throw new Error('Not a namespace element');\n      }\n    };\n    const getSanitizer = (settings, schema) => {\n      const namespaceTracker = createNamespaceTracker();\n      if (settings.sanitize) {\n        const purify = setupPurify(settings, schema, namespaceTracker);\n        const sanitizeHtmlElement = (body, mimeType) => {\n          purify.sanitize(body, getPurifyConfig(settings, mimeType));\n          purify.removed = [];\n          namespaceTracker.reset();\n        };\n        return {\n          sanitizeHtmlElement,\n          sanitizeNamespaceElement\n        };\n      } else {\n        const sanitizeHtmlElement = (body, _mimeType) => {\n          const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);\n          let node;\n          while (node = nodeIterator.nextNode()) {\n            const currentScope = namespaceTracker.track(node);\n            processNode(node, settings, schema, currentScope);\n            if (isElement$6(node)) {\n              filterAttributes(node, settings, schema, currentScope);\n            }\n          }\n          namespaceTracker.reset();\n        };\n        const sanitizeNamespaceElement = noop;\n        return {\n          sanitizeHtmlElement,\n          sanitizeNamespaceElement\n        };\n      }\n    };\n\n    const makeMap = Tools.makeMap, extend$1 = Tools.extend;\n    const transferChildren = (parent, nativeParent, specialElements, nsSanitizer) => {\n      const parentName = parent.name;\n      const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea' && parentName !== 'noscript';\n      const childNodes = nativeParent.childNodes;\n      for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {\n        const nativeChild = childNodes[ni];\n        const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);\n        if (isElement$6(nativeChild)) {\n          const attributes = nativeChild.attributes;\n          for (let ai = 0, al = attributes.length; ai < al; ai++) {\n            const attr = attributes[ai];\n            child.attr(attr.name, attr.value);\n          }\n          if (isNonHtmlElementRootName(child.name)) {\n            nsSanitizer(nativeChild);\n            child.value = nativeChild.innerHTML;\n          }\n        } else if (isText$b(nativeChild)) {\n          child.value = nativeChild.data;\n          if (isSpecial) {\n            child.raw = true;\n          }\n        } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {\n          child.value = nativeChild.data;\n        }\n        if (!isNonHtmlElementRootName(child.name)) {\n          transferChildren(child, nativeChild, specialElements, nsSanitizer);\n        }\n        parent.append(child);\n      }\n    };\n    const walkTree = (root, preprocessors, postprocessors) => {\n      const traverseOrder = [];\n      for (let node = root, lastNode = node; node; lastNode = node, node = node.walk()) {\n        const tempNode = node;\n        each$e(preprocessors, preprocess => preprocess(tempNode));\n        if (isNullable(tempNode.parent) && tempNode !== root) {\n          node = lastNode;\n        } else {\n          traverseOrder.push(tempNode);\n        }\n      }\n      for (let i = traverseOrder.length - 1; i >= 0; i--) {\n        const node = traverseOrder[i];\n        each$e(postprocessors, postprocess => postprocess(node));\n      }\n    };\n    const whitespaceCleaner = (root, schema, settings, args) => {\n      const validate = settings.validate;\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n      const textRootBlockElements = getTextRootBlockElements(schema);\n      const allWhiteSpaceRegExp = /[ \\t\\r\\n]+/g;\n      const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n      const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n      const hasWhitespaceParent = node => {\n        let tempNode = node.parent;\n        while (isNonNullable(tempNode)) {\n          if (tempNode.name in whitespaceElements) {\n            return true;\n          } else {\n            tempNode = tempNode.parent;\n          }\n        }\n        return false;\n      };\n      const isTextRootBlockEmpty = node => {\n        let tempNode = node;\n        while (isNonNullable(tempNode)) {\n          if (tempNode.name in textRootBlockElements) {\n            return isEmpty(schema, nonEmptyElements, whitespaceElements, tempNode);\n          } else {\n            tempNode = tempNode.parent;\n          }\n        }\n        return false;\n      };\n      const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node) || isNonHtmlElementRootName(node.name) && node.parent === root;\n      const isAtEdgeOfBlock = (node, start) => {\n        const neighbour = start ? node.prev : node.next;\n        if (isNonNullable(neighbour) || isNullable(node.parent)) {\n          return false;\n        }\n        return isBlock(node.parent) && (node.parent !== root || args.isRootContent === true);\n      };\n      const preprocess = node => {\n        var _a;\n        if (node.type === 3) {\n          if (!hasWhitespaceParent(node)) {\n            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n            text = text.replace(allWhiteSpaceRegExp, ' ');\n            if (isLineBreakNode(node.prev, isBlock) || isAtEdgeOfBlock(node, true)) {\n              text = text.replace(startWhiteSpaceRegExp, '');\n            }\n            if (text.length === 0) {\n              node.remove();\n            } else {\n              node.value = text;\n            }\n          }\n        }\n      };\n      const postprocess = node => {\n        var _a;\n        if (node.type === 1) {\n          const elementRule = schema.getElementRule(node.name);\n          if (validate && elementRule) {\n            const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);\n            if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {\n              paddEmptyNode(settings, args, isBlock, node);\n            } else if (elementRule.removeEmpty && isNodeEmpty) {\n              if (isBlock(node)) {\n                node.remove();\n              } else {\n                node.unwrap();\n              }\n            } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {\n              paddEmptyNode(settings, args, isBlock, node);\n            }\n          }\n        } else if (node.type === 3) {\n          if (!hasWhitespaceParent(node)) {\n            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n            if (node.next && isBlock(node.next) || isAtEdgeOfBlock(node, false)) {\n              text = text.replace(endWhiteSpaceRegExp, '');\n            }\n            if (text.length === 0) {\n              node.remove();\n            } else {\n              node.value = text;\n            }\n          }\n        }\n      };\n      return [\n        preprocess,\n        postprocess\n      ];\n    };\n    const getRootBlockName = (settings, args) => {\n      var _a;\n      const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;\n      if (name === false) {\n        return '';\n      } else if (name === true) {\n        return 'p';\n      } else {\n        return name;\n      }\n    };\n    const DomParser = (settings = {}, schema = Schema()) => {\n      const nodeFilterRegistry = create$8();\n      const attributeFilterRegistry = create$8();\n      const defaultedSettings = {\n        validate: true,\n        root_name: 'body',\n        sanitize: true,\n        ...settings\n      };\n      const parser = new DOMParser();\n      const sanitizer = getSanitizer(defaultedSettings, schema);\n      const parseAndSanitizeWithContext = (html, rootName, format = 'html') => {\n        const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';\n        const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());\n        const content = isSpecialRoot ? `<${ rootName }>${ html }</${ rootName }>` : html;\n        const wrappedHtml = format === 'xhtml' ? `<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>${ content }</body></html>` : `<body>${ content }</body>`;\n        const body = parser.parseFromString(wrappedHtml, mimeType).body;\n        sanitizer.sanitizeHtmlElement(body, mimeType);\n        return isSpecialRoot ? body.firstChild : body;\n      };\n      const addNodeFilter = nodeFilterRegistry.addFilter;\n      const getNodeFilters = nodeFilterRegistry.getFilters;\n      const removeNodeFilter = nodeFilterRegistry.removeFilter;\n      const addAttributeFilter = attributeFilterRegistry.addFilter;\n      const getAttributeFilters = attributeFilterRegistry.getFilters;\n      const removeAttributeFilter = attributeFilterRegistry.removeFilter;\n      const findInvalidChildren = (node, invalidChildren) => {\n        if (isInvalid(schema, node)) {\n          invalidChildren.push(node);\n        }\n      };\n      const isWrappableNode = (blockElements, node) => {\n        const isInternalElement = isString(node.attr(internalElementAttr));\n        const isInlineElement = node.type === 1 && (!has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node)) && !isNonHtmlElementRootName(node.name);\n        return node.type === 3 || isInlineElement && !isInternalElement;\n      };\n      const addRootBlocks = (rootNode, rootBlockName) => {\n        const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n        const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n        const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n        let node = rootNode.firstChild, rootBlockNode = null;\n        const trim = rootBlock => {\n          var _a, _b;\n          if (rootBlock) {\n            node = rootBlock.firstChild;\n            if (node && node.type === 3) {\n              node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, '');\n            }\n            node = rootBlock.lastChild;\n            if (node && node.type === 3) {\n              node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, '');\n            }\n          }\n        };\n        if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {\n          return;\n        }\n        while (node) {\n          const next = node.next;\n          if (isWrappableNode(blockElements, node)) {\n            if (!rootBlockNode) {\n              rootBlockNode = new AstNode(rootBlockName, 1);\n              rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);\n              rootNode.insert(rootBlockNode, node);\n              rootBlockNode.append(node);\n            } else {\n              rootBlockNode.append(node);\n            }\n          } else {\n            trim(rootBlockNode);\n            rootBlockNode = null;\n          }\n          node = next;\n        }\n        trim(rootBlockNode);\n      };\n      const parse = (html, args = {}) => {\n        var _a;\n        const validate = defaultedSettings.validate;\n        const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;\n        const element = parseAndSanitizeWithContext(html, rootName, args.format);\n        updateChildren(schema, element);\n        const rootNode = new AstNode(rootName, 11);\n        transferChildren(rootNode, element, schema.getSpecialElements(), sanitizer.sanitizeNamespaceElement);\n        element.innerHTML = '';\n        const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);\n        const invalidChildren = [];\n        const invalidFinder = validate ? node => findInvalidChildren(node, invalidChildren) : noop;\n        const matches = {\n          nodes: {},\n          attributes: {}\n        };\n        const matchFinder = node => matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);\n        walkTree(rootNode, [\n          whitespacePre,\n          matchFinder\n        ], [\n          whitespacePost,\n          invalidFinder\n        ]);\n        invalidChildren.reverse();\n        if (validate && invalidChildren.length > 0) {\n          if (args.context) {\n            const {\n              pass: topLevelChildren,\n              fail: otherChildren\n            } = partition$2(invalidChildren, child => child.parent === rootNode);\n            cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);\n            args.invalid = topLevelChildren.length > 0;\n          } else {\n            cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);\n          }\n        }\n        const rootBlockName = getRootBlockName(defaultedSettings, args);\n        if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {\n          addRootBlocks(rootNode, rootBlockName);\n        }\n        if (!args.invalid) {\n          runFilters(matches, args);\n        }\n        return rootNode;\n      };\n      const exports = {\n        schema,\n        addAttributeFilter,\n        getAttributeFilters,\n        removeAttributeFilter,\n        addNodeFilter,\n        getNodeFilters,\n        removeNodeFilter,\n        parse\n      };\n      register$4(exports, defaultedSettings);\n      register$5(exports, defaultedSettings, schema);\n      return exports;\n    };\n\n    const serializeContent = content => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;\n    const withSerializedContent = (content, fireEvent, parserSettings) => {\n      const serializedContent = serializeContent(content);\n      const eventArgs = fireEvent(serializedContent);\n      if (eventArgs.isDefaultPrevented()) {\n        return eventArgs;\n      } else if (isTreeNode(content)) {\n        if (eventArgs.content !== serializedContent) {\n          const rootNode = DomParser({\n            validate: false,\n            forced_root_block: false,\n            ...parserSettings\n          }).parse(eventArgs.content, { context: content.name });\n          return {\n            ...eventArgs,\n            content: rootNode\n          };\n        } else {\n          return {\n            ...eventArgs,\n            content\n          };\n        }\n      } else {\n        return eventArgs;\n      }\n    };\n    const makeParserSettings = editor => ({\n      sanitize: shouldSanitizeXss(editor),\n      sandbox_iframes: shouldSandboxIframes(editor),\n      sandbox_iframes_exclusions: getSandboxIframesExclusions(editor)\n    });\n    const preProcessGetContent = (editor, args) => {\n      if (args.no_events) {\n        return Result.value(args);\n      } else {\n        const eventArgs = fireBeforeGetContent(editor, args);\n        if (eventArgs.isDefaultPrevented()) {\n          return Result.error(fireGetContent(editor, {\n            content: '',\n            ...eventArgs\n          }).content);\n        } else {\n          return Result.value(eventArgs);\n        }\n      }\n    };\n    const postProcessGetContent = (editor, content, args) => {\n      if (args.no_events) {\n        return content;\n      } else {\n        const processedEventArgs = withSerializedContent(content, content => fireGetContent(editor, {\n          ...args,\n          content\n        }), makeParserSettings(editor));\n        return processedEventArgs.content;\n      }\n    };\n    const preProcessSetContent = (editor, args) => {\n      if (args.no_events) {\n        return Result.value(args);\n      } else {\n        const processedEventArgs = withSerializedContent(args.content, content => fireBeforeSetContent(editor, {\n          ...args,\n          content\n        }), makeParserSettings(editor));\n        if (processedEventArgs.isDefaultPrevented()) {\n          fireSetContent(editor, processedEventArgs);\n          return Result.error(undefined);\n        } else {\n          return Result.value(processedEventArgs);\n        }\n      }\n    };\n    const postProcessSetContent = (editor, content, args) => {\n      if (!args.no_events) {\n        fireSetContent(editor, {\n          ...args,\n          content\n        });\n      }\n    };\n\n    const tableModel = (element, width, rows) => ({\n      element,\n      width,\n      rows\n    });\n    const tableRow = (element, cells) => ({\n      element,\n      cells\n    });\n    const cellPosition = (x, y) => ({\n      x,\n      y\n    });\n    const getSpan = (td, key) => {\n      return getOpt(td, key).bind(toInt).getOr(1);\n    };\n    const fillout = (table, x, y, tr, td) => {\n      const rowspan = getSpan(td, 'rowspan');\n      const colspan = getSpan(td, 'colspan');\n      const rows = table.rows;\n      for (let y2 = y; y2 < y + rowspan; y2++) {\n        if (!rows[y2]) {\n          rows[y2] = tableRow(deep$1(tr), []);\n        }\n        for (let x2 = x; x2 < x + colspan; x2++) {\n          const cells = rows[y2].cells;\n          cells[x2] = y2 === y && x2 === x ? td : shallow$1(td);\n        }\n      }\n    };\n    const cellExists = (table, x, y) => {\n      const rows = table.rows;\n      const cells = rows[y] ? rows[y].cells : [];\n      return !!cells[x];\n    };\n    const skipCellsX = (table, x, y) => {\n      while (cellExists(table, x, y)) {\n        x++;\n      }\n      return x;\n    };\n    const getWidth = rows => {\n      return foldl(rows, (acc, row) => {\n        return row.cells.length > acc ? row.cells.length : acc;\n      }, 0);\n    };\n    const findElementPos = (table, element) => {\n      const rows = table.rows;\n      for (let y = 0; y < rows.length; y++) {\n        const cells = rows[y].cells;\n        for (let x = 0; x < cells.length; x++) {\n          if (eq(cells[x], element)) {\n            return Optional.some(cellPosition(x, y));\n          }\n        }\n      }\n      return Optional.none();\n    };\n    const extractRows = (table, sx, sy, ex, ey) => {\n      const newRows = [];\n      const rows = table.rows;\n      for (let y = sy; y <= ey; y++) {\n        const cells = rows[y].cells;\n        const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);\n        newRows.push(tableRow(rows[y].element, slice));\n      }\n      return newRows;\n    };\n    const subTable = (table, startPos, endPos) => {\n      const sx = startPos.x, sy = startPos.y;\n      const ex = endPos.x, ey = endPos.y;\n      const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);\n      return tableModel(table.element, getWidth(newRows), newRows);\n    };\n    const createDomTable = (table, rows) => {\n      const tableElement = shallow$1(table.element);\n      const tableBody = SugarElement.fromTag('tbody');\n      append(tableBody, rows);\n      append$1(tableElement, tableBody);\n      return tableElement;\n    };\n    const modelRowsToDomRows = table => {\n      return map$3(table.rows, row => {\n        const cells = map$3(row.cells, cell => {\n          const td = deep$1(cell);\n          remove$9(td, 'colspan');\n          remove$9(td, 'rowspan');\n          return td;\n        });\n        const tr = shallow$1(row.element);\n        append(tr, cells);\n        return tr;\n      });\n    };\n    const fromDom = tableElm => {\n      const table = tableModel(shallow$1(tableElm), 0, []);\n      each$e(descendants(tableElm, 'tr'), (tr, y) => {\n        each$e(descendants(tr, 'td,th'), (td, x) => {\n          fillout(table, skipCellsX(table, x, y), y, tr, td);\n        });\n      });\n      return tableModel(table.element, getWidth(table.rows), table.rows);\n    };\n    const toDom = table => {\n      return createDomTable(table, modelRowsToDomRows(table));\n    };\n    const subsection = (table, startElement, endElement) => {\n      return findElementPos(table, startElement).bind(startPos => {\n        return findElementPos(table, endElement).map(endPos => {\n          return subTable(table, startPos, endPos);\n        });\n      });\n    };\n\n    const findParentListContainer = parents => find$2(parents, elm => name(elm) === 'ul' || name(elm) === 'ol');\n    const getFullySelectedListWrappers = (parents, rng) => find$2(parents, elm => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), _li => findParentListContainer(parents).map(listCont => {\n      const listElm = SugarElement.fromTag(name(listCont));\n      const listStyles = filter$4(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));\n      setAll(listElm, listStyles);\n      return [\n        SugarElement.fromTag('li'),\n        listElm\n      ];\n    }).getOr([]));\n    const wrap = (innerElm, elms) => {\n      const wrapped = foldl(elms, (acc, elm) => {\n        append$1(elm, acc);\n        return elm;\n      }, innerElm);\n      return elms.length > 0 ? fromElements([wrapped]) : wrapped;\n    };\n    const directListWrappers = commonAnchorContainer => {\n      if (isListItem$1(commonAnchorContainer)) {\n        return parent(commonAnchorContainer).filter(isList).fold(constant([]), listElm => [\n          commonAnchorContainer,\n          listElm\n        ]);\n      } else {\n        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];\n      }\n    };\n    const getWrapElements = (rootNode, rng, schema) => {\n      const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);\n      const parents = parentsAndSelf(commonAnchorContainer, rootNode);\n      const wrapElements = filter$5(parents, el => schema.isWrapper(name(el)));\n      const listWrappers = getFullySelectedListWrappers(parents, rng);\n      const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));\n      return map$3(allWrappers, shallow$1);\n    };\n    const emptyFragment = () => fromElements([]);\n    const getFragmentFromRange = (rootNode, rng, schema) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng, schema));\n    const getParentTable = (rootElm, cell) => ancestor$3(cell, 'table', curry(eq, rootElm));\n    const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind(tableElm => {\n      const firstCell = selectedTableCells[0];\n      const lastCell = selectedTableCells[selectedTableCells.length - 1];\n      const fullTableModel = fromDom(tableElm);\n      return subsection(fullTableModel, firstCell, lastCell).map(sectionedTableModel => fromElements([toDom(sectionedTableModel)]));\n    }).getOrThunk(emptyFragment);\n    const getSelectionFragment = (rootNode, ranges, schema) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0], schema);\n    const read$3 = (rootNode, ranges, schema) => {\n      const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);\n      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges, schema);\n    };\n\n    const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));\n    const getInnerText = bin => {\n      return trim$2(bin.innerText);\n    };\n    const getContextNodeName = parentBlockOpt => parentBlockOpt.map(block => block.nodeName).getOr('div').toLowerCase();\n    const getTextContent = editor => Optional.from(editor.selection.getRng()).map(rng => {\n      var _a;\n      const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));\n      const body = editor.getBody();\n      const contextNodeName = getContextNodeName(parentBlockOpt);\n      const rangeContentClone = SugarElement.fromDom(rng.cloneContents());\n      cleanupBogusElements(rangeContentClone);\n      cleanupInputNames(rangeContentClone);\n      const bin = editor.dom.add(body, contextNodeName, {\n        'data-mce-bogus': 'all',\n        'style': 'overflow: hidden; opacity: 0;'\n      }, rangeContentClone.dom);\n      const text = getInnerText(bin);\n      const nonRenderedText = trim$2((_a = bin.textContent) !== null && _a !== void 0 ? _a : '');\n      editor.dom.remove(bin);\n      if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {\n        const parentBlock = parentBlockOpt.getOr(body);\n        const parentBlockText = getInnerText(parentBlock);\n        const textIndex = parentBlockText.indexOf(text);\n        if (textIndex === -1) {\n          return text;\n        } else {\n          const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);\n          const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);\n          return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');\n        }\n      } else {\n        return text;\n      }\n    }).getOr('');\n    const getSerializedContent = (editor, args) => {\n      const rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');\n      const sel = editor.selection.getSel();\n      const ranges = processRanges(editor, getRanges$1(sel));\n      const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges, editor.schema).dom : rng.cloneContents();\n      if (fragment) {\n        tmpElm.appendChild(fragment);\n      }\n      return editor.selection.serializer.serialize(tmpElm, args);\n    };\n    const extractSelectedContent = (editor, args) => {\n      if (args.format === 'text') {\n        return getTextContent(editor);\n      } else {\n        const content = getSerializedContent(editor, args);\n        if (args.format === 'tree') {\n          return content;\n        } else {\n          return editor.selection.isCollapsed() ? '' : content;\n        }\n      }\n    };\n    const setupArgs$3 = (args, format) => ({\n      ...args,\n      format,\n      get: true,\n      selection: true,\n      getInner: true\n    });\n    const getSelectedContentInternal = (editor, format, args = {}) => {\n      const defaultedArgs = setupArgs$3(args, format);\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n        const content = extractSelectedContent(editor, updatedArgs);\n        return postProcessGetContent(editor, content, updatedArgs);\n      });\n    };\n\n    const KEEP = 0, INSERT = 1, DELETE = 2;\n    const diff = (left, right) => {\n      const size = left.length + right.length + 2;\n      const vDown = new Array(size);\n      const vUp = new Array(size);\n      const snake = (start, end, diag) => {\n        return {\n          start,\n          end,\n          diag\n        };\n      };\n      const buildScript = (start1, end1, start2, end2, script) => {\n        const middle = getMiddleSnake(start1, end1, start2, end2);\n        if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {\n          let i = start1;\n          let j = start2;\n          while (i < end1 || j < end2) {\n            if (i < end1 && j < end2 && left[i] === right[j]) {\n              script.push([\n                KEEP,\n                left[i]\n              ]);\n              ++i;\n              ++j;\n            } else {\n              if (end1 - start1 > end2 - start2) {\n                script.push([\n                  DELETE,\n                  left[i]\n                ]);\n                ++i;\n              } else {\n                script.push([\n                  INSERT,\n                  right[j]\n                ]);\n                ++j;\n              }\n            }\n          }\n        } else {\n          buildScript(start1, middle.start, start2, middle.start - middle.diag, script);\n          for (let i2 = middle.start; i2 < middle.end; ++i2) {\n            script.push([\n              KEEP,\n              left[i2]\n            ]);\n          }\n          buildScript(middle.end, end1, middle.end - middle.diag, end2, script);\n        }\n      };\n      const buildSnake = (start, diag, end1, end2) => {\n        let end = start;\n        while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {\n          ++end;\n        }\n        return snake(start, end, diag);\n      };\n      const getMiddleSnake = (start1, end1, start2, end2) => {\n        const m = end1 - start1;\n        const n = end2 - start2;\n        if (m === 0 || n === 0) {\n          return null;\n        }\n        const delta = m - n;\n        const sum = n + m;\n        const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;\n        vDown[1 + offset] = start1;\n        vUp[1 + offset] = end1 + 1;\n        let d, k, i, x, y;\n        for (d = 0; d <= offset; ++d) {\n          for (k = -d; k <= d; k += 2) {\n            i = k + offset;\n            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {\n              vDown[i] = vDown[i + 1];\n            } else {\n              vDown[i] = vDown[i - 1] + 1;\n            }\n            x = vDown[i];\n            y = x - start1 + start2 - k;\n            while (x < end1 && y < end2 && left[x] === right[y]) {\n              vDown[i] = ++x;\n              ++y;\n            }\n            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {\n              if (vUp[i - delta] <= vDown[i]) {\n                return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);\n              }\n            }\n          }\n          for (k = delta - d; k <= delta + d; k += 2) {\n            i = k + offset - delta;\n            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {\n              vUp[i] = vUp[i + 1] - 1;\n            } else {\n              vUp[i] = vUp[i - 1];\n            }\n            x = vUp[i] - 1;\n            y = x - start1 + start2 - k;\n            while (x >= start1 && y >= start2 && left[x] === right[y]) {\n              vUp[i] = x--;\n              y--;\n            }\n            if (delta % 2 === 0 && -d <= k && k <= d) {\n              if (vUp[i] <= vDown[i + delta]) {\n                return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n              }\n            }\n          }\n        }\n        return null;\n      };\n      const script = [];\n      buildScript(0, left.length, 0, right.length, script);\n      return script;\n    };\n\n    const getOuterHtml = elm => {\n      if (isElement$6(elm)) {\n        return elm.outerHTML;\n      } else if (isText$b(elm)) {\n        return Entities.encodeRaw(elm.data, false);\n      } else if (isComment(elm)) {\n        return '<!--' + elm.data + '-->';\n      }\n      return '';\n    };\n    const createFragment = html => {\n      let node;\n      const container = document.createElement('div');\n      const frag = document.createDocumentFragment();\n      if (html) {\n        container.innerHTML = html;\n      }\n      while (node = container.firstChild) {\n        frag.appendChild(node);\n      }\n      return frag;\n    };\n    const insertAt = (elm, html, index) => {\n      const fragment = createFragment(html);\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\n        const target = elm.childNodes[index];\n        elm.insertBefore(fragment, target);\n      } else {\n        elm.appendChild(fragment);\n      }\n    };\n    const removeAt = (elm, index) => {\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\n        const target = elm.childNodes[index];\n        elm.removeChild(target);\n      }\n    };\n    const applyDiff = (diff, elm) => {\n      let index = 0;\n      each$e(diff, action => {\n        if (action[0] === KEEP) {\n          index++;\n        } else if (action[0] === INSERT) {\n          insertAt(elm, action[1], index);\n          index++;\n        } else if (action[0] === DELETE) {\n          removeAt(elm, index);\n        }\n      });\n    };\n    const read$2 = (elm, trimZwsp) => filter$5(map$3(from(elm.childNodes), trimZwsp ? compose(trim$2, getOuterHtml) : getOuterHtml), item => {\n      return item.length > 0;\n    });\n    const write = (fragments, elm) => {\n      const currentFragments = map$3(from(elm.childNodes), getOuterHtml);\n      applyDiff(diff(currentFragments, fragments), elm);\n      return elm;\n    };\n\n    const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));\n    const hasIframes = body => body.querySelector('iframe') !== null;\n    const createFragmentedLevel = fragments => {\n      return {\n        type: 'fragmented',\n        fragments,\n        content: '',\n        bookmark: null,\n        beforeBookmark: null\n      };\n    };\n    const createCompleteLevel = content => {\n      return {\n        type: 'complete',\n        fragments: null,\n        content,\n        bookmark: null,\n        beforeBookmark: null\n      };\n    };\n    const createFromEditor = editor => {\n      const tempAttrs = editor.serializer.getTempAttrs();\n      const body = trim$1(editor.getBody(), tempAttrs);\n      return hasIframes(body) ? createFragmentedLevel(read$2(body, true)) : createCompleteLevel(trim$2(body.innerHTML));\n    };\n    const applyToEditor = (editor, level, before) => {\n      const bookmark = before ? level.beforeBookmark : level.bookmark;\n      if (level.type === 'fragmented') {\n        write(level.fragments, editor.getBody());\n      } else {\n        editor.setContent(level.content, {\n          format: 'raw',\n          no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true\n        });\n      }\n      if (bookmark) {\n        editor.selection.moveToBookmark(bookmark);\n        editor.selection.scrollIntoView();\n      }\n    };\n    const getLevelContent = level => {\n      return level.type === 'fragmented' ? level.fragments.join('') : level.content;\n    };\n    const getCleanLevelContent = level => {\n      const elm = SugarElement.fromTag('body', lazyTempDocument());\n      set$1(elm, getLevelContent(level));\n      each$e(descendants(elm, '*[data-mce-bogus]'), unwrap);\n      return get$6(elm);\n    };\n    const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);\n    const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);\n    const isEq$1 = (level1, level2) => {\n      if (!level1 || !level2) {\n        return false;\n      } else if (hasEqualContent(level1, level2)) {\n        return true;\n      } else {\n        return hasEqualCleanedContent(level1, level2);\n      }\n    };\n\n    const isUnlocked = locks => locks.get() === 0;\n\n    const setTyping = (undoManager, typing, locks) => {\n      if (isUnlocked(locks)) {\n        undoManager.typing = typing;\n      }\n    };\n    const endTyping = (undoManager, locks) => {\n      if (undoManager.typing) {\n        setTyping(undoManager, false, locks);\n        undoManager.add();\n      }\n    };\n    const endTypingLevelIgnoreLocks = undoManager => {\n      if (undoManager.typing) {\n        undoManager.typing = false;\n        undoManager.add();\n      }\n    };\n\n    const beforeChange$1 = (editor, locks, beforeBookmark) => {\n      if (isUnlocked(locks)) {\n        beforeBookmark.set(getUndoBookmark(editor.selection));\n      }\n    };\n    const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {\n      const currentLevel = createFromEditor(editor);\n      const newLevel = Tools.extend(level || {}, currentLevel);\n      if (!isUnlocked(locks) || editor.removed) {\n        return null;\n      }\n      const lastLevel = undoManager.data[index.get()];\n      if (editor.dispatch('BeforeAddUndo', {\n          level: newLevel,\n          lastLevel,\n          originalEvent: event\n        }).isDefaultPrevented()) {\n        return null;\n      }\n      if (lastLevel && isEq$1(lastLevel, newLevel)) {\n        return null;\n      }\n      if (undoManager.data[index.get()]) {\n        beforeBookmark.get().each(bm => {\n          undoManager.data[index.get()].beforeBookmark = bm;\n        });\n      }\n      const customUndoRedoLevels = getCustomUndoRedoLevels(editor);\n      if (customUndoRedoLevels) {\n        if (undoManager.data.length > customUndoRedoLevels) {\n          for (let i = 0; i < undoManager.data.length - 1; i++) {\n            undoManager.data[i] = undoManager.data[i + 1];\n          }\n          undoManager.data.length--;\n          index.set(undoManager.data.length);\n        }\n      }\n      newLevel.bookmark = getUndoBookmark(editor.selection);\n      if (index.get() < undoManager.data.length - 1) {\n        undoManager.data.length = index.get() + 1;\n      }\n      undoManager.data.push(newLevel);\n      index.set(undoManager.data.length - 1);\n      const args = {\n        level: newLevel,\n        lastLevel,\n        originalEvent: event\n      };\n      if (index.get() > 0) {\n        editor.setDirty(true);\n        editor.dispatch('AddUndo', args);\n        editor.dispatch('change', args);\n      } else {\n        editor.dispatch('AddUndo', args);\n      }\n      return newLevel;\n    };\n    const clear$1 = (editor, undoManager, index) => {\n      undoManager.data = [];\n      index.set(0);\n      undoManager.typing = false;\n      editor.dispatch('ClearUndos');\n    };\n    const extra$1 = (editor, undoManager, index, callback1, callback2) => {\n      if (undoManager.transact(callback1)) {\n        const bookmark = undoManager.data[index.get()].bookmark;\n        const lastLevel = undoManager.data[index.get() - 1];\n        applyToEditor(editor, lastLevel, true);\n        if (undoManager.transact(callback2)) {\n          undoManager.data[index.get() - 1].beforeBookmark = bookmark;\n        }\n      }\n    };\n    const redo$1 = (editor, index, data) => {\n      let level;\n      if (index.get() < data.length - 1) {\n        index.set(index.get() + 1);\n        level = data[index.get()];\n        applyToEditor(editor, level, false);\n        editor.setDirty(true);\n        editor.dispatch('Redo', { level });\n      }\n      return level;\n    };\n    const undo$1 = (editor, undoManager, locks, index) => {\n      let level;\n      if (undoManager.typing) {\n        undoManager.add();\n        undoManager.typing = false;\n        setTyping(undoManager, false, locks);\n      }\n      if (index.get() > 0) {\n        index.set(index.get() - 1);\n        level = undoManager.data[index.get()];\n        applyToEditor(editor, level, true);\n        editor.setDirty(true);\n        editor.dispatch('Undo', { level });\n      }\n      return level;\n    };\n    const reset$1 = undoManager => {\n      undoManager.clear();\n      undoManager.add();\n    };\n    const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);\n    const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;\n    const transact$1 = (undoManager, locks, callback) => {\n      endTyping(undoManager, locks);\n      undoManager.beforeChange();\n      undoManager.ignore(callback);\n      return undoManager.add();\n    };\n    const ignore$1 = (locks, callback) => {\n      try {\n        locks.set(locks.get() + 1);\n        callback();\n      } finally {\n        locks.set(locks.get() - 1);\n      }\n    };\n\n    const addVisualInternal = (editor, elm) => {\n      const dom = editor.dom;\n      const scope = isNonNullable(elm) ? elm : editor.getBody();\n      each$e(dom.select('table,a', scope), matchedElm => {\n        switch (matchedElm.nodeName) {\n        case 'TABLE':\n          const cls = getVisualAidsTableClass(editor);\n          const value = dom.getAttrib(matchedElm, 'border');\n          if ((!value || value === '0') && editor.hasVisual) {\n            dom.addClass(matchedElm, cls);\n          } else {\n            dom.removeClass(matchedElm, cls);\n          }\n          break;\n        case 'A':\n          if (!dom.getAttrib(matchedElm, 'href')) {\n            const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;\n            const cls = getVisualAidsAnchorClass(editor);\n            if (value && editor.hasVisual) {\n              dom.addClass(matchedElm, cls);\n            } else {\n              dom.removeClass(matchedElm, cls);\n            }\n          }\n          break;\n        }\n      });\n      editor.dispatch('VisualAid', {\n        element: elm,\n        hasVisual: editor.hasVisual\n      });\n    };\n\n    const makePlainAdaptor = editor => ({\n      init: { bindEvents: noop },\n      undoManager: {\n        beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),\n        add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),\n        undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),\n        redo: (index, data) => redo$1(editor, index, data),\n        clear: (undoManager, index) => clear$1(editor, undoManager, index),\n        reset: undoManager => reset$1(undoManager),\n        hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),\n        hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),\n        transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),\n        ignore: (locks, callback) => ignore$1(locks, callback),\n        extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)\n      },\n      formatter: {\n        match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),\n        matchAll: (names, vars) => matchAll(editor, names, vars),\n        matchNode: (node, name, vars, similar) => matchNode(editor, node, name, vars, similar),\n        canApply: name => canApply(editor, name),\n        closest: names => closest(editor, names),\n        apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),\n        remove: (name, vars, node, similar) => removeFormat$1(editor, name, vars, node, similar),\n        toggle: (name, vars, node) => toggle(editor, name, vars, node),\n        formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)\n      },\n      editor: {\n        getContent: args => getContentInternal(editor, args),\n        setContent: (content, args) => setContentInternal(editor, content, args),\n        insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),\n        addVisual: elm => addVisualInternal(editor, elm)\n      },\n      selection: { getContent: (format, args) => getSelectedContentInternal(editor, format, args) },\n      autocompleter: {\n        addDecoration: noop,\n        removeDecoration: noop\n      },\n      raw: { getModel: () => Optional.none() }\n    });\n    const makeRtcAdaptor = rtcEditor => {\n      const defaultVars = vars => isObject(vars) ? vars : {};\n      const {init, undoManager, formatter, editor, selection, autocompleter, raw} = rtcEditor;\n      return {\n        init: { bindEvents: init.bindEvents },\n        undoManager: {\n          beforeChange: undoManager.beforeChange,\n          add: undoManager.add,\n          undo: undoManager.undo,\n          redo: undoManager.redo,\n          clear: undoManager.clear,\n          reset: undoManager.reset,\n          hasUndo: undoManager.hasUndo,\n          hasRedo: undoManager.hasRedo,\n          transact: (_undoManager, _locks, fn) => undoManager.transact(fn),\n          ignore: (_locks, callback) => undoManager.ignore(callback),\n          extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)\n        },\n        formatter: {\n          match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),\n          matchAll: formatter.matchAll,\n          matchNode: formatter.matchNode,\n          canApply: name => formatter.canApply(name),\n          closest: names => formatter.closest(names),\n          apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),\n          remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),\n          toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),\n          formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)\n        },\n        editor: {\n          getContent: args => editor.getContent(args),\n          setContent: (content, args) => {\n            return {\n              content: editor.setContent(content, args),\n              html: ''\n            };\n          },\n          insertContent: (content, _details) => {\n            editor.insertContent(content);\n            return '';\n          },\n          addVisual: editor.addVisual\n        },\n        selection: { getContent: (_format, args) => selection.getContent(args) },\n        autocompleter: {\n          addDecoration: autocompleter.addDecoration,\n          removeDecoration: autocompleter.removeDecoration\n        },\n        raw: { getModel: () => Optional.some(raw.getRawModel()) }\n      };\n    };\n    const makeNoopAdaptor = () => {\n      const nul = constant(null);\n      const empty = constant('');\n      return {\n        init: { bindEvents: noop },\n        undoManager: {\n          beforeChange: noop,\n          add: nul,\n          undo: nul,\n          redo: nul,\n          clear: noop,\n          reset: noop,\n          hasUndo: never,\n          hasRedo: never,\n          transact: nul,\n          ignore: noop,\n          extra: noop\n        },\n        formatter: {\n          match: never,\n          matchAll: constant([]),\n          matchNode: constant(undefined),\n          canApply: never,\n          closest: empty,\n          apply: noop,\n          remove: noop,\n          toggle: noop,\n          formatChanged: constant({ unbind: noop })\n        },\n        editor: {\n          getContent: empty,\n          setContent: constant({\n            content: '',\n            html: ''\n          }),\n          insertContent: constant(''),\n          addVisual: noop\n        },\n        selection: { getContent: empty },\n        autocompleter: {\n          addDecoration: noop,\n          removeDecoration: noop\n        },\n        raw: { getModel: constant(Optional.none()) }\n      };\n    };\n    const isRtc = editor => has$2(editor.plugins, 'rtc');\n    const getRtcSetup = editor => get$a(editor.plugins, 'rtc').bind(rtcPlugin => Optional.from(rtcPlugin.setup));\n    const setup$t = editor => {\n      const editorCast = editor;\n      return getRtcSetup(editor).fold(() => {\n        editorCast.rtcInstance = makePlainAdaptor(editor);\n        return Optional.none();\n      }, setup => {\n        editorCast.rtcInstance = makeNoopAdaptor();\n        return Optional.some(() => setup().then(rtcEditor => {\n          editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);\n          return rtcEditor.rtc.isRemote;\n        }));\n      });\n    };\n    const getRtcInstanceWithFallback = editor => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);\n    const getRtcInstanceWithError = editor => {\n      const rtcInstance = editor.rtcInstance;\n      if (!rtcInstance) {\n        throw new Error('Failed to get RTC instance not yet initialized.');\n      } else {\n        return rtcInstance;\n      }\n    };\n    const beforeChange = (editor, locks, beforeBookmark) => {\n      getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);\n    };\n    const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);\n    const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);\n    const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);\n    const clear = (editor, undoManager, index) => {\n      getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);\n    };\n    const reset = (editor, undoManager) => {\n      getRtcInstanceWithError(editor).undoManager.reset(undoManager);\n    };\n    const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);\n    const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);\n    const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);\n    const ignore = (editor, locks, callback) => {\n      getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);\n    };\n    const extra = (editor, undoManager, index, callback1, callback2) => {\n      getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);\n    };\n    const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);\n    const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);\n    const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);\n    const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);\n    const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);\n    const applyFormat = (editor, name, vars, node) => {\n      getRtcInstanceWithError(editor).formatter.apply(name, vars, node);\n    };\n    const removeFormat = (editor, name, vars, node, similar) => {\n      getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);\n    };\n    const toggleFormat = (editor, name, vars, node) => {\n      getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);\n    };\n    const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);\n    const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);\n    const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);\n    const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);\n    const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);\n    const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);\n    const bindEvents = editor => getRtcInstanceWithError(editor).init.bindEvents();\n\n    const getContent$1 = (editor, args = {}) => {\n      const format = args.format ? args.format : 'html';\n      return getSelectedContent(editor, format, args);\n    };\n\n    const removeEmpty = text => {\n      if (text.dom.length === 0) {\n        remove$4(text);\n        return Optional.none();\n      } else {\n        return Optional.some(text);\n      }\n    };\n    const walkPastBookmark = (node, start) => node.filter(elm => BookmarkManager.isBookmarkNode(elm.dom)).bind(start ? nextSibling : prevSibling);\n    const merge$1 = (outer, inner, rng, start, schema) => {\n      const outerElm = outer.dom;\n      const innerElm = inner.dom;\n      const oldLength = start ? outerElm.length : innerElm.length;\n      if (start) {\n        mergeTextNodes(outerElm, innerElm, schema, false, !start);\n        rng.setStart(innerElm, oldLength);\n      } else {\n        mergeTextNodes(innerElm, outerElm, schema, false, !start);\n        rng.setEnd(innerElm, oldLength);\n      }\n    };\n    const normalizeTextIfRequired = (inner, start, schema) => {\n      parent(inner).each(root => {\n        const text = inner.dom;\n        if (start && needsToBeNbspLeft(root, CaretPosition(text, 0), schema)) {\n          normalizeWhitespaceAfter(text, 0, schema);\n        } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length), schema)) {\n          normalizeWhitespaceBefore(text, text.length, schema);\n        }\n      });\n    };\n    const mergeAndNormalizeText = (outerNode, innerNode, rng, start, schema) => {\n      outerNode.bind(outer => {\n        const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;\n        normalizer(outer.dom, start ? outer.dom.length : 0, schema);\n        return innerNode.filter(isText$c).map(inner => merge$1(outer, inner, rng, start, schema));\n      }).orThunk(() => {\n        const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$c);\n        return innerTextNode.map(inner => normalizeTextIfRequired(inner, start, schema));\n      });\n    };\n    const rngSetContent = (rng, fragment, schema) => {\n      const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);\n      const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);\n      rng.deleteContents();\n      rng.insertNode(fragment);\n      const prevText = firstChild.bind(prevSibling).filter(isText$c).bind(removeEmpty);\n      const nextText = lastChild.bind(nextSibling).filter(isText$c).bind(removeEmpty);\n      mergeAndNormalizeText(prevText, firstChild, rng, true, schema);\n      mergeAndNormalizeText(nextText, lastChild, rng, false, schema);\n      rng.collapse(false);\n    };\n    const setupArgs$2 = (args, content) => ({\n      format: 'html',\n      ...args,\n      set: true,\n      selection: true,\n      content\n    });\n    const cleanContent = (editor, args) => {\n      if (args.format !== 'raw') {\n        const rng = editor.selection.getRng();\n        const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);\n        const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};\n        const node = editor.parser.parse(args.content, {\n          forced_root_block: false,\n          ...contextArgs,\n          ...args\n        });\n        return HtmlSerializer({ validate: false }, editor.schema).serialize(node);\n      } else {\n        return args.content;\n      }\n    };\n    const setContent$1 = (editor, content, args = {}) => {\n      const defaultedArgs = setupArgs$2(args, content);\n      preProcessSetContent(editor, defaultedArgs).each(updatedArgs => {\n        const cleanedContent = cleanContent(editor, updatedArgs);\n        const rng = editor.selection.getRng();\n        rngSetContent(rng, rng.createContextualFragment(cleanedContent), editor.schema);\n        editor.selection.setRng(rng);\n        scrollRangeIntoView(editor, rng);\n        postProcessSetContent(editor, cleanedContent, updatedArgs);\n      });\n    };\n\n    const deleteFromCallbackMap = (callbackMap, selector, callback) => {\n      if (has$2(callbackMap, selector)) {\n        const newCallbacks = filter$5(callbackMap[selector], cb => cb !== callback);\n        if (newCallbacks.length === 0) {\n          delete callbackMap[selector];\n        } else {\n          callbackMap[selector] = newCallbacks;\n        }\n      }\n    };\n    var SelectorChanged = (dom, editor) => {\n      let selectorChangedData;\n      let currentSelectors;\n      const findMatchingNode = (selector, nodes) => find$2(nodes, node => dom.is(node, selector));\n      const getParents = elem => dom.getParents(elem, undefined, dom.getRoot());\n      const setup = () => {\n        selectorChangedData = {};\n        currentSelectors = {};\n        editor.on('NodeChange', e => {\n          const node = e.element;\n          const parents = getParents(node);\n          const matchedSelectors = {};\n          each$d(selectorChangedData, (callbacks, selector) => {\n            findMatchingNode(selector, parents).each(node => {\n              if (!currentSelectors[selector]) {\n                each$e(callbacks, callback => {\n                  callback(true, {\n                    node,\n                    selector,\n                    parents\n                  });\n                });\n                currentSelectors[selector] = callbacks;\n              }\n              matchedSelectors[selector] = callbacks;\n            });\n          });\n          each$d(currentSelectors, (callbacks, selector) => {\n            if (!matchedSelectors[selector]) {\n              delete currentSelectors[selector];\n              each$e(callbacks, callback => {\n                callback(false, {\n                  node,\n                  selector,\n                  parents\n                });\n              });\n            }\n          });\n        });\n      };\n      return {\n        selectorChangedWithUnbind: (selector, callback) => {\n          if (!selectorChangedData) {\n            setup();\n          }\n          if (!selectorChangedData[selector]) {\n            selectorChangedData[selector] = [];\n          }\n          selectorChangedData[selector].push(callback);\n          findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {\n            currentSelectors[selector] = selectorChangedData[selector];\n          });\n          return {\n            unbind: () => {\n              deleteFromCallbackMap(selectorChangedData, selector, callback);\n              deleteFromCallbackMap(currentSelectors, selector, callback);\n            }\n          };\n        }\n      };\n    };\n\n    const isAttachedToDom = node => {\n      return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));\n    };\n    const isValidRange = rng => {\n      if (!rng) {\n        return false;\n      } else {\n        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);\n      }\n    };\n    const EditorSelection = (dom, win, serializer, editor) => {\n      let selectedRange;\n      let explicitRange;\n      const {selectorChangedWithUnbind} = SelectorChanged(dom, editor);\n      const setCursorLocation = (node, offset) => {\n        const rng = dom.createRng();\n        if (isNonNullable(node) && isNonNullable(offset)) {\n          rng.setStart(node, offset);\n          rng.setEnd(node, offset);\n          setRng(rng);\n          collapse(false);\n        } else {\n          moveEndPoint(dom, rng, editor.getBody(), true);\n          setRng(rng);\n        }\n      };\n      const getContent = args => getContent$1(editor, args);\n      const setContent = (content, args) => setContent$1(editor, content, args);\n      const getStart$1 = real => getStart(editor.getBody(), getRng$1(), real);\n      const getEnd$1 = real => getEnd(editor.getBody(), getRng$1(), real);\n      const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);\n      const moveToBookmark = bookmark => bookmarkManager.moveToBookmark(bookmark);\n      const select$1 = (node, content) => {\n        select(dom, node, content).each(setRng);\n        return node;\n      };\n      const isCollapsed = () => {\n        const rng = getRng$1(), sel = getSel();\n        if (!rng || rng.item) {\n          return false;\n        }\n        if (rng.compareEndPoints) {\n          return rng.compareEndPoints('StartToEnd', rng) === 0;\n        }\n        return !sel || rng.collapsed;\n      };\n      const isEditable = () => {\n        const rng = getRng$1();\n        const fakeSelectedElements = editor.getBody().querySelectorAll('[data-mce-selected=\"1\"]');\n        if (fakeSelectedElements.length > 0) {\n          return forall(fakeSelectedElements, el => dom.isEditable(el.parentElement));\n        } else {\n          return isEditableRange(dom, rng);\n        }\n      };\n      const collapse = toStart => {\n        const rng = getRng$1();\n        rng.collapse(!!toStart);\n        setRng(rng);\n      };\n      const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;\n      const getRng$1 = () => {\n        let rng;\n        const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {\n          try {\n            return sourceRange.compareBoundaryPoints(how, destinationRange);\n          } catch (ex) {\n            return -1;\n          }\n        };\n        const doc = win.document;\n        if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {\n          const bookmark = getRng(editor);\n          if (bookmark.isSome()) {\n            return bookmark.map(r => processRanges(editor, [r])[0]).getOr(doc.createRange());\n          }\n        }\n        try {\n          const selection = getSel();\n          if (selection && !isRestrictedNode(selection.anchorNode)) {\n            if (selection.rangeCount > 0) {\n              rng = selection.getRangeAt(0);\n            } else {\n              rng = doc.createRange();\n            }\n            rng = processRanges(editor, [rng])[0];\n          }\n        } catch (ex) {\n        }\n        if (!rng) {\n          rng = doc.createRange();\n        }\n        if (isDocument$1(rng.startContainer) && rng.collapsed) {\n          const elm = dom.getRoot();\n          rng.setStart(elm, 0);\n          rng.setEnd(elm, 0);\n        }\n        if (selectedRange && explicitRange) {\n          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {\n            rng = explicitRange;\n          } else {\n            selectedRange = null;\n            explicitRange = null;\n          }\n        }\n        return rng;\n      };\n      const setRng = (rng, forward) => {\n        if (!isValidRange(rng)) {\n          return;\n        }\n        const sel = getSel();\n        const evt = editor.dispatch('SetSelectionRange', {\n          range: rng,\n          forward\n        });\n        rng = evt.range;\n        if (sel) {\n          explicitRange = rng;\n          try {\n            sel.removeAllRanges();\n            sel.addRange(rng);\n          } catch (ex) {\n          }\n          if (forward === false && sel.extend) {\n            sel.collapse(rng.endContainer, rng.endOffset);\n            sel.extend(rng.startContainer, rng.startOffset);\n          }\n          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n        }\n        if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {\n          if (rng.endOffset - rng.startOffset < 2) {\n            if (rng.startContainer.hasChildNodes()) {\n              const node = rng.startContainer.childNodes[rng.startOffset];\n              if (node && node.nodeName === 'IMG') {\n                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);\n                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {\n                  sel.setBaseAndExtent(node, 0, node, 1);\n                }\n              }\n            }\n          }\n        }\n        editor.dispatch('AfterSetSelectionRange', {\n          range: rng,\n          forward\n        });\n      };\n      const setNode = elm => {\n        setContent(dom.getOuterHTML(elm));\n        return elm;\n      };\n      const getNode$1 = () => getNode(editor.getBody(), getRng$1());\n      const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);\n      const isForward = () => {\n        const sel = getSel();\n        const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n        const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n        if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {\n          return true;\n        }\n        const anchorRange = dom.createRng();\n        const focusRange = dom.createRng();\n        try {\n          anchorRange.setStart(anchorNode, sel.anchorOffset);\n          anchorRange.collapse(true);\n          focusRange.setStart(focusNode, sel.focusOffset);\n          focusRange.collapse(true);\n        } catch (e) {\n          return true;\n        }\n        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;\n      };\n      const normalize = () => {\n        const rng = getRng$1();\n        const sel = getSel();\n        if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {\n          const normRng = normalize$2(dom, rng);\n          normRng.each(normRng => {\n            setRng(normRng, isForward());\n          });\n          return normRng.getOr(rng);\n        }\n        return rng;\n      };\n      const selectorChanged = (selector, callback) => {\n        selectorChangedWithUnbind(selector, callback);\n        return exports;\n      };\n      const getScrollContainer = () => {\n        let scrollContainer;\n        let node = dom.getRoot();\n        while (node && node.nodeName !== 'BODY') {\n          if (node.scrollHeight > node.clientHeight) {\n            scrollContainer = node;\n            break;\n          }\n          node = node.parentNode;\n        }\n        return scrollContainer;\n      };\n      const scrollIntoView = (elm, alignToTop) => {\n        if (isNonNullable(elm)) {\n          scrollElementIntoView(editor, elm, alignToTop);\n        } else {\n          scrollRangeIntoView(editor, getRng$1(), alignToTop);\n        }\n      };\n      const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));\n      const getBoundingClientRect = () => {\n        const rng = getRng$1();\n        return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();\n      };\n      const destroy = () => {\n        win = selectedRange = explicitRange = null;\n        controlSelection.destroy();\n      };\n      const expand = (options = { type: 'word' }) => setRng(RangeUtils(dom).expand(getRng$1(), options));\n      const exports = {\n        dom,\n        win,\n        serializer,\n        editor,\n        expand,\n        collapse,\n        setCursorLocation,\n        getContent,\n        setContent,\n        getBookmark,\n        moveToBookmark,\n        select: select$1,\n        isCollapsed,\n        isEditable,\n        isForward,\n        setNode,\n        getNode: getNode$1,\n        getSel,\n        setRng,\n        getRng: getRng$1,\n        getStart: getStart$1,\n        getEnd: getEnd$1,\n        getSelectedBlocks: getSelectedBlocks$1,\n        normalize,\n        selectorChanged,\n        selectorChangedWithUnbind,\n        getScrollContainer,\n        scrollIntoView,\n        placeCaretAt,\n        getBoundingClientRect,\n        destroy\n      };\n      const bookmarkManager = BookmarkManager(exports);\n      const controlSelection = ControlSelection(exports, editor);\n      exports.bookmarkManager = bookmarkManager;\n      exports.controlSelection = controlSelection;\n      return exports;\n    };\n\n    const addNodeFilter = (settings, htmlParser, schema) => {\n      htmlParser.addNodeFilter('br', (nodes, _, args) => {\n        const blockElements = Tools.extend({}, schema.getBlockElements());\n        const nonEmptyElements = schema.getNonEmptyElements();\n        const whitespaceElements = schema.getWhitespaceElements();\n        blockElements.body = 1;\n        const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node);\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          let node = nodes[i];\n          let parent = node.parent;\n          if (parent && isBlock(parent) && node === parent.lastChild) {\n            let prev = node.prev;\n            while (prev) {\n              const prevName = prev.name;\n              if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {\n                if (prevName === 'br') {\n                  node = null;\n                }\n                break;\n              }\n              prev = prev.prev;\n            }\n            if (node) {\n              node.remove();\n              if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {\n                const elementRule = schema.getElementRule(parent.name);\n                if (elementRule) {\n                  if (elementRule.removeEmpty) {\n                    parent.remove();\n                  } else if (elementRule.paddEmpty) {\n                    paddEmptyNode(settings, args, isBlock, parent);\n                  }\n                }\n              }\n            }\n          } else {\n            let lastParent = node;\n            while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {\n              lastParent = parent;\n              if (blockElements[parent.name]) {\n                break;\n              }\n              parent = parent.parent;\n            }\n            if (lastParent === parent) {\n              const textNode = new AstNode('#text', 3);\n              textNode.value = nbsp;\n              node.replace(textNode);\n            }\n          }\n        }\n      });\n    };\n\n    const register$3 = (htmlParser, settings, dom) => {\n      htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          node.attr('tabindex', node.attr('data-mce-tabindex'));\n          node.attr(name, null);\n        }\n      });\n      htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {\n        const internalName = 'data-mce-' + name;\n        const urlConverter = settings.url_converter;\n        const urlConverterScope = settings.url_converter_scope;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr(internalName);\n          if (value !== undefined) {\n            node.attr(name, value.length > 0 ? value : null);\n            node.attr(internalName, null);\n          } else {\n            value = node.attr(name);\n            if (name === 'style') {\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\n            } else if (urlConverter) {\n              value = urlConverter.call(urlConverterScope, value, name, node.name);\n            }\n            node.attr(name, value.length > 0 ? value : null);\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('class', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr('class');\n          if (value) {\n            value = value.replace(/(?:^|\\s)mce-item-\\w+(?!\\S)/g, '');\n            node.attr('class', value.length > 0 ? value : null);\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {\n            const hasChildren = Optional.from(node.firstChild).exists(firstChild => {\n              var _a;\n              return !isZwsp((_a = firstChild.value) !== null && _a !== void 0 ? _a : '');\n            });\n            if (hasChildren) {\n              node.unwrap();\n            } else {\n              node.remove();\n            }\n          }\n        }\n      });\n      htmlParser.addNodeFilter('script,style', (nodes, name) => {\n        var _a;\n        const trim = value => {\n          return value.replace(/(<!--\\[CDATA\\[|\\]\\]-->)/g, '\\n').replace(/^[\\r\\n]*|[\\r\\n]*$/g, '').replace(/^\\s*((<!--)?(\\s*\\/\\/)?\\s*<!\\[CDATA\\[|(<!--\\s*)?\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\/|(\\/\\/)?\\s*<!--|\\/\\*\\s*<!--\\s*\\*\\/)\\s*[\\r\\n]*/gi, '').replace(/\\s*(\\/\\*\\s*\\]\\]>\\s*\\*\\/(-->)?|\\s*\\/\\/\\s*\\]\\]>(-->)?|\\/\\/\\s*(-->)?|\\]\\]>|\\/\\*\\s*-->\\s*\\*\\/|\\s*-->\\s*)\\s*$/g, '');\n        };\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const firstChild = node.firstChild;\n          const value = (_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.value) !== null && _a !== void 0 ? _a : '';\n          if (name === 'script') {\n            const type = node.attr('type');\n            if (type) {\n              node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\\-/, ''));\n            }\n            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\n              firstChild.value = '// <![CDATA[\\n' + trim(value) + '\\n// ]]>';\n            }\n          } else {\n            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\n              firstChild.value = '<!--\\n' + trim(value) + '\\n-->';\n            }\n          }\n        }\n      });\n      htmlParser.addNodeFilter('#comment', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const value = node.value;\n          if (settings.preserve_cdata && (value === null || value === void 0 ? void 0 : value.indexOf('[CDATA[')) === 0) {\n            node.name = '#cdata';\n            node.type = 4;\n            node.value = dom.decode(value.replace(/^\\[CDATA\\[|\\]\\]$/g, ''));\n          } else if ((value === null || value === void 0 ? void 0 : value.indexOf('mce:protected ')) === 0) {\n            node.name = '#text';\n            node.type = 3;\n            node.raw = true;\n            node.value = unescape(value).substr(14);\n          }\n        }\n      });\n      htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (node.type === 7) {\n            node.remove();\n          } else if (node.type === 1) {\n            if (name === 'input' && !node.attr('type')) {\n              node.attr('type', 'text');\n            }\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('data-mce-type', nodes => {\n        each$e(nodes, node => {\n          if (node.attr('data-mce-type') === 'format-caret') {\n            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {\n              node.remove();\n            } else {\n              node.unwrap();\n            }\n          }\n        });\n      });\n      htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,data-mce-block,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          nodes[i].attr(name, null);\n        }\n      });\n      if (settings.remove_trailing_brs) {\n        addNodeFilter(settings, htmlParser, htmlParser.schema);\n      }\n    };\n    const trimTrailingBr = rootNode => {\n      const isBr = node => {\n        return (node === null || node === void 0 ? void 0 : node.name) === 'br';\n      };\n      const brNode1 = rootNode.lastChild;\n      if (isBr(brNode1)) {\n        const brNode2 = brNode1.prev;\n        if (isBr(brNode2)) {\n          brNode1.remove();\n          brNode2.remove();\n        }\n      }\n    };\n\n    const preProcess$1 = (editor, node, args) => {\n      let oldDoc;\n      const dom = editor.dom;\n      let clonedNode = node.cloneNode(true);\n      const impl = document.implementation;\n      if (impl.createHTMLDocument) {\n        const doc = impl.createHTMLDocument('');\n        Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], node => {\n          doc.body.appendChild(doc.importNode(node, true));\n        });\n        if (clonedNode.nodeName !== 'BODY') {\n          clonedNode = doc.body.firstChild;\n        } else {\n          clonedNode = doc.body;\n        }\n        oldDoc = dom.doc;\n        dom.doc = doc;\n      }\n      firePreProcess(editor, {\n        ...args,\n        node: clonedNode\n      });\n      if (oldDoc) {\n        dom.doc = oldDoc;\n      }\n      return clonedNode;\n    };\n    const shouldFireEvent = (editor, args) => {\n      return isNonNullable(editor) && editor.hasEventListeners('PreProcess') && !args.no_events;\n    };\n    const process$1 = (editor, node, args) => {\n      return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;\n    };\n\n    const addTempAttr = (htmlParser, tempAttrs, name) => {\n      if (Tools.inArray(tempAttrs, name) === -1) {\n        htmlParser.addAttributeFilter(name, (nodes, name) => {\n          let i = nodes.length;\n          while (i--) {\n            nodes[i].attr(name, null);\n          }\n        });\n        tempAttrs.push(name);\n      }\n    };\n    const postProcess = (editor, args, content) => {\n      if (!args.no_events && editor) {\n        const outArgs = firePostProcess(editor, {\n          ...args,\n          content\n        });\n        return outArgs.content;\n      } else {\n        return content;\n      }\n    };\n    const getHtmlFromNode = (dom, node, args) => {\n      const html = trim$2(args.getInner ? node.innerHTML : dom.getOuterHTML(node));\n      return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);\n    };\n    const parseHtml = (htmlParser, html, args) => {\n      const parserArgs = args.selection ? {\n        forced_root_block: false,\n        ...args\n      } : args;\n      const rootNode = htmlParser.parse(html, parserArgs);\n      trimTrailingBr(rootNode);\n      return rootNode;\n    };\n    const serializeNode = (settings, schema, node) => {\n      const htmlSerializer = HtmlSerializer(settings, schema);\n      return htmlSerializer.serialize(node);\n    };\n    const toHtml = (editor, settings, schema, rootNode, args) => {\n      const content = serializeNode(settings, schema, rootNode);\n      return postProcess(editor, args, content);\n    };\n    const DomSerializerImpl = (settings, editor) => {\n      const tempAttrs = ['data-mce-selected'];\n      const defaultedSettings = {\n        entity_encoding: 'named',\n        remove_trailing_brs: true,\n        pad_empty_with_br: false,\n        ...settings\n      };\n      const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;\n      const schema = editor && editor.schema ? editor.schema : Schema(defaultedSettings);\n      const htmlParser = DomParser(defaultedSettings, schema);\n      register$3(htmlParser, defaultedSettings, dom);\n      const serialize = (node, parserArgs = {}) => {\n        const args = {\n          format: 'html',\n          ...parserArgs\n        };\n        const targetNode = process$1(editor, node, args);\n        const html = getHtmlFromNode(dom, targetNode, args);\n        const rootNode = parseHtml(htmlParser, html, args);\n        return args.format === 'tree' ? rootNode : toHtml(editor, defaultedSettings, schema, rootNode, args);\n      };\n      return {\n        schema,\n        addNodeFilter: htmlParser.addNodeFilter,\n        addAttributeFilter: htmlParser.addAttributeFilter,\n        serialize: serialize,\n        addRules: schema.addValidElements,\n        setRules: schema.setValidElements,\n        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),\n        getTempAttrs: constant(tempAttrs),\n        getNodeFilters: htmlParser.getNodeFilters,\n        getAttributeFilters: htmlParser.getAttributeFilters,\n        removeNodeFilter: htmlParser.removeNodeFilter,\n        removeAttributeFilter: htmlParser.removeAttributeFilter\n      };\n    };\n\n    const DomSerializer = (settings, editor) => {\n      const domSerializer = DomSerializerImpl(settings, editor);\n      return {\n        schema: domSerializer.schema,\n        addNodeFilter: domSerializer.addNodeFilter,\n        addAttributeFilter: domSerializer.addAttributeFilter,\n        serialize: domSerializer.serialize,\n        addRules: domSerializer.addRules,\n        setRules: domSerializer.setRules,\n        addTempAttr: domSerializer.addTempAttr,\n        getTempAttrs: domSerializer.getTempAttrs,\n        getNodeFilters: domSerializer.getNodeFilters,\n        getAttributeFilters: domSerializer.getAttributeFilters,\n        removeNodeFilter: domSerializer.removeNodeFilter,\n        removeAttributeFilter: domSerializer.removeAttributeFilter\n      };\n    };\n\n    const defaultFormat$1 = 'html';\n    const setupArgs$1 = (args, format) => ({\n      ...args,\n      format,\n      get: true,\n      getInner: true\n    });\n    const getContent = (editor, args = {}) => {\n      const format = args.format ? args.format : defaultFormat$1;\n      const defaultedArgs = setupArgs$1(args, format);\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n        const content = getContent$2(editor, updatedArgs);\n        return postProcessGetContent(editor, content, updatedArgs);\n      });\n    };\n\n    const defaultFormat = 'html';\n    const setupArgs = (args, content) => ({\n      format: defaultFormat,\n      ...args,\n      set: true,\n      content\n    });\n    const setContent = (editor, content, args = {}) => {\n      const defaultedArgs = setupArgs(args, content);\n      return preProcessSetContent(editor, defaultedArgs).map(updatedArgs => {\n        const result = setContent$2(editor, updatedArgs.content, updatedArgs);\n        postProcessSetContent(editor, result.html, updatedArgs);\n        return result.content;\n      }).getOr(content);\n    };\n\n    const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists,' + 'template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format').split(',');\n    const deprecatedOptions = [];\n    const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,template,textcolor,rtc'.split(',');\n    const deprecatedPlugins = [];\n    const getMatchingOptions = (options, searchingFor) => {\n      const settingNames = filter$5(searchingFor, setting => has$2(options, setting));\n      return sort(settingNames);\n    };\n    const getRemovedOptions = options => {\n      const settingNames = getMatchingOptions(options, removedOptions);\n      const forcedRootBlock = options.forced_root_block;\n      if (forcedRootBlock === false || forcedRootBlock === '') {\n        settingNames.push('forced_root_block (false only)');\n      }\n      return sort(settingNames);\n    };\n    const getDeprecatedOptions = options => getMatchingOptions(options, deprecatedOptions);\n    const getMatchingPlugins = (options, searchingFor) => {\n      const plugins = Tools.makeMap(options.plugins, ' ');\n      const hasPlugin = plugin => has$2(plugins, plugin);\n      const pluginNames = filter$5(searchingFor, hasPlugin);\n      return sort(pluginNames);\n    };\n    const getRemovedPlugins = options => getMatchingPlugins(options, removedPlugins);\n    const getDeprecatedPlugins = options => getMatchingPlugins(options, deprecatedPlugins.map(entry => entry.name));\n    const logRemovedWarnings = (rawOptions, normalizedOptions) => {\n      const removedOptions = getRemovedOptions(rawOptions);\n      const removedPlugins = getRemovedPlugins(normalizedOptions);\n      const hasRemovedPlugins = removedPlugins.length > 0;\n      const hasRemovedOptions = removedOptions.length > 0;\n      const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';\n      if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {\n        const listJoiner = '\\n- ';\n        const themesMessage = isLegacyMobileTheme ? `\\n\\nThemes:${ listJoiner }mobile` : '';\n        const pluginsMessage = hasRemovedPlugins ? `\\n\\nPlugins:${ listJoiner }${ removedPlugins.join(listJoiner) }` : '';\n        const optionsMessage = hasRemovedOptions ? `\\n\\nOptions:${ listJoiner }${ removedOptions.join(listJoiner) }` : '';\n        console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 7.0. These features will no longer work and should be removed from the TinyMCE configuration. ' + 'See https://www.tiny.cloud/docs/tinymce/7/migration-from-6x/ for more information.' + themesMessage + pluginsMessage + optionsMessage);\n      }\n    };\n    const getPluginDescription = name => find$2(deprecatedPlugins, entry => entry.name === name).fold(() => name, entry => {\n      if (entry.replacedWith) {\n        return `${ name }, replaced by ${ entry.replacedWith }`;\n      } else {\n        return name;\n      }\n    });\n    const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {\n      const deprecatedOptions = getDeprecatedOptions(rawOptions);\n      const deprecatedPlugins = getDeprecatedPlugins(normalizedOptions);\n      const hasDeprecatedPlugins = deprecatedPlugins.length > 0;\n      const hasDeprecatedOptions = deprecatedOptions.length > 0;\n      if (hasDeprecatedPlugins || hasDeprecatedOptions) {\n        const listJoiner = '\\n- ';\n        const pluginsMessage = hasDeprecatedPlugins ? `\\n\\nPlugins:${ listJoiner }${ deprecatedPlugins.map(getPluginDescription).join(listJoiner) }` : '';\n        const optionsMessage = hasDeprecatedOptions ? `\\n\\nOptions:${ listJoiner }${ deprecatedOptions.join(listJoiner) }` : '';\n        console.warn('The following deprecated features are currently enabled but will be removed soon.' + pluginsMessage + optionsMessage);\n      }\n    };\n    const logWarnings = (rawOptions, normalizedOptions) => {\n      logRemovedWarnings(rawOptions, normalizedOptions);\n      logDeprecatedWarnings(rawOptions, normalizedOptions);\n    };\n\n    const DOM$8 = DOMUtils.DOM;\n    const restoreOriginalStyles = editor => {\n      DOM$8.setStyle(editor.id, 'display', editor.orgDisplay);\n    };\n    const safeDestroy = x => Optional.from(x).each(x => x.destroy());\n    const clearDomReferences = editor => {\n      const ed = editor;\n      ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;\n      ed.bodyElement = ed.contentDocument = ed.contentWindow = null;\n      ed.iframeElement = ed.targetElm = null;\n      const selection = editor.selection;\n      if (selection) {\n        const dom = selection.dom;\n        ed.selection = selection.win = selection.dom = dom.doc = null;\n      }\n    };\n    const restoreForm = editor => {\n      const form = editor.formElement;\n      if (form) {\n        if (form._mceOldSubmit) {\n          form.submit = form._mceOldSubmit;\n          delete form._mceOldSubmit;\n        }\n        DOM$8.unbind(form, 'submit reset', editor.formEventDelegate);\n      }\n    };\n    const remove$1 = editor => {\n      if (!editor.removed) {\n        const {_selectionOverrides, editorUpload} = editor;\n        const body = editor.getBody();\n        const element = editor.getElement();\n        if (body) {\n          editor.save({ is_removing: true });\n        }\n        editor.removed = true;\n        editor.unbindAllNativeEvents();\n        if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) {\n          DOM$8.remove(element.nextSibling);\n        }\n        fireRemove(editor);\n        editor.editorManager.remove(editor);\n        if (!editor.inline && body) {\n          restoreOriginalStyles(editor);\n        }\n        fireDetach(editor);\n        DOM$8.remove(editor.getContainer());\n        safeDestroy(_selectionOverrides);\n        safeDestroy(editorUpload);\n        editor.destroy();\n      }\n    };\n    const destroy = (editor, automatic) => {\n      const {selection, dom} = editor;\n      if (editor.destroyed) {\n        return;\n      }\n      if (!automatic && !editor.removed) {\n        editor.remove();\n        return;\n      }\n      if (!automatic) {\n        editor.editorManager.off('beforeunload', editor._beforeUnload);\n        if (editor.theme && editor.theme.destroy) {\n          editor.theme.destroy();\n        }\n        safeDestroy(selection);\n        safeDestroy(dom);\n      }\n      restoreForm(editor);\n      clearDomReferences(editor);\n      editor.destroyed = true;\n    };\n\n    const CreateIconManager = () => {\n      const lookup = {};\n      const add = (id, iconPack) => {\n        lookup[id] = iconPack;\n      };\n      const get = id => {\n        if (lookup[id]) {\n          return lookup[id];\n        } else {\n          return { icons: {} };\n        }\n      };\n      const has = id => has$2(lookup, id);\n      return {\n        add,\n        get,\n        has\n      };\n    };\n    const IconManager = CreateIconManager();\n\n    const ModelManager = AddOnManager.ModelManager;\n\n    const getProp = (propName, elm) => {\n      const rawElm = elm.dom;\n      return rawElm[propName];\n    };\n    const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);\n    const getClientWidth = curry(getProp, 'clientWidth');\n    const getClientHeight = curry(getProp, 'clientHeight');\n    const getMarginTop = curry(getComputedSizeProp, 'margin-top');\n    const getMarginLeft = curry(getComputedSizeProp, 'margin-left');\n    const getBoundingClientRect = elm => elm.dom.getBoundingClientRect();\n    const isInsideElementContentArea = (bodyElm, clientX, clientY) => {\n      const clientWidth = getClientWidth(bodyElm);\n      const clientHeight = getClientHeight(bodyElm);\n      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;\n    };\n    const transpose = (inline, elm, clientX, clientY) => {\n      const clientRect = getBoundingClientRect(elm);\n      const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;\n      const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;\n      const x = clientX - deltaX;\n      const y = clientY - deltaY;\n      return {\n        x,\n        y\n      };\n    };\n    const isXYInContentArea = (editor, clientX, clientY) => {\n      const bodyElm = SugarElement.fromDom(editor.getBody());\n      const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);\n      const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);\n      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);\n    };\n    const fromDomSafe = node => Optional.from(node).map(SugarElement.fromDom);\n    const isEditorAttachedToDom = editor => {\n      const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();\n      return fromDomSafe(rawContainer).map(inBody).getOr(false);\n    };\n\n    var NotificationManagerImpl = () => {\n      const unimplemented = () => {\n        throw new Error('Theme did not provide a NotificationManager implementation.');\n      };\n      return {\n        open: unimplemented,\n        close: unimplemented,\n        getArgs: unimplemented\n      };\n    };\n\n    const NotificationManager = editor => {\n      const notifications = [];\n      const getImplementation = () => {\n        const theme = editor.theme;\n        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();\n      };\n      const getTopNotification = () => {\n        return Optional.from(notifications[0]);\n      };\n      const isEqual = (a, b) => {\n        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;\n      };\n      const reposition = () => {\n        getTopNotification().each(notification => {\n          notification.reposition();\n        });\n      };\n      const addNotification = notification => {\n        notifications.push(notification);\n      };\n      const closeNotification = notification => {\n        findIndex$2(notifications, otherNotification => {\n          return otherNotification === notification;\n        }).each(index => {\n          notifications.splice(index, 1);\n        });\n      };\n      const open = (spec, fireEvent = true) => {\n        if (editor.removed || !isEditorAttachedToDom(editor)) {\n          return {};\n        }\n        if (fireEvent) {\n          editor.dispatch('BeforeOpenNotification', { notification: spec });\n        }\n        return find$2(notifications, notification => {\n          return isEqual(getImplementation().getArgs(notification), spec);\n        }).getOrThunk(() => {\n          editor.editorManager.setActive(editor);\n          const notification = getImplementation().open(spec, () => {\n            closeNotification(notification);\n          }, () => hasEditorOrUiFocus(editor));\n          addNotification(notification);\n          reposition();\n          editor.dispatch('OpenNotification', { notification: { ...notification } });\n          return notification;\n        });\n      };\n      const close = () => {\n        getTopNotification().each(notification => {\n          getImplementation().close(notification);\n          closeNotification(notification);\n          reposition();\n        });\n      };\n      const getNotifications = constant(notifications);\n      const registerEvents = editor => {\n        editor.on('SkinLoaded', () => {\n          const serviceMessage = getServiceMessage(editor);\n          if (serviceMessage) {\n            open({\n              text: serviceMessage,\n              type: 'warning',\n              timeout: 0\n            }, false);\n          }\n          reposition();\n        });\n        editor.on('show ResizeEditor NodeChange', () => {\n          requestAnimationFrame(reposition);\n        });\n        editor.on('remove', () => {\n          each$e(notifications.slice(), notification => {\n            getImplementation().close(notification);\n          });\n        });\n        editor.addShortcut('alt+F12', 'Focus to notification', () => getTopNotification().map(notificationApi => SugarElement.fromDom(notificationApi.getEl())).each(elm => focus$1(elm)));\n      };\n      registerEvents(editor);\n      return {\n        open,\n        close,\n        getNotifications\n      };\n    };\n\n    const PluginManager = AddOnManager.PluginManager;\n\n    const ThemeManager = AddOnManager.ThemeManager;\n\n    var WindowManagerImpl = () => {\n      const unimplemented = () => {\n        throw new Error('Theme did not provide a WindowManager implementation.');\n      };\n      return {\n        open: unimplemented,\n        openUrl: unimplemented,\n        alert: unimplemented,\n        confirm: unimplemented,\n        close: unimplemented\n      };\n    };\n\n    const WindowManager = editor => {\n      let dialogs = [];\n      const getImplementation = () => {\n        const theme = editor.theme;\n        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();\n      };\n      const funcBind = (scope, f) => {\n        return (...args) => {\n          return f ? f.apply(scope, args) : undefined;\n        };\n      };\n      const fireOpenEvent = dialog => {\n        editor.dispatch('OpenWindow', { dialog });\n      };\n      const fireCloseEvent = dialog => {\n        editor.dispatch('CloseWindow', { dialog });\n      };\n      const addDialog = dialog => {\n        dialogs.push(dialog);\n        fireOpenEvent(dialog);\n      };\n      const closeDialog = dialog => {\n        fireCloseEvent(dialog);\n        dialogs = filter$5(dialogs, otherDialog => {\n          return otherDialog !== dialog;\n        });\n        if (dialogs.length === 0) {\n          editor.focus();\n        }\n      };\n      const getTopDialog = () => {\n        return Optional.from(dialogs[dialogs.length - 1]);\n      };\n      const storeSelectionAndOpenDialog = openDialog => {\n        editor.editorManager.setActive(editor);\n        store(editor);\n        editor.ui.show();\n        const dialog = openDialog();\n        addDialog(dialog);\n        return dialog;\n      };\n      const open = (args, params) => {\n        return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));\n      };\n      const openUrl = args => {\n        return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));\n      };\n      const alert = (message, callback, scope) => {\n        const windowManagerImpl = getImplementation();\n        windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));\n      };\n      const confirm = (message, callback, scope) => {\n        const windowManagerImpl = getImplementation();\n        windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));\n      };\n      const close = () => {\n        getTopDialog().each(dialog => {\n          getImplementation().close(dialog);\n          closeDialog(dialog);\n        });\n      };\n      editor.on('remove', () => {\n        each$e(dialogs, dialog => {\n          getImplementation().close(dialog);\n        });\n      });\n      return {\n        open,\n        openUrl,\n        alert,\n        confirm,\n        close\n      };\n    };\n\n    const displayNotification = (editor, message) => {\n      editor.notificationManager.open({\n        type: 'error',\n        text: message\n      });\n    };\n    const displayError = (editor, message) => {\n      if (editor._skinLoaded) {\n        displayNotification(editor, message);\n      } else {\n        editor.on('SkinLoaded', () => {\n          displayNotification(editor, message);\n        });\n      }\n    };\n    const uploadError = (editor, message) => {\n      displayError(editor, I18n.translate([\n        'Failed to upload image: {0}',\n        message\n      ]));\n    };\n    const logError = (editor, errorType, msg) => {\n      fireError(editor, errorType, { message: msg });\n      console.error(msg);\n    };\n    const createLoadError = (type, url, name) => name ? `Failed to load ${ type }: ${ name } from url ${ url }` : `Failed to load ${ type } url: ${ url }`;\n    const pluginLoadError = (editor, url, name) => {\n      logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));\n    };\n    const iconsLoadError = (editor, url, name) => {\n      logError(editor, 'IconsLoadError', createLoadError('icons', url, name));\n    };\n    const languageLoadError = (editor, url, name) => {\n      logError(editor, 'LanguageLoadError', createLoadError('language', url, name));\n    };\n    const themeLoadError = (editor, url, name) => {\n      logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));\n    };\n    const modelLoadError = (editor, url, name) => {\n      logError(editor, 'ModelLoadError', createLoadError('model', url, name));\n    };\n    const pluginInitError = (editor, name, err) => {\n      const message = I18n.translate([\n        'Failed to initialize plugin: {0}',\n        name\n      ]);\n      fireError(editor, 'PluginLoadError', { message });\n      initError(message, err);\n      displayError(editor, message);\n    };\n    const initError = (message, ...x) => {\n      const console = window.console;\n      if (console) {\n        if (console.error) {\n          console.error(message, ...x);\n        } else {\n          console.log(message, ...x);\n        }\n      }\n    };\n\n    const isContentCssSkinName = url => /^[a-z0-9\\-]+$/i.test(url);\n    const toContentSkinResourceName = url => 'content/' + url + '/content.css';\n    const isBundledCssSkinName = url => tinymce.Resource.has(toContentSkinResourceName(url));\n    const getContentCssUrls = editor => {\n      return transformToUrls(editor, getContentCss(editor));\n    };\n    const getFontCssUrls = editor => {\n      return transformToUrls(editor, getFontCss(editor));\n    };\n    const transformToUrls = (editor, cssLinks) => {\n      const skinUrl = editor.editorManager.baseURL + '/skins/content';\n      const suffix = editor.editorManager.suffix;\n      const contentCssFile = `content${ suffix }.css`;\n      return map$3(cssLinks, url => {\n        if (isBundledCssSkinName(url)) {\n          return url;\n        } else if (isContentCssSkinName(url) && !editor.inline) {\n          return `${ skinUrl }/${ url }/${ contentCssFile }`;\n        } else {\n          return editor.documentBaseURI.toAbsolute(url);\n        }\n      });\n    };\n    const appendContentCssFromSettings = editor => {\n      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));\n    };\n\n    const getAllImages = elm => {\n      return elm ? from(elm.getElementsByTagName('img')) : [];\n    };\n    const ImageScanner = (uploadStatus, blobCache) => {\n      const cachedPromises = {};\n      const findAll = (elm, predicate = always) => {\n        const images = filter$5(getAllImages(elm), img => {\n          const src = img.src;\n          if (img.hasAttribute('data-mce-bogus')) {\n            return false;\n          }\n          if (img.hasAttribute('data-mce-placeholder')) {\n            return false;\n          }\n          if (!src || src === Env.transparentSrc) {\n            return false;\n          }\n          if (startsWith(src, 'blob:')) {\n            return !uploadStatus.isUploaded(src) && predicate(img);\n          }\n          if (startsWith(src, 'data:')) {\n            return predicate(img);\n          }\n          return false;\n        });\n        const promises = map$3(images, img => {\n          const imageSrc = img.src;\n          if (has$2(cachedPromises, imageSrc)) {\n            return cachedPromises[imageSrc].then(imageInfo => {\n              if (isString(imageInfo)) {\n                return imageInfo;\n              } else {\n                return {\n                  image: img,\n                  blobInfo: imageInfo.blobInfo\n                };\n              }\n            });\n          } else {\n            const newPromise = imageToBlobInfo(blobCache, imageSrc).then(blobInfo => {\n              delete cachedPromises[imageSrc];\n              return {\n                image: img,\n                blobInfo\n              };\n            }).catch(error => {\n              delete cachedPromises[imageSrc];\n              return error;\n            });\n            cachedPromises[imageSrc] = newPromise;\n            return newPromise;\n          }\n        });\n        return Promise.all(promises);\n      };\n      return { findAll };\n    };\n\n    const UploadStatus = () => {\n      const PENDING = 1, UPLOADED = 2;\n      let blobUriStatuses = {};\n      const createStatus = (status, resultUri) => {\n        return {\n          status,\n          resultUri\n        };\n      };\n      const hasBlobUri = blobUri => {\n        return blobUri in blobUriStatuses;\n      };\n      const getResultUri = blobUri => {\n        const result = blobUriStatuses[blobUri];\n        return result ? result.resultUri : null;\n      };\n      const isPending = blobUri => {\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;\n      };\n      const isUploaded = blobUri => {\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;\n      };\n      const markPending = blobUri => {\n        blobUriStatuses[blobUri] = createStatus(PENDING, null);\n      };\n      const markUploaded = (blobUri, resultUri) => {\n        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);\n      };\n      const removeFailed = blobUri => {\n        delete blobUriStatuses[blobUri];\n      };\n      const destroy = () => {\n        blobUriStatuses = {};\n      };\n      return {\n        hasBlobUri,\n        getResultUri,\n        isPending,\n        isUploaded,\n        markPending,\n        markUploaded,\n        removeFailed,\n        destroy\n      };\n    };\n\n    let count = 0;\n    const seed = () => {\n      const rnd = () => {\n        return Math.round(Math.random() * 4294967295).toString(36);\n      };\n      const now = new Date().getTime();\n      return 's' + now.toString(36) + rnd() + rnd() + rnd();\n    };\n    const uuid = prefix => {\n      return prefix + count++ + seed();\n    };\n\n    const BlobCache = () => {\n      let cache = [];\n      const mimeToExt = mime => {\n        const mimes = {\n          'image/jpeg': 'jpg',\n          'image/jpg': 'jpg',\n          'image/gif': 'gif',\n          'image/png': 'png',\n          'image/apng': 'apng',\n          'image/avif': 'avif',\n          'image/svg+xml': 'svg',\n          'image/webp': 'webp',\n          'image/bmp': 'bmp',\n          'image/tiff': 'tiff'\n        };\n        return mimes[mime.toLowerCase()] || 'dat';\n      };\n      const create = (o, blob, base64, name, filename) => {\n        if (isString(o)) {\n          const id = o;\n          return toBlobInfo({\n            id,\n            name,\n            filename,\n            blob: blob,\n            base64: base64\n          });\n        } else if (isObject(o)) {\n          return toBlobInfo(o);\n        } else {\n          throw new Error('Unknown input type');\n        }\n      };\n      const toBlobInfo = o => {\n        if (!o.blob || !o.base64) {\n          throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');\n        }\n        const id = o.id || uuid('blobid');\n        const name = o.name || id;\n        const blob = o.blob;\n        return {\n          id: constant(id),\n          name: constant(name),\n          filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),\n          blob: constant(blob),\n          base64: constant(o.base64),\n          blobUri: constant(o.blobUri || URL.createObjectURL(blob)),\n          uri: constant(o.uri)\n        };\n      };\n      const add = blobInfo => {\n        if (!get(blobInfo.id())) {\n          cache.push(blobInfo);\n        }\n      };\n      const findFirst = predicate => find$2(cache, predicate).getOrUndefined();\n      const get = id => findFirst(cachedBlobInfo => cachedBlobInfo.id() === id);\n      const getByUri = blobUri => findFirst(blobInfo => blobInfo.blobUri() === blobUri);\n      const getByData = (base64, type) => findFirst(blobInfo => blobInfo.base64() === base64 && blobInfo.blob().type === type);\n      const removeByUri = blobUri => {\n        cache = filter$5(cache, blobInfo => {\n          if (blobInfo.blobUri() === blobUri) {\n            URL.revokeObjectURL(blobInfo.blobUri());\n            return false;\n          }\n          return true;\n        });\n      };\n      const destroy = () => {\n        each$e(cache, cachedBlobInfo => {\n          URL.revokeObjectURL(cachedBlobInfo.blobUri());\n        });\n        cache = [];\n      };\n      return {\n        create,\n        add,\n        get,\n        getByUri,\n        getByData,\n        findFirst,\n        removeByUri,\n        destroy\n      };\n    };\n\n    const Uploader = (uploadStatus, settings) => {\n      const pendingPromises = {};\n      const pathJoin = (path1, path2) => {\n        if (path1) {\n          return path1.replace(/\\/$/, '') + '/' + path2.replace(/^\\//, '');\n        }\n        return path2;\n      };\n      const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', settings.url);\n        xhr.withCredentials = settings.credentials;\n        xhr.upload.onprogress = e => {\n          progress(e.loaded / e.total * 100);\n        };\n        xhr.onerror = () => {\n          failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);\n        };\n        xhr.onload = () => {\n          if (xhr.status < 200 || xhr.status >= 300) {\n            failure('HTTP Error: ' + xhr.status);\n            return;\n          }\n          const json = JSON.parse(xhr.responseText);\n          if (!json || !isString(json.location)) {\n            failure('Invalid JSON: ' + xhr.responseText);\n            return;\n          }\n          success(pathJoin(settings.basePath, json.location));\n        };\n        const formData = new FormData();\n        formData.append('file', blobInfo.blob(), blobInfo.filename());\n        xhr.send(formData);\n      });\n      const uploadHandler = isFunction(settings.handler) ? settings.handler : defaultHandler;\n      const noUpload = () => new Promise(resolve => {\n        resolve([]);\n      });\n      const handlerSuccess = (blobInfo, url) => ({\n        url,\n        blobInfo,\n        status: true\n      });\n      const handlerFailure = (blobInfo, error) => ({\n        url: '',\n        blobInfo,\n        status: false,\n        error\n      });\n      const resolvePending = (blobUri, result) => {\n        Tools.each(pendingPromises[blobUri], resolve => {\n          resolve(result);\n        });\n        delete pendingPromises[blobUri];\n      };\n      const uploadBlobInfo = (blobInfo, handler, openNotification) => {\n        uploadStatus.markPending(blobInfo.blobUri());\n        return new Promise(resolve => {\n          let notification;\n          let progress;\n          try {\n            const closeNotification = () => {\n              if (notification) {\n                notification.close();\n                progress = noop;\n              }\n            };\n            const success = url => {\n              closeNotification();\n              uploadStatus.markUploaded(blobInfo.blobUri(), url);\n              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));\n              resolve(handlerSuccess(blobInfo, url));\n            };\n            const failure = error => {\n              closeNotification();\n              uploadStatus.removeFailed(blobInfo.blobUri());\n              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));\n              resolve(handlerFailure(blobInfo, error));\n            };\n            progress = percent => {\n              if (percent < 0 || percent > 100) {\n                return;\n              }\n              Optional.from(notification).orThunk(() => Optional.from(openNotification).map(apply$1)).each(n => {\n                notification = n;\n                n.progressBar.value(percent);\n              });\n            };\n            handler(blobInfo, progress).then(success, err => {\n              failure(isString(err) ? { message: err } : err);\n            });\n          } catch (ex) {\n            resolve(handlerFailure(blobInfo, ex));\n          }\n        });\n      };\n      const isDefaultHandler = handler => handler === defaultHandler;\n      const pendingUploadBlobInfo = blobInfo => {\n        const blobUri = blobInfo.blobUri();\n        return new Promise(resolve => {\n          pendingPromises[blobUri] = pendingPromises[blobUri] || [];\n          pendingPromises[blobUri].push(resolve);\n        });\n      };\n      const uploadBlobs = (blobInfos, openNotification) => {\n        blobInfos = Tools.grep(blobInfos, blobInfo => !uploadStatus.isUploaded(blobInfo.blobUri()));\n        return Promise.all(Tools.map(blobInfos, blobInfo => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification)));\n      };\n      const upload = (blobInfos, openNotification) => !settings.url && isDefaultHandler(uploadHandler) ? noUpload() : uploadBlobs(blobInfos, openNotification);\n      return { upload };\n    };\n\n    const openNotification = editor => () => editor.notificationManager.open({\n      text: editor.translate('Image uploading...'),\n      type: 'info',\n      timeout: -1,\n      progressBar: true\n    });\n    const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {\n      url: getImageUploadUrl(editor),\n      basePath: getImageUploadBasePath(editor),\n      credentials: getImagesUploadCredentials(editor),\n      handler: getImagesUploadHandler(editor)\n    });\n    const ImageUploader = editor => {\n      const uploadStatus = UploadStatus();\n      const uploader = createUploader(editor, uploadStatus);\n      return { upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined) };\n    };\n\n    const isEmptyForPadding = (editor, element) => editor.dom.isEmpty(element.dom) && isNonNullable(editor.schema.getTextBlockElements()[name(element)]);\n    const addPaddingToEmpty = editor => element => {\n      if (isEmptyForPadding(editor, element)) {\n        append$1(element, SugarElement.fromHtml('<br data-mce-bogus=\"1\" />'));\n      }\n    };\n    const EditorUpload = editor => {\n      const blobCache = BlobCache();\n      let uploader, imageScanner;\n      const uploadStatus = UploadStatus();\n      const urlFilters = [];\n      const aliveGuard = callback => {\n        return result => {\n          if (editor.selection) {\n            return callback(result);\n          }\n          return [];\n        };\n      };\n      const cacheInvalidator = url => url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();\n      const replaceString = (content, search, replace) => {\n        let index = 0;\n        do {\n          index = content.indexOf(search, index);\n          if (index !== -1) {\n            content = content.substring(0, index) + replace + content.substr(index + search.length);\n            index += replace.length - search.length + 1;\n          }\n        } while (index !== -1);\n        return content;\n      };\n      const replaceImageUrl = (content, targetUrl, replacementUrl) => {\n        const replacementString = `src=\"${ replacementUrl }\"${ replacementUrl === Env.transparentSrc ? ' data-mce-placeholder=\"1\"' : '' }`;\n        content = replaceString(content, `src=\"${ targetUrl }\"`, replacementString);\n        content = replaceString(content, 'data-mce-src=\"' + targetUrl + '\"', 'data-mce-src=\"' + replacementUrl + '\"');\n        return content;\n      };\n      const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {\n        each$e(editor.undoManager.data, level => {\n          if (level.type === 'fragmented') {\n            level.fragments = map$3(level.fragments, fragment => replaceImageUrl(fragment, targetUrl, replacementUrl));\n          } else {\n            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);\n          }\n        });\n      };\n      const replaceImageUriInView = (image, resultUri) => {\n        const src = editor.convertURL(resultUri, 'src');\n        replaceUrlInUndoStack(image.src, resultUri);\n        setAll$1(SugarElement.fromDom(image), {\n          'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,\n          'data-mce-src': src\n        });\n      };\n      const uploadImages = () => {\n        if (!uploader) {\n          uploader = createUploader(editor, uploadStatus);\n        }\n        return scanForImages().then(aliveGuard(imageInfos => {\n          const blobInfos = map$3(imageInfos, imageInfo => imageInfo.blobInfo);\n          return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(result => {\n            const imagesToRemove = [];\n            let shouldDispatchChange = false;\n            const filteredResult = map$3(result, (uploadInfo, index) => {\n              const {blobInfo, image} = imageInfos[index];\n              let removed = false;\n              if (uploadInfo.status && shouldReplaceBlobUris(editor)) {\n                if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) {\n                  shouldDispatchChange = true;\n                }\n                blobCache.removeByUri(image.src);\n                if (isRtc(editor)) ; else {\n                  replaceImageUriInView(image, uploadInfo.url);\n                }\n              } else if (uploadInfo.error) {\n                if (uploadInfo.error.remove) {\n                  replaceUrlInUndoStack(image.src, Env.transparentSrc);\n                  imagesToRemove.push(image);\n                  removed = true;\n                }\n                uploadError(editor, uploadInfo.error.message);\n              }\n              return {\n                element: image,\n                status: uploadInfo.status,\n                uploadUri: uploadInfo.url,\n                blobInfo,\n                removed\n              };\n            });\n            if (imagesToRemove.length > 0 && !isRtc(editor)) {\n              editor.undoManager.transact(() => {\n                each$e(fromDom$1(imagesToRemove), sugarElement => {\n                  const parentOpt = parent(sugarElement);\n                  remove$4(sugarElement);\n                  parentOpt.each(addPaddingToEmpty(editor));\n                  blobCache.removeByUri(sugarElement.dom.src);\n                });\n              });\n            } else if (shouldDispatchChange) {\n              editor.undoManager.dispatchChange();\n            }\n            return filteredResult;\n          }));\n        }));\n      };\n      const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);\n      const isValidDataUriImage = imgElm => forall(urlFilters, filter => filter(imgElm));\n      const addFilter = filter => {\n        urlFilters.push(filter);\n      };\n      const scanForImages = () => {\n        if (!imageScanner) {\n          imageScanner = ImageScanner(uploadStatus, blobCache);\n        }\n        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(result => {\n          const filteredResult = filter$5(result, resultItem => {\n            if (isString(resultItem)) {\n              displayError(editor, resultItem);\n              return false;\n            } else if (resultItem.uriType === 'blob') {\n              return false;\n            } else {\n              return true;\n            }\n          });\n          if (isRtc(editor)) ; else {\n            each$e(filteredResult, resultItem => {\n              replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());\n              resultItem.image.src = resultItem.blobInfo.blobUri();\n              resultItem.image.removeAttribute('data-mce-src');\n            });\n          }\n          return filteredResult;\n        }));\n      };\n      const destroy = () => {\n        blobCache.destroy();\n        uploadStatus.destroy();\n        imageScanner = uploader = null;\n      };\n      const replaceBlobUris = content => {\n        return content.replace(/src=\"(blob:[^\"]+)\"/g, (match, blobUri) => {\n          const resultUri = uploadStatus.getResultUri(blobUri);\n          if (resultUri) {\n            return 'src=\"' + resultUri + '\"';\n          }\n          let blobInfo = blobCache.getByUri(blobUri);\n          if (!blobInfo) {\n            blobInfo = foldl(editor.editorManager.get(), (result, editor) => {\n              return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);\n            }, undefined);\n          }\n          if (blobInfo) {\n            const blob = blobInfo.blob();\n            return 'src=\"data:' + blob.type + ';base64,' + blobInfo.base64() + '\"';\n          }\n          return match;\n        });\n      };\n      editor.on('SetContent', () => {\n        if (isAutomaticUploadsEnabled(editor)) {\n          uploadImagesAuto();\n        } else {\n          scanForImages();\n        }\n      });\n      editor.on('RawSaveContent', e => {\n        e.content = replaceBlobUris(e.content);\n      });\n      editor.on('GetContent', e => {\n        if (e.source_view || e.format === 'raw' || e.format === 'tree') {\n          return;\n        }\n        e.content = replaceBlobUris(e.content);\n      });\n      editor.on('PostRender', () => {\n        editor.parser.addNodeFilter('img', images => {\n          each$e(images, img => {\n            const src = img.attr('src');\n            if (!src || blobCache.getByUri(src)) {\n              return;\n            }\n            const resultUri = uploadStatus.getResultUri(src);\n            if (resultUri) {\n              img.attr('src', resultUri);\n            }\n          });\n        });\n      });\n      return {\n        blobCache,\n        addFilter,\n        uploadImages,\n        uploadImagesAuto,\n        scanForImages,\n        destroy\n      };\n    };\n\n    const get$1 = editor => {\n      const dom = editor.dom;\n      const schemaType = editor.schema.type;\n      const formats = {\n        valigntop: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'top' }\n          }],\n        valignmiddle: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'middle' }\n          }],\n        valignbottom: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'bottom' }\n          }],\n        alignleft: [\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-left',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'left' },\n            inherit: false,\n            preview: false\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: { float: 'left' },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginLeft: '0px',\n              marginRight: 'auto'\n            },\n            onformat: table => {\n              dom.setStyle(table, 'float', null);\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object,[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: { float: 'left' }\n          }\n        ],\n        aligncenter: [\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'center' },\n            inherit: false,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-center',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: {\n              display: 'block',\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object',\n            ceFalseOverride: true,\n            styles: {\n              display: 'table',\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          },\n          {\n            selector: '[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: {\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          }\n        ],\n        alignright: [\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-right',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'right' },\n            inherit: false,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: { float: 'right' },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginRight: '0px',\n              marginLeft: 'auto'\n            },\n            onformat: table => {\n              dom.setStyle(table, 'float', null);\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object,[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: { float: 'right' },\n            preview: false\n          }\n        ],\n        alignjustify: [{\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'justify' },\n            inherit: false,\n            preview: 'font-family font-size'\n          }],\n        bold: [\n          {\n            inline: 'strong',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          },\n          {\n            inline: 'span',\n            styles: { fontWeight: 'bold' }\n          },\n          {\n            inline: 'b',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        italic: [\n          {\n            inline: 'em',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          },\n          {\n            inline: 'span',\n            styles: { fontStyle: 'italic' }\n          },\n          {\n            inline: 'i',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        underline: [\n          {\n            inline: 'span',\n            styles: { textDecoration: 'underline' },\n            exact: true\n          },\n          {\n            inline: 'u',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        strikethrough: (() => {\n          const span = {\n            inline: 'span',\n            styles: { textDecoration: 'line-through' },\n            exact: true\n          };\n          const strike = {\n            inline: 'strike',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          };\n          const s = {\n            inline: 's',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          };\n          return schemaType !== 'html4' ? [\n            s,\n            span,\n            strike\n          ] : [\n            span,\n            s,\n            strike\n          ];\n        })(),\n        forecolor: {\n          inline: 'span',\n          styles: { color: '%value' },\n          links: true,\n          remove_similar: true,\n          clear_child_styles: true\n        },\n        hilitecolor: {\n          inline: 'span',\n          styles: { backgroundColor: '%value' },\n          links: true,\n          remove_similar: true,\n          clear_child_styles: true\n        },\n        fontname: {\n          inline: 'span',\n          toggle: false,\n          styles: { fontFamily: '%value' },\n          clear_child_styles: true\n        },\n        fontsize: {\n          inline: 'span',\n          toggle: false,\n          styles: { fontSize: '%value' },\n          clear_child_styles: true\n        },\n        lineheight: {\n          selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',\n          styles: { lineHeight: '%value' }\n        },\n        fontsize_class: {\n          inline: 'span',\n          attributes: { class: '%value' }\n        },\n        blockquote: {\n          block: 'blockquote',\n          wrapper: true,\n          remove: 'all'\n        },\n        subscript: { inline: 'sub' },\n        superscript: { inline: 'sup' },\n        code: { inline: 'code' },\n        link: {\n          inline: 'a',\n          selector: 'a',\n          remove: 'all',\n          split: true,\n          deep: true,\n          onmatch: (node, _fmt, _itemName) => {\n            return isElement$6(node) && node.hasAttribute('href');\n          },\n          onformat: (elm, _fmt, vars) => {\n            Tools.each(vars, (value, key) => {\n              dom.setAttrib(elm, key, value);\n            });\n          }\n        },\n        lang: {\n          inline: 'span',\n          clear_child_styles: true,\n          remove_similar: true,\n          attributes: {\n            'lang': '%value',\n            'data-mce-lang': vars => {\n              var _a;\n              return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;\n            }\n          }\n        },\n        removeformat: [\n          {\n            selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',\n            remove: 'all',\n            split: true,\n            expand: false,\n            block_expand: true,\n            deep: true\n          },\n          {\n            selector: 'span',\n            attributes: [\n              'style',\n              'class'\n            ],\n            remove: 'empty',\n            split: true,\n            expand: false,\n            deep: true\n          },\n          {\n            selector: '*',\n            attributes: [\n              'style',\n              'class'\n            ],\n            split: false,\n            expand: false,\n            deep: true\n          }\n        ]\n      };\n      Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\\s/), name => {\n        formats[name] = {\n          block: name,\n          remove: 'all'\n        };\n      });\n      return formats;\n    };\n\n    const genericBase = {\n      remove_similar: true,\n      inherit: false\n    };\n    const cellBase = {\n      selector: 'td,th',\n      ...genericBase\n    };\n    const cellFormats = {\n      tablecellbackgroundcolor: {\n        styles: { backgroundColor: '%value' },\n        ...cellBase\n      },\n      tablecellverticalalign: {\n        styles: { 'vertical-align': '%value' },\n        ...cellBase\n      },\n      tablecellbordercolor: {\n        styles: { borderColor: '%value' },\n        ...cellBase\n      },\n      tablecellclass: {\n        classes: ['%value'],\n        ...cellBase\n      },\n      tableclass: {\n        selector: 'table',\n        classes: ['%value'],\n        ...genericBase\n      },\n      tablecellborderstyle: {\n        styles: { borderStyle: '%value' },\n        ...cellBase\n      },\n      tablecellborderwidth: {\n        styles: { borderWidth: '%value' },\n        ...cellBase\n      }\n    };\n    const get = constant(cellFormats);\n\n    const FormatRegistry = editor => {\n      const formats = {};\n      const get$2 = name => isNonNullable(name) ? formats[name] : formats;\n      const has = name => has$2(formats, name);\n      const register = (name, format) => {\n        if (name) {\n          if (!isString(name)) {\n            each$d(name, (format, name) => {\n              register(name, format);\n            });\n          } else {\n            if (!isArray$1(format)) {\n              format = [format];\n            }\n            each$e(format, format => {\n              if (isUndefined(format.deep)) {\n                format.deep = !isSelectorFormat(format);\n              }\n              if (isUndefined(format.split)) {\n                format.split = !isSelectorFormat(format) || isInlineFormat(format);\n              }\n              if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {\n                format.remove = 'none';\n              }\n              if (isSelectorFormat(format) && isInlineFormat(format)) {\n                format.mixed = true;\n                format.block_expand = true;\n              }\n              if (isString(format.classes)) {\n                format.classes = format.classes.split(/\\s+/);\n              }\n            });\n            formats[name] = format;\n          }\n        }\n      };\n      const unregister = name => {\n        if (name && formats[name]) {\n          delete formats[name];\n        }\n        return formats;\n      };\n      register(get$1(editor));\n      register(get());\n      register(getFormats(editor));\n      return {\n        get: get$2,\n        has,\n        register,\n        unregister\n      };\n    };\n\n    const each$3 = Tools.each;\n    const dom = DOMUtils.DOM;\n    const isPreviewItem = item => isNonNullable(item) && isObject(item);\n    const parsedSelectorToHtml = (ancestry, editor) => {\n      const schema = editor && editor.schema || Schema({});\n      const decorate = (elm, item) => {\n        if (item.classes.length > 0) {\n          dom.addClass(elm, item.classes.join(' '));\n        }\n        dom.setAttribs(elm, item.attrs);\n      };\n      const createElement = sItem => {\n        const item = isString(sItem) ? {\n          name: sItem,\n          classes: [],\n          attrs: {}\n        } : sItem;\n        const elm = dom.create(item.name);\n        decorate(elm, item);\n        return elm;\n      };\n      const getRequiredParent = (elm, candidate) => {\n        const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());\n        const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;\n        if (parentsRequired && parentsRequired.length) {\n          return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];\n        } else {\n          return false;\n        }\n      };\n      const wrapInHtml = (elm, ancestors, siblings) => {\n        let parentCandidate;\n        const ancestor = ancestors[0];\n        const ancestorName = isPreviewItem(ancestor) ? ancestor.name : undefined;\n        const parentRequired = getRequiredParent(elm, ancestorName);\n        if (parentRequired) {\n          if (ancestorName === parentRequired) {\n            parentCandidate = ancestor;\n            ancestors = ancestors.slice(1);\n          } else {\n            parentCandidate = parentRequired;\n          }\n        } else if (ancestor) {\n          parentCandidate = ancestor;\n          ancestors = ancestors.slice(1);\n        } else if (!siblings) {\n          return elm;\n        }\n        const parent = parentCandidate ? createElement(parentCandidate) : dom.create('div');\n        parent.appendChild(elm);\n        if (siblings) {\n          Tools.each(siblings, sibling => {\n            const siblingElm = createElement(sibling);\n            parent.insertBefore(siblingElm, elm);\n          });\n        }\n        const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : undefined;\n        return wrapInHtml(parent, ancestors, parentSiblings);\n      };\n      const fragment = dom.create('div');\n      if (ancestry.length > 0) {\n        const item = ancestry[0];\n        const elm = createElement(item);\n        const siblings = isPreviewItem(item) ? item.siblings : undefined;\n        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings));\n      }\n      return fragment;\n    };\n    const parseSelectorItem = item => {\n      item = Tools.trim(item);\n      let tagName = 'div';\n      const obj = {\n        name: tagName,\n        classes: [],\n        attrs: {},\n        selector: item\n      };\n      if (item !== '*') {\n        tagName = item.replace(/(?:([#\\.]|::?)([\\w\\-]+)|(\\[)([^\\]]+)\\]?)/g, ($0, $1, $2, $3, $4) => {\n          switch ($1) {\n          case '#':\n            obj.attrs.id = $2;\n            break;\n          case '.':\n            obj.classes.push($2);\n            break;\n          case ':':\n            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {\n              obj.attrs[$2] = $2;\n            }\n            break;\n          }\n          if ($3 === '[') {\n            const m = $4.match(/([\\w\\-]+)(?:\\=\\\"([^\\\"]+))?/);\n            if (m) {\n              obj.attrs[m[1]] = m[2];\n            }\n          }\n          return '';\n        });\n      }\n      obj.name = tagName || 'div';\n      return obj;\n    };\n    const parseSelector = selector => {\n      if (!isString(selector)) {\n        return [];\n      }\n      selector = selector.split(/\\s*,\\s*/)[0];\n      selector = selector.replace(/\\s*(~\\+|~|\\+|>)\\s*/g, '$1');\n      return Tools.map(selector.split(/(?:>|\\s+(?![^\\[\\]]+\\]))/), item => {\n        const siblings = Tools.map(item.split(/(?:~\\+|~|\\+)/), parseSelectorItem);\n        const obj = siblings.pop();\n        if (siblings.length) {\n          obj.siblings = siblings;\n        }\n        return obj;\n      }).reverse();\n    };\n    const getCssText = (editor, format) => {\n      let previewCss = '';\n      let previewStyles = getPreviewStyles(editor);\n      if (previewStyles === '') {\n        return '';\n      }\n      const removeVars = val => {\n        return isString(val) ? val.replace(/%(\\w+)/g, '') : '';\n      };\n      const getComputedStyle = (name, elm) => {\n        return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name, true);\n      };\n      if (isString(format)) {\n        const formats = editor.formatter.get(format);\n        if (!formats) {\n          return '';\n        }\n        format = formats[0];\n      }\n      if ('preview' in format) {\n        const preview = format.preview;\n        if (preview === false) {\n          return '';\n        } else {\n          previewStyles = preview || previewStyles;\n        }\n      }\n      let name = format.block || format.inline || 'span';\n      let previewFrag;\n      const items = parseSelector(format.selector);\n      if (items.length > 0) {\n        if (!items[0].name) {\n          items[0].name = name;\n        }\n        name = format.selector;\n        previewFrag = parsedSelectorToHtml(items, editor);\n      } else {\n        previewFrag = parsedSelectorToHtml([name], editor);\n      }\n      const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;\n      each$3(format.styles, (value, name) => {\n        const newValue = removeVars(value);\n        if (newValue) {\n          dom.setStyle(previewElm, name, newValue);\n        }\n      });\n      each$3(format.attributes, (value, name) => {\n        const newValue = removeVars(value);\n        if (newValue) {\n          dom.setAttrib(previewElm, name, newValue);\n        }\n      });\n      each$3(format.classes, value => {\n        const newValue = removeVars(value);\n        if (!dom.hasClass(previewElm, newValue)) {\n          dom.addClass(previewElm, newValue);\n        }\n      });\n      editor.dispatch('PreviewFormats');\n      dom.setStyles(previewFrag, {\n        position: 'absolute',\n        left: -65535\n      });\n      editor.getBody().appendChild(previewFrag);\n      const rawParentFontSize = getComputedStyle('fontSize');\n      const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;\n      each$3(previewStyles.split(' '), name => {\n        let value = getComputedStyle(name, previewElm);\n        if (name === 'background-color' && /transparent|rgba\\s*\\([^)]+,\\s*0\\)/.test(value)) {\n          value = getComputedStyle(name);\n          if (rgbaToHexString(value).toLowerCase() === '#ffffff') {\n            return;\n          }\n        }\n        if (name === 'color') {\n          if (rgbaToHexString(value).toLowerCase() === '#000000') {\n            return;\n          }\n        }\n        if (name === 'font-size') {\n          if (/em|%$/.test(value)) {\n            if (parentFontSize === 0) {\n              return;\n            }\n            const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);\n            value = numValue * parentFontSize + 'px';\n          }\n        }\n        if (name === 'border' && value) {\n          previewCss += 'padding:0 2px;';\n        }\n        previewCss += name + ':' + value + ';';\n      });\n      editor.dispatch('AfterPreviewFormats');\n      dom.remove(previewFrag);\n      return previewCss;\n    };\n\n    const setup$s = editor => {\n      editor.addShortcut('meta+b', '', 'Bold');\n      editor.addShortcut('meta+i', '', 'Italic');\n      editor.addShortcut('meta+u', '', 'Underline');\n      for (let i = 1; i <= 6; i++) {\n        editor.addShortcut('access+' + i, '', [\n          'FormatBlock',\n          false,\n          'h' + i\n        ]);\n      }\n      editor.addShortcut('access+7', '', [\n        'FormatBlock',\n        false,\n        'p'\n      ]);\n      editor.addShortcut('access+8', '', [\n        'FormatBlock',\n        false,\n        'div'\n      ]);\n      editor.addShortcut('access+9', '', [\n        'FormatBlock',\n        false,\n        'address'\n      ]);\n    };\n\n    const Formatter = editor => {\n      const formats = FormatRegistry(editor);\n      const formatChangeState = Cell({});\n      setup$s(editor);\n      setup$v(editor);\n      if (!isRtc(editor)) {\n        setup$u(formatChangeState, editor);\n      }\n      return {\n        get: formats.get,\n        has: formats.has,\n        register: formats.register,\n        unregister: formats.unregister,\n        apply: (name, vars, node) => {\n          applyFormat(editor, name, vars, node);\n        },\n        remove: (name, vars, node, similar) => {\n          removeFormat(editor, name, vars, node, similar);\n        },\n        toggle: (name, vars, node) => {\n          toggleFormat(editor, name, vars, node);\n        },\n        match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),\n        closest: names => closestFormat(editor, names),\n        matchAll: (names, vars) => matchAllFormats(editor, names, vars),\n        matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),\n        canApply: name => canApplyFormat(editor, name),\n        formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),\n        getCssText: curry(getCssText, editor)\n      };\n    };\n\n    const shouldIgnoreCommand = cmd => {\n      switch (cmd.toLowerCase()) {\n      case 'undo':\n      case 'redo':\n      case 'mcefocus':\n        return true;\n      default:\n        return false;\n      }\n    };\n    const registerEvents = (editor, undoManager, locks) => {\n      const isFirstTypedCharacter = Cell(false);\n      const addNonTypingUndoLevel = e => {\n        setTyping(undoManager, false, locks);\n        undoManager.add({}, e);\n      };\n      editor.on('init', () => {\n        undoManager.add();\n      });\n      editor.on('BeforeExecCommand', e => {\n        const cmd = e.command;\n        if (!shouldIgnoreCommand(cmd)) {\n          endTyping(undoManager, locks);\n          undoManager.beforeChange();\n        }\n      });\n      editor.on('ExecCommand', e => {\n        const cmd = e.command;\n        if (!shouldIgnoreCommand(cmd)) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      editor.on('ObjectResizeStart cut', () => {\n        undoManager.beforeChange();\n      });\n      editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);\n      editor.on('dragend', addNonTypingUndoLevel);\n      editor.on('keyup', e => {\n        const keyCode = e.keyCode;\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        const isMeta = Env.os.isMacOS() && e.key === 'Meta';\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey || isMeta) {\n          addNonTypingUndoLevel();\n          editor.nodeChanged();\n        }\n        if (keyCode === 46 || keyCode === 8) {\n          editor.nodeChanged();\n        }\n        if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {\n          if (!editor.isDirty()) {\n            editor.setDirty(true);\n          }\n          editor.dispatch('TypingUndo');\n          isFirstTypedCharacter.set(false);\n          editor.nodeChanged();\n        }\n      });\n      editor.on('keydown', e => {\n        const keyCode = e.keyCode;\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {\n          if (undoManager.typing) {\n            addNonTypingUndoLevel(e);\n          }\n          return;\n        }\n        const modKey = e.ctrlKey && !e.altKey || e.metaKey;\n        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {\n          undoManager.beforeChange();\n          setTyping(undoManager, true, locks);\n          undoManager.add({}, e);\n          isFirstTypedCharacter.set(true);\n          return;\n        }\n        const hasOnlyMetaOrCtrlModifier = Env.os.isMacOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n        if (hasOnlyMetaOrCtrlModifier) {\n          undoManager.beforeChange();\n        }\n      });\n      editor.on('mousedown', e => {\n        if (undoManager.typing) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      const isInsertReplacementText = event => event.inputType === 'insertReplacementText';\n      const isInsertTextDataNull = event => event.inputType === 'insertText' && event.data === null;\n      const isInsertFromPasteOrDrop = event => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';\n      editor.on('input', e => {\n        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      editor.on('AddUndo Undo Redo ClearUndos', e => {\n        if (!e.isDefaultPrevented()) {\n          editor.nodeChanged();\n        }\n      });\n    };\n    const addKeyboardShortcuts = editor => {\n      editor.addShortcut('meta+z', '', 'Undo');\n      editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');\n    };\n\n    const UndoManager = editor => {\n      const beforeBookmark = value$2();\n      const locks = Cell(0);\n      const index = Cell(0);\n      const undoManager = {\n        data: [],\n        typing: false,\n        beforeChange: () => {\n          beforeChange(editor, locks, beforeBookmark);\n        },\n        add: (level, event) => {\n          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);\n        },\n        dispatchChange: () => {\n          editor.setDirty(true);\n          const level = createFromEditor(editor);\n          level.bookmark = getUndoBookmark(editor.selection);\n          editor.dispatch('change', {\n            level,\n            lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()\n          });\n        },\n        undo: () => {\n          return undo(editor, undoManager, locks, index);\n        },\n        redo: () => {\n          return redo(editor, index, undoManager.data);\n        },\n        clear: () => {\n          clear(editor, undoManager, index);\n        },\n        reset: () => {\n          reset(editor, undoManager);\n        },\n        hasUndo: () => {\n          return hasUndo(editor, undoManager, index);\n        },\n        hasRedo: () => {\n          return hasRedo(editor, undoManager, index);\n        },\n        transact: callback => {\n          return transact(editor, undoManager, locks, callback);\n        },\n        ignore: callback => {\n          ignore(editor, locks, callback);\n        },\n        extra: (callback1, callback2) => {\n          extra(editor, undoManager, index, callback1, callback2);\n        }\n      };\n      if (!isRtc(editor)) {\n        registerEvents(editor, undoManager, locks);\n      }\n      addKeyboardShortcuts(editor);\n      return undoManager;\n    };\n\n    const nonTypingKeycodes = [\n      9,\n      27,\n      VK.HOME,\n      VK.END,\n      19,\n      20,\n      44,\n      144,\n      145,\n      33,\n      34,\n      45,\n      16,\n      17,\n      18,\n      91,\n      92,\n      93,\n      VK.DOWN,\n      VK.UP,\n      VK.LEFT,\n      VK.RIGHT\n    ].concat(Env.browser.isFirefox() ? [224] : []);\n    const placeholderAttr = 'data-mce-placeholder';\n    const isKeyboardEvent = e => e.type === 'keydown' || e.type === 'keyup';\n    const isDeleteEvent = e => {\n      const keyCode = e.keyCode;\n      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;\n    };\n    const isNonTypingKeyboardEvent = e => {\n      if (isKeyboardEvent(e)) {\n        const keyCode = e.keyCode;\n        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));\n      } else {\n        return false;\n      }\n    };\n    const isTypingKeyboardEvent = e => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);\n    const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {\n      if (dom.isEmpty(rootElm, undefined, {\n          skipBogus: false,\n          includeZwsp: true\n        })) {\n        const firstElement = rootElm.firstElementChild;\n        if (!firstElement) {\n          return true;\n        } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {\n          return false;\n        } else {\n          return forcedRootBlock === firstElement.nodeName.toLowerCase();\n        }\n      } else {\n        return false;\n      }\n    };\n    const setup$r = editor => {\n      var _a;\n      const dom = editor.dom;\n      const rootBlock = getForcedRootBlock(editor);\n      const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : '';\n      const updatePlaceholder = (e, initial) => {\n        if (isNonTypingKeyboardEvent(e)) {\n          return;\n        }\n        const body = editor.getBody();\n        const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);\n        const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';\n        if (isPlaceholderShown !== showPlaceholder || initial) {\n          dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);\n          firePlaceholderToggle(editor, showPlaceholder);\n          editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);\n          editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);\n        }\n      };\n      if (isNotEmpty(placeholder)) {\n        editor.on('init', e => {\n          updatePlaceholder(e, true);\n          editor.on('change SetContent ExecCommand', updatePlaceholder);\n          editor.on('paste', e => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));\n        });\n      }\n    };\n\n    const blockPosition = (block, position) => ({\n      block,\n      position\n    });\n    const blockBoundary = (from, to) => ({\n      from,\n      to\n    });\n    const getBlockPosition = (rootNode, pos) => {\n      const rootElm = SugarElement.fromDom(rootNode);\n      const containerElm = SugarElement.fromDom(pos.container());\n      return getParentBlock$2(rootElm, containerElm).map(block => blockPosition(block, pos));\n    };\n    const isNotAncestorial = blockBoundary => !(contains(blockBoundary.to.block, blockBoundary.from.block) || contains(blockBoundary.from.block, blockBoundary.to.block));\n    const isDifferentBlocks = blockBoundary => !eq(blockBoundary.from.block, blockBoundary.to.block);\n    const getClosestHost = (root, scope) => {\n      const isRoot = node => eq(node, root);\n      const isHost = node => isTableCell$2(node) || isContentEditableTrue$3(node.dom);\n      return closest$4(scope, isHost, isRoot).filter(isElement$7).getOr(root);\n    };\n    const hasSameHost = (rootNode, blockBoundary) => {\n      const root = SugarElement.fromDom(rootNode);\n      return eq(getClosestHost(root, blockBoundary.from.block), getClosestHost(root, blockBoundary.to.block));\n    };\n    const isEditable$1 = blockBoundary => isContentEditableFalse$b(blockBoundary.from.block.dom) === false && isContentEditableFalse$b(blockBoundary.to.block.dom) === false;\n    const hasValidBlocks = blockBoundary => {\n      const isValidBlock = block => isTextBlock$2(block) || hasBlockAttr(block.dom) || isListItem$1(block);\n      return isValidBlock(blockBoundary.from.block) && isValidBlock(blockBoundary.to.block);\n    };\n    const skipLastBr = (schema, rootNode, forward, blockPosition) => {\n      if (isBr$6(blockPosition.position.getNode()) && !isEmpty$2(schema, blockPosition.block)) {\n        return positionIn(false, blockPosition.block.dom).bind(lastPositionInBlock => {\n          if (lastPositionInBlock.isEqual(blockPosition.position)) {\n            return fromPosition(forward, rootNode, lastPositionInBlock).bind(to => getBlockPosition(rootNode, to));\n          } else {\n            return Optional.some(blockPosition);\n          }\n        }).getOr(blockPosition);\n      } else {\n        return blockPosition;\n      }\n    };\n    const readFromRange = (schema, rootNode, forward, rng) => {\n      const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));\n      const toBlockPos = fromBlockPos.bind(blockPos => fromPosition(forward, rootNode, blockPos.position).bind(to => getBlockPosition(rootNode, to).map(blockPos => skipLastBr(schema, rootNode, forward, blockPos))));\n      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(blockBoundary => isDifferentBlocks(blockBoundary) && hasSameHost(rootNode, blockBoundary) && isEditable$1(blockBoundary) && hasValidBlocks(blockBoundary) && isNotAncestorial(blockBoundary));\n    };\n    const read$1 = (schema, rootNode, forward, rng) => rng.collapsed ? readFromRange(schema, rootNode, forward, rng) : Optional.none();\n\n    const getChildrenFromNestedUntilBlockBoundary = (block, schema, forwardDelete) => {\n      const allSiblingsInDirection = forwardDelete ? prevSiblings(block).reverse() : nextSiblings(block);\n      const siblingsToMergeIn = findIndex$2(allSiblingsInDirection, element => schema.isBlock(name(element))).fold(constant(allSiblingsInDirection), index => allSiblingsInDirection.slice(0, index));\n      if (forwardDelete) {\n        return siblingsToMergeIn.reverse();\n      }\n      return siblingsToMergeIn;\n    };\n    const getChildrenUntilBlockBoundary = (toBlock, fromBlock, schema, forwardDelete, extractsiblingsIfNested) => {\n      if (extractsiblingsIfNested && contains(toBlock, fromBlock)) {\n        return getChildrenFromNestedUntilBlockBoundary(fromBlock, schema, forwardDelete);\n      } else if (extractsiblingsIfNested && contains(fromBlock, toBlock)) {\n        return getChildrenFromNestedUntilBlockBoundary(toBlock, schema, forwardDelete);\n      } else {\n        const children = children$1(fromBlock);\n        return findIndex$2(children, el => schema.isBlock(name(el))).fold(constant(children), index => children.slice(0, index));\n      }\n    };\n    const extractChildren = (toBlock, fromBlock, schema, forwardDelete, extractsiblingsIfNested) => {\n      const children = getChildrenUntilBlockBoundary(toBlock, fromBlock, schema, forwardDelete, extractsiblingsIfNested);\n      each$e(children, remove$4);\n      return children;\n    };\n    const removeEmptyRoot = (schema, rootNode, block) => {\n      const parents = parentsAndSelf(block, rootNode);\n      return find$2(parents.reverse(), element => isEmpty$2(schema, element)).each(remove$4);\n    };\n    const isEmptyBefore = (schema, el) => filter$5(prevSiblings(el), el => !isEmpty$2(schema, el)).length === 0;\n    const nestedBlockMerge = (rootNode, fromBlock, toBlock, schema, forward, insertionPoint) => {\n      if (isEmpty$2(schema, toBlock)) {\n        fillWithPaddingBr(toBlock);\n        return firstPositionIn(toBlock.dom);\n      }\n      if (isEmptyBefore(schema, insertionPoint) && isEmpty$2(schema, fromBlock)) {\n        before$3(insertionPoint, SugarElement.fromTag('br'));\n      }\n      const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));\n      each$e(extractChildren(toBlock, fromBlock, schema, forward, false), child => {\n        before$3(insertionPoint, child);\n      });\n      removeEmptyRoot(schema, rootNode, fromBlock);\n      return position;\n    };\n    const isInline = (schema, node) => schema.isInline(name(node));\n    const sidelongBlockMerge = (rootNode, fromBlock, toBlock, schema, forwardDelete) => {\n      if (isEmpty$2(schema, toBlock)) {\n        if (isEmpty$2(schema, fromBlock)) {\n          const getInlineToBlockDescendants = el => {\n            const helper = (node, elements) => firstChild(node).fold(() => elements, child => isInline(schema, child) ? helper(child, elements.concat(shallow$1(child))) : elements);\n            return helper(el, []);\n          };\n          const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant) => {\n            wrap$2(element, descendant);\n            return descendant;\n          }, createPaddingBr());\n          empty(fromBlock);\n          append$1(fromBlock, newFromBlockDescendants);\n        }\n        remove$4(toBlock);\n        return firstPositionIn(fromBlock.dom);\n      }\n      const position = lastPositionIn(toBlock.dom);\n      each$e(extractChildren(toBlock, fromBlock, schema, forwardDelete, true), child => {\n        if (forwardDelete && contains(fromBlock, toBlock)) {\n          prepend(toBlock, child);\n        } else {\n          append$1(toBlock, child);\n        }\n      });\n      removeEmptyRoot(schema, rootNode, fromBlock);\n      return position;\n    };\n    const findInsertionPoint = (toBlock, block) => {\n      const parentsAndSelf$1 = parentsAndSelf(block, toBlock);\n      return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);\n    };\n    const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();\n    const trimBr = (first, block) => {\n      positionIn(first, block.dom).bind(position => Optional.from(position.getNode())).map(SugarElement.fromDom).filter(isBr$5).each(remove$4);\n    };\n    const mergeBlockInto = (rootNode, fromBlock, toBlock, schema, forward) => {\n      trimBr(true, fromBlock);\n      trimBr(false, toBlock);\n      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock, schema, forward), curry(nestedBlockMerge, rootNode, fromBlock, toBlock, schema, forward));\n    };\n    const mergeBlocks = (rootNode, forward, block1, block2, schema, mergeNotDelete = false) => {\n      if (mergeNotDelete) {\n        if (contains(block2, block1)) {\n          return mergeBlockInto(rootNode, block2, block1, schema, !forward);\n        } else if (contains(block1, block2)) {\n          return mergeBlockInto(rootNode, block1, block2, schema, forward);\n        }\n      }\n      return forward ? mergeBlockInto(rootNode, block2, block1, schema, forward) : mergeBlockInto(rootNode, block1, block2, schema, !forward);\n    };\n\n    const backspaceDelete$a = (editor, forward) => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const position = read$1(editor.schema, rootNode.dom, forward, editor.selection.getRng()).map(blockBoundary => () => {\n        mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block, editor.schema, true).each(pos => {\n          editor.selection.setRng(pos.toRange());\n        });\n      });\n      return position;\n    };\n\n    const deleteRangeMergeBlocks = (rootNode, selection, schema) => {\n      const rng = selection.getRng();\n      return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {\n        if (!eq(block1, block2)) {\n          return Optional.some(() => {\n            rng.deleteContents();\n            mergeBlocks(rootNode, true, block1, block2, schema).each(pos => {\n              selection.setRng(pos.toRange());\n            });\n          });\n        } else {\n          return Optional.none();\n        }\n      }).getOr(Optional.none());\n    };\n    const isRawNodeInTable = (root, rawNode) => {\n      const node = SugarElement.fromDom(rawNode);\n      const isRoot = curry(eq, root);\n      return ancestor$4(node, isTableCell$2, isRoot).isSome();\n    };\n    const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);\n    const isEverythingSelected = (root, rng) => {\n      const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();\n      const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();\n      return !isSelectionInTable(root, rng) && noPrevious && noNext;\n    };\n    const emptyEditor = editor => {\n      return Optional.some(() => {\n        editor.setContent('');\n        editor.selection.setCursorLocation();\n      });\n    };\n    const deleteRange$2 = editor => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const rng = editor.selection.getRng();\n      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection, editor.schema);\n    };\n    const backspaceDelete$9 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);\n\n    const showCaret = (direction, editor, node, before, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));\n    const getNodeRange = node => {\n      const rng = node.ownerDocument.createRange();\n      rng.selectNode(node);\n      return rng;\n    };\n    const selectNode = (editor, node) => {\n      const e = editor.dispatch('BeforeObjectSelected', { target: node });\n      if (e.isDefaultPrevented()) {\n        return Optional.none();\n      }\n      return Optional.some(getNodeRange(node));\n    };\n    const renderCaretAtRange = (editor, range, scrollIntoView) => {\n      const normalizedRange = normalizeRange(1, editor.getBody(), range);\n      const caretPosition = CaretPosition.fromRangeStart(normalizedRange);\n      const caretPositionNode = caretPosition.getNode();\n      if (isInlineFakeCaretTarget(caretPositionNode)) {\n        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);\n      }\n      const caretPositionBeforeNode = caretPosition.getNode(true);\n      if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {\n        return showCaret(1, editor, caretPositionBeforeNode, false, false);\n      }\n      const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());\n      if (isInlineFakeCaretTarget(ceRoot)) {\n        return showCaret(1, editor, ceRoot, false, scrollIntoView);\n      }\n      return Optional.none();\n    };\n    const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;\n\n    const isBeforeBoundary = pos => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);\n    const isAfterBoundary = pos => isAfterContentEditableFalse(pos) || isAfterMedia(pos);\n    const trimEmptyTextNode = (dom, node) => {\n      if (isText$b(node) && node.data.length === 0) {\n        dom.remove(node);\n      }\n    };\n    const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {\n      showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(caretRange => {\n        if (range.collapsed) {\n          const deleteRange = range.cloneRange();\n          if (forward) {\n            deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);\n          } else {\n            deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);\n          }\n          deleteRange.deleteContents();\n        } else {\n          range.deleteContents();\n        }\n        editor.selection.setRng(caretRange);\n      });\n      trimEmptyTextNode(editor.dom, node);\n    };\n    const deleteBoundaryText = (editor, forward) => {\n      const range = editor.selection.getRng();\n      if (!isText$b(range.commonAncestorContainer)) {\n        return Optional.none();\n      }\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const caretWalker = CaretWalker(editor.getBody());\n      const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);\n      const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      const nextCaretPosition = getNextPosFn(caretPosition);\n      const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;\n      if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) {\n        return Optional.none();\n      } else if (isBeforeFn(normalizedNextCaretPosition)) {\n        return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));\n      }\n      const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n        if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) {\n          return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));\n        }\n      }\n      return Optional.none();\n    };\n    const backspaceDelete$8 = (editor, forward) => deleteBoundaryText(editor, forward);\n\n    const getEdgeCefPosition = (editor, atStart) => {\n      const root = editor.getBody();\n      return atStart ? firstPositionIn(root).filter(isBeforeContentEditableFalse) : lastPositionIn(root).filter(isAfterContentEditableFalse);\n    };\n    const isCefAtEdgeSelected = editor => {\n      const rng = editor.selection.getRng();\n      return !rng.collapsed && (getEdgeCefPosition(editor, true).exists(pos => pos.isEqual(CaretPosition.fromRangeStart(rng))) || getEdgeCefPosition(editor, false).exists(pos => pos.isEqual(CaretPosition.fromRangeEnd(rng))));\n    };\n\n    const isCompoundElement = node => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$1(SugarElement.fromDom(node)));\n    const DeleteAction = Adt.generate([\n      { remove: ['element'] },\n      { moveToElement: ['element'] },\n      { moveToPosition: ['position'] }\n    ]);\n    const isAtContentEditableBlockCaret = (forward, from) => {\n      const elm = from.getNode(!forward);\n      const caretLocation = forward ? 'after' : 'before';\n      return isElement$6(elm) && elm.getAttribute('data-mce-caret') === caretLocation;\n    };\n    const isDeleteFromCefDifferentBlocks = (root, forward, from, to, schema) => {\n      const inSameBlock = elm => schema.isInline(elm.nodeName.toLowerCase()) && !isInSameBlock(from, to, root);\n      return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);\n    };\n    const deleteEmptyBlockOrMoveToCef = (schema, root, forward, from, to) => {\n      const toCefElm = to.getNode(!forward);\n      return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(blockElm => isEmpty$2(schema, blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));\n    };\n    const findCefPosition = (root, forward, from, schema) => fromPosition(forward, root, from).bind(to => {\n      if (isCompoundElement(to.getNode())) {\n        return Optional.none();\n      } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to, schema)) {\n        return Optional.none();\n      } else if (forward && isContentEditableFalse$b(to.getNode())) {\n        return deleteEmptyBlockOrMoveToCef(schema, root, forward, from, to);\n      } else if (!forward && isContentEditableFalse$b(to.getNode(true))) {\n        return deleteEmptyBlockOrMoveToCef(schema, root, forward, from, to);\n      } else if (forward && isAfterContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      } else if (!forward && isBeforeContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      } else {\n        return Optional.none();\n      }\n    });\n    const getContentEditableBlockAction = (forward, elm) => {\n      if (isNullable(elm)) {\n        return Optional.none();\n      } else if (forward && isContentEditableFalse$b(elm.nextSibling)) {\n        return Optional.some(DeleteAction.moveToElement(elm.nextSibling));\n      } else if (!forward && isContentEditableFalse$b(elm.previousSibling)) {\n        return Optional.some(DeleteAction.moveToElement(elm.previousSibling));\n      } else {\n        return Optional.none();\n      }\n    };\n    const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold(elm => Optional.some(DeleteAction.remove(elm)), elm => Optional.some(DeleteAction.moveToElement(elm)), to => {\n      if (isInSameBlock(from, to, root)) {\n        return Optional.none();\n      } else {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      }\n    });\n    const getContentEditableAction = (root, forward, from, schema) => {\n      if (isAtContentEditableBlockCaret(forward, from)) {\n        return getContentEditableBlockAction(forward, from.getNode(!forward)).orThunk(() => findCefPosition(root, forward, from, schema));\n      } else {\n        return findCefPosition(root, forward, from, schema).bind(deleteAction => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));\n      }\n    };\n    const read = (root, forward, rng, schema) => {\n      const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);\n      const from = CaretPosition.fromRangeStart(normalizedRange);\n      const rootElement = SugarElement.fromDom(root);\n      if (!forward && isAfterContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.remove(from.getNode(true)));\n      } else if (forward && isBeforeContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.remove(from.getNode()));\n      } else if (!forward && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from, schema)) {\n        return findPreviousBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\n      } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from, schema)) {\n        return findNextBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\n      } else {\n        return getContentEditableAction(root, forward, from, schema);\n      }\n    };\n\n    const deleteElement$1 = (editor, forward) => element => {\n      editor._selectionOverrides.hideFakeCaret();\n      deleteElement$2(editor, forward, SugarElement.fromDom(element));\n      return true;\n    };\n    const moveToElement = (editor, forward) => element => {\n      const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);\n      editor.selection.setRng(pos.toRange());\n      return true;\n    };\n    const moveToPosition = editor => pos => {\n      editor.selection.setRng(pos.toRange());\n      return true;\n    };\n    const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));\n    const backspaceDeleteCaret = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$b).fold(() => read(editor.getBody(), forward, editor.selection.getRng(), editor.schema).map(deleteAction => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));\n    };\n    const deleteOffscreenSelection = rootElement => {\n      each$e(descendants(rootElement, '.mce-offscreen-selection'), remove$4);\n    };\n    const backspaceDeleteRange = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      if (isContentEditableFalse$b(selectedNode) && !isTableCell$3(selectedNode)) {\n        const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b);\n        return hasCefAncestor.fold(() => Optional.some(() => {\n          deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));\n          deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));\n          paddEmptyBody(editor);\n        }), () => Optional.some(noop));\n      }\n      if (isCefAtEdgeSelected(editor)) {\n        return Optional.some(() => {\n          deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));\n        });\n      }\n      return Optional.none();\n    };\n    const paddEmptyElement = editor => {\n      const dom = editor.dom, selection = editor.selection;\n      const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());\n      if (isContentEditableTrue$3(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {\n        const br = dom.create('br', { 'data-mce-bogus': '1' });\n        dom.setHTML(ceRoot, '');\n        ceRoot.appendChild(br);\n        selection.setRng(CaretPosition.before(br).toRange());\n      }\n      return true;\n    };\n    const backspaceDelete$7 = (editor, forward) => {\n      if (editor.selection.isCollapsed()) {\n        return backspaceDeleteCaret(editor, forward);\n      } else {\n        return backspaceDeleteRange(editor, forward);\n      }\n    };\n\n    const isTextEndpoint = endpoint => endpoint.hasOwnProperty('text');\n    const isElementEndpoint = endpoint => endpoint.hasOwnProperty('marker');\n    const getBookmark = (range, createMarker) => {\n      const getEndpoint = (container, offset) => {\n        if (isText$b(container)) {\n          return {\n            text: container,\n            offset\n          };\n        } else {\n          const marker = createMarker();\n          const children = container.childNodes;\n          if (offset < children.length) {\n            container.insertBefore(marker, children[offset]);\n            return {\n              marker,\n              before: true\n            };\n          } else {\n            container.appendChild(marker);\n            return {\n              marker,\n              before: false\n            };\n          }\n        }\n      };\n      const end = getEndpoint(range.endContainer, range.endOffset);\n      const start = getEndpoint(range.startContainer, range.startOffset);\n      return {\n        start,\n        end\n      };\n    };\n    const resolveBookmark = bm => {\n      var _a, _b;\n      const {start, end} = bm;\n      const rng = new window.Range();\n      if (isTextEndpoint(start)) {\n        rng.setStart(start.text, start.offset);\n      } else {\n        if (isElementEndpoint(start)) {\n          if (start.before) {\n            rng.setStartBefore(start.marker);\n          } else {\n            rng.setStartAfter(start.marker);\n          }\n          (_a = start.marker.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(start.marker);\n        }\n      }\n      if (isTextEndpoint(end)) {\n        rng.setEnd(end.text, end.offset);\n      } else {\n        if (isElementEndpoint(end)) {\n          if (end.before) {\n            rng.setEndBefore(end.marker);\n          } else {\n            rng.setEndAfter(end.marker);\n          }\n          (_b = end.marker.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(end.marker);\n        }\n      }\n      return rng;\n    };\n\n    const backspaceDelete$6 = (editor, forward) => {\n      var _a;\n      const dom = editor.dom;\n      const startBlock = dom.getParent(editor.selection.getStart(), dom.isBlock);\n      const endBlock = dom.getParent(editor.selection.getEnd(), dom.isBlock);\n      const body = editor.getBody();\n      const startBlockName = (_a = startBlock === null || startBlock === void 0 ? void 0 : startBlock.nodeName) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n      if (startBlockName === 'div' && startBlock && endBlock && startBlock === body.firstChild && endBlock === body.lastChild && !dom.isEmpty(body)) {\n        const wrapper = startBlock.cloneNode(false);\n        const deleteAction = () => {\n          if (forward) {\n            execNativeForwardDeleteCommand(editor);\n          } else {\n            execNativeDeleteCommand(editor);\n          }\n          if (body.firstChild !== startBlock) {\n            const bookmark = getBookmark(editor.selection.getRng(), () => document.createElement('span'));\n            Array.from(body.childNodes).forEach(node => wrapper.appendChild(node));\n            body.appendChild(wrapper);\n            editor.selection.setRng(resolveBookmark(bookmark));\n          }\n        };\n        return Optional.some(deleteAction);\n      }\n      return Optional.none();\n    };\n\n    const deleteCaret$2 = (editor, forward) => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return fromPosition(forward, editor.getBody(), fromPos).filter(pos => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind(pos => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos)).map(elm => () => editor.selection.select(elm));\n    };\n    const backspaceDelete$5 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();\n\n    const isText$2 = isText$b;\n    const startsWithCaretContainer = node => isText$2(node) && node.data[0] === ZWSP$1;\n    const endsWithCaretContainer = node => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;\n    const createZwsp = node => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      return doc.createTextNode(ZWSP$1);\n    };\n    const insertBefore$1 = node => {\n      var _a;\n      if (isText$2(node.previousSibling)) {\n        if (endsWithCaretContainer(node.previousSibling)) {\n          return node.previousSibling;\n        } else {\n          node.previousSibling.appendData(ZWSP$1);\n          return node.previousSibling;\n        }\n      } else if (isText$2(node)) {\n        if (startsWithCaretContainer(node)) {\n          return node;\n        } else {\n          node.insertData(0, ZWSP$1);\n          return node;\n        }\n      } else {\n        const newNode = createZwsp(node);\n        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node);\n        return newNode;\n      }\n    };\n    const insertAfter$1 = node => {\n      var _a, _b;\n      if (isText$2(node.nextSibling)) {\n        if (startsWithCaretContainer(node.nextSibling)) {\n          return node.nextSibling;\n        } else {\n          node.nextSibling.insertData(0, ZWSP$1);\n          return node.nextSibling;\n        }\n      } else if (isText$2(node)) {\n        if (endsWithCaretContainer(node)) {\n          return node;\n        } else {\n          node.appendData(ZWSP$1);\n          return node;\n        }\n      } else {\n        const newNode = createZwsp(node);\n        if (node.nextSibling) {\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node.nextSibling);\n        } else {\n          (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(newNode);\n        }\n        return newNode;\n      }\n    };\n    const insertInline = (before, node) => before ? insertBefore$1(node) : insertAfter$1(node);\n    const insertInlineBefore = curry(insertInline, true);\n    const insertInlineAfter = curry(insertInline, false);\n\n    const insertInlinePos = (pos, before) => {\n      if (isText$b(pos.container())) {\n        return insertInline(before, pos.container());\n      } else {\n        return insertInline(before, pos.getNode());\n      }\n    };\n    const isPosCaretContainer = (pos, caret) => {\n      const caretNode = caret.get();\n      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);\n    };\n    const renderCaret = (caret, location) => location.fold(element => {\n      remove$2(caret.get());\n      const text = insertInlineBefore(element);\n      caret.set(text);\n      return Optional.some(CaretPosition(text, text.length - 1));\n    }, element => firstPositionIn(element).map(pos => {\n      if (!isPosCaretContainer(pos, caret)) {\n        remove$2(caret.get());\n        const text = insertInlinePos(pos, true);\n        caret.set(text);\n        return CaretPosition(text, 1);\n      } else {\n        const node = caret.get();\n        return CaretPosition(node, 1);\n      }\n    }), element => lastPositionIn(element).map(pos => {\n      if (!isPosCaretContainer(pos, caret)) {\n        remove$2(caret.get());\n        const text = insertInlinePos(pos, false);\n        caret.set(text);\n        return CaretPosition(text, text.length - 1);\n      } else {\n        const node = caret.get();\n        return CaretPosition(node, node.length - 1);\n      }\n    }), element => {\n      remove$2(caret.get());\n      const text = insertInlineAfter(element);\n      caret.set(text);\n      return Optional.some(CaretPosition(text, 1));\n    });\n\n    const evaluateUntil = (fns, args) => {\n      for (let i = 0; i < fns.length; i++) {\n        const result = fns[i].apply(null, args);\n        if (result.isSome()) {\n          return result;\n        }\n      }\n      return Optional.none();\n    };\n\n    const Location = Adt.generate([\n      { before: ['element'] },\n      { start: ['element'] },\n      { end: ['element'] },\n      { after: ['element'] }\n    ]);\n    const rescope$1 = (rootNode, node) => {\n      const parentBlock = getParentBlock$3(node, rootNode);\n      return parentBlock ? parentBlock : rootNode;\n    };\n    const before = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeForwards(pos);\n      const scope = rescope$1(rootNode, nPos.container());\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.before(inline)), Optional.none);\n    };\n    const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;\n    const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));\n    const start$1 = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeBackwards(pos);\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n        const prevPos = prevPosition(inline, nPos);\n        return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();\n      });\n    };\n    const end = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeForwards(pos);\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n        const nextPos = nextPosition(inline, nPos);\n        return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();\n      });\n    };\n    const after = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeBackwards(pos);\n      const scope = rescope$1(rootNode, nPos.container());\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.after(inline)), Optional.none);\n    };\n    const isValidLocation = location => !isRtl(getElement(location));\n    const readLocation = (isInlineTarget, rootNode, pos) => {\n      const location = evaluateUntil([\n        before,\n        start$1,\n        end,\n        after\n      ], [\n        isInlineTarget,\n        rootNode,\n        pos\n      ]);\n      return location.filter(isValidLocation);\n    };\n    const getElement = location => location.fold(identity, identity, identity, identity);\n    const getName = location => location.fold(constant('before'), constant('start'), constant('end'), constant('after'));\n    const outside = location => location.fold(Location.before, Location.before, Location.after, Location.after);\n    const inside = location => location.fold(Location.start, Location.start, Location.end, Location.end);\n    const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);\n    const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {\n      if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {\n        return Location.after(forward ? fromInline : toInline);\n      } else {\n        return location;\n      }\n    }).getOr(location);\n    const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, fromLocation => !isEq(fromLocation, toLocation));\n    const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {\n      const from = normalizePosition(forward, pos);\n      const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));\n      const location = to.fold(() => fromLocation.map(outside), to => readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation)));\n      return location.filter(isValidLocation);\n    };\n    const findLocationSimple = (forward, location) => {\n      if (forward) {\n        return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);\n      } else {\n        return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));\n      }\n    };\n    const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {\n      const from = normalizePosition(forward, pos);\n      const fromLocation = readLocation(isInlineTarget, rootNode, from);\n      return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));\n    };\n\n    const hasSelectionModifyApi = editor => {\n      return isFunction(editor.selection.getSel().modify);\n    };\n    const moveRel = (forward, selection, pos) => {\n      const delta = forward ? 1 : -1;\n      selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());\n      selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');\n      return true;\n    };\n    const moveByWord = (forward, editor) => {\n      const rng = editor.selection.getRng();\n      const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      if (!hasSelectionModifyApi(editor)) {\n        return false;\n      } else if (forward && isBeforeInline(pos)) {\n        return moveRel(true, editor.selection, pos);\n      } else if (!forward && isAfterInline(pos)) {\n        return moveRel(false, editor.selection, pos);\n      } else {\n        return false;\n      }\n    };\n\n    var BreakType;\n    (function (BreakType) {\n      BreakType[BreakType['Br'] = 0] = 'Br';\n      BreakType[BreakType['Block'] = 1] = 'Block';\n      BreakType[BreakType['Wrap'] = 2] = 'Wrap';\n      BreakType[BreakType['Eol'] = 3] = 'Eol';\n    }(BreakType || (BreakType = {})));\n    const flip = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;\n    const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);\n    const getBreakType = (scope, direction, currentPos, nextPos) => {\n      if (isBr$6(nextPos.getNode(direction === HDirection.Forwards))) {\n        return BreakType.Br;\n      } else if (isInSameBlock(currentPos, nextPos) === false) {\n        return BreakType.Block;\n      } else {\n        return BreakType.Wrap;\n      }\n    };\n    const getPositionsUntil = (predicate, direction, scope, start) => {\n      const caretWalker = CaretWalker(scope);\n      let currentPos = start;\n      const positions = [];\n      while (currentPos) {\n        const nextPos = walk$1(direction, caretWalker, currentPos);\n        if (!nextPos) {\n          break;\n        }\n        if (isBr$6(nextPos.getNode(false))) {\n          if (direction === HDirection.Forwards) {\n            return {\n              positions: flip(direction, positions).concat([nextPos]),\n              breakType: BreakType.Br,\n              breakAt: Optional.some(nextPos)\n            };\n          } else {\n            return {\n              positions: flip(direction, positions),\n              breakType: BreakType.Br,\n              breakAt: Optional.some(nextPos)\n            };\n          }\n        }\n        if (!nextPos.isVisible()) {\n          currentPos = nextPos;\n          continue;\n        }\n        if (predicate(currentPos, nextPos)) {\n          const breakType = getBreakType(scope, direction, currentPos, nextPos);\n          return {\n            positions: flip(direction, positions),\n            breakType,\n            breakAt: Optional.some(nextPos)\n          };\n        }\n        positions.push(nextPos);\n        currentPos = nextPos;\n      }\n      return {\n        positions: flip(direction, positions),\n        breakType: BreakType.Eol,\n        breakAt: Optional.none()\n      };\n    };\n    const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map(pos => {\n      const positions = getPositionsUntilBreak(scope, pos).positions;\n      return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);\n    }).getOr([]);\n    const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), lastPos => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {\n      const lastDist = Math.abs(x - lastRect.left);\n      const newDist = Math.abs(x - newRect.left);\n      return newDist <= lastDist ? newPos : lastPos;\n    }).or(acc)), Optional.none());\n    const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind(targetRect => findClosestHorizontalPositionFromPoint(positions, targetRect.left));\n    const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);\n    const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);\n    const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);\n    const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);\n    const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();\n    const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();\n    const getFirstLinePositions = scope => firstPositionIn(scope).map(pos => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);\n    const getLastLinePositions = scope => lastPositionIn(scope).map(pos => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);\n    const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);\n    const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);\n\n    const isContentEditableFalse$5 = isContentEditableFalse$b;\n    const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n    const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n    const isNodeClientRect = rect => hasNonNullableKey(rect, 'node');\n    const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {\n      const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));\n      const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));\n      if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$5(clientRect.node)) {\n        return clientRect;\n      }\n      if (newDistance < oldDistance) {\n        return clientRect;\n      }\n      return oldClientRect;\n    });\n\n    const getNodeClientRects = node => {\n      const toArrayWithNode = clientRects => {\n        return map$3(clientRects, rect => {\n          const clientRect = clone$1(rect);\n          clientRect.node = node;\n          return clientRect;\n        });\n      };\n      if (isElement$6(node)) {\n        return toArrayWithNode(node.getClientRects());\n      } else if (isText$b(node)) {\n        const rng = node.ownerDocument.createRange();\n        rng.setStart(node, 0);\n        rng.setEnd(node, node.data.length);\n        return toArrayWithNode(rng.getClientRects());\n      } else {\n        return [];\n      }\n    };\n    const getClientRects = nodes => bind$3(nodes, getNodeClientRects);\n\n    var VDirection;\n    (function (VDirection) {\n      VDirection[VDirection['Up'] = -1] = 'Up';\n      VDirection[VDirection['Down'] = 1] = 'Down';\n    }(VDirection || (VDirection = {})));\n    const findUntil = (direction, root, predicateFn, node) => {\n      let currentNode = node;\n      while (currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root)) {\n        if (predicateFn(currentNode)) {\n          return;\n        }\n      }\n    };\n    const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {\n      let line = 0;\n      const result = [];\n      const add = node => {\n        let clientRects = getClientRects([node]);\n        if (direction === -1) {\n          clientRects = clientRects.reverse();\n        }\n        for (let i = 0; i < clientRects.length; i++) {\n          const clientRect = clientRects[i];\n          if (isBeflowFn(clientRect, targetClientRect)) {\n            continue;\n          }\n          if (result.length > 0 && isAboveFn(clientRect, last$1(result))) {\n            line++;\n          }\n          clientRect.line = line;\n          if (predicateFn(clientRect)) {\n            return true;\n          }\n          result.push(clientRect);\n        }\n        return false;\n      };\n      const targetClientRect = last$1(caretPosition.getClientRects());\n      if (!targetClientRect) {\n        return result;\n      }\n      const node = caretPosition.getNode();\n      if (node) {\n        add(node);\n        findUntil(direction, root, add, node);\n      }\n      return result;\n    };\n    const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;\n    const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;\n    const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);\n    const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);\n    const getLastClientRect = caretPosition => {\n      return last$1(caretPosition.getClientRects());\n    };\n    const positionsUntil = (direction, root, predicateFn, node) => {\n      const caretWalker = CaretWalker(root);\n      let walkFn;\n      let isBelowFn;\n      let isAboveFn;\n      let caretPosition;\n      const result = [];\n      let line = 0;\n      if (direction === 1) {\n        walkFn = caretWalker.next;\n        isBelowFn = isBelow$1;\n        isAboveFn = isAbove$1;\n        caretPosition = CaretPosition.after(node);\n      } else {\n        walkFn = caretWalker.prev;\n        isBelowFn = isAbove$1;\n        isAboveFn = isBelow$1;\n        caretPosition = CaretPosition.before(node);\n      }\n      const targetClientRect = getLastClientRect(caretPosition);\n      do {\n        if (!caretPosition.isVisible()) {\n          continue;\n        }\n        const rect = getLastClientRect(caretPosition);\n        if (isAboveFn(rect, targetClientRect)) {\n          continue;\n        }\n        if (result.length > 0 && isBelowFn(rect, last$1(result))) {\n          line++;\n        }\n        const clientRect = clone$1(rect);\n        clientRect.position = caretPosition;\n        clientRect.line = line;\n        if (predicateFn(clientRect)) {\n          return result;\n        }\n        result.push(clientRect);\n      } while (caretPosition = walkFn(caretPosition));\n      return result;\n    };\n    const isAboveLine = lineNumber => clientRect => aboveLineNumber(lineNumber, clientRect);\n    const isLine = lineNumber => clientRect => isLineNumber(lineNumber, clientRect);\n\n    const moveToRange = (editor, rng) => {\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, editor.selection.getRng());\n    };\n    const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));\n    const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {\n      const forwards = direction === HDirection.Forwards;\n      const caretWalker = CaretWalker(editor.getBody());\n      const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);\n      const isBeforeFn = forwards ? isBefore : isAfter;\n      if (!range.collapsed) {\n        const node = getSelectedNode(range);\n        if (isElement(node)) {\n          return showCaret(direction, editor, node, direction === HDirection.Backwards, false);\n        } else if (isCefAtEdgeSelected(editor)) {\n          const newRange = range.cloneRange();\n          newRange.collapse(direction === HDirection.Backwards);\n          return Optional.from(newRange);\n        }\n      }\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      if (isBeforeFn(caretPosition)) {\n        return selectNode(editor, caretPosition.getNode(!forwards));\n      }\n      let nextCaretPosition = getNextPosFn(caretPosition);\n      const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);\n      if (!nextCaretPosition) {\n        return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();\n      } else {\n        nextCaretPosition = normalizePosition(forwards, nextCaretPosition);\n      }\n      if (isBeforeFn(nextCaretPosition)) {\n        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);\n      }\n      const peekCaretPosition = getNextPosFn(nextCaretPosition);\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\n          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);\n        }\n      }\n      if (rangeIsInContainerBlock) {\n        return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);\n      }\n      return Optional.none();\n    };\n    const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      const caretClientRect = last$1(caretPosition.getClientRects());\n      const forwards = direction === VDirection.Down;\n      const root = editor.getBody();\n      if (!caretClientRect) {\n        return Optional.none();\n      }\n      if (isCefAtEdgeSelected(editor)) {\n        const caretPosition = forwards ? CaretPosition.fromRangeEnd(range) : CaretPosition.fromRangeStart(range);\n        const getClosestFn = !forwards ? getClosestPositionAbove : getClosestPositionBelow;\n        return getClosestFn(root, caretPosition).orThunk(() => Optional.from(caretPosition)).map(pos => pos.toRange());\n      }\n      const walkerFn = forwards ? downUntil : upUntil;\n      const linePositions = walkerFn(root, isAboveLine(1), caretPosition);\n      const nextLinePositions = filter$5(linePositions, isLine(1));\n      const clientX = caretClientRect.left;\n      const nextLineRect = findClosestClientRect(nextLinePositions, clientX);\n      if (nextLineRect && isElement(nextLineRect.node)) {\n        const dist1 = Math.abs(clientX - nextLineRect.left);\n        const dist2 = Math.abs(clientX - nextLineRect.right);\n        return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);\n      }\n      let currentNode;\n      if (isBefore(caretPosition)) {\n        currentNode = caretPosition.getNode();\n      } else if (isAfter(caretPosition)) {\n        currentNode = caretPosition.getNode(true);\n      } else {\n        currentNode = getSelectedNode(range);\n      }\n      if (currentNode) {\n        const caretPositions = positionsUntil(direction, root, isAboveLine(1), currentNode);\n        let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);\n        if (closestNextLineRect) {\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n        }\n        closestNextLineRect = last$1(filter$5(caretPositions, isLine(0)));\n        if (closestNextLineRect) {\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n        }\n      }\n      if (nextLinePositions.length === 0) {\n        return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(pos => renderRangeCaret(editor, pos.toRange(), false));\n      }\n      return Optional.none();\n    };\n    const getLineEndPoint = (editor, forward) => {\n      const rng = editor.selection.getRng();\n      const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      const host = getEditingHost(from.container(), editor.getBody());\n      if (forward) {\n        const lineInfo = getPositionsUntilNextLine(host, from);\n        return last$2(lineInfo.positions);\n      } else {\n        const lineInfo = getPositionsUntilPreviousLine(host, from);\n        return head(lineInfo.positions);\n      }\n    };\n    const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists(pos => {\n      editor.selection.setRng(pos.toRange());\n      return true;\n    });\n\n    const setCaretPosition = (editor, pos) => {\n      const rng = editor.dom.createRng();\n      rng.setStart(pos.container(), pos.offset());\n      rng.setEnd(pos.container(), pos.offset());\n      editor.selection.setRng(rng);\n    };\n    const setSelected = (state, elm) => {\n      if (state) {\n        elm.setAttribute('data-mce-selected', 'inline-boundary');\n      } else {\n        elm.removeAttribute('data-mce-selected');\n      }\n    };\n    const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map(pos => {\n      setCaretPosition(editor, pos);\n      return location;\n    });\n    const getPositionFromRange = (range, root, forward) => {\n      const start = CaretPosition.fromRangeStart(range);\n      if (range.collapsed) {\n        return start;\n      } else {\n        const end = CaretPosition.fromRangeEnd(range);\n        return forward ? prevPosition(root, end).getOr(end) : nextPosition(root, start).getOr(start);\n      }\n    };\n    const findLocation = (editor, caret, forward) => {\n      const rootNode = editor.getBody();\n      const from = getPositionFromRange(editor.selection.getRng(), rootNode, forward);\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);\n      return location.bind(location => renderCaretLocation(editor, caret, location));\n    };\n    const toggleInlines = (isInlineTarget, dom, elms) => {\n      const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected=\"inline-boundary\"]'), e => e.dom);\n      const selectedInlines = filter$5(inlineBoundaries, isInlineTarget);\n      const targetInlines = filter$5(elms, isInlineTarget);\n      each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));\n      each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));\n    };\n    const safeRemoveCaretContainer = (editor, caret) => {\n      const caretValue = caret.get();\n      if (editor.selection.isCollapsed() && !editor.composing && caretValue) {\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {\n          setCaretPosition(editor, removeAndReposition(caretValue, pos));\n          caret.set(null);\n        }\n      }\n    };\n    const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {\n      if (editor.selection.isCollapsed()) {\n        const inlines = filter$5(elms, isInlineTarget);\n        each$e(inlines, _inline => {\n          const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n          readLocation(isInlineTarget, editor.getBody(), pos).bind(location => renderCaretLocation(editor, caret, location));\n        });\n      }\n    };\n    const move$3 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;\n    const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;\n    const setupSelectedState = editor => {\n      const caret = Cell(null);\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      editor.on('NodeChange', e => {\n        if (isInlineBoundariesEnabled(editor)) {\n          toggleInlines(isInlineTarget$1, editor.dom, e.parents);\n          safeRemoveCaretContainer(editor, caret);\n          renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);\n        }\n      });\n      return caret;\n    };\n    const moveNextWord = curry(moveWord, true);\n    const movePrevWord = curry(moveWord, false);\n    const moveToLineEndPoint$2 = (editor, forward, caret) => {\n      if (isInlineBoundariesEnabled(editor)) {\n        const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {\n          const rng = editor.selection.getRng();\n          return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n        });\n        return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(loc => {\n          const outsideLoc = outside(loc);\n          return renderCaret(caret, outsideLoc).exists(pos => {\n            setCaretPosition(editor, pos);\n            return true;\n          });\n        });\n      } else {\n        return false;\n      }\n    };\n\n    const rangeFromPositions = (from, to) => {\n      const range = document.createRange();\n      range.setStart(from.container(), from.offset());\n      range.setEnd(to.container(), to.offset());\n      return range;\n    };\n    const hasOnlyTwoOrLessPositionsLeft = elm => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n      const normalizedFirstPos = normalizePosition(true, firstPos);\n      const normalizedLastPos = normalizePosition(false, lastPos);\n      return nextPosition(elm, normalizedFirstPos).forall(pos => pos.isEqual(normalizedLastPos));\n    }).getOr(true);\n    const setCaretLocation = (editor, caret) => location => renderCaret(caret, location).map(pos => () => setCaretPosition(editor, pos));\n    const deleteFromTo = (editor, caret, from, to) => {\n      const rootNode = editor.getBody();\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      editor.undoManager.ignore(() => {\n        editor.selection.setRng(rangeFromPositions(from, to));\n        execNativeDeleteCommand(editor);\n        readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);\n      });\n      editor.nodeChanged();\n    };\n    const rescope = (rootNode, node) => {\n      const parentBlock = getParentBlock$3(node, rootNode);\n      return parentBlock ? parentBlock : rootNode;\n    };\n    const backspaceDeleteCollapsed = (editor, caret, forward, from) => {\n      const rootNode = rescope(editor.getBody(), from.container());\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const fromLocation = readLocation(isInlineTarget$1, rootNode, from);\n      const location = fromLocation.bind(location => {\n        if (forward) {\n          return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);\n        } else {\n          return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));\n        }\n      });\n      return location.map(setCaretLocation(editor, caret)).getOrThunk(() => {\n        const toPosition = navigate(forward, rootNode, from);\n        const toLocation = toPosition.bind(pos => readLocation(isInlineTarget$1, rootNode, pos));\n        return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind(elm => {\n          if (hasOnlyTwoOrLessPositionsLeft(elm)) {\n            return Optional.some(() => {\n              deleteElement$2(editor, forward, SugarElement.fromDom(elm));\n            });\n          } else {\n            return Optional.none();\n          }\n        })).getOrThunk(() => toLocation.bind(() => toPosition.map(to => {\n          return () => {\n            if (forward) {\n              deleteFromTo(editor, caret, from, to);\n            } else {\n              deleteFromTo(editor, caret, to, from);\n            }\n          };\n        })));\n      });\n    };\n    const backspaceDelete$4 = (editor, caret, forward) => {\n      if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {\n        const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n        return backspaceDeleteCollapsed(editor, caret, forward, from);\n      }\n      return Optional.none();\n    };\n\n    const hasMultipleChildren = elm => childNodesCount(elm) > 1;\n    const getParentsUntil = (editor, pred) => {\n      const rootElm = SugarElement.fromDom(editor.getBody());\n      const startElm = SugarElement.fromDom(editor.selection.getStart());\n      const parents = parentsAndSelf(startElm, rootElm);\n      return findIndex$2(parents, pred).fold(constant(parents), index => parents.slice(0, index));\n    };\n    const hasOnlyOneChild = elm => childNodesCount(elm) === 1;\n    const getParentInlinesUntilMultichildInline = editor => getParentsUntil(editor, elm => editor.schema.isBlock(name(elm)) || hasMultipleChildren(elm));\n    const getParentInlines = editor => getParentsUntil(editor, el => editor.schema.isBlock(name(el)));\n    const getFormatNodes = (editor, parentInlines) => {\n      const isFormatElement$1 = curry(isFormatElement, editor);\n      return bind$3(parentInlines, elm => isFormatElement$1(elm) ? [elm.dom] : []);\n    };\n    const getFormatNodesAtStart = editor => {\n      const parentInlines = getParentInlines(editor);\n      return getFormatNodes(editor, parentInlines);\n    };\n    const deleteLastPosition = (forward, editor, target, parentInlines) => {\n      const formatNodes = getFormatNodes(editor, parentInlines);\n      if (formatNodes.length === 0) {\n        deleteElement$2(editor, forward, target);\n      } else {\n        const pos = replaceWithCaretFormat(target.dom, formatNodes);\n        editor.selection.setRng(pos.toRange());\n      }\n    };\n    const deleteCaret$1 = (editor, forward) => {\n      const parentInlines = filter$5(getParentInlinesUntilMultichildInline(editor), hasOnlyOneChild);\n      return last$2(parentInlines).bind(target => {\n        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {\n          return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));\n        } else {\n          return Optional.none();\n        }\n      });\n    };\n    const isBrInEmptyElement = (editor, elm) => {\n      const parentElm = elm.parentElement;\n      return isBr$6(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);\n    };\n    const isEmptyCaret = elm => isEmptyCaretFormatElement(SugarElement.fromDom(elm));\n    const createCaretFormatAtStart = (editor, formatNodes) => {\n      const startElm = editor.selection.getStart();\n      const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm) ? replaceWithCaretFormat(startElm, formatNodes) : createCaretFormatAtStart$1(editor.selection.getRng(), formatNodes);\n      editor.selection.setRng(pos.toRange());\n    };\n    const updateCaretFormat = (editor, updateFormats) => {\n      const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));\n      if (missingFormats.length > 0) {\n        createCaretFormatAtStart(editor, missingFormats);\n      }\n    };\n    const rangeStartsAtTextContainer = rng => isText$b(rng.startContainer);\n    const rangeStartsAtStartOfTextContainer = rng => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);\n    const rangeStartParentIsFormatElement = (editor, rng) => {\n      const startParent = rng.startContainer.parentElement;\n      return !isNull(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));\n    };\n    const rangeStartAndEndHaveSameParent = rng => {\n      const startParent = rng.startContainer.parentNode;\n      const endParent = rng.endContainer.parentNode;\n      return !isNull(startParent) && !isNull(endParent) && startParent.isEqualNode(endParent);\n    };\n    const rangeEndsAtEndOfEndContainer = rng => {\n      const endContainer = rng.endContainer;\n      return rng.endOffset === (isText$b(endContainer) ? endContainer.length : endContainer.childNodes.length);\n    };\n    const rangeEndsAtEndOfStartContainer = rng => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);\n    const rangeEndsAfterEndOfStartContainer = rng => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);\n    const rangeEndsAtOrAfterEndOfStartContainer = rng => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);\n    const requiresDeleteRangeOverride = editor => {\n      const rng = editor.selection.getRng();\n      return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);\n    };\n    const deleteRange$1 = editor => {\n      if (requiresDeleteRangeOverride(editor)) {\n        const formatNodes = getFormatNodesAtStart(editor);\n        return Optional.some(() => {\n          execNativeDeleteCommand(editor);\n          updateCaretFormat(editor, formatNodes);\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const backspaceDelete$3 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$1(editor);\n    const hasAncestorInlineCaret = (elm, schema) => ancestor$2(elm, node => isCaretNode(node.dom), el => schema.isBlock(name(el)));\n    const hasAncestorInlineCaretAtStart = editor => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()), editor.schema);\n    const requiresRefreshCaretOverride = editor => {\n      const rng = editor.selection.getRng();\n      return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);\n    };\n    const refreshCaret = editor => {\n      if (requiresRefreshCaretOverride(editor)) {\n        createCaretFormatAtStart(editor, []);\n      }\n      return true;\n    };\n\n    const deleteElement = (editor, forward, element) => {\n      if (isNonNullable(element)) {\n        return Optional.some(() => {\n          editor._selectionOverrides.hideFakeCaret();\n          deleteElement$2(editor, forward, SugarElement.fromDom(element));\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const deleteCaret = (editor, forward) => {\n      const isNearMedia = forward ? isBeforeMedia : isAfterMedia;\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());\n      if (isNearMedia(fromPos)) {\n        return deleteElement(editor, forward, fromPos.getNode(!forward));\n      } else {\n        return Optional.from(normalizePosition(forward, fromPos)).filter(pos => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).bind(pos => deleteElement(editor, forward, pos.getNode(!forward)));\n      }\n    };\n    const deleteRange = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();\n    };\n    const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);\n\n    const isEditable = target => closest$4(target, elm => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$b(elm.dom)).exists(elm => isContentEditableTrue$3(elm.dom));\n    const parseIndentValue = value => toInt(value !== null && value !== void 0 ? value : '').getOr(0);\n    const getIndentStyleName = (useMargin, element) => {\n      const indentStyleName = useMargin || isTable$1(element) ? 'margin' : 'padding';\n      const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';\n      return indentStyleName + suffix;\n    };\n    const indentElement = (dom, command, useMargin, value, unit, element) => {\n      const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));\n      const parsedValue = parseIndentValue(dom.getStyle(element, indentStyleName));\n      if (command === 'outdent') {\n        const styleValue = Math.max(0, parsedValue - value);\n        dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');\n      } else {\n        const styleValue = parsedValue + value + unit;\n        dom.setStyle(element, indentStyleName, styleValue);\n      }\n    };\n    const validateBlocks = (editor, blocks) => forall(blocks, block => {\n      const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);\n      const intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);\n      const contentEditable = editor.dom.getContentEditable(block.dom);\n      return contentEditable !== 'false' && intentValue > 0;\n    });\n    const canOutdent = editor => {\n      const blocks = getBlocksToIndent(editor);\n      return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));\n    };\n    const isListComponent = el => isList(el) || isListItem$1(el);\n    const parentIsListComponent = el => parent(el).exists(isListComponent);\n    const getBlocksToIndent = editor => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), el => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));\n    const handle = (editor, command) => {\n      var _a, _b;\n      const {dom} = editor;\n      const indentation = getIndentation(editor);\n      const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'px';\n      const indentValue = parseIndentValue(indentation);\n      const useMargin = shouldIndentUseMargin(editor);\n      each$e(getBlocksToIndent(editor), block => {\n        indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);\n      });\n    };\n    const indent = editor => handle(editor, 'indent');\n    const outdent = editor => handle(editor, 'outdent');\n\n    const backspaceDelete$1 = editor => {\n      if (editor.selection.isCollapsed() && canOutdent(editor)) {\n        const dom = editor.dom;\n        const rng = editor.selection.getRng();\n        const pos = CaretPosition.fromRangeStart(rng);\n        const block = dom.getParent(rng.startContainer, dom.isBlock);\n        if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos, editor.schema)) {\n          return Optional.some(() => outdent(editor));\n        }\n      }\n      return Optional.none();\n    };\n\n    const findAction = (editor, caret, forward) => findMap([\n      backspaceDelete$1,\n      backspaceDelete$7,\n      backspaceDelete$8,\n      (editor, forward) => backspaceDelete$4(editor, caret, forward),\n      backspaceDelete$a,\n      backspaceDelete$b,\n      backspaceDelete$5,\n      backspaceDelete$2,\n      backspaceDelete$9,\n      backspaceDelete$3,\n      backspaceDelete$6\n    ], item => item(editor, forward)).filter(_ => editor.selection.isEditable());\n    const deleteCommand = (editor, caret) => {\n      const result = findAction(editor, caret, false);\n      result.fold(() => {\n        if (editor.selection.isEditable()) {\n          execNativeDeleteCommand(editor);\n          paddEmptyBody(editor);\n        }\n      }, call);\n    };\n    const forwardDeleteCommand = (editor, caret) => {\n      const result = findAction(editor, caret, true);\n      result.fold(() => {\n        if (editor.selection.isEditable()) {\n          execNativeForwardDeleteCommand(editor);\n        }\n      }, call);\n    };\n    const setup$q = (editor, caret) => {\n      editor.addCommand('delete', () => {\n        deleteCommand(editor, caret);\n      });\n      editor.addCommand('forwardDelete', () => {\n        forwardDeleteCommand(editor, caret);\n      });\n    };\n\n    const SIGNIFICANT_MOVE = 5;\n    const LONGPRESS_DELAY = 400;\n    const getTouch = event => {\n      if (event.touches === undefined || event.touches.length !== 1) {\n        return Optional.none();\n      }\n      return Optional.some(event.touches[0]);\n    };\n    const isFarEnough = (touch, data) => {\n      const distX = Math.abs(touch.clientX - data.x);\n      const distY = Math.abs(touch.clientY - data.y);\n      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\n    };\n    const setup$p = editor => {\n      const startData = value$2();\n      const longpressFired = Cell(false);\n      const debounceLongpress = last(e => {\n        editor.dispatch('longpress', {\n          ...e,\n          type: 'longpress'\n        });\n        longpressFired.set(true);\n      }, LONGPRESS_DELAY);\n      editor.on('touchstart', e => {\n        getTouch(e).each(touch => {\n          debounceLongpress.cancel();\n          const data = {\n            x: touch.clientX,\n            y: touch.clientY,\n            target: e.target\n          };\n          debounceLongpress.throttle(e);\n          longpressFired.set(false);\n          startData.set(data);\n        });\n      }, true);\n      editor.on('touchmove', e => {\n        debounceLongpress.cancel();\n        getTouch(e).each(touch => {\n          startData.on(data => {\n            if (isFarEnough(touch, data)) {\n              startData.clear();\n              longpressFired.set(false);\n              editor.dispatch('longpresscancel');\n            }\n          });\n        });\n      }, true);\n      editor.on('touchend touchcancel', e => {\n        debounceLongpress.cancel();\n        if (e.type === 'touchcancel') {\n          return;\n        }\n        startData.get().filter(data => data.target.isEqualNode(e.target)).each(() => {\n          if (longpressFired.get()) {\n            e.preventDefault();\n          } else {\n            editor.dispatch('tap', {\n              ...e,\n              type: 'tap'\n            });\n          }\n        });\n      }, true);\n    };\n\n    const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);\n    const isValidTarget = (schema, node) => {\n      if (isText$b(node)) {\n        return true;\n      } else if (isElement$6(node)) {\n        return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) && !isTransparentBlock(schema, node) && !isNonHtmlElementRoot(node);\n      } else {\n        return false;\n      }\n    };\n    const hasBlockParent = (blockElements, root, node) => {\n      return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), elm => {\n        return isBlockElement(blockElements, elm.dom);\n      });\n    };\n    const shouldRemoveTextNode = (blockElements, node) => {\n      if (isText$b(node)) {\n        if (node.data.length === 0) {\n          return true;\n        } else if (/^\\s+$/.test(node.data)) {\n          return !node.nextSibling || isBlockElement(blockElements, node.nextSibling) || isNonHtmlElementRoot(node.nextSibling);\n        }\n      }\n      return false;\n    };\n    const createRootBlock = editor => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n    const addRootBlocks = editor => {\n      const dom = editor.dom, selection = editor.selection;\n      const schema = editor.schema;\n      const blockElements = schema.getBlockElements();\n      const startNode = selection.getStart();\n      const rootNode = editor.getBody();\n      let rootBlockNode;\n      let tempNode;\n      let bm = null;\n      const forcedRootBlock = getForcedRootBlock(editor);\n      if (!startNode || !isElement$6(startNode)) {\n        return;\n      }\n      const rootNodeName = rootNode.nodeName.toLowerCase();\n      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) {\n        return;\n      }\n      if (rootNode.firstChild === rootNode.lastChild && isBr$6(rootNode.firstChild)) {\n        rootBlockNode = createRootBlock(editor);\n        rootBlockNode.appendChild(createPaddingBr().dom);\n        rootNode.replaceChild(rootBlockNode, rootNode.firstChild);\n        editor.selection.setCursorLocation(rootBlockNode, 0);\n        editor.nodeChanged();\n        return;\n      }\n      let node = rootNode.firstChild;\n      while (node) {\n        if (isElement$6(node)) {\n          updateElement(schema, node);\n        }\n        if (isValidTarget(schema, node)) {\n          if (shouldRemoveTextNode(blockElements, node)) {\n            tempNode = node;\n            node = node.nextSibling;\n            dom.remove(tempNode);\n            continue;\n          }\n          if (!rootBlockNode) {\n            if (!bm && editor.hasFocus()) {\n              bm = getBookmark(editor.selection.getRng(), () => document.createElement('span'));\n            }\n            if (!node.parentNode) {\n              node = null;\n              break;\n            }\n            rootBlockNode = createRootBlock(editor);\n            rootNode.insertBefore(rootBlockNode, node);\n          }\n          tempNode = node;\n          node = node.nextSibling;\n          rootBlockNode.appendChild(tempNode);\n        } else {\n          rootBlockNode = null;\n          node = node.nextSibling;\n        }\n      }\n      if (bm) {\n        editor.selection.setRng(resolveBookmark(bm));\n        editor.nodeChanged();\n      }\n    };\n    const insertEmptyLine = (editor, root, insertBlock) => {\n      const block = SugarElement.fromDom(createRootBlock(editor));\n      const br = createPaddingBr();\n      append$1(block, br);\n      insertBlock(root, block);\n      const rng = document.createRange();\n      rng.setStartBefore(br.dom);\n      rng.setEndBefore(br.dom);\n      return rng;\n    };\n    const setup$o = editor => {\n      editor.on('NodeChange', () => addRootBlocks(editor));\n    };\n\n    const hasClass = checkClassName => node => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;\n    const replaceMatchWithSpan = (editor, content, cls) => {\n      return function (match) {\n        const args = arguments, index = args[args.length - 2];\n        const prevChar = index > 0 ? content.charAt(index - 1) : '';\n        if (prevChar === '\"') {\n          return match;\n        }\n        if (prevChar === '>') {\n          const findStartTagIndex = content.lastIndexOf('<', index);\n          if (findStartTagIndex !== -1) {\n            const tagHtml = content.substring(findStartTagIndex, index);\n            if (tagHtml.indexOf('contenteditable=\"false\"') !== -1) {\n              return match;\n            }\n          }\n        }\n        return '<span class=\"' + cls + '\" data-mce-content=\"' + editor.dom.encode(args[0]) + '\">' + editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>';\n      };\n    };\n    const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {\n      let i = nonEditableRegExps.length, content = e.content;\n      if (e.format === 'raw') {\n        return;\n      }\n      while (i--) {\n        content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));\n      }\n      e.content = content;\n    };\n    const isValidContent = (nonEditableRegExps, content) => {\n      return forall(nonEditableRegExps, re => {\n        const matches = content.match(re);\n        return matches !== null && matches[0].length === content.length;\n      });\n    };\n    const setup$n = editor => {\n      const contentEditableAttrName = 'contenteditable';\n      const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';\n      const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';\n      const hasEditClass = hasClass(editClass);\n      const hasNonEditClass = hasClass(nonEditClass);\n      const nonEditableRegExps = getNonEditableRegExps(editor);\n      if (nonEditableRegExps.length > 0) {\n        editor.on('BeforeSetContent', e => {\n          convertRegExpsToNonEditable(editor, nonEditableRegExps, e);\n        });\n      }\n      editor.parser.addAttributeFilter('class', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (hasEditClass(node)) {\n            node.attr(contentEditableAttrName, 'true');\n          } else if (hasNonEditClass(node)) {\n            node.attr(contentEditableAttrName, 'false');\n          }\n        }\n      });\n      editor.serializer.addAttributeFilter(contentEditableAttrName, nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (!hasEditClass(node) && !hasNonEditClass(node)) {\n            continue;\n          }\n          const content = node.attr('data-mce-content');\n          if (nonEditableRegExps.length > 0 && content) {\n            if (isValidContent(nonEditableRegExps, content)) {\n              node.name = '#text';\n              node.type = 3;\n              node.raw = true;\n              node.value = content;\n            } else {\n              node.remove();\n            }\n          } else {\n            node.attr(contentEditableAttrName, null);\n          }\n        }\n      });\n    };\n\n    const findBlockCaretContainer = editor => descendant$1(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(elm => elm.dom).getOrNull();\n    const showBlockCaretContainer = (editor, blockCaretContainer) => {\n      if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n        showCaretContainerBlock(blockCaretContainer);\n        editor.selection.setRng(editor.selection.getRng());\n        editor.selection.scrollIntoView(blockCaretContainer);\n      }\n    };\n    const handleBlockContainer = (editor, e) => {\n      const blockCaretContainer = findBlockCaretContainer(editor);\n      if (!blockCaretContainer) {\n        return;\n      }\n      if (e.type === 'compositionstart') {\n        e.preventDefault();\n        e.stopPropagation();\n        showBlockCaretContainer(editor, blockCaretContainer);\n        return;\n      }\n      if (hasContent(blockCaretContainer)) {\n        showBlockCaretContainer(editor, blockCaretContainer);\n        editor.undoManager.add();\n      }\n    };\n    const setup$m = editor => {\n      editor.on('keyup compositionstart', curry(handleBlockContainer, editor));\n    };\n\n    const isContentEditableFalse$4 = isContentEditableFalse$b;\n    const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$4);\n    const moveToCeFalseVertically = (direction, editor, range) => {\n      const isBefore = caretPosition => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);\n      const isAfter = caretPosition => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);\n      return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$4);\n    };\n    const createTextBlock = editor => {\n      const textBlock = editor.dom.create(getForcedRootBlock(editor));\n      textBlock.innerHTML = '<br data-mce-bogus=\"1\">';\n      return textBlock;\n    };\n    const exitPreBlock = (editor, direction, range) => {\n      const caretWalker = CaretWalker(editor.getBody());\n      const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);\n      if (range.collapsed) {\n        const pre = editor.dom.getParent(range.startContainer, 'PRE');\n        if (!pre) {\n          return;\n        }\n        const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));\n        if (!caretPos) {\n          const newBlock = SugarElement.fromDom(createTextBlock(editor));\n          if (direction === 1) {\n            after$4(SugarElement.fromDom(pre), newBlock);\n          } else {\n            before$3(SugarElement.fromDom(pre), newBlock);\n          }\n          editor.selection.select(newBlock.dom, true);\n          editor.selection.collapse();\n        }\n      }\n    };\n    const getHorizontalRange = (editor, forward) => {\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const range = editor.selection.getRng();\n      return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {\n        exitPreBlock(editor, direction, range);\n        return Optional.none();\n      });\n    };\n    const getVerticalRange = (editor, down) => {\n      const direction = down ? 1 : -1;\n      const range = editor.selection.getRng();\n      return moveToCeFalseVertically(direction, editor, range).orThunk(() => {\n        exitPreBlock(editor, direction, range);\n        return Optional.none();\n      });\n    };\n    const flipDirection = (selection, forward) => {\n      const elm = forward ? selection.getEnd(true) : selection.getStart(true);\n      return isRtl(elm) ? !forward : forward;\n    };\n    const moveH$2 = (editor, forward) => getHorizontalRange(editor, flipDirection(editor.selection, forward)).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n    const moveV$4 = (editor, down) => getVerticalRange(editor, down).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n    const moveToLineEndPoint$1 = (editor, forward) => {\n      const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;\n      return moveToLineEndPoint$3(editor, forward, isCefPosition);\n    };\n    const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward).map(pos => {\n      const rng = pos.toRange();\n      const curRng = editor.selection.getRng();\n      if (forward) {\n        rng.setStart(curRng.startContainer, curRng.startOffset);\n      } else {\n        rng.setEnd(curRng.endContainer, curRng.endOffset);\n      }\n      return rng;\n    }).exists(rng => {\n      moveToRange(editor, rng);\n      return true;\n    });\n\n    const isTarget = node => contains$2(['figcaption'], name(node));\n    const getClosestTargetBlock = (pos, root, schema) => {\n      const isRoot = curry(eq, root);\n      return closest$4(SugarElement.fromDom(pos.container()), el => schema.isBlock(name(el)), isRoot).filter(isTarget);\n    };\n    const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);\n    const moveCaretToNewEmptyLine = (editor, forward) => {\n      const root = SugarElement.fromDom(editor.getBody());\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return getClosestTargetBlock(pos, root, editor.schema).exists(() => {\n        if (isAtFirstOrLastLine(root, forward, pos)) {\n          const insertFn = forward ? append$1 : prepend;\n          const rng = insertEmptyLine(editor, root, insertFn);\n          editor.selection.setRng(rng);\n          return true;\n        } else {\n          return false;\n        }\n      });\n    };\n    const moveV$3 = (editor, forward) => {\n      if (editor.selection.isCollapsed()) {\n        return moveCaretToNewEmptyLine(editor, forward);\n      } else {\n        return false;\n      }\n    };\n\n    const moveUp = (editor, details, summary) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (root.firstChild === details && isAtFirstLine(summary, pos)) {\n        editor.execCommand('InsertNewBlockBefore');\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const moveDown = (editor, details) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (root.lastChild === details && isAtLastLine(details, pos)) {\n        editor.execCommand('InsertNewBlockAfter');\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const move$2 = (editor, forward) => {\n      if (forward) {\n        return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'details')).map(details => moveDown(editor, details)).getOr(false);\n      } else {\n        return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'summary')).bind(summary => Optional.from(editor.dom.getParent(summary, 'details')).map(details => moveUp(editor, details, summary))).getOr(false);\n      }\n    };\n    const moveV$2 = (editor, forward) => move$2(editor, forward);\n\n    const baseKeyPattern = {\n      shiftKey: false,\n      altKey: false,\n      ctrlKey: false,\n      metaKey: false,\n      keyCode: 0\n    };\n    const defaultPatterns = patterns => map$3(patterns, pattern => ({\n      ...baseKeyPattern,\n      ...pattern\n    }));\n    const defaultDelayedPatterns = patterns => map$3(patterns, pattern => ({\n      ...baseKeyPattern,\n      ...pattern\n    }));\n    const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;\n    const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n    const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n    const action = (f, ...x) => () => f.apply(null, x);\n    const execute = (patterns, evt) => find$2(match$1(patterns, evt), pattern => pattern.action());\n    const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), pattern => pattern.action());\n\n    const moveH$1 = (editor, forward) => {\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const range = editor.selection.getRng();\n      return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n        moveToRange(editor, newRange);\n        return true;\n      });\n    };\n    const moveV$1 = (editor, down) => {\n      const direction = down ? 1 : -1;\n      const range = editor.selection.getRng();\n      return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n        moveToRange(editor, newRange);\n        return true;\n      });\n    };\n    const moveToLineEndPoint = (editor, forward) => {\n      const isNearMedia = forward ? isAfterMedia : isBeforeMedia;\n      return moveToLineEndPoint$3(editor, forward, isNearMedia);\n    };\n\n    const adt = Adt.generate([\n      { none: ['current'] },\n      { first: ['current'] },\n      {\n        middle: [\n          'current',\n          'target'\n        ]\n      },\n      { last: ['current'] }\n    ]);\n    const none = current => adt.none(current);\n    const CellLocation = {\n      ...adt,\n      none\n    };\n\n    const firstLayer = (scope, selector) => {\n      return filterFirstLayer(scope, selector, always);\n    };\n    const filterFirstLayer = (scope, selector, predicate) => {\n      return bind$3(children$1(scope), x => {\n        if (is$1(x, selector)) {\n          return predicate(x) ? [x] : [];\n        } else {\n          return filterFirstLayer(x, selector, predicate);\n        }\n      });\n    };\n\n    const lookup$1 = (tags, element, isRoot = never) => {\n      if (isRoot(element)) {\n        return Optional.none();\n      }\n      if (contains$2(tags, name(element))) {\n        return Optional.some(element);\n      }\n      const isRootOrUpperTable = elm => is$1(elm, 'table') || isRoot(elm);\n      return ancestor$3(element, tags.join(','), isRootOrUpperTable);\n    };\n    const cell = (element, isRoot) => lookup$1([\n      'td',\n      'th'\n    ], element, isRoot);\n    const cells = ancestor => firstLayer(ancestor, 'th,td');\n    const table = (element, isRoot) => closest$3(element, 'table', isRoot);\n\n    const walk = (all, current, index, direction, isEligible = always) => {\n      const forwards = direction === 1;\n      if (!forwards && index <= 0) {\n        return CellLocation.first(all[0]);\n      } else if (forwards && index >= all.length - 1) {\n        return CellLocation.last(all[all.length - 1]);\n      } else {\n        const newIndex = index + direction;\n        const elem = all[newIndex];\n        return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);\n      }\n    };\n    const detect = (current, isRoot) => {\n      return table(current, isRoot).bind(table => {\n        const all = cells(table);\n        const index = findIndex$2(all, x => eq(current, x));\n        return index.map(index => ({\n          index,\n          all\n        }));\n      });\n    };\n    const next = (current, isEligible, isRoot) => {\n      const detection = detect(current, isRoot);\n      return detection.fold(() => {\n        return CellLocation.none(current);\n      }, info => {\n        return walk(info.all, current, info.index, 1, isEligible);\n      });\n    };\n    const prev = (current, isEligible, isRoot) => {\n      const detection = detect(current, isRoot);\n      return detection.fold(() => {\n        return CellLocation.none();\n      }, info => {\n        return walk(info.all, current, info.index, -1, isEligible);\n      });\n    };\n\n    const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();\n    const isContentEditableFalse$3 = elem => isHTMLElement$1(elem) && get$9(elem, 'contenteditable') === 'false';\n    const elementsWithCursorPosition = [\n      'img',\n      'br'\n    ];\n    const isCursorPosition = elem => {\n      const hasCursorPosition = isTextNodeWithCursorPosition(elem);\n      return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse$3(elem);\n    };\n\n    const first = element => descendant$2(element, isCursorPosition);\n\n    const deflate = (rect, delta) => ({\n      left: rect.left - delta,\n      top: rect.top - delta,\n      right: rect.right + delta * 2,\n      bottom: rect.bottom + delta * 2,\n      width: rect.width + delta,\n      height: rect.height + delta\n    });\n    const getCorners = (getYAxisValue, tds) => bind$3(tds, td => {\n      const rect = deflate(clone$1(td.getBoundingClientRect()), -1);\n      return [\n        {\n          x: rect.left,\n          y: getYAxisValue(rect),\n          cell: td\n        },\n        {\n          x: rect.right,\n          y: getYAxisValue(rect),\n          cell: td\n        }\n      ];\n    });\n    const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), oldCorner => {\n      const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));\n      const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));\n      return Optional.some(newDist < oldDist ? newCorner : oldCorner);\n    }), Optional.none());\n    const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {\n      const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(e => e.dom);\n      const corners = filter$5(getCorners(getYAxisValue, cells), corner => isTargetCorner(corner, y));\n      return findClosestCorner(corners, x, y).map(corner => corner.cell);\n    };\n    const getBottomValue = rect => rect.bottom;\n    const getTopValue = rect => rect.top;\n    const isAbove = (corner, y) => corner.y < y;\n    const isBelow = (corner, y) => corner.y > y;\n    const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);\n    const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);\n    const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects()).bind(rect => getClosestCellAbove(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getLastLinePositions(cell), pos));\n    const findClosestPositionInBelowCell = (table, pos) => last$2(pos.getClientRects()).bind(rect => getClosestCellBelow(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));\n\n    const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists(breakPos => getPositionsUntil(scope, breakPos).breakAt.isSome());\n    const startsWithWrapBreak = lineInfo => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;\n    const startsWithBrBreak = lineInfo => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;\n    const isAtTableCellLine = (getPositionsUntil, scope, pos) => {\n      const lineInfo = getPositionsUntil(scope, pos);\n      if (startsWithWrapBreak(lineInfo) || !isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo)) {\n        return !hasNextBreak(getPositionsUntil, scope, lineInfo);\n      } else {\n        return lineInfo.breakAt.isNone();\n      }\n    };\n    const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);\n    const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);\n    const isCaretAtStartOrEndOfTable = (forward, rng, table) => {\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      return positionIn(!forward, table).exists(pos => pos.isEqual(caretPos));\n    };\n    const navigateHorizontally = (editor, forward, table, _td) => {\n      const rng = editor.selection.getRng();\n      const direction = forward ? 1 : -1;\n      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {\n        showCaret(direction, editor, table, !forward, false).each(newRng => {\n          moveToRange(editor, newRng);\n        });\n        return true;\n      }\n      return false;\n    };\n    const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));\n    const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));\n    const getTable = (previous, pos) => {\n      const node = pos.getNode(previous);\n      return isTable$2(node) ? Optional.some(node) : Optional.none();\n    };\n    const renderBlock = (down, editor, table) => {\n      editor.undoManager.transact(() => {\n        const insertFn = down ? after$4 : before$3;\n        const rng = insertEmptyLine(editor, SugarElement.fromDom(table), insertFn);\n        moveToRange(editor, rng);\n      });\n    };\n    const moveCaret = (editor, down, pos) => {\n      const table = down ? getTable(true, pos) : getTable(false, pos);\n      const last = down === false;\n      table.fold(() => moveToRange(editor, pos.toRange()), table => positionIn(last, editor.getBody()).filter(lastPos => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), _ => renderBlock(down, editor, table)));\n    };\n    const navigateVertically = (editor, down, table, td) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (!down && isAtFirstTableCellLine(td, pos)) {\n        const newPos = getClosestAbovePosition(root, table, pos);\n        moveCaret(editor, down, newPos);\n        return true;\n      } else if (down && isAtLastTableCellLine(td, pos)) {\n        const newPos = getClosestBelowPosition(root, table, pos);\n        moveCaret(editor, down, newPos);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(td => Optional.from(editor.dom.getParent(td, 'table')).map(table => mover(editor, forward, table, td))).getOr(false);\n    const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);\n    const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);\n    const getCellFirstCursorPosition = cell => {\n      const selection = SimSelection.exact(cell, 0, cell, 0);\n      return toNative(selection);\n    };\n    const tabGo = (editor, isRoot, cell) => {\n      return cell.fold(Optional.none, Optional.none, (_current, next) => {\n        return first(next).map(cell => {\n          return getCellFirstCursorPosition(cell);\n        });\n      }, current => {\n        editor.execCommand('mceTableInsertRowAfter');\n        return tabForward(editor, isRoot, current);\n      });\n    };\n    const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isEditable$2));\n    const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isEditable$2));\n    const handleTab = (editor, forward) => {\n      const rootElements = [\n        'table',\n        'li',\n        'dl'\n      ];\n      const body = SugarElement.fromDom(editor.getBody());\n      const isRoot = element => {\n        const name$1 = name(element);\n        return eq(element, body) || contains$2(rootElements, name$1);\n      };\n      const rng = editor.selection.getRng();\n      const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);\n      return cell(container, isRoot).map(cell => {\n        table(cell, isRoot).each(table => {\n          editor.model.table.clearSelectedCells(table.dom);\n        });\n        editor.selection.collapse(!forward);\n        const navigation = !forward ? tabBackward : tabForward;\n        const rng = navigation(editor, isRoot, cell);\n        rng.each(range => {\n          editor.selection.setRng(range);\n        });\n        return true;\n      }).getOr(false);\n    };\n\n    const executeKeydownOverride$4 = (editor, caret, evt) => {\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      execute([\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH$2, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH$2, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$4, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$4, editor, true)\n        },\n        ...isMac ? [\n          {\n            keyCode: VK.UP,\n            action: action(selectToEndPoint, editor, false),\n            metaKey: true,\n            shiftKey: true\n          },\n          {\n            keyCode: VK.DOWN,\n            action: action(selectToEndPoint, editor, true),\n            metaKey: true,\n            shiftKey: true\n          }\n        ] : [],\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV, editor, true)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$2, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$2, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH$1, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH$1, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$1, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$1, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(move$3, editor, caret, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(move$3, editor, caret, false)\n        },\n        {\n          keyCode: VK.RIGHT,\n          ctrlKey: !isMac,\n          altKey: isMac,\n          action: action(moveNextWord, editor, caret)\n        },\n        {\n          keyCode: VK.LEFT,\n          ctrlKey: !isMac,\n          altKey: isMac,\n          action: action(movePrevWord, editor, caret)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$3, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$3, editor, true)\n        }\n      ], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$l = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$4(editor, caret, evt);\n        }\n      });\n    };\n\n    const point = (container, offset) => ({\n      container,\n      offset\n    });\n\n    const DOM$7 = DOMUtils.DOM;\n    const alwaysNext = startNode => node => startNode === node ? -1 : 0;\n    const isBoundary = dom => node => dom.isBlock(node) || contains$2([\n      'BR',\n      'IMG',\n      'HR',\n      'INPUT'\n    ], node.nodeName) || dom.getContentEditable(node) === 'false';\n    const textBefore = (node, offset, rootNode) => {\n      if (isText$b(node) && offset >= 0) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, prev.container.data.length));\n      }\n    };\n    const textAfter = (node, offset, rootNode) => {\n      if (isText$b(node) && offset >= node.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, 0));\n      }\n    };\n    const scanLeft = (node, offset, rootNode) => {\n      if (!isText$b(node)) {\n        return Optional.none();\n      }\n      const text = node.data;\n      if (offset >= 0 && offset <= text.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind(prev => {\n          const prevText = prev.container.data;\n          return scanLeft(prev.container, offset + prevText.length, rootNode);\n        });\n      }\n    };\n    const scanRight = (node, offset, rootNode) => {\n      if (!isText$b(node)) {\n        return Optional.none();\n      }\n      const text = node.data;\n      if (offset <= text.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind(next => scanRight(next.container, offset - text.length, rootNode));\n      }\n    };\n    const repeatLeft = (dom, node, offset, process, rootNode) => {\n      const search = TextSeeker(dom, isBoundary(dom));\n      return Optional.from(search.backwards(node, offset, process, rootNode));\n    };\n\n    const isValidTextRange = rng => rng.collapsed && isText$b(rng.startContainer);\n    const getText = rng => trim$2(rng.toString().replace(/\\u00A0/g, ' '));\n    const isWhitespace = chr => chr !== '' && ' \\xA0\\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n\n    const stripTrigger = (text, trigger) => text.substring(trigger.length);\n    const findTrigger = (text, index, trigger, includeWhitespace = false) => {\n      let i;\n      const firstChar = trigger.charAt(0);\n      for (i = index - 1; i >= 0; i--) {\n        const char = text.charAt(i);\n        if (!includeWhitespace && isWhitespace(char)) {\n          return Optional.none();\n        }\n        if (firstChar === char && contains$1(text, trigger, i, index)) {\n          break;\n        }\n      }\n      return Optional.some(i);\n    };\n    const getContext = (dom, initRange, trigger, includeWhitespace = false) => {\n      if (!isValidTextRange(initRange)) {\n        return Optional.none();\n      }\n      const buffer = {\n        text: '',\n        offset: 0\n      };\n      const findTriggerIndex = (element, offset, text) => {\n        buffer.text = text + buffer.text;\n        buffer.offset += offset;\n        return findTrigger(buffer.text, buffer.offset, trigger, includeWhitespace).getOr(offset);\n      };\n      const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();\n      return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerIndex, root).bind(spot => {\n        const range = initRange.cloneRange();\n        range.setStart(spot.container, spot.offset);\n        range.setEnd(initRange.endContainer, initRange.endOffset);\n        if (range.collapsed) {\n          return Optional.none();\n        }\n        const text = getText(range);\n        const triggerIndex = text.lastIndexOf(trigger);\n        if (triggerIndex !== 0) {\n          return Optional.none();\n        } else {\n          return Optional.some({\n            text: stripTrigger(text, trigger),\n            range,\n            trigger\n          });\n        }\n      });\n    };\n\n    const isText$1 = node => node.nodeType === TEXT;\n    const isElement = node => node.nodeType === ELEMENT;\n    const toLast = node => {\n      if (isText$1(node)) {\n        return point(node, node.data.length);\n      } else {\n        const children = node.childNodes;\n        return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);\n      }\n    };\n    const toLeaf = (node, offset) => {\n      const children = node.childNodes;\n      if (children.length > 0 && offset < children.length) {\n        return toLeaf(children[offset], 0);\n      } else if (children.length > 0 && isElement(node) && children.length === offset) {\n        return toLast(children[children.length - 1]);\n      } else {\n        return point(node, offset);\n      }\n    };\n\n    const isPreviousCharContent = (dom, leaf) => {\n      var _a;\n      const root = (_a = dom.getParent(leaf.container, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      return repeatLeft(dom, leaf.container, leaf.offset, (_element, offset) => offset === 0 ? -1 : offset, root).filter(spot => {\n        const char = spot.container.data.charAt(spot.offset - 1);\n        return !isWhitespace(char);\n      }).isSome();\n    };\n    const isStartOfWord = dom => rng => {\n      const leaf = toLeaf(rng.startContainer, rng.startOffset);\n      return !isPreviousCharContent(dom, leaf);\n    };\n    const getTriggerContext = (dom, initRange, database) => findMap(database.triggers, trigger => getContext(dom, initRange, trigger));\n    const lookup = (editor, getDatabase) => {\n      const database = getDatabase();\n      const rng = editor.selection.getRng();\n      return getTriggerContext(editor.dom, rng, database).bind(context => lookupWithContext(editor, getDatabase, context));\n    };\n    const lookupWithContext = (editor, getDatabase, context, fetchOptions = {}) => {\n      var _a;\n      const database = getDatabase();\n      const rng = editor.selection.getRng();\n      const startText = (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : '';\n      const autocompleters = filter$5(database.lookupByTrigger(context.trigger), autocompleter => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));\n      if (autocompleters.length === 0) {\n        return Optional.none();\n      }\n      const lookupData = Promise.all(map$3(autocompleters, ac => {\n        const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);\n        return fetchResult.then(results => ({\n          matchText: context.text,\n          items: results,\n          columns: ac.columns,\n          onAction: ac.onAction,\n          highlightOn: ac.highlightOn\n        }));\n      }));\n      return Optional.some({\n        lookupData,\n        context\n      });\n    };\n\n    var SimpleResultType;\n    (function (SimpleResultType) {\n      SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';\n      SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';\n    }(SimpleResultType || (SimpleResultType = {})));\n    const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);\n    const partition = results => {\n      const values = [];\n      const errors = [];\n      each$e(results, obj => {\n        fold$1(obj, err => errors.push(err), val => values.push(val));\n      });\n      return {\n        values,\n        errors\n      };\n    };\n    const mapError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return {\n          stype: SimpleResultType.Error,\n          serror: f(res.serror)\n        };\n      } else {\n        return res;\n      }\n    };\n    const map = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return {\n          stype: SimpleResultType.Value,\n          svalue: f(res.svalue)\n        };\n      } else {\n        return res;\n      }\n    };\n    const bind$1 = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return f(res.svalue);\n      } else {\n        return res;\n      }\n    };\n    const bindError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return f(res.serror);\n      } else {\n        return res;\n      }\n    };\n    const svalue = v => ({\n      stype: SimpleResultType.Value,\n      svalue: v\n    });\n    const serror = e => ({\n      stype: SimpleResultType.Error,\n      serror: e\n    });\n    const toResult = res => fold$1(res, Result.error, Result.value);\n    const fromResult = res => res.fold(serror, svalue);\n    const SimpleResult = {\n      fromResult,\n      toResult,\n      svalue,\n      partition,\n      serror,\n      bind: bind$1,\n      bindError,\n      map,\n      mapError,\n      fold: fold$1\n    };\n\n    const formatObj = input => {\n      return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);\n    };\n    const formatErrors = errors => {\n      const es = errors.length > 10 ? errors.slice(0, 10).concat([{\n          path: [],\n          getErrorInfo: constant('... (only showing first ten failures)')\n        }]) : errors;\n      return map$3(es, e => {\n        return 'Failed path: (' + e.path.join(' > ') + ')\\n' + e.getErrorInfo();\n      });\n    };\n\n    const nu = (path, getErrorInfo) => {\n      return SimpleResult.serror([{\n          path,\n          getErrorInfo\n        }]);\n    };\n    const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for \"' + key + '\" in ' + formatObj(obj));\n    const missingKey = (path, key) => nu(path, () => 'Choice schema did not contain choice key: \"' + key + '\"');\n    const missingBranch = (path, branches, branch) => nu(path, () => 'The chosen schema: \"' + branch + '\" did not exist in branches: ' + formatObj(branches));\n    const custom = (path, err) => nu(path, constant(err));\n\n    const chooseFrom = (path, input, branches, ch) => {\n      const fields = get$a(branches, ch);\n      return fields.fold(() => missingBranch(path, branches, ch), vp => vp.extract(path.concat(['branch: ' + ch]), input));\n    };\n    const choose$1 = (key, branches) => {\n      const extract = (path, input) => {\n        const choice = get$a(input, key);\n        return choice.fold(() => missingKey(path, key), chosen => chooseFrom(path, input, branches, chosen));\n      };\n      const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const shallow = (old, nu) => {\n      return nu;\n    };\n    const deep = (old, nu) => {\n      const bothObjects = isPlainObject(old) && isPlainObject(nu);\n      return bothObjects ? deepMerge(old, nu) : nu;\n    };\n    const baseMerge = merger => {\n      return (...objects) => {\n        if (objects.length === 0) {\n          throw new Error(`Can't merge zero objects`);\n        }\n        const ret = {};\n        for (let j = 0; j < objects.length; j++) {\n          const curObject = objects[j];\n          for (const key in curObject) {\n            if (has$2(curObject, key)) {\n              ret[key] = merger(ret[key], curObject[key]);\n            }\n          }\n        }\n        return ret;\n      };\n    };\n    const deepMerge = baseMerge(deep);\n    const merge = baseMerge(shallow);\n\n    const required = () => ({\n      tag: 'required',\n      process: {}\n    });\n    const defaultedThunk = fallbackThunk => ({\n      tag: 'defaultedThunk',\n      process: fallbackThunk\n    });\n    const defaulted$1 = fallback => defaultedThunk(constant(fallback));\n    const asOption = () => ({\n      tag: 'option',\n      process: {}\n    });\n\n    const mergeValues = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values))) : SimpleResult.svalue(base);\n    const mergeErrors = errors => compose(SimpleResult.serror, flatten)(errors);\n    const consolidateObj = (objects, base) => {\n      const partition = SimpleResult.partition(objects);\n      return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);\n    };\n    const consolidateArr = objects => {\n      const partitions = SimpleResult.partition(objects);\n      return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);\n    };\n    const ResultCombine = {\n      consolidateObj,\n      consolidateArr\n    };\n\n    const field$1 = (key, newKey, presence, prop) => ({\n      tag: 'field',\n      key,\n      newKey,\n      presence,\n      prop\n    });\n    const customField$1 = (newKey, instantiator) => ({\n      tag: 'custom',\n      newKey,\n      instantiator\n    });\n    const fold = (value, ifField, ifCustom) => {\n      switch (value.tag) {\n      case 'field':\n        return ifField(value.key, value.newKey, value.presence, value.prop);\n      case 'custom':\n        return ifCustom(value.newKey, value.instantiator);\n      }\n    };\n\n    const value = validator => {\n      const extract = (path, val) => {\n        return SimpleResult.bindError(validator(val), err => custom(path, err));\n      };\n      const toString = constant('val');\n      return {\n        extract,\n        toString\n      };\n    };\n    const anyValue$1 = value(SimpleResult.svalue);\n\n    const requiredAccess = (path, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);\n    const fallbackAccess = (obj, key, fallback, bundle) => {\n      const v = get$a(obj, key).getOrThunk(() => fallback(obj));\n      return bundle(v);\n    };\n    const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));\n    const optionDefaultedAccess = (obj, key, fallback, bundle) => {\n      const opt = get$a(obj, key).map(val => val === true ? fallback(obj) : val);\n      return bundle(opt);\n    };\n    const extractField = (field, path, obj, key, prop) => {\n      const bundle = av => prop.extract(path.concat([key]), av);\n      const bundleAsOption = optValue => optValue.fold(() => SimpleResult.svalue(Optional.none()), ov => {\n        const result = prop.extract(path.concat([key]), ov);\n        return SimpleResult.map(result, Optional.some);\n      });\n      switch (field.tag) {\n      case 'required':\n        return requiredAccess(path, obj, key, bundle);\n      case 'defaultedThunk':\n        return fallbackAccess(obj, key, field.process, bundle);\n      case 'option':\n        return optionAccess(obj, key, bundleAsOption);\n      case 'defaultedOptionThunk':\n        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);\n      case 'mergeWithThunk': {\n          return fallbackAccess(obj, key, constant({}), v => {\n            const result = deepMerge(field.process(obj), v);\n            return bundle(result);\n          });\n        }\n      }\n    };\n    const extractFields = (path, obj, fields) => {\n      const success = {};\n      const errors = [];\n      for (const field of fields) {\n        fold(field, (key, newKey, presence, prop) => {\n          const result = extractField(presence, path, obj, key, prop);\n          SimpleResult.fold(result, err => {\n            errors.push(...err);\n          }, res => {\n            success[newKey] = res;\n          });\n        }, (newKey, instantiator) => {\n          success[newKey] = instantiator(obj);\n        });\n      }\n      return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);\n    };\n    const objOf = values => {\n      const extract = (path, o) => extractFields(path, o, values);\n      const toString = () => {\n        const fieldStrings = map$3(values, value => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));\n        return 'obj{\\n' + fieldStrings.join('\\n') + '}';\n      };\n      return {\n        extract,\n        toString\n      };\n    };\n    const arrOf = prop => {\n      const extract = (path, array) => {\n        const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));\n        return ResultCombine.consolidateArr(results);\n      };\n      const toString = () => 'array(' + prop.toString() + ')';\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const valueOf = validator => value(v => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));\n    const extractValue = (label, prop, obj) => {\n      const res = prop.extract([label], obj);\n      return SimpleResult.mapError(res, errs => ({\n        input: obj,\n        errors: errs\n      }));\n    };\n    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));\n    const formatError = errInfo => {\n      return 'Errors: \\n' + formatErrors(errInfo.errors).join('\\n') + '\\n\\nInput object: ' + formatObj(errInfo.input);\n    };\n    const choose = (key, branches) => choose$1(key, map$2(branches, objOf));\n\n    const anyValue = constant(anyValue$1);\n    const typedValue = (validator, expectedType) => value(a => {\n      const actualType = typeof a;\n      return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${ expectedType } but got: ${ actualType }`);\n    });\n    const number = typedValue(isNumber, 'number');\n    const string = typedValue(isString, 'string');\n    const boolean = typedValue(isBoolean, 'boolean');\n    const functionProcessor = typedValue(isFunction, 'function');\n\n    const field = field$1;\n    const customField = customField$1;\n    const validateEnum = values => valueOf(value => contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: \"${ value }\", choose one of \"${ values.join(', ') }\".`));\n    const requiredOf = (key, schema) => field(key, key, required(), schema);\n    const requiredString = key => requiredOf(key, string);\n    const requiredFunction = key => requiredOf(key, functionProcessor);\n    const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));\n    const optionOf = (key, schema) => field(key, key, asOption(), schema);\n    const optionString = key => optionOf(key, string);\n    const optionFunction = key => optionOf(key, functionProcessor);\n    const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());\n    const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);\n    const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);\n    const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);\n    const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));\n    const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);\n    const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);\n    const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));\n\n    const type = requiredString('type');\n    const fetch$1 = requiredFunction('fetch');\n    const onAction = requiredFunction('onAction');\n    const onSetup = defaultedFunction('onSetup', () => noop);\n    const optionalText = optionString('text');\n    const optionalIcon = optionString('icon');\n    const optionalTooltip = optionString('tooltip');\n    const optionalLabel = optionString('label');\n    const active = defaultedBoolean('active', false);\n    const enabled = defaultedBoolean('enabled', true);\n    const primary = defaultedBoolean('primary', false);\n    const defaultedColumns = num => defaulted('columns', num);\n    const defaultedType = type => defaultedString('type', type);\n\n    const autocompleterSchema = objOf([\n      type,\n      requiredString('trigger'),\n      defaultedNumber('minChars', 1),\n      defaultedColumns(1),\n      defaultedNumber('maxResults', 10),\n      optionFunction('matches'),\n      fetch$1,\n      onAction,\n      defaultedArrayOf('highlightOn', [], string)\n    ]);\n    const createAutocompleter = spec => asRaw('Autocompleter', autocompleterSchema, spec);\n\n    const baseToolbarButtonFields = [\n      enabled,\n      optionalTooltip,\n      optionalIcon,\n      optionalText,\n      onSetup\n    ];\n\n    const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);\n\n    const contextBarFields = [\n      defaultedFunction('predicate', never),\n      defaultedStringEnum('scope', 'node', [\n        'node',\n        'editor'\n      ]),\n      defaultedStringEnum('position', 'selection', [\n        'node',\n        'selection',\n        'line'\n      ])\n    ];\n\n    const contextButtonFields = baseToolbarButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);\n    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);\n    const toggleOrNormal = choose('type', {\n      contextformbutton: contextButtonFields,\n      contextformtogglebutton: contextToggleButtonFields\n    });\n    objOf([\n      defaultedType('contextform'),\n      defaultedFunction('initValue', constant('')),\n      optionalLabel,\n      requiredArrayOf('commands', toggleOrNormal),\n      optionOf('launch', choose('type', {\n        contextformbutton: launchButtonFields,\n        contextformtogglebutton: launchToggleButtonFields\n      }))\n    ].concat(contextBarFields));\n\n    const register$2 = editor => {\n      const popups = editor.ui.registry.getAll().popups;\n      const dataset = map$2(popups, popup => createAutocompleter(popup).fold(err => {\n        throw new Error(formatError(err));\n      }, identity));\n      const triggers = stringArray(mapToArray(dataset, v => v.trigger));\n      const datasetValues = values(dataset);\n      const lookupByTrigger = trigger => filter$5(datasetValues, dv => dv.trigger === trigger);\n      return {\n        dataset,\n        triggers,\n        lookupByTrigger\n      };\n    };\n\n    const setupEditorInput = (editor, api) => {\n      const update = last(api.load, 50);\n      editor.on('input', e => {\n        if (e.inputType === 'insertCompositionText' && !editor.composing) {\n          return;\n        }\n        update.throttle();\n      });\n      editor.on('keydown', e => {\n        const keyCode = e.which;\n        if (keyCode === 8) {\n          update.throttle();\n        } else if (keyCode === 27) {\n          update.cancel();\n          api.cancelIfNecessary();\n        } else if (keyCode === 38 || keyCode === 40) {\n          update.cancel();\n        }\n      }, true);\n      editor.on('remove', update.cancel);\n    };\n    const setup$k = editor => {\n      const activeAutocompleter = value$2();\n      const uiActive = Cell(false);\n      const isActive = activeAutocompleter.isSet;\n      const cancelIfNecessary = () => {\n        if (isActive()) {\n          fireAutocompleterEnd(editor);\n          uiActive.set(false);\n          activeAutocompleter.clear();\n        }\n      };\n      const commenceIfNecessary = context => {\n        if (!isActive()) {\n          activeAutocompleter.set({\n            trigger: context.trigger,\n            matchLength: context.text.length\n          });\n        }\n      };\n      const getAutocompleters = cached(() => register$2(editor));\n      const doLookup = fetchOptions => activeAutocompleter.get().map(ac => getContext(editor.dom, editor.selection.getRng(), ac.trigger, true).bind(newContext => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));\n      const load = fetchOptions => {\n        doLookup(fetchOptions).fold(cancelIfNecessary, lookupInfo => {\n          commenceIfNecessary(lookupInfo.context);\n          lookupInfo.lookupData.then(lookupData => {\n            activeAutocompleter.get().map(ac => {\n              const context = lookupInfo.context;\n              if (ac.trigger !== context.trigger) {\n                return;\n              }\n              activeAutocompleter.set({\n                ...ac,\n                matchLength: context.text.length\n              });\n              if (uiActive.get()) {\n                fireAutocompleterUpdateActiveRange(editor, { range: context.range });\n                fireAutocompleterUpdate(editor, { lookupData });\n              } else {\n                uiActive.set(true);\n                fireAutocompleterUpdateActiveRange(editor, { range: context.range });\n                fireAutocompleterStart(editor, { lookupData });\n              }\n            });\n          });\n        });\n      };\n      const isRangeInsideOrEqual = (innerRange, outerRange) => {\n        const startComparison = innerRange.compareBoundaryPoints(window.Range.START_TO_START, outerRange);\n        const endComparison = innerRange.compareBoundaryPoints(window.Range.END_TO_END, outerRange);\n        return startComparison >= 0 && endComparison <= 0;\n      };\n      const readActiveRange = () => {\n        return activeAutocompleter.get().bind(({trigger}) => {\n          const selRange = editor.selection.getRng();\n          return getContext(editor.dom, selRange, trigger, uiActive.get()).filter(({range}) => isRangeInsideOrEqual(selRange, range)).map(({range}) => range);\n        });\n      };\n      editor.addCommand('mceAutocompleterReload', (_ui, value) => {\n        const fetchOptions = isObject(value) ? value.fetchOptions : {};\n        load(fetchOptions);\n      });\n      editor.addCommand('mceAutocompleterClose', cancelIfNecessary);\n      editor.addCommand('mceAutocompleterRefreshActiveRange', () => {\n        readActiveRange().each(range => {\n          fireAutocompleterUpdateActiveRange(editor, { range });\n        });\n      });\n      editor.editorCommands.addQueryStateHandler('mceAutoCompleterInRange', () => readActiveRange().isSome());\n      setupEditorInput(editor, {\n        cancelIfNecessary,\n        load\n      });\n    };\n\n    const browser$1 = detect$1().browser;\n    const isSafari = browser$1.isSafari();\n    const emptyNodeContents = node => fillWithPaddingBr(SugarElement.fromDom(node));\n    const isEntireNodeSelected = (rng, node) => {\n      var _a;\n      return rng.startOffset === 0 && rng.endOffset === ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length);\n    };\n    const getParentDetailsElementAtPos = (dom, pos) => Optional.from(dom.getParent(pos.container(), 'details'));\n    const isInDetailsElement = (dom, pos) => getParentDetailsElementAtPos(dom, pos).isSome();\n    const getDetailsElements = (dom, rng) => {\n      const startDetails = Optional.from(dom.getParent(rng.startContainer, 'details'));\n      const endDetails = Optional.from(dom.getParent(rng.endContainer, 'details'));\n      if (startDetails.isSome() || endDetails.isSome()) {\n        const startSummary = startDetails.bind(details => Optional.from(dom.select('summary', details)[0]));\n        return Optional.some({\n          startSummary,\n          startDetails,\n          endDetails\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const isCaretInTheBeginningOf = (caretPos, element) => firstPositionIn(element).exists(pos => pos.isEqual(caretPos));\n    const isCaretInTheEndOf = (caretPos, element) => {\n      return lastPositionIn(element).exists(pos => {\n        if (isBr$6(pos.getNode())) {\n          return prevPosition(element, pos).exists(pos2 => pos2.isEqual(caretPos)) || pos.isEqual(caretPos);\n        } else {\n          return pos.isEqual(caretPos);\n        }\n      });\n    };\n    const isCaretAtStartOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheBeginningOf(caretPos, summary));\n    const isCaretAtEndOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheEndOf(caretPos, summary));\n    const isCaretInFirstPositionInBody = (caretPos, detailsElements) => detailsElements.startDetails.exists(details => prevPosition(details, caretPos).forall(pos => detailsElements.startSummary.exists(summary => !summary.contains(caretPos.container()) && summary.contains(pos.container()))));\n    const isCaretInLastPositionInBody = (root, caretPos, detailsElements) => detailsElements.startDetails.exists(details => nextPosition(root, caretPos).forall(pos => !details.contains(pos.container())));\n    const setCaretToPosition = (editor, position) => {\n      const node = position.getNode();\n      if (!isUndefined(node)) {\n        editor.selection.setCursorLocation(node, position.offset());\n      }\n    };\n    const moveCaretToDetailsPos = (editor, pos, forward) => {\n      const details = editor.dom.getParent(pos.container(), 'details');\n      if (details && !details.open) {\n        const summary = editor.dom.select('summary', details)[0];\n        if (summary) {\n          const newPos = forward ? firstPositionIn(summary) : lastPositionIn(summary);\n          newPos.each(pos => setCaretToPosition(editor, pos));\n        }\n      } else {\n        setCaretToPosition(editor, pos);\n      }\n    };\n    const isPartialDelete = (rng, detailsElements) => {\n      const containsStart = element => element.contains(rng.startContainer);\n      const containsEnd = element => element.contains(rng.endContainer);\n      const startInSummary = detailsElements.startSummary.exists(containsStart);\n      const endInSummary = detailsElements.startSummary.exists(containsEnd);\n      const isPartiallySelectedDetailsElements = detailsElements.startDetails.forall(startDetails => detailsElements.endDetails.forall(endDetails => startDetails !== endDetails));\n      const isInPartiallySelectedSummary = (startInSummary || endInSummary) && !(startInSummary && endInSummary);\n      return isInPartiallySelectedSummary || isPartiallySelectedDetailsElements;\n    };\n    const shouldPreventDeleteIntoDetails = (editor, forward, granularity) => {\n      const {dom, selection} = editor;\n      const root = editor.getBody();\n      if (granularity === 'character') {\n        const caretPos = CaretPosition.fromRangeStart(selection.getRng());\n        const parentBlock = dom.getParent(caretPos.container(), dom.isBlock);\n        const parentDetailsAtCaret = getParentDetailsElementAtPos(dom, caretPos);\n        const inEmptyParentBlock = parentBlock && dom.isEmpty(parentBlock);\n        const isFirstBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.previousSibling);\n        const isLastBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.nextSibling);\n        if (inEmptyParentBlock) {\n          const firstOrLast = forward ? isLastBlock : isFirstBlock;\n          if (firstOrLast) {\n            const isBeforeAfterDetails = navigate(!forward, root, caretPos).exists(pos => {\n              return isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, getParentDetailsElementAtPos(dom, pos));\n            });\n            if (isBeforeAfterDetails) {\n              return true;\n            }\n          }\n        }\n        return navigate(forward, root, caretPos).fold(never, pos => {\n          const parentDetailsAtNewPos = getParentDetailsElementAtPos(dom, pos);\n          if (isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, parentDetailsAtNewPos)) {\n            if (!forward) {\n              moveCaretToDetailsPos(editor, pos, false);\n            }\n            if (parentBlock && inEmptyParentBlock) {\n              if (forward && isFirstBlock) {\n                return true;\n              } else if (!forward && isLastBlock) {\n                return true;\n              }\n              moveCaretToDetailsPos(editor, pos, forward);\n              editor.dom.remove(parentBlock);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        });\n      } else {\n        return false;\n      }\n    };\n    const shouldPreventDeleteSummaryAction = (editor, detailElements, forward, granularity) => {\n      const selection = editor.selection;\n      const rng = selection.getRng();\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (granularity === 'selection') {\n        return isPartialDelete(rng, detailElements);\n      } else if (forward) {\n        return isCaretAtEndOfSummary(caretPos, detailElements) || isCaretInLastPositionInBody(root, caretPos, detailElements);\n      } else {\n        return isCaretAtStartOfSummary(caretPos, detailElements) || isCaretInFirstPositionInBody(caretPos, detailElements);\n      }\n    };\n    const shouldPreventDeleteAction = (editor, forward, granularity) => getDetailsElements(editor.dom, editor.selection.getRng()).fold(() => shouldPreventDeleteIntoDetails(editor, forward, granularity), detailsElements => shouldPreventDeleteSummaryAction(editor, detailsElements, forward, granularity) || shouldPreventDeleteIntoDetails(editor, forward, granularity));\n    const handleDeleteActionSafari = (editor, forward, granularity) => {\n      const selection = editor.selection;\n      const node = selection.getNode();\n      const rng = selection.getRng();\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      if (isSummary$1(node)) {\n        if (granularity === 'selection' && isEntireNodeSelected(rng, node) || willDeleteLastPositionInElement(forward, caretPos, node)) {\n          emptyNodeContents(node);\n        } else {\n          editor.undoManager.transact(() => {\n            const sel = selection.getSel();\n            let {anchorNode, anchorOffset, focusNode, focusOffset} = sel !== null && sel !== void 0 ? sel : {};\n            const applySelection = () => {\n              if (isNonNullable(anchorNode) && isNonNullable(anchorOffset) && isNonNullable(focusNode) && isNonNullable(focusOffset)) {\n                sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);\n              }\n            };\n            const updateSelection = () => {\n              anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n              anchorOffset = sel === null || sel === void 0 ? void 0 : sel.anchorOffset;\n              focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n              focusOffset = sel === null || sel === void 0 ? void 0 : sel.focusOffset;\n            };\n            const appendAllChildNodes = (from, to) => {\n              each$e(from.childNodes, child => {\n                if (isNode(child)) {\n                  to.appendChild(child);\n                }\n              });\n            };\n            const container = editor.dom.create('span', { 'data-mce-bogus': '1' });\n            appendAllChildNodes(node, container);\n            node.appendChild(container);\n            applySelection();\n            if (granularity === 'word' || granularity === 'line') {\n              sel === null || sel === void 0 ? void 0 : sel.modify('extend', forward ? 'right' : 'left', granularity);\n            }\n            if (!selection.isCollapsed() && isEntireNodeSelected(selection.getRng(), container)) {\n              emptyNodeContents(node);\n            } else {\n              editor.execCommand(forward ? 'ForwardDelete' : 'Delete');\n              updateSelection();\n              appendAllChildNodes(container, node);\n              applySelection();\n            }\n            editor.dom.remove(container);\n          });\n        }\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const backspaceDelete = (editor, forward, granularity) => shouldPreventDeleteAction(editor, forward, granularity) || isSafari && handleDeleteActionSafari(editor, forward, granularity) ? Optional.some(noop) : Optional.none();\n\n    const createAndFireInputEvent = eventType => (editor, inputType, specifics = {}) => {\n      const target = editor.getBody();\n      const overrides = {\n        bubbles: true,\n        composed: true,\n        data: null,\n        isComposing: false,\n        detail: 0,\n        view: null,\n        target,\n        currentTarget: target,\n        eventPhase: Event.AT_TARGET,\n        originalTarget: target,\n        explicitOriginalTarget: target,\n        isTrusted: false,\n        srcElement: target,\n        cancelable: false,\n        preventDefault: noop,\n        inputType\n      };\n      const input = clone$3(new InputEvent(eventType));\n      return editor.dispatch(eventType, {\n        ...input,\n        ...overrides,\n        ...specifics\n      });\n    };\n    const fireInputEvent = createAndFireInputEvent('input');\n    const fireBeforeInputEvent = createAndFireInputEvent('beforeinput');\n\n    const platform$2 = detect$1();\n    const os = platform$2.os;\n    const isMacOSOriOS = os.isMacOS() || os.isiOS();\n    const browser = platform$2.browser;\n    const isFirefox = browser.isFirefox();\n    const executeKeydownOverride$3 = (editor, caret, evt) => {\n      const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';\n      const isCollapsed = editor.selection.isCollapsed();\n      const unmodifiedGranularity = isCollapsed ? 'character' : 'selection';\n      const getModifiedGranularity = isWord => {\n        if (isCollapsed) {\n          return isWord ? 'word' : 'line';\n        } else {\n          return 'selection';\n        }\n      };\n      executeWithDelayedAction([\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$1, editor)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$7, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$7, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$8, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$8, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$4, editor, caret, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$4, editor, caret, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$b, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$b, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete, editor, false, unmodifiedGranularity)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete, editor, true, unmodifiedGranularity)\n        },\n        ...isMacOSOriOS ? [\n          {\n            keyCode: VK.BACKSPACE,\n            altKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.DELETE,\n            altKey: true,\n            action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.BACKSPACE,\n            metaKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(false))\n          }\n        ] : [\n          {\n            keyCode: VK.BACKSPACE,\n            ctrlKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.DELETE,\n            ctrlKey: true,\n            action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\n          }\n        ],\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$5, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$5, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$2, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$2, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$9, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$9, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$a, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$a, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$3, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$3, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$6, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$6, editor, true)\n        }\n      ], evt).filter(_ => editor.selection.isEditable()).each(applyAction => {\n        evt.preventDefault();\n        const beforeInput = fireBeforeInputEvent(editor, inputType);\n        if (!beforeInput.isDefaultPrevented()) {\n          applyAction();\n          fireInputEvent(editor, inputType);\n        }\n      });\n    };\n    const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => execute([\n      {\n        keyCode: VK.BACKSPACE,\n        action: action(paddEmptyElement, editor)\n      },\n      {\n        keyCode: VK.DELETE,\n        action: action(paddEmptyElement, editor)\n      },\n      ...isMacOSOriOS ? [\n        {\n          keyCode: VK.BACKSPACE,\n          altKey: true,\n          action: action(refreshCaret, editor)\n        },\n        {\n          keyCode: VK.DELETE,\n          altKey: true,\n          action: action(refreshCaret, editor)\n        },\n        ...isBackspaceKeydown ? [{\n            keyCode: isFirefox ? 224 : 91,\n            action: action(refreshCaret, editor)\n          }] : []\n      ] : [\n        {\n          keyCode: VK.BACKSPACE,\n          ctrlKey: true,\n          action: action(refreshCaret, editor)\n        },\n        {\n          keyCode: VK.DELETE,\n          ctrlKey: true,\n          action: action(refreshCaret, editor)\n        }\n      ]\n    ], evt);\n    const setup$j = (editor, caret) => {\n      let isBackspaceKeydown = false;\n      editor.on('keydown', evt => {\n        isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$3(editor, caret, evt);\n        }\n      });\n      editor.on('keyup', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeyupOverride(editor, evt, isBackspaceKeydown);\n        }\n        isBackspaceKeydown = false;\n      });\n    };\n\n    const firstNonWhiteSpaceNodeSibling = node => {\n      while (node) {\n        if (isElement$6(node) || isText$b(node) && node.data && /[\\r\\n\\s]/.test(node.data)) {\n          return node;\n        }\n        node = node.nextSibling;\n      }\n      return null;\n    };\n    const moveToCaretPosition = (editor, root) => {\n      const dom = editor.dom;\n      const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();\n      if (!root) {\n        return;\n      }\n      if (/^(LI|DT|DD)$/.test(root.nodeName)) {\n        const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);\n        if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {\n          root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);\n        }\n      }\n      const rng = dom.createRng();\n      root.normalize();\n      if (root.hasChildNodes()) {\n        const walker = new DomTreeWalker(root, root);\n        let lastNode = root;\n        let node;\n        while (node = walker.current()) {\n          if (isText$b(node)) {\n            rng.setStart(node, 0);\n            rng.setEnd(node, 0);\n            break;\n          }\n          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {\n            rng.setStartBefore(node);\n            rng.setEndBefore(node);\n            break;\n          }\n          lastNode = node;\n          node = walker.next();\n        }\n        if (!node) {\n          rng.setStart(lastNode, 0);\n          rng.setEnd(lastNode, 0);\n        }\n      } else {\n        if (isBr$6(root)) {\n          if (root.nextSibling && dom.isBlock(root.nextSibling)) {\n            rng.setStartBefore(root);\n            rng.setEndBefore(root);\n          } else {\n            rng.setStartAfter(root);\n            rng.setEndAfter(root);\n          }\n        } else {\n          rng.setStart(root, 0);\n          rng.setEnd(root, 0);\n        }\n      }\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n    };\n    const getEditableRoot = (dom, node) => {\n      const root = dom.getRoot();\n      let editableRoot;\n      let parent = node;\n      while (parent !== root && parent && dom.getContentEditable(parent) !== 'false') {\n        if (dom.getContentEditable(parent) === 'true') {\n          editableRoot = parent;\n          break;\n        }\n        parent = parent.parentNode;\n      }\n      return parent !== root ? editableRoot : root;\n    };\n    const getParentBlock$1 = editor => {\n      return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));\n    };\n    const getParentBlockName = editor => {\n      return getParentBlock$1(editor).fold(constant(''), parentBlock => {\n        return parentBlock.nodeName.toUpperCase();\n      });\n    };\n    const isListItemParentBlock = editor => {\n      return getParentBlock$1(editor).filter(elm => {\n        return isListItem$1(SugarElement.fromDom(elm));\n      }).isSome();\n    };\n    const emptyBlock = elm => {\n      elm.innerHTML = '<br data-mce-bogus=\"1\">';\n    };\n    const applyAttributes = (editor, node, forcedRootBlockAttrs) => {\n      const dom = editor.dom;\n      Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(attrStyles => {\n        const currentStyles = getAllRaw(SugarElement.fromDom(node));\n        const newStyles = {\n          ...currentStyles,\n          ...attrStyles\n        };\n        dom.setStyles(node, newStyles);\n      });\n      const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(attrClasses => attrClasses.split(/\\s+/));\n      const currentClassesOpt = Optional.from(node.className).map(currentClasses => filter$5(currentClasses.split(/\\s+/), clazz => clazz !== ''));\n      lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {\n        const filteredClasses = filter$5(currentClasses, clazz => !contains$2(attrClasses, clazz));\n        const newClasses = [\n          ...attrClasses,\n          ...filteredClasses\n        ];\n        dom.setAttrib(node, 'class', newClasses.join(' '));\n      });\n      const appliedAttrs = [\n        'style',\n        'class'\n      ];\n      const remainingAttrs = filter$4(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));\n      dom.setAttribs(node, remainingAttrs);\n    };\n    const setForcedBlockAttrs = (editor, node) => {\n      const forcedRootBlockName = getForcedRootBlock(editor);\n      if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {\n        const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);\n        applyAttributes(editor, node, forcedRootBlockAttrs);\n      }\n    };\n    const createNewBlock = (editor, container, parentBlock, editableRoot, keepStyles = true, name, styles) => {\n      const dom = editor.dom;\n      const schema = editor.schema;\n      const newBlockName = getForcedRootBlock(editor);\n      const parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n      let node = container;\n      const textInlineElements = schema.getTextInlineElements();\n      let block;\n      if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {\n        block = dom.create(name || newBlockName, styles || {});\n      } else {\n        block = parentBlock.cloneNode(false);\n      }\n      let caretNode = block;\n      if (!keepStyles) {\n        dom.setAttrib(block, 'style', null);\n        dom.setAttrib(block, 'class', null);\n      } else {\n        do {\n          if (textInlineElements[node.nodeName]) {\n            if (isCaretNode(node) || isBookmarkNode$1(node)) {\n              continue;\n            }\n            const clonedNode = node.cloneNode(false);\n            dom.setAttrib(clonedNode, 'id', '');\n            if (block.hasChildNodes()) {\n              clonedNode.appendChild(block.firstChild);\n              block.appendChild(clonedNode);\n            } else {\n              caretNode = clonedNode;\n              block.appendChild(clonedNode);\n            }\n          }\n        } while ((node = node.parentNode) && node !== editableRoot);\n      }\n      setForcedBlockAttrs(editor, block);\n      emptyBlock(caretNode);\n      return block;\n    };\n\n    const getDetailsRoot = (editor, element) => editor.dom.getParent(element, isDetails);\n    const isAtDetailsEdge = (root, element, isTextBlock) => {\n      let node = element;\n      while (node && node !== root && isNull(node.nextSibling)) {\n        const parent = node.parentElement;\n        if (!parent || !isTextBlock(parent)) {\n          return isDetails(parent);\n        }\n        node = parent;\n      }\n      return false;\n    };\n    const isLastEmptyBlockInDetails = (editor, shiftKey, element) => !shiftKey && element.nodeName.toLowerCase() === getForcedRootBlock(editor) && editor.dom.isEmpty(element) && isAtDetailsEdge(editor.getBody(), element, el => has$2(editor.schema.getTextBlockElements(), el.nodeName.toLowerCase()));\n    const insertNewLine = (editor, createNewBlock, parentBlock) => {\n      var _a, _b, _c;\n      const newBlock = createNewBlock(getForcedRootBlock(editor));\n      const root = getDetailsRoot(editor, parentBlock);\n      if (!root) {\n        return;\n      }\n      editor.dom.insertAfter(newBlock, root);\n      moveToCaretPosition(editor, newBlock);\n      if (((_c = (_b = (_a = parentBlock.parentElement) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 1) {\n        editor.dom.remove(parentBlock);\n      }\n    };\n\n    const hasFirstChild = (elm, name) => {\n      return elm.firstChild && elm.firstChild.nodeName === name;\n    };\n    const isFirstChild = elm => {\n      var _a;\n      return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;\n    };\n    const hasParent = (elm, parentName) => {\n      const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;\n      return isNonNullable(parentNode) && parentNode.nodeName === parentName;\n    };\n    const isListBlock = elm => {\n      return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);\n    };\n    const isListItem = elm => {\n      return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);\n    };\n    const isNestedList = elm => {\n      return isListBlock(elm) && isListBlock(elm.parentNode);\n    };\n    const getContainerBlock = containerBlock => {\n      const containerBlockParent = containerBlock.parentNode;\n      return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;\n    };\n    const isFirstOrLastLi = (containerBlock, parentBlock, first) => {\n      let node = containerBlock[first ? 'firstChild' : 'lastChild'];\n      while (node) {\n        if (isElement$6(node)) {\n          break;\n        }\n        node = node[first ? 'nextSibling' : 'previousSibling'];\n      }\n      return node === parentBlock;\n    };\n    const getStyles = elm => foldl(mapToArray(getAllRaw(SugarElement.fromDom(elm)), (style, styleName) => `${ styleName }: ${ style };`), (acc, s) => acc + s, '');\n    const insert$4 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      const containerParent = containerBlock.parentNode;\n      if (containerBlock === editor.getBody() || !containerParent) {\n        return;\n      }\n      if (isNestedList(containerBlock)) {\n        newBlockName = 'LI';\n      }\n      const parentBlockStyles = isListItem(parentBlock) ? getStyles(parentBlock) : undefined;\n      let newBlock = isListItem(parentBlock) && parentBlockStyles ? createNewBlock(newBlockName, { style: getStyles(parentBlock) }) : createNewBlock(newBlockName);\n      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {\n        if (hasParent(containerBlock, 'LI')) {\n          const containerBlockParent = getContainerBlock(containerBlock);\n          dom.insertAfter(newBlock, containerBlockParent);\n          if (isFirstChild(containerBlock)) {\n            dom.remove(containerBlockParent);\n          } else {\n            dom.remove(containerBlock);\n          }\n        } else {\n          dom.replace(newBlock, containerBlock);\n        }\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {\n        if (hasParent(containerBlock, 'LI')) {\n          dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n          newBlock.appendChild(dom.doc.createTextNode(' '));\n          newBlock.appendChild(containerBlock);\n        } else {\n          containerParent.insertBefore(newBlock, containerBlock);\n        }\n        dom.remove(parentBlock);\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {\n        dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n        dom.remove(parentBlock);\n      } else {\n        containerBlock = getContainerBlock(containerBlock);\n        const tmpRng = rng.cloneRange();\n        tmpRng.setStartAfter(parentBlock);\n        tmpRng.setEndAfter(containerBlock);\n        const fragment = tmpRng.extractContents();\n        if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {\n          const previousChildren = filter$5(map$3(newBlock.children, SugarElement.fromDom), not(isTag('br')));\n          newBlock = fragment.firstChild;\n          dom.insertAfter(fragment, containerBlock);\n          each$e(previousChildren, child => prepend(SugarElement.fromDom(newBlock), child));\n          if (parentBlockStyles) {\n            newBlock.setAttribute('style', parentBlockStyles);\n          }\n        } else {\n          dom.insertAfter(fragment, containerBlock);\n          dom.insertAfter(newBlock, containerBlock);\n        }\n        dom.remove(parentBlock);\n      }\n      moveToCaretPosition(editor, newBlock);\n    };\n\n    const trimZwsp = fragment => {\n      each$e(descendants$1(SugarElement.fromDom(fragment), isText$c), text => {\n        const rawNode = text.dom;\n        rawNode.nodeValue = trim$2(rawNode.data);\n      });\n    };\n    const isWithinNonEditableList = (editor, node) => {\n      const parentList = editor.dom.getParent(node, 'ol,ul,dl');\n      return parentList !== null && editor.dom.getContentEditableParent(parentList) === 'false';\n    };\n    const isEmptyAnchor = (dom, elm) => {\n      return elm && elm.nodeName === 'A' && dom.isEmpty(elm);\n    };\n    const containerAndSiblingName = (container, nodeName) => {\n      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;\n    };\n    const canSplitBlock = (dom, node) => {\n      return isNonNullable(node) && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.isEditable(node.parentNode) && dom.getContentEditable(node) !== 'false';\n    };\n    const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {\n      var _a;\n      const firstChilds = [];\n      if (!block) {\n        return;\n      }\n      let currentNode = block;\n      while (currentNode = currentNode.firstChild) {\n        if (dom.isBlock(currentNode)) {\n          return;\n        }\n        if (isElement$6(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) {\n          firstChilds.push(currentNode);\n        }\n      }\n      let i = firstChilds.length;\n      while (i--) {\n        currentNode = firstChilds[i];\n        if (!currentNode.hasChildNodes() || currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === '') {\n          dom.remove(currentNode);\n        } else {\n          if (isEmptyAnchor(dom, currentNode)) {\n            dom.remove(currentNode);\n          }\n        }\n      }\n    };\n    const normalizeZwspOffset = (start, container, offset) => {\n      if (!isText$b(container)) {\n        return offset;\n      } else if (start) {\n        return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;\n      } else {\n        return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;\n      }\n    };\n    const includeZwspInRange = rng => {\n      const newRng = rng.cloneRange();\n      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));\n      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));\n      return newRng;\n    };\n    const trimLeadingLineBreaks = node => {\n      let currentNode = node;\n      do {\n        if (isText$b(currentNode)) {\n          currentNode.data = currentNode.data.replace(/^[\\r\\n]+/, '');\n        }\n        currentNode = currentNode.firstChild;\n      } while (currentNode);\n    };\n    const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {\n      var _a, _b;\n      const dom = editor.dom;\n      const editableRoot = (_a = getEditableRoot(dom, container)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      let parentBlock = dom.getParent(container, dom.isBlock);\n      if (!parentBlock || !canSplitBlock(dom, parentBlock)) {\n        parentBlock = parentBlock || editableRoot;\n        if (!parentBlock.hasChildNodes()) {\n          const newBlock = dom.create(newBlockName);\n          setForcedBlockAttrs(editor, newBlock);\n          parentBlock.appendChild(newBlock);\n          rng.setStart(newBlock, 0);\n          rng.setEnd(newBlock, 0);\n          return newBlock;\n        }\n        let node = container;\n        while (node && node.parentNode !== parentBlock) {\n          node = node.parentNode;\n        }\n        let startNode;\n        while (node && !dom.isBlock(node)) {\n          startNode = node;\n          node = node.previousSibling;\n        }\n        const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;\n        if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {\n          const startNodeParent = startNode.parentNode;\n          const newBlock = dom.create(newBlockName);\n          setForcedBlockAttrs(editor, newBlock);\n          startNodeParent.insertBefore(newBlock, startNode);\n          node = startNode;\n          while (node && !dom.isBlock(node)) {\n            const next = node.nextSibling;\n            newBlock.appendChild(node);\n            node = next;\n          }\n          rng.setStart(container, offset);\n          rng.setEnd(container, offset);\n        }\n      }\n      return container;\n    };\n    const addBrToBlockIfNeeded = (dom, block) => {\n      block.normalize();\n      const lastChild = block.lastChild;\n      if (!lastChild || isElement$6(lastChild) && /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {\n        dom.add(block, 'br');\n      }\n    };\n    const shouldEndContainer = (editor, container) => {\n      const optionValue = shouldEndContainerOnEmptyBlock(editor);\n      if (isNullable(container)) {\n        return false;\n      } else if (isString(optionValue)) {\n        return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());\n      } else {\n        return optionValue;\n      }\n    };\n    const insert$3 = (editor, evt) => {\n      let container;\n      let offset;\n      let parentBlockName;\n      let containerBlock;\n      let isAfterLastNodeInContainer = false;\n      const dom = editor.dom;\n      const schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();\n      const rng = editor.selection.getRng();\n      const newBlockName = getForcedRootBlock(editor);\n      const start = SugarElement.fromDom(rng.startContainer);\n      const child = child$1(start, rng.startOffset);\n      const isCef = child.exists(element => isHTMLElement$1(element) && !isEditable$2(element));\n      const collapsedAndCef = rng.collapsed && isCef;\n      const createNewBlock$1 = (name, styles) => {\n        return createNewBlock(editor, container, parentBlock, editableRoot, shouldKeepStyles(editor), name, styles);\n      };\n      const isCaretAtStartOrEndOfBlock = start => {\n        const normalizedOffset = normalizeZwspOffset(start, container, offset);\n        if (isText$b(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.data.length)) {\n          return false;\n        }\n        if ((container.parentNode === parentBlock || container === parentBlock) && isAfterLastNodeInContainer && !start) {\n          return true;\n        }\n        if (start && isElement$6(container) && container === parentBlock.firstChild) {\n          return true;\n        }\n        if (containerAndSiblingName(container, 'TABLE') || containerAndSiblingName(container, 'HR')) {\n          return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;\n        }\n        const walker = new DomTreeWalker(container, parentBlock);\n        if (isText$b(container)) {\n          if (start && normalizedOffset === 0) {\n            walker.prev();\n          } else if (!start && normalizedOffset === container.data.length) {\n            walker.next();\n          }\n        }\n        let node;\n        while (node = walker.current()) {\n          if (isElement$6(node)) {\n            if (!node.getAttribute('data-mce-bogus')) {\n              const name = node.nodeName.toLowerCase();\n              if (nonEmptyElementsMap[name] && name !== 'br') {\n                return false;\n              }\n            }\n          } else if (isText$b(node) && !isWhitespaceText(node.data)) {\n            return false;\n          }\n          if (start) {\n            walker.prev();\n          } else {\n            walker.next();\n          }\n        }\n        return true;\n      };\n      const insertNewBlockAfter = () => {\n        let block;\n        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {\n          block = createNewBlock$1(newBlockName);\n        } else {\n          block = createNewBlock$1();\n        }\n        if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock, undefined, { includeZwsp: true })) {\n          block = dom.split(containerBlock, parentBlock);\n        } else {\n          dom.insertAfter(block, parentBlock);\n        }\n        moveToCaretPosition(editor, block);\n        return block;\n      };\n      normalize$2(dom, rng).each(normRng => {\n        rng.setStart(normRng.startContainer, normRng.startOffset);\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\n      });\n      container = rng.startContainer;\n      offset = rng.startOffset;\n      const shiftKey = !!(evt && evt.shiftKey);\n      const ctrlKey = !!(evt && evt.ctrlKey);\n      if (isElement$6(container) && container.hasChildNodes() && !collapsedAndCef) {\n        isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        if (isAfterLastNodeInContainer && isText$b(container)) {\n          offset = container.data.length;\n        } else {\n          offset = 0;\n        }\n      }\n      const editableRoot = getEditableRoot(dom, container);\n      if (!editableRoot || isWithinNonEditableList(editor, container)) {\n        return;\n      }\n      if (!shiftKey) {\n        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);\n      }\n      let parentBlock = dom.getParent(container, dom.isBlock) || dom.getRoot();\n      containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n      if (containerBlockName === 'LI' && !ctrlKey) {\n        const liBlock = containerBlock;\n        parentBlock = liBlock;\n        containerBlock = liBlock.parentNode;\n        parentBlockName = containerBlockName;\n      }\n      if (isElement$6(containerBlock) && isLastEmptyBlockInDetails(editor, shiftKey, parentBlock)) {\n        return insertNewLine(editor, createNewBlock$1, parentBlock);\n      }\n      if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {\n        if (dom.isEmpty(parentBlock)) {\n          insert$4(editor, createNewBlock$1, containerBlock, parentBlock, newBlockName);\n          return;\n        }\n      }\n      if (!collapsedAndCef && (parentBlock === editor.getBody() || !canSplitBlock(dom, parentBlock))) {\n        return;\n      }\n      const parentBlockParent = parentBlock.parentNode;\n      let newBlock;\n      if (collapsedAndCef) {\n        newBlock = createNewBlock$1(newBlockName);\n        child.fold(() => {\n          append$1(start, SugarElement.fromDom(newBlock));\n        }, child => {\n          before$3(child, SugarElement.fromDom(newBlock));\n        });\n        editor.selection.setCursorLocation(newBlock, 0);\n      } else if (isCaretContainerBlock$1(parentBlock)) {\n        newBlock = showCaretContainerBlock(parentBlock);\n        if (dom.isEmpty(parentBlock)) {\n          emptyBlock(parentBlock);\n        }\n        setForcedBlockAttrs(editor, newBlock);\n        moveToCaretPosition(editor, newBlock);\n      } else if (isCaretAtStartOrEndOfBlock(false)) {\n        newBlock = insertNewBlockAfter();\n      } else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {\n        const caretPos = CaretPosition.fromRangeStart(rng);\n        const afterTable = isAfterTable(caretPos);\n        const parentBlockSugar = SugarElement.fromDom(parentBlock);\n        const afterBr = isAfterBr(parentBlockSugar, caretPos, editor.schema);\n        const prevBrOpt = afterBr ? findPreviousBr(parentBlockSugar, caretPos, editor.schema).bind(pos => Optional.from(pos.getNode())) : Optional.none();\n        newBlock = parentBlockParent.insertBefore(createNewBlock$1(), parentBlock);\n        const root = containerAndSiblingName(parentBlock, 'HR') || afterTable ? newBlock : prevBrOpt.getOr(parentBlock);\n        moveToCaretPosition(editor, root);\n      } else {\n        const tmpRng = includeZwspInRange(rng).cloneRange();\n        tmpRng.setEndAfter(parentBlock);\n        const fragment = tmpRng.extractContents();\n        trimZwsp(fragment);\n        trimLeadingLineBreaks(fragment);\n        newBlock = fragment.firstChild;\n        dom.insertAfter(fragment, parentBlock);\n        trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);\n        addBrToBlockIfNeeded(dom, parentBlock);\n        if (dom.isEmpty(parentBlock)) {\n          emptyBlock(parentBlock);\n        }\n        newBlock.normalize();\n        if (dom.isEmpty(newBlock)) {\n          dom.remove(newBlock);\n          insertNewBlockAfter();\n        } else {\n          setForcedBlockAttrs(editor, newBlock);\n          moveToCaretPosition(editor, newBlock);\n        }\n      }\n      dom.setAttrib(newBlock, 'id', '');\n      editor.dispatch('NewBlock', { newBlock });\n    };\n    const fakeEventName$1 = 'insertParagraph';\n    const blockbreak = {\n      insert: insert$3,\n      fakeEventName: fakeEventName$1\n    };\n\n    const hasRightSideContent = (schema, container, parentBlock) => {\n      const walker = new DomTreeWalker(container, parentBlock);\n      let node;\n      const nonEmptyElementsMap = schema.getNonEmptyElements();\n      while (node = walker.next()) {\n        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$b(node) && node.length > 0) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const moveSelectionToBr = (editor, brElm, extraBr) => {\n      const rng = editor.dom.createRng();\n      if (!extraBr) {\n        rng.setStartAfter(brElm);\n        rng.setEndAfter(brElm);\n      } else {\n        rng.setStartBefore(brElm);\n        rng.setEndBefore(brElm);\n      }\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n    };\n    const insertBrAtCaret = (editor, evt) => {\n      const selection = editor.selection;\n      const dom = editor.dom;\n      const rng = selection.getRng();\n      let brElm;\n      let extraBr = false;\n      normalize$2(dom, rng).each(normRng => {\n        rng.setStart(normRng.startContainer, normRng.startOffset);\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\n      });\n      let offset = rng.startOffset;\n      let container = rng.startContainer;\n      if (isElement$6(container) && container.hasChildNodes()) {\n        const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        if (isAfterLastNodeInContainer && isText$b(container)) {\n          offset = container.data.length;\n        } else {\n          offset = 0;\n        }\n      }\n      let parentBlock = dom.getParent(container, dom.isBlock);\n      const containerBlock = parentBlock && parentBlock.parentNode ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n      const isControlKey = !!(evt && evt.ctrlKey);\n      if (containerBlockName === 'LI' && !isControlKey) {\n        parentBlock = containerBlock;\n      }\n      if (isText$b(container) && offset >= container.data.length) {\n        if (!hasRightSideContent(editor.schema, container, parentBlock || dom.getRoot())) {\n          brElm = dom.create('br');\n          rng.insertNode(brElm);\n          rng.setStartAfter(brElm);\n          rng.setEndAfter(brElm);\n          extraBr = true;\n        }\n      }\n      brElm = dom.create('br');\n      rangeInsertNode(dom, rng, brElm);\n      moveSelectionToBr(editor, brElm, extraBr);\n      editor.undoManager.add();\n    };\n    const insertBrBefore = (editor, inline) => {\n      const br = SugarElement.fromTag('br');\n      before$3(SugarElement.fromDom(inline), br);\n      editor.undoManager.add();\n    };\n    const insertBrAfter = (editor, inline) => {\n      if (!hasBrAfter(editor.getBody(), inline)) {\n        after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));\n      }\n      const br = SugarElement.fromTag('br');\n      after$4(SugarElement.fromDom(inline), br);\n      moveSelectionToBr(editor, br.dom, false);\n      editor.undoManager.add();\n    };\n    const isBeforeBr = pos => {\n      return isBr$6(pos.getNode());\n    };\n    const hasBrAfter = (rootNode, startNode) => {\n      if (isBeforeBr(CaretPosition.after(startNode))) {\n        return true;\n      } else {\n        return nextPosition(rootNode, CaretPosition.after(startNode)).map(pos => {\n          return isBr$6(pos.getNode());\n        }).getOr(false);\n      }\n    };\n    const isAnchorLink = elm => {\n      return elm && elm.nodeName === 'A' && 'href' in elm;\n    };\n    const isInsideAnchor = location => {\n      return location.fold(never, isAnchorLink, isAnchorLink, never);\n    };\n    const readInlineAnchorLocation = editor => {\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const position = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);\n    };\n    const insertBrOutsideAnchor = (editor, location) => {\n      location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);\n    };\n    const insert$2 = (editor, evt) => {\n      const anchorLocation = readInlineAnchorLocation(editor);\n      if (anchorLocation.isSome()) {\n        anchorLocation.each(curry(insertBrOutsideAnchor, editor));\n      } else {\n        insertBrAtCaret(editor, evt);\n      }\n    };\n    const fakeEventName = 'insertLineBreak';\n    const linebreak = {\n      insert: insert$2,\n      fakeEventName\n    };\n\n    const matchesSelector = (editor, selector) => {\n      return getParentBlock$1(editor).filter(parentBlock => {\n        return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);\n      }).isSome();\n    };\n    const shouldInsertBr = editor => {\n      return matchesSelector(editor, getBrNewLineSelector(editor));\n    };\n    const shouldBlockNewLine$1 = editor => {\n      return matchesSelector(editor, getNoNewLineSelector(editor));\n    };\n\n    const newLineAction = Adt.generate([\n      { br: [] },\n      { block: [] },\n      { none: [] }\n    ]);\n    const shouldBlockNewLine = (editor, _shiftKey) => {\n      return shouldBlockNewLine$1(editor);\n    };\n    const inListBlock = requiredState => {\n      return (editor, _shiftKey) => {\n        return isListItemParentBlock(editor) === requiredState;\n      };\n    };\n    const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {\n      const state = getParentBlockName(editor) === blockName.toUpperCase();\n      return state === requiredState;\n    };\n    const inCefBlock = editor => {\n      const editableRoot = getEditableRoot(editor.dom, editor.selection.getStart());\n      return isNullable(editableRoot);\n    };\n    const inPreBlock = requiredState => inBlock('pre', requiredState);\n    const inSummaryBlock = () => inBlock('summary', true);\n    const shouldPutBrInPre = requiredState => {\n      return (editor, _shiftKey) => {\n        return shouldPutBrInPre$1(editor) === requiredState;\n      };\n    };\n    const inBrContext = (editor, _shiftKey) => {\n      return shouldInsertBr(editor);\n    };\n    const hasShiftKey = (_editor, shiftKey) => {\n      return shiftKey;\n    };\n    const canInsertIntoEditableRoot = editor => {\n      const forcedRootBlock = getForcedRootBlock(editor);\n      const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());\n      return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);\n    };\n    const isInRootWithEmptyOrCEF = editor => {\n      const rng = editor.selection.getRng();\n      const start = SugarElement.fromDom(rng.startContainer);\n      const child = child$1(start, rng.startOffset);\n      const isCefOpt = child.map(element => isHTMLElement$1(element) && !isEditable$2(element));\n      return rng.collapsed && isCefOpt.getOr(true);\n    };\n    const match = (predicates, action) => {\n      return (editor, shiftKey) => {\n        const isMatch = foldl(predicates, (res, p) => {\n          return res && p(editor, shiftKey);\n        }, true);\n        return isMatch ? Optional.some(action) : Optional.none();\n      };\n    };\n    const getAction = (editor, evt) => {\n      return evaluateUntil([\n        match([shouldBlockNewLine], newLineAction.none()),\n        match([\n          inPreBlock(true),\n          inCefBlock\n        ], newLineAction.none()),\n        match([inSummaryBlock()], newLineAction.br()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(false),\n          hasShiftKey\n        ], newLineAction.br()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(false)\n        ], newLineAction.block()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(true),\n          hasShiftKey\n        ], newLineAction.block()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(true)\n        ], newLineAction.br()),\n        match([\n          inListBlock(true),\n          hasShiftKey\n        ], newLineAction.br()),\n        match([inListBlock(true)], newLineAction.block()),\n        match([inBrContext], newLineAction.br()),\n        match([hasShiftKey], newLineAction.br()),\n        match([canInsertIntoEditableRoot], newLineAction.block()),\n        match([isInRootWithEmptyOrCEF], newLineAction.block())\n      ], [\n        editor,\n        !!(evt && evt.shiftKey)\n      ]).getOr(newLineAction.none());\n    };\n\n    const insertBreak = (breakType, editor, evt) => {\n      if (!editor.selection.isCollapsed()) {\n        execEditorDeleteCommand(editor);\n      }\n      if (isNonNullable(evt)) {\n        const event = fireBeforeInputEvent(editor, breakType.fakeEventName);\n        if (event.isDefaultPrevented()) {\n          return;\n        }\n      }\n      breakType.insert(editor, evt);\n      if (isNonNullable(evt)) {\n        fireInputEvent(editor, breakType.fakeEventName);\n      }\n    };\n    const insert$1 = (editor, evt) => {\n      const br = () => insertBreak(linebreak, editor, evt);\n      const block = () => insertBreak(blockbreak, editor, evt);\n      const logicalAction = getAction(editor, evt);\n      switch (getNewlineBehavior(editor)) {\n      case 'linebreak':\n        logicalAction.fold(br, br, noop);\n        break;\n      case 'block':\n        logicalAction.fold(block, block, noop);\n        break;\n      case 'invert':\n        logicalAction.fold(block, br, noop);\n        break;\n      default:\n        logicalAction.fold(br, block, noop);\n        break;\n      }\n    };\n\n    const platform$1 = detect$1();\n    const isIOSSafari = platform$1.os.isiOS() && platform$1.browser.isSafari();\n    const handleEnterKeyEvent = (editor, event) => {\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n      event.preventDefault();\n      endTypingLevelIgnoreLocks(editor.undoManager);\n      editor.undoManager.transact(() => {\n        insert$1(editor, event);\n      });\n    };\n    const isCaretAfterKoreanCharacter = rng => {\n      if (!rng.collapsed) {\n        return false;\n      }\n      const startContainer = rng.startContainer;\n      if (isText$b(startContainer)) {\n        const koreanCharRegex = /^[\\uAC00-\\uD7AF\\u1100-\\u11FF\\u3130-\\u318F\\uA960-\\uA97F\\uD7B0-\\uD7FF]$/;\n        const char = startContainer.data.charAt(rng.startOffset - 1);\n        return koreanCharRegex.test(char);\n      } else {\n        return false;\n      }\n    };\n    const setup$i = editor => {\n      let iOSSafariKeydownBookmark = Optional.none();\n      const iOSSafariKeydownOverride = editor => {\n        iOSSafariKeydownBookmark = Optional.some(editor.selection.getBookmark());\n        editor.undoManager.add();\n      };\n      const iOSSafariKeyupOverride = (editor, event) => {\n        editor.undoManager.undo();\n        iOSSafariKeydownBookmark.fold(noop, b => editor.selection.moveToBookmark(b));\n        handleEnterKeyEvent(editor, event);\n        iOSSafariKeydownBookmark = Optional.none();\n      };\n      editor.on('keydown', event => {\n        if (event.keyCode === VK.ENTER) {\n          if (isIOSSafari && isCaretAfterKoreanCharacter(editor.selection.getRng())) {\n            iOSSafariKeydownOverride(editor);\n          } else {\n            handleEnterKeyEvent(editor, event);\n          }\n        }\n      });\n      editor.on('keyup', event => {\n        if (event.keyCode === VK.ENTER) {\n          iOSSafariKeydownBookmark.each(() => iOSSafariKeyupOverride(editor, event));\n        }\n      });\n    };\n\n    const executeKeydownOverride$2 = (editor, caret, evt) => {\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      execute([\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint$1, editor, true)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint$1, editor, false)\n        },\n        ...!isMac ? [\n          {\n            keyCode: VK.HOME,\n            action: action(selectToEndPoint, editor, false),\n            ctrlKey: true,\n            shiftKey: true\n          },\n          {\n            keyCode: VK.END,\n            action: action(selectToEndPoint, editor, true),\n            ctrlKey: true,\n            shiftKey: true\n          }\n        ] : [],\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint, editor, true)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint, editor, false)\n        },\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint$2, editor, true, caret)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint$2, editor, false, caret)\n        }\n      ], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$h = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$2(editor, caret, evt);\n        }\n      });\n    };\n\n    const setup$g = editor => {\n      editor.on('input', e => {\n        if (!e.isComposing) {\n          normalizeNbspsInEditor(editor);\n        }\n      });\n    };\n\n    const platform = detect$1();\n    const executeKeyupAction = (editor, caret, evt) => {\n      execute([\n        {\n          keyCode: VK.PAGE_UP,\n          action: action(moveToLineEndPoint$2, editor, false, caret)\n        },\n        {\n          keyCode: VK.PAGE_DOWN,\n          action: action(moveToLineEndPoint$2, editor, true, caret)\n        }\n      ], evt);\n    };\n    const stopImmediatePropagation = e => e.stopImmediatePropagation();\n    const isPageUpDown = evt => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;\n    const setNodeChangeBlocker = (blocked, editor, block) => {\n      if (block && !blocked.get()) {\n        editor.on('NodeChange', stopImmediatePropagation, true);\n      } else if (!block && blocked.get()) {\n        editor.off('NodeChange', stopImmediatePropagation);\n      }\n      blocked.set(block);\n    };\n    const setup$f = (editor, caret) => {\n      if (platform.os.isMacOS()) {\n        return;\n      }\n      const blocked = Cell(false);\n      editor.on('keydown', evt => {\n        if (isPageUpDown(evt)) {\n          setNodeChangeBlocker(blocked, editor, true);\n        }\n      });\n      editor.on('keyup', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeyupAction(editor, caret, evt);\n        }\n        if (isPageUpDown(evt) && blocked.get()) {\n          setNodeChangeBlocker(blocked, editor, false);\n          editor.nodeChanged();\n        }\n      });\n    };\n\n    const setup$e = editor => {\n      editor.on('beforeinput', e => {\n        if (!editor.selection.isEditable() || exists(e.getTargetRanges(), rng => !isEditableRange(editor.dom, rng))) {\n          e.preventDefault();\n        }\n      });\n    };\n\n    const insertTextAtPosition = (text, pos) => {\n      const container = pos.container();\n      const offset = pos.offset();\n      if (isText$b(container)) {\n        container.insertData(offset, text);\n        return Optional.some(CaretPosition(container, offset + text.length));\n      } else {\n        return getElementFromPosition(pos).map(elm => {\n          const textNode = SugarElement.fromText(text);\n          if (pos.isAtEnd()) {\n            after$4(elm, textNode);\n          } else {\n            before$3(elm, textNode);\n          }\n          return CaretPosition(textNode.dom, text.length);\n        });\n      }\n    };\n    const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);\n    const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');\n\n    const insertSpaceOrNbspAtPosition = (root, pos, schema) => needsToHaveNbsp(root, pos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n    const locationToCaretPosition = root => location => location.fold(element => prevPosition(root.dom, CaretPosition.before(element)), element => firstPositionIn(element), element => lastPositionIn(element), element => nextPosition(root.dom, CaretPosition.after(element)));\n    const insertInlineBoundarySpaceOrNbsp = (root, pos, schema) => checkPos => needsToHaveNbsp(root, checkPos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n    const setSelection = editor => pos => {\n      editor.selection.setRng(pos.toRange());\n      editor.nodeChanged();\n    };\n    const isInsideSummary = (domUtils, node) => domUtils.isEditable(domUtils.getParent(node, 'summary'));\n    const insertSpaceOrNbspAtSelection = editor => {\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      const root = SugarElement.fromDom(editor.getBody());\n      if (editor.selection.isCollapsed()) {\n        const isInlineTarget$1 = curry(isInlineTarget, editor);\n        const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());\n        return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map(checkPos => () => insertInlineBoundarySpaceOrNbsp(root, pos, editor.schema)(checkPos).each(setSelection(editor)));\n      } else {\n        return Optional.none();\n      }\n    };\n    const insertSpaceInSummaryAtSelectionOnFirefox = editor => {\n      const insertSpaceThunk = () => {\n        const root = SugarElement.fromDom(editor.getBody());\n        if (!editor.selection.isCollapsed()) {\n          editor.getDoc().execCommand('Delete');\n        }\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        insertSpaceOrNbspAtPosition(root, pos, editor.schema).each(setSelection(editor));\n      };\n      return someIf(Env.browser.isFirefox() && editor.selection.isEditable() && isInsideSummary(editor.dom, editor.selection.getRng().startContainer), insertSpaceThunk);\n    };\n\n    const executeKeydownOverride$1 = (editor, evt) => {\n      executeWithDelayedAction([\n        {\n          keyCode: VK.SPACEBAR,\n          action: action(insertSpaceOrNbspAtSelection, editor)\n        },\n        {\n          keyCode: VK.SPACEBAR,\n          action: action(insertSpaceInSummaryAtSelectionOnFirefox, editor)\n        }\n      ], evt).each(applyAction => {\n        evt.preventDefault();\n        const event = fireBeforeInputEvent(editor, 'insertText', { data: ' ' });\n        if (!event.isDefaultPrevented()) {\n          applyAction();\n          fireInputEvent(editor, 'insertText', { data: ' ' });\n        }\n      });\n    };\n    const setup$d = editor => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$1(editor, evt);\n        }\n      });\n    };\n\n    const tableTabNavigation = editor => {\n      if (hasTableTabNavigation(editor)) {\n        return [\n          {\n            keyCode: VK.TAB,\n            action: action(handleTab, editor, true)\n          },\n          {\n            keyCode: VK.TAB,\n            shiftKey: true,\n            action: action(handleTab, editor, false)\n          }\n        ];\n      } else {\n        return [];\n      }\n    };\n    const executeKeydownOverride = (editor, evt) => {\n      execute([...tableTabNavigation(editor)], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$c = editor => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride(editor, evt);\n        }\n      });\n    };\n\n    const setup$b = editor => {\n      editor.addShortcut('Meta+P', '', 'mcePrint');\n      setup$k(editor);\n      if (isRtc(editor)) {\n        return Cell(null);\n      } else {\n        const caret = setupSelectedState(editor);\n        setup$e(editor);\n        setup$m(editor);\n        setup$l(editor, caret);\n        setup$j(editor, caret);\n        setup$i(editor);\n        setup$d(editor);\n        setup$g(editor);\n        setup$c(editor);\n        setup$h(editor, caret);\n        setup$f(editor, caret);\n        return caret;\n      }\n    };\n\n    class NodeChange {\n      constructor(editor) {\n        this.lastPath = [];\n        this.editor = editor;\n        let lastRng;\n        const self = this;\n        if (!('onselectionchange' in editor.getDoc())) {\n          editor.on('NodeChange click mouseup keyup focus', e => {\n            const nativeRng = editor.selection.getRng();\n            const fakeRng = {\n              startContainer: nativeRng.startContainer,\n              startOffset: nativeRng.startOffset,\n              endContainer: nativeRng.endContainer,\n              endOffset: nativeRng.endOffset\n            };\n            if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {\n              editor.dispatch('SelectionChange');\n            }\n            lastRng = fakeRng;\n          });\n        }\n        editor.on('contextmenu', () => {\n          store(editor);\n          editor.dispatch('SelectionChange');\n        });\n        editor.on('SelectionChange', () => {\n          const startElm = editor.selection.getStart(true);\n          if (!startElm) {\n            return;\n          }\n          if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {\n            editor.nodeChanged({ selectionChange: true });\n          }\n        });\n        editor.on('mouseup', e => {\n          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {\n            if (editor.selection.getNode().nodeName === 'IMG') {\n              Delay.setEditorTimeout(editor, () => {\n                editor.nodeChanged();\n              });\n            } else {\n              editor.nodeChanged();\n            }\n          }\n        });\n      }\n      nodeChanged(args = {}) {\n        const selection = this.editor.selection;\n        let node;\n        if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {\n          const root = this.editor.getBody();\n          node = selection.getStart(true) || root;\n          if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {\n            node = root;\n          }\n          const parents = [];\n          this.editor.dom.getParent(node, node => {\n            if (node === root) {\n              return true;\n            } else {\n              parents.push(node);\n              return false;\n            }\n          });\n          this.editor.dispatch('NodeChange', {\n            ...args,\n            element: node,\n            parents\n          });\n        }\n      }\n      isSameElementPath(startElm) {\n        let i;\n        const editor = this.editor;\n        const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));\n        if (currentPath.length === this.lastPath.length) {\n          for (i = currentPath.length; i >= 0; i--) {\n            if (currentPath[i] !== this.lastPath[i]) {\n              break;\n            }\n          }\n          if (i === -1) {\n            this.lastPath = currentPath;\n            return true;\n          }\n        }\n        this.lastPath = currentPath;\n        return false;\n      }\n    }\n\n    const imageId = generate$1('image');\n    const getDragImage = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[imageId]);\n    };\n    const setDragImage = (transfer, imageData) => {\n      const dt = transfer;\n      dt[imageId] = imageData;\n    };\n\n    const eventId = generate$1('event');\n    const getEvent = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[eventId]);\n    };\n    const mkSetEventFn = type => transfer => {\n      const dt = transfer;\n      dt[eventId] = type;\n    };\n    const setEvent = (transfer, type) => mkSetEventFn(type)(transfer);\n    const setDragstartEvent = mkSetEventFn(0);\n    const setDropEvent = mkSetEventFn(2);\n    const setDragendEvent = mkSetEventFn(1);\n    const checkEvent = expectedType => transfer => {\n      const dt = transfer;\n      return Optional.from(dt[eventId]).exists(type => type === expectedType);\n    };\n    const isInDragStartEvent = checkEvent(0);\n\n    const createEmptyFileList = () => Object.freeze({\n      length: 0,\n      item: _ => null\n    });\n\n    const modeId = generate$1('mode');\n    const getMode = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[modeId]);\n    };\n    const mkSetModeFn = mode => transfer => {\n      const dt = transfer;\n      dt[modeId] = mode;\n    };\n    const setMode$1 = (transfer, mode) => mkSetModeFn(mode)(transfer);\n    const setReadWriteMode = mkSetModeFn(0);\n    const setReadOnlyMode = mkSetModeFn(2);\n    const setProtectedMode = mkSetModeFn(1);\n    const checkMode = expectedMode => transfer => {\n      const dt = transfer;\n      return Optional.from(dt[modeId]).exists(mode => mode === expectedMode);\n    };\n    const isInReadWriteMode = checkMode(0);\n    const isInProtectedMode = checkMode(1);\n\n    const normalizeItems = (dataTransfer, itemsImpl) => ({\n      ...itemsImpl,\n      get length() {\n        return itemsImpl.length;\n      },\n      add: (data, type) => {\n        if (isInReadWriteMode(dataTransfer)) {\n          if (isString(data)) {\n            if (!isUndefined(type)) {\n              return itemsImpl.add(data, type);\n            }\n          } else {\n            return itemsImpl.add(data);\n          }\n        }\n        return null;\n      },\n      remove: idx => {\n        if (isInReadWriteMode(dataTransfer)) {\n          itemsImpl.remove(idx);\n        }\n      },\n      clear: () => {\n        if (isInReadWriteMode(dataTransfer)) {\n          itemsImpl.clear();\n        }\n      }\n    });\n\n    const validDropEffects = [\n      'none',\n      'copy',\n      'link',\n      'move'\n    ];\n    const validEffectAlloweds = [\n      'none',\n      'copy',\n      'copyLink',\n      'copyMove',\n      'link',\n      'linkMove',\n      'move',\n      'all',\n      'uninitialized'\n    ];\n    const createDataTransfer = () => {\n      const dataTransferImpl = new window.DataTransfer();\n      let dropEffect = 'move';\n      let effectAllowed = 'all';\n      const dataTransfer = {\n        get dropEffect() {\n          return dropEffect;\n        },\n        set dropEffect(effect) {\n          if (contains$2(validDropEffects, effect)) {\n            dropEffect = effect;\n          }\n        },\n        get effectAllowed() {\n          return effectAllowed;\n        },\n        set effectAllowed(allowed) {\n          if (isInDragStartEvent(dataTransfer) && contains$2(validEffectAlloweds, allowed)) {\n            effectAllowed = allowed;\n          }\n        },\n        get items() {\n          return normalizeItems(dataTransfer, dataTransferImpl.items);\n        },\n        get files() {\n          if (isInProtectedMode(dataTransfer)) {\n            return createEmptyFileList();\n          } else {\n            return dataTransferImpl.files;\n          }\n        },\n        get types() {\n          return dataTransferImpl.types;\n        },\n        setDragImage: (image, x, y) => {\n          if (isInReadWriteMode(dataTransfer)) {\n            setDragImage(dataTransfer, {\n              image,\n              x,\n              y\n            });\n            dataTransferImpl.setDragImage(image, x, y);\n          }\n        },\n        getData: format => {\n          if (isInProtectedMode(dataTransfer)) {\n            return '';\n          } else {\n            return dataTransferImpl.getData(format);\n          }\n        },\n        setData: (format, data) => {\n          if (isInReadWriteMode(dataTransfer)) {\n            dataTransferImpl.setData(format, data);\n          }\n        },\n        clearData: format => {\n          if (isInReadWriteMode(dataTransfer)) {\n            dataTransferImpl.clearData(format);\n          }\n        }\n      };\n      setReadWriteMode(dataTransfer);\n      return dataTransfer;\n    };\n    const cloneDataTransfer = original => {\n      const clone = createDataTransfer();\n      const originalMode = getMode(original);\n      setReadOnlyMode(original);\n      setDragstartEvent(clone);\n      clone.dropEffect = original.dropEffect;\n      clone.effectAllowed = original.effectAllowed;\n      getDragImage(original).each(imageData => clone.setDragImage(imageData.image, imageData.x, imageData.y));\n      each$e(original.types, type => {\n        if (type !== 'Files') {\n          clone.setData(type, original.getData(type));\n        }\n      });\n      each$e(original.files, file => clone.items.add(file));\n      getEvent(original).each(type => {\n        setEvent(clone, type);\n      });\n      originalMode.each(mode => {\n        setMode$1(original, mode);\n        setMode$1(clone, mode);\n      });\n      return clone;\n    };\n\n    const getHtmlData = dataTransfer => {\n      const html = dataTransfer.getData('text/html');\n      return html === '' ? Optional.none() : Optional.some(html);\n    };\n    const setHtmlData = (dataTransfer, html) => dataTransfer.setData('text/html', html);\n\n    const internalMimeType = 'x-tinymce/html';\n    const internalHtmlMime = constant(internalMimeType);\n    const internalMark = '<!-- ' + internalMimeType + ' -->';\n    const mark = html => internalMark + html;\n    const unmark = html => html.replace(internalMark, '');\n    const isMarked = html => html.indexOf(internalMark) !== -1;\n\n    const isPlainText = text => {\n      return !/<(?:\\/?(?!(?:div|p|br|span)>)\\w+|(?:(?!(?:span style=\"white-space:\\s?pre;?\">)|br\\s?\\/>))\\w+\\s[^>]+)>/i.test(text);\n    };\n    const openContainer = (rootTag, rootAttrs) => {\n      let tag = '<' + rootTag;\n      const attrs = mapToArray(rootAttrs, (value, key) => key + '=\"' + Entities.encodeAllRaw(value) + '\"');\n      if (attrs.length) {\n        tag += ' ' + attrs.join(' ');\n      }\n      return tag + '>';\n    };\n    const toBlockElements = (text, rootTag, rootAttrs) => {\n      const blocks = text.split(/\\n\\n/);\n      const tagOpen = openContainer(rootTag, rootAttrs);\n      const tagClose = '</' + rootTag + '>';\n      const paragraphs = map$3(blocks, p => {\n        return p.split(/\\n/).join('<br />');\n      });\n      const stitch = p => {\n        return tagOpen + p + tagClose;\n      };\n      return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');\n    };\n\n    const pasteBinDefaultContent = '%MCEPASTEBIN%';\n    const create$6 = (editor, lastRngCell) => {\n      const {dom, selection} = editor;\n      const body = editor.getBody();\n      lastRngCell.set(selection.getRng());\n      const pasteBinElm = dom.add(editor.getBody(), 'div', {\n        'id': 'mcepastebin',\n        'class': 'mce-pastebin',\n        'contentEditable': true,\n        'data-mce-bogus': 'all',\n        'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'\n      }, pasteBinDefaultContent);\n      if (Env.browser.isFirefox()) {\n        dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 65535 : -65535);\n      }\n      dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', e => {\n        e.stopPropagation();\n      });\n      pasteBinElm.focus();\n      selection.select(pasteBinElm, true);\n    };\n    const remove = (editor, lastRngCell) => {\n      const dom = editor.dom;\n      if (getEl(editor)) {\n        let pasteBinClone;\n        const lastRng = lastRngCell.get();\n        while (pasteBinClone = getEl(editor)) {\n          dom.remove(pasteBinClone);\n          dom.unbind(pasteBinClone);\n        }\n        if (lastRng) {\n          editor.selection.setRng(lastRng);\n        }\n      }\n      lastRngCell.set(null);\n    };\n    const getEl = editor => editor.dom.get('mcepastebin');\n    const isPasteBin = elm => isNonNullable(elm) && elm.id === 'mcepastebin';\n    const getHtml = editor => {\n      const dom = editor.dom;\n      const copyAndRemove = (toElm, fromElm) => {\n        toElm.appendChild(fromElm);\n        dom.remove(fromElm, true);\n      };\n      const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);\n      each$e(pasteBinClones, pasteBinClone => {\n        copyAndRemove(pasteBinElm, pasteBinClone);\n      });\n      const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);\n      for (let i = dirtyWrappers.length - 1; i >= 0; i--) {\n        const cleanWrapper = dom.create('div');\n        pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);\n        copyAndRemove(cleanWrapper, dirtyWrappers[i]);\n      }\n      return pasteBinElm ? pasteBinElm.innerHTML : '';\n    };\n    const isDefaultPasteBinContent = content => content === pasteBinDefaultContent;\n    const PasteBin = editor => {\n      const lastRng = Cell(null);\n      return {\n        create: () => create$6(editor, lastRng),\n        remove: () => remove(editor, lastRng),\n        getEl: () => getEl(editor),\n        getHtml: () => getHtml(editor),\n        getLastRng: lastRng.get\n      };\n    };\n\n    const filter$1 = (content, items) => {\n      Tools.each(items, v => {\n        if (is$4(v, RegExp)) {\n          content = content.replace(v, '');\n        } else {\n          content = content.replace(v[0], v[1]);\n        }\n      });\n      return content;\n    };\n    const innerText = html => {\n      const schema = Schema();\n      const domParser = DomParser({}, schema);\n      let text = '';\n      const voidElements = schema.getVoidElements();\n      const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');\n      const blockElements = schema.getBlockElements();\n      const walk = node => {\n        const name = node.name, currentNode = node;\n        if (name === 'br') {\n          text += '\\n';\n          return;\n        }\n        if (name === 'wbr') {\n          return;\n        }\n        if (voidElements[name]) {\n          text += ' ';\n        }\n        if (ignoreElements[name]) {\n          text += ' ';\n          return;\n        }\n        if (node.type === 3) {\n          text += node.value;\n        }\n        if (!(node.name in schema.getVoidElements())) {\n          let currentNode = node.firstChild;\n          if (currentNode) {\n            do {\n              walk(currentNode);\n            } while (currentNode = currentNode.next);\n          }\n        }\n        if (blockElements[name] && currentNode.next) {\n          text += '\\n';\n          if (name === 'p') {\n            text += '\\n';\n          }\n        }\n      };\n      html = filter$1(html, [/<!\\[[^\\]]+\\]>/g]);\n      walk(domParser.parse(html));\n      return text;\n    };\n    const trimHtml = html => {\n      const trimSpaces = (all, s1, s2) => {\n        if (!s1 && !s2) {\n          return ' ';\n        }\n        return nbsp;\n      };\n      html = filter$1(html, [\n        /^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/ig,\n        /<!--StartFragment-->|<!--EndFragment-->/g,\n        [\n          /( ?)<span class=\"Apple-converted-space\">\\u00a0<\\/span>( ?)/g,\n          trimSpaces\n        ],\n        /<br class=\"Apple-interchange-newline\">/g,\n        /<br>$/i\n      ]);\n      return html;\n    };\n    const createIdGenerator = prefix => {\n      let count = 0;\n      return () => {\n        return prefix + count++;\n      };\n    };\n    const getImageMimeType = ext => {\n      const lowerExt = ext.toLowerCase();\n      const mimeOverrides = {\n        jpg: 'jpeg',\n        jpe: 'jpeg',\n        jfi: 'jpeg',\n        jif: 'jpeg',\n        jfif: 'jpeg',\n        pjpeg: 'jpeg',\n        pjp: 'jpeg',\n        svg: 'svg+xml'\n      };\n      return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;\n    };\n\n    const preProcess = (editor, html) => {\n      const parser = DomParser({\n        sanitize: shouldSanitizeXss(editor),\n        sandbox_iframes: shouldSandboxIframes(editor),\n        sandbox_iframes_exclusions: getSandboxIframesExclusions(editor),\n        convert_unsafe_embeds: shouldConvertUnsafeEmbeds(editor)\n      }, editor.schema);\n      parser.addNodeFilter('meta', nodes => {\n        Tools.each(nodes, node => {\n          node.remove();\n        });\n      });\n      const fragment = parser.parse(html, {\n        forced_root_block: false,\n        isRootContent: true\n      });\n      return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);\n    };\n    const processResult = (content, cancelled) => ({\n      content,\n      cancelled\n    });\n    const postProcessFilter = (editor, html, internal) => {\n      const tempBody = editor.dom.create('div', { style: 'display:none' }, html);\n      const postProcessArgs = firePastePostProcess(editor, tempBody, internal);\n      return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());\n    };\n    const filterContent = (editor, content, internal) => {\n      const preProcessArgs = firePastePreProcess(editor, content, internal);\n      const filteredContent = preProcess(editor, preProcessArgs.content);\n      if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {\n        return postProcessFilter(editor, filteredContent, internal);\n      } else {\n        return processResult(filteredContent, preProcessArgs.isDefaultPrevented());\n      }\n    };\n    const process = (editor, html, internal) => {\n      return filterContent(editor, html, internal);\n    };\n\n    const pasteHtml$1 = (editor, html) => {\n      editor.insertContent(html, {\n        merge: shouldPasteMergeFormats(editor),\n        paste: true\n      });\n      return true;\n    };\n    const isAbsoluteUrl = url => /^https?:\\/\\/[\\w\\-\\/+=.,!;:&%@^~(){}?#]+$/i.test(url);\n    const isImageUrl = (editor, url) => {\n      return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), type => endsWith(url.toLowerCase(), `.${ type.toLowerCase() }`));\n    };\n    const createImage = (editor, url, pasteHtmlFn) => {\n      editor.undoManager.extra(() => {\n        pasteHtmlFn(editor, url);\n      }, () => {\n        editor.insertContent('<img src=\"' + url + '\">');\n      });\n      return true;\n    };\n    const createLink = (editor, url, pasteHtmlFn) => {\n      editor.undoManager.extra(() => {\n        pasteHtmlFn(editor, url);\n      }, () => {\n        editor.execCommand('mceInsertLink', false, url);\n      });\n      return true;\n    };\n    const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;\n    const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;\n    const smartInsertContent = (editor, html) => {\n      Tools.each([\n        linkSelection,\n        insertImage,\n        pasteHtml$1\n      ], action => {\n        return !action(editor, html, pasteHtml$1);\n      });\n    };\n    const insertContent = (editor, html, pasteAsText) => {\n      if (pasteAsText || !isSmartPasteEnabled(editor)) {\n        pasteHtml$1(editor, html);\n      } else {\n        smartInsertContent(editor, html);\n      }\n    };\n\n    const uniqueId = createIdGenerator('mceclip');\n    const createPasteDataTransfer = html => {\n      const dataTransfer = createDataTransfer();\n      setHtmlData(dataTransfer, html);\n      setReadOnlyMode(dataTransfer);\n      return dataTransfer;\n    };\n    const doPaste = (editor, content, internal, pasteAsText, shouldSimulateInputEvent) => {\n      const res = process(editor, content, internal);\n      if (!res.cancelled) {\n        const content = res.content;\n        const doPasteAction = () => insertContent(editor, content, pasteAsText);\n        if (shouldSimulateInputEvent) {\n          const args = fireBeforeInputEvent(editor, 'insertFromPaste', { dataTransfer: createPasteDataTransfer(content) });\n          if (!args.isDefaultPrevented()) {\n            doPasteAction();\n            fireInputEvent(editor, 'insertFromPaste');\n          }\n        } else {\n          doPasteAction();\n        }\n      }\n    };\n    const pasteHtml = (editor, html, internalFlag, shouldSimulateInputEvent) => {\n      const internal = internalFlag ? internalFlag : isMarked(html);\n      doPaste(editor, unmark(html), internal, false, shouldSimulateInputEvent);\n    };\n    const pasteText = (editor, text, shouldSimulateInputEvent) => {\n      const encodedText = editor.dom.encode(text).replace(/\\r\\n/g, '\\n');\n      const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));\n      const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n      doPaste(editor, html, false, true, shouldSimulateInputEvent);\n    };\n    const getDataTransferItems = dataTransfer => {\n      const items = {};\n      if (dataTransfer && dataTransfer.types) {\n        for (let i = 0; i < dataTransfer.types.length; i++) {\n          const contentType = dataTransfer.types[i];\n          try {\n            items[contentType] = dataTransfer.getData(contentType);\n          } catch (ex) {\n            items[contentType] = '';\n          }\n        }\n      }\n      return items;\n    };\n    const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;\n    const hasHtmlOrText = content => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');\n    const extractFilename = (editor, str) => {\n      const m = str.match(/([\\s\\S]+?)(?:\\.[a-z0-9.]+)$/i);\n      return isNonNullable(m) ? editor.dom.encode(m[1]) : undefined;\n    };\n    const createBlobInfo = (editor, blobCache, file, base64) => {\n      const id = uniqueId();\n      const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);\n      const name = useFileName ? extractFilename(editor, file.name) : id;\n      const filename = useFileName ? file.name : undefined;\n      const blobInfo = blobCache.create(id, file, base64, name, filename);\n      blobCache.add(blobInfo);\n      return blobInfo;\n    };\n    const pasteImage = (editor, imageItem) => {\n      parseDataUri(imageItem.uri).each(({data, type, base64Encoded}) => {\n        const base64 = base64Encoded ? data : btoa(data);\n        const file = imageItem.file;\n        const blobCache = editor.editorUpload.blobCache;\n        const existingBlobInfo = blobCache.getByData(base64, type);\n        const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);\n        pasteHtml(editor, `<img src=\"${ blobInfo.blobUri() }\">`, false, true);\n      });\n    };\n    const isClipboardEvent = event => event.type === 'paste';\n    const readFilesAsDataUris = items => Promise.all(map$3(items, file => {\n      return blobToDataUri(file).then(uri => ({\n        file,\n        uri\n      }));\n    }));\n    const isImage = editor => {\n      const allowedExtensions = getAllowedImageFileTypes(editor);\n      return file => startsWith(file.type, 'image/') && exists(allowedExtensions, extension => {\n        return getImageMimeType(extension) === file.type;\n      });\n    };\n    const getImagesFromDataTransfer = (editor, dataTransfer) => {\n      const items = dataTransfer.items ? bind$3(from(dataTransfer.items), item => {\n        return item.kind === 'file' ? [item.getAsFile()] : [];\n      }) : [];\n      const files = dataTransfer.files ? from(dataTransfer.files) : [];\n      return filter$5(items.length > 0 ? items : files, isImage(editor));\n    };\n    const pasteImageData = (editor, e, rng) => {\n      const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;\n      if (shouldPasteDataImages(editor) && dataTransfer) {\n        const images = getImagesFromDataTransfer(editor, dataTransfer);\n        if (images.length > 0) {\n          e.preventDefault();\n          readFilesAsDataUris(images).then(fileResults => {\n            if (rng) {\n              editor.selection.setRng(rng);\n            }\n            each$e(fileResults, result => {\n              pasteImage(editor, result);\n            });\n          });\n          return true;\n        }\n      }\n      return false;\n    };\n    const isBrokenAndroidClipboardEvent = e => {\n      var _a, _b;\n      return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;\n    };\n    const isKeyboardPasteEvent = e => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;\n    const insertClipboardContent = (editor, clipboardContent, html, plainTextMode, shouldSimulateInputEvent) => {\n      let content = trimHtml(html);\n      const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);\n      const isPlainTextHtml = !isInternal && isPlainText(content);\n      const isAbsoluteUrl$1 = isAbsoluteUrl(content);\n      if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {\n        plainTextMode = true;\n      }\n      if (plainTextMode || isAbsoluteUrl$1) {\n        if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {\n          content = clipboardContent['text/plain'];\n        } else {\n          content = innerText(content);\n        }\n      }\n      if (isDefaultPasteBinContent(content)) {\n        return;\n      }\n      if (plainTextMode) {\n        pasteText(editor, content, shouldSimulateInputEvent);\n      } else {\n        pasteHtml(editor, content, isInternal, shouldSimulateInputEvent);\n      }\n    };\n    const registerEventHandlers = (editor, pasteBin, pasteFormat) => {\n      let keyboardPastePlainTextState;\n      const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();\n      editor.on('keydown', e => {\n        if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {\n          keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;\n        }\n      });\n      editor.on('paste', e => {\n        if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {\n          return;\n        }\n        const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;\n        keyboardPastePlainTextState = false;\n        const clipboardContent = getDataTransferItems(e.clipboardData);\n        if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {\n          return;\n        }\n        if (hasContentType(clipboardContent, 'text/html')) {\n          e.preventDefault();\n          insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode, true);\n        } else if (hasContentType(clipboardContent, 'text/plain') && hasContentType(clipboardContent, 'text/uri-list')) {\n          e.preventDefault();\n          insertClipboardContent(editor, clipboardContent, clipboardContent['text/plain'], plainTextMode, true);\n        } else {\n          pasteBin.create();\n          Delay.setEditorTimeout(editor, () => {\n            const html = pasteBin.getHtml();\n            pasteBin.remove();\n            insertClipboardContent(editor, clipboardContent, html, plainTextMode, false);\n          }, 0);\n        }\n      });\n    };\n    const registerDataImageFilter = editor => {\n      const isWebKitFakeUrl = src => startsWith(src, 'webkit-fake-url');\n      const isDataUri = src => startsWith(src, 'data:');\n      const isPasteInsert = args => {\n        var _a;\n        return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;\n      };\n      editor.parser.addNodeFilter('img', (nodes, name, args) => {\n        if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {\n          for (const node of nodes) {\n            const src = node.attr('src');\n            if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {\n              if (isWebKitFakeUrl(src)) {\n                node.remove();\n              } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {\n                node.remove();\n              }\n            }\n          }\n        }\n      });\n    };\n    const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {\n      registerEventHandlers(editor, pasteBin, pasteFormat);\n      registerDataImageFilter(editor);\n    };\n\n    const togglePlainTextPaste = (editor, pasteFormat) => {\n      if (pasteFormat.get() === 'text') {\n        pasteFormat.set('html');\n        firePastePlainTextToggle(editor, false);\n      } else {\n        pasteFormat.set('text');\n        firePastePlainTextToggle(editor, true);\n      }\n      editor.focus();\n    };\n    const register$1 = (editor, pasteFormat) => {\n      editor.addCommand('mceTogglePlainTextPaste', () => {\n        togglePlainTextPaste(editor, pasteFormat);\n      });\n      editor.addCommand('mceInsertClipboardContent', (ui, value) => {\n        if (value.html) {\n          pasteHtml(editor, value.html, value.internal, false);\n        }\n        if (value.text) {\n          pasteText(editor, value.text, false);\n        }\n      });\n    };\n\n    const setHtml5Clipboard = (clipboardData, html, text) => {\n      if (clipboardData) {\n        try {\n          clipboardData.clearData();\n          clipboardData.setData('text/html', html);\n          clipboardData.setData('text/plain', text);\n          clipboardData.setData(internalHtmlMime(), html);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    };\n    const setClipboardData = (evt, data, fallback, done) => {\n      if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {\n        evt.preventDefault();\n        done();\n      } else {\n        fallback(data.html, done);\n      }\n    };\n    const fallback = editor => (html, done) => {\n      const {dom, selection} = editor;\n      const outer = dom.create('div', {\n        'contenteditable': 'false',\n        'data-mce-bogus': 'all'\n      });\n      const inner = dom.create('div', { contenteditable: 'true' }, html);\n      dom.setStyles(outer, {\n        position: 'fixed',\n        top: '0',\n        left: '-3000px',\n        width: '1000px',\n        overflow: 'hidden'\n      });\n      outer.appendChild(inner);\n      dom.add(editor.getBody(), outer);\n      const range = selection.getRng();\n      inner.focus();\n      const offscreenRange = dom.createRng();\n      offscreenRange.selectNodeContents(inner);\n      selection.setRng(offscreenRange);\n      Delay.setEditorTimeout(editor, () => {\n        selection.setRng(range);\n        dom.remove(outer);\n        done();\n      }, 0);\n    };\n    const getData = editor => ({\n      html: mark(editor.selection.getContent({ contextual: true })),\n      text: editor.selection.getContent({ format: 'text' })\n    });\n    const isTableSelection = editor => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());\n    const hasSelectedContent = editor => !editor.selection.isCollapsed() || isTableSelection(editor);\n    const cut = editor => evt => {\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor) && editor.selection.isEditable()) {\n        setClipboardData(evt, getData(editor), fallback(editor), () => {\n          if (Env.browser.isChromium() || Env.browser.isFirefox()) {\n            const rng = editor.selection.getRng();\n            Delay.setEditorTimeout(editor, () => {\n              editor.selection.setRng(rng);\n              editor.execCommand('Delete');\n            }, 0);\n          } else {\n            editor.execCommand('Delete');\n          }\n        });\n      }\n    };\n    const copy = editor => evt => {\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {\n        setClipboardData(evt, getData(editor), fallback(editor), noop);\n      }\n    };\n    const register = editor => {\n      editor.on('cut', cut(editor));\n      editor.on('copy', copy(editor));\n    };\n\n    const getCaretRangeFromEvent = (editor, e) => {\n      var _a, _b;\n      return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());\n    };\n    const isPlainTextFileUrl = content => {\n      const plainTextContent = content['text/plain'];\n      return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;\n    };\n    const setFocusedRange = (editor, rng) => {\n      editor.focus();\n      if (rng) {\n        editor.selection.setRng(rng);\n      }\n    };\n    const hasImage = dataTransfer => exists(dataTransfer.files, file => /^image\\//.test(file.type));\n    const needsCustomInternalDrop = (dom, schema, target, dropContent) => {\n      const parentTransparent = dom.getParent(target, node => isTransparentBlock(schema, node));\n      const inSummary = !isNull(dom.getParent(target, 'summary'));\n      if (inSummary) {\n        return true;\n      } else if (parentTransparent && has$2(dropContent, 'text/html')) {\n        const fragment = new DOMParser().parseFromString(dropContent['text/html'], 'text/html').body;\n        return !isNull(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));\n      } else {\n        return false;\n      }\n    };\n    const setupSummaryDeleteByDragFix = editor => {\n      editor.on('input', e => {\n        const hasNoSummary = el => isNull(el.querySelector('summary'));\n        if (e.inputType === 'deleteByDrag') {\n          const brokenDetailElements = filter$5(editor.dom.select('details'), hasNoSummary);\n          each$e(brokenDetailElements, details => {\n            if (isBr$6(details.firstChild)) {\n              details.firstChild.remove();\n            }\n            const summary = editor.dom.create('summary');\n            summary.appendChild(createPaddingBr().dom);\n            details.prepend(summary);\n          });\n        }\n      });\n    };\n    const setup$a = (editor, draggingInternallyState) => {\n      if (shouldPasteBlockDrop(editor)) {\n        editor.on('dragend dragover draggesture dragdrop drop drag', e => {\n          e.preventDefault();\n          e.stopPropagation();\n        });\n      }\n      if (!shouldPasteDataImages(editor)) {\n        editor.on('drop', e => {\n          const dataTransfer = e.dataTransfer;\n          if (dataTransfer && hasImage(dataTransfer)) {\n            e.preventDefault();\n          }\n        });\n      }\n      editor.on('drop', e => {\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        const rng = getCaretRangeFromEvent(editor, e);\n        if (isNullable(rng)) {\n          return;\n        }\n        const dropContent = getDataTransferItems(e.dataTransfer);\n        const internal = hasContentType(dropContent, internalHtmlMime());\n        if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {\n          return;\n        }\n        const internalContent = dropContent[internalHtmlMime()];\n        const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];\n        const needsInternalDrop = needsCustomInternalDrop(editor.dom, editor.schema, rng.startContainer, dropContent);\n        const isInternalDrop = draggingInternallyState.get();\n        if (isInternalDrop && !needsInternalDrop) {\n          return;\n        }\n        if (content) {\n          e.preventDefault();\n          Delay.setEditorTimeout(editor, () => {\n            editor.undoManager.transact(() => {\n              if (internalContent || isInternalDrop && needsInternalDrop) {\n                editor.execCommand('Delete');\n              }\n              setFocusedRange(editor, rng);\n              const trimmedContent = trimHtml(content);\n              if (dropContent['text/html']) {\n                pasteHtml(editor, trimmedContent, internal, true);\n              } else {\n                pasteText(editor, trimmedContent, true);\n              }\n            });\n          });\n        }\n      });\n      editor.on('dragstart', _e => {\n        draggingInternallyState.set(true);\n      });\n      editor.on('dragover dragend', e => {\n        if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {\n          e.preventDefault();\n          setFocusedRange(editor, getCaretRangeFromEvent(editor, e));\n        }\n        if (e.type === 'dragend') {\n          draggingInternallyState.set(false);\n        }\n      });\n      setupSummaryDeleteByDragFix(editor);\n    };\n\n    const setup$9 = editor => {\n      const processEvent = f => e => {\n        f(editor, e);\n      };\n      const preProcess = getPastePreProcess(editor);\n      if (isFunction(preProcess)) {\n        editor.on('PastePreProcess', processEvent(preProcess));\n      }\n      const postProcess = getPastePostProcess(editor);\n      if (isFunction(postProcess)) {\n        editor.on('PastePostProcess', processEvent(postProcess));\n      }\n    };\n\n    const addPreProcessFilter = (editor, filterFunc) => {\n      editor.on('PastePreProcess', e => {\n        e.content = filterFunc(editor, e.content, e.internal);\n      });\n    };\n    const rgbRegExp = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/gi;\n    const rgbToHex = value => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();\n    const removeWebKitStyles = (editor, content, internal) => {\n      const webKitStylesOption = getPasteWebkitStyles(editor);\n      if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {\n        return content;\n      }\n      const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];\n      if (webKitStyles && webKitStylesOption !== 'none') {\n        const dom = editor.dom, node = editor.selection.getNode();\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, (all, before, value, after) => {\n          const inputStyles = dom.parseStyle(dom.decode(value));\n          const outputStyles = {};\n          for (let i = 0; i < webKitStyles.length; i++) {\n            const inputValue = inputStyles[webKitStyles[i]];\n            let compareInput = inputValue;\n            let currentValue = dom.getStyle(node, webKitStyles[i], true);\n            if (/color/.test(webKitStyles[i])) {\n              compareInput = rgbToHex(compareInput);\n              currentValue = rgbToHex(currentValue);\n            }\n            if (currentValue !== compareInput) {\n              outputStyles[webKitStyles[i]] = inputValue;\n            }\n          }\n          const outputStyle = dom.serializeStyle(outputStyles, 'span');\n          if (outputStyle) {\n            return before + ' style=\"' + outputStyle + '\"' + after;\n          }\n          return before + after;\n        });\n      } else {\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, '$1$3');\n      }\n      content = content.replace(/(<[^>]+) data-mce-style=\"([^\"]+)\"([^>]*>)/gi, (all, before, value, after) => {\n        return before + ' style=\"' + value + '\"' + after;\n      });\n      return content;\n    };\n    const setup$8 = editor => {\n      if (Env.browser.isChromium() || Env.browser.isSafari()) {\n        addPreProcessFilter(editor, removeWebKitStyles);\n      }\n    };\n\n    const setup$7 = editor => {\n      const draggingInternallyState = Cell(false);\n      const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');\n      const pasteBin = PasteBin(editor);\n      setup$8(editor);\n      register$1(editor, pasteFormat);\n      setup$9(editor);\n      editor.addQueryStateHandler('mceTogglePlainTextPaste', () => pasteFormat.get() === 'text');\n      editor.on('PreInit', () => {\n        register(editor);\n        setup$a(editor, draggingInternallyState);\n        registerEventsAndFilters(editor, pasteBin, pasteFormat);\n      });\n    };\n\n    const preventSummaryToggle = editor => {\n      editor.on('click', e => {\n        if (editor.dom.getParent(e.target, 'details')) {\n          e.preventDefault();\n        }\n      });\n    };\n    const filterDetails = editor => {\n      editor.parser.addNodeFilter('details', elms => {\n        const initialStateOption = getDetailsInitialState(editor);\n        each$e(elms, details => {\n          if (initialStateOption === 'expanded') {\n            details.attr('open', 'open');\n          } else if (initialStateOption === 'collapsed') {\n            details.attr('open', null);\n          }\n        });\n      });\n      editor.serializer.addNodeFilter('details', elms => {\n        const serializedStateOption = getDetailsSerializedState(editor);\n        each$e(elms, details => {\n          if (serializedStateOption === 'expanded') {\n            details.attr('open', 'open');\n          } else if (serializedStateOption === 'collapsed') {\n            details.attr('open', null);\n          }\n        });\n      });\n    };\n    const setup$6 = editor => {\n      preventSummaryToggle(editor);\n      filterDetails(editor);\n    };\n\n    const isBr = isBr$6;\n    const isText = isText$b;\n    const isContentEditableFalse$2 = elm => isContentEditableFalse$b(elm.dom);\n    const isContentEditableTrue = elm => isContentEditableTrue$3(elm.dom);\n    const isRoot = rootNode => elm => eq(SugarElement.fromDom(rootNode), elm);\n    const getClosestScope = (node, rootNode, schema) => closest$4(SugarElement.fromDom(node), elm => isContentEditableTrue(elm) || schema.isBlock(name(elm)), isRoot(rootNode)).getOr(SugarElement.fromDom(rootNode)).dom;\n    const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));\n    const findEdgeCaretCandidate = (startNode, scope, forward) => {\n      const walker = new DomTreeWalker(startNode, scope);\n      const next = forward ? walker.next.bind(walker) : walker.prev.bind(walker);\n      let result = startNode;\n      for (let current = forward ? startNode : next(); current && !isBr(current); current = next()) {\n        if (isCaretCandidate$3(current)) {\n          result = current;\n        }\n      }\n      return result;\n    };\n    const findClosestBlockRange = (startRng, rootNode, schema) => {\n      const startPos = CaretPosition.fromRangeStart(startRng);\n      const clickNode = startPos.getNode();\n      const scope = getClosestScope(clickNode, rootNode, schema);\n      const startNode = findEdgeCaretCandidate(clickNode, scope, false);\n      const endNode = findEdgeCaretCandidate(clickNode, scope, true);\n      const rng = document.createRange();\n      getClosestCef(startNode, scope).fold(() => {\n        if (isText(startNode)) {\n          rng.setStart(startNode, 0);\n        } else {\n          rng.setStartBefore(startNode);\n        }\n      }, cef => rng.setStartBefore(cef.dom));\n      getClosestCef(endNode, scope).fold(() => {\n        if (isText(endNode)) {\n          rng.setEnd(endNode, endNode.data.length);\n        } else {\n          rng.setEndAfter(endNode);\n        }\n      }, cef => rng.setEndAfter(cef.dom));\n      return rng;\n    };\n    const onTripleClickSelect = editor => {\n      const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody(), editor.schema);\n      editor.selection.setRng(normalize(rng));\n    };\n    const setup$5 = editor => {\n      editor.on('mousedown', e => {\n        if (e.detail >= 3) {\n          e.preventDefault();\n          onTripleClickSelect(editor);\n        }\n      });\n    };\n\n    var FakeCaretPosition;\n    (function (FakeCaretPosition) {\n      FakeCaretPosition['Before'] = 'before';\n      FakeCaretPosition['After'] = 'after';\n    }(FakeCaretPosition || (FakeCaretPosition = {})));\n    const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n    const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n    const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;\n    const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;\n    const isOverlapping = (r1, r2) => {\n      const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);\n      return collidesY(r1, r2) && overlap > 0.5;\n    };\n    const splitRectsPerAxis = (rects, y) => {\n      const intersectingRects = filter$5(rects, rect => isInsideY(y, rect));\n      return boundingClientRectFromRects(intersectingRects).fold(() => [\n        [],\n        rects\n      ], boundingRect => {\n        const {\n          pass: horizontal,\n          fail: vertical\n        } = partition$2(rects, rect => isOverlapping(rect, boundingRect));\n        return [\n          horizontal,\n          vertical\n        ];\n      });\n    };\n    const clientInfo = (rect, clientX) => {\n      return {\n        node: rect.node,\n        position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After\n      };\n    };\n    const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));\n    const closestChildCaretCandidateNodeRect = (children, clientX, clientY, findCloserTextNode) => {\n      const caretCandidateRect = rect => {\n        if (isCaretCandidate$3(rect.node)) {\n          return Optional.some(rect);\n        } else if (isElement$6(rect.node)) {\n          return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY, false);\n        } else {\n          return Optional.none();\n        }\n      };\n      const tryFindSecondBestTextNode = (closest, sndClosest, distance) => {\n        return caretCandidateRect(sndClosest).filter(rect => {\n          const deltaDistance = Math.abs(distance(closest, clientX, clientY) - distance(rect, clientX, clientY));\n          return deltaDistance < 2 && isText$b(rect.node);\n        });\n      };\n      const findClosestCaretCandidateNodeRect = (rects, distance) => {\n        const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));\n        return findMap(sortedRects, caretCandidateRect).map(closest => {\n          if (findCloserTextNode && !isText$b(closest.node) && sortedRects.length > 1) {\n            return tryFindSecondBestTextNode(closest, sortedRects[1], distance).getOr(closest);\n          } else {\n            return closest;\n          }\n        });\n      };\n      const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);\n      const {\n        pass: above,\n        fail: below\n      } = partition$2(verticalRects, rect => rect.top < clientY);\n      return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));\n    };\n    const traverseUp = (rootElm, scope, clientX, clientY) => {\n      const helper = (scope, prevScope) => {\n        const isDragGhostContainer = node => isElement$6(node) && node.classList.contains('mce-drag-container');\n        const childNodesWithoutGhost = filter$5(scope.dom.childNodes, not(isDragGhostContainer));\n        return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY, true), prevScope => {\n          const uncheckedChildren = filter$5(childNodesWithoutGhost, node => node !== prevScope.dom);\n          return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY, true);\n        }).orThunk(() => {\n          const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);\n          return parent.bind(newScope => helper(newScope, Optional.some(scope)));\n        });\n      };\n      return helper(scope, Optional.none());\n    };\n    const closestCaretCandidateNodeRect = (root, clientX, clientY) => {\n      const rootElm = SugarElement.fromDom(root);\n      const ownerDoc = documentOrOwner(rootElm);\n      const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter(elm => contains(rootElm, elm));\n      const element = elementAtPoint.getOr(rootElm);\n      return traverseUp(rootElm, element, clientX, clientY);\n    };\n    const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter(rect => isFakeCaretTarget(rect.node)).map(rect => clientInfo(rect, clientX));\n\n    const getAbsolutePosition = elm => {\n      var _a, _b;\n      const clientRect = elm.getBoundingClientRect();\n      const doc = elm.ownerDocument;\n      const docElem = doc.documentElement;\n      const win = doc.defaultView;\n      return {\n        top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,\n        left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft\n      };\n    };\n    const getBodyPosition = editor => editor.inline ? getAbsolutePosition(editor.getBody()) : {\n      left: 0,\n      top: 0\n    };\n    const getScrollPosition = editor => {\n      const body = editor.getBody();\n      return editor.inline ? {\n        left: body.scrollLeft,\n        top: body.scrollTop\n      } : {\n        left: 0,\n        top: 0\n      };\n    };\n    const getBodyScroll = editor => {\n      const body = editor.getBody(), docElm = editor.getDoc().documentElement;\n      const inlineScroll = {\n        left: body.scrollLeft,\n        top: body.scrollTop\n      };\n      const iframeScroll = {\n        left: body.scrollLeft || docElm.scrollLeft,\n        top: body.scrollTop || docElm.scrollTop\n      };\n      return editor.inline ? inlineScroll : iframeScroll;\n    };\n    const getMousePosition = (editor, event) => {\n      if (event.target.ownerDocument !== editor.getDoc()) {\n        const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());\n        const scrollPosition = getBodyScroll(editor);\n        return {\n          left: event.pageX - iframePosition.left + scrollPosition.left,\n          top: event.pageY - iframePosition.top + scrollPosition.top\n        };\n      }\n      return {\n        left: event.pageX,\n        top: event.pageY\n      };\n    };\n    const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({\n      pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,\n      pageY: mousePosition.top - bodyPosition.top + scrollPosition.top\n    });\n    const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));\n\n    const getTargetProps = target => ({\n      target,\n      srcElement: target\n    });\n    const makeDndEventFromMouseEvent = (type, mouseEvent, target, dataTransfer) => ({\n      ...mouseEvent,\n      dataTransfer,\n      type,\n      ...getTargetProps(target)\n    });\n    const makeDndEvent = (type, target, dataTransfer) => {\n      const fail = die('Function not supported on simulated event.');\n      const event = {\n        bubbles: true,\n        cancelBubble: false,\n        cancelable: true,\n        composed: false,\n        currentTarget: null,\n        defaultPrevented: false,\n        eventPhase: 0,\n        isTrusted: true,\n        returnValue: false,\n        timeStamp: 0,\n        type,\n        composedPath: fail,\n        initEvent: fail,\n        preventDefault: noop,\n        stopImmediatePropagation: noop,\n        stopPropagation: noop,\n        AT_TARGET: window.Event.AT_TARGET,\n        BUBBLING_PHASE: window.Event.BUBBLING_PHASE,\n        CAPTURING_PHASE: window.Event.CAPTURING_PHASE,\n        NONE: window.Event.NONE,\n        altKey: false,\n        button: 0,\n        buttons: 0,\n        clientX: 0,\n        clientY: 0,\n        ctrlKey: false,\n        metaKey: false,\n        movementX: 0,\n        movementY: 0,\n        offsetX: 0,\n        offsetY: 0,\n        pageX: 0,\n        pageY: 0,\n        relatedTarget: null,\n        screenX: 0,\n        screenY: 0,\n        shiftKey: false,\n        x: 0,\n        y: 0,\n        detail: 0,\n        view: null,\n        which: 0,\n        initUIEvent: fail,\n        initMouseEvent: fail,\n        getModifierState: fail,\n        dataTransfer,\n        ...getTargetProps(target)\n      };\n      return event;\n    };\n    const makeDataTransferCopyForDragEvent = (dataTransfer, eventType) => {\n      const copy = cloneDataTransfer(dataTransfer);\n      if (eventType === 'dragstart') {\n        setDragstartEvent(copy);\n        setReadWriteMode(copy);\n      } else if (eventType === 'drop') {\n        setDropEvent(copy);\n        setReadOnlyMode(copy);\n      } else {\n        setDragendEvent(copy);\n        setProtectedMode(copy);\n      }\n      return copy;\n    };\n    const makeDragEvent = (type, target, dataTransfer, mouseEvent) => {\n      const dataTransferForDispatch = makeDataTransferCopyForDragEvent(dataTransfer, type);\n      return isUndefined(mouseEvent) ? makeDndEvent(type, target, dataTransferForDispatch) : makeDndEventFromMouseEvent(type, mouseEvent, target, dataTransferForDispatch);\n    };\n\n    const scrollPixelsPerInterval = 32;\n    const scrollIntervalValue = 100;\n    const mouseRangeToTriggerScrollInsideEditor = 8;\n    const mouseRangeToTriggerScrollOutsideEditor = 16;\n    const isContentEditableFalse$1 = isContentEditableFalse$b;\n    const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);\n    const isDraggable = (dom, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom.isEditable(elm.parentElement);\n    const isValidDropTarget = (editor, targetElement, dragElement) => {\n      if (isNullable(targetElement)) {\n        return false;\n      } else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {\n        return false;\n      } else {\n        return editor.dom.isEditable(targetElement);\n      }\n    };\n    const createGhost = (editor, elm, width, height) => {\n      const dom = editor.dom;\n      const clonedElm = elm.cloneNode(true);\n      dom.setStyles(clonedElm, {\n        width,\n        height\n      });\n      dom.setAttrib(clonedElm, 'data-mce-selected', null);\n      const ghostElm = dom.create('div', {\n        'class': 'mce-drag-container',\n        'data-mce-bogus': 'all',\n        'unselectable': 'on',\n        'contenteditable': 'false'\n      });\n      dom.setStyles(ghostElm, {\n        position: 'absolute',\n        opacity: 0.5,\n        overflow: 'hidden',\n        border: 0,\n        padding: 0,\n        margin: 0,\n        width,\n        height\n      });\n      dom.setStyles(clonedElm, {\n        margin: 0,\n        boxSizing: 'border-box'\n      });\n      ghostElm.appendChild(clonedElm);\n      return ghostElm;\n    };\n    const appendGhostToBody = (ghostElm, bodyElm) => {\n      if (ghostElm.parentNode !== bodyElm) {\n        bodyElm.appendChild(ghostElm);\n      }\n    };\n    const scrollEditor = (direction, amount) => win => () => {\n      const current = direction === 'left' ? win.scrollX : win.scrollY;\n      win.scroll({\n        [direction]: current + amount,\n        behavior: 'smooth'\n      });\n    };\n    const scrollLeft = scrollEditor('left', -scrollPixelsPerInterval);\n    const scrollRight = scrollEditor('left', scrollPixelsPerInterval);\n    const scrollUp = scrollEditor('top', -scrollPixelsPerInterval);\n    const scrollDown = scrollEditor('top', scrollPixelsPerInterval);\n    const moveGhost = (ghostElm, position, width, height, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state, mouseEventOriginatedFromWithinTheEditor) => {\n      let overflowX = 0, overflowY = 0;\n      ghostElm.style.left = position.pageX + 'px';\n      ghostElm.style.top = position.pageY + 'px';\n      if (position.pageX + width > maxX) {\n        overflowX = position.pageX + width - maxX;\n      }\n      if (position.pageY + height > maxY) {\n        overflowY = position.pageY + height - maxY;\n      }\n      ghostElm.style.width = width - overflowX + 'px';\n      ghostElm.style.height = height - overflowY + 'px';\n      const clientHeight = contentAreaContainer.clientHeight;\n      const clientWidth = contentAreaContainer.clientWidth;\n      const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;\n      const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;\n      state.on(state => {\n        state.intervalId.clear();\n        if (state.dragging && mouseEventOriginatedFromWithinTheEditor) {\n          if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {\n            state.intervalId.set(scrollDown(win));\n          } else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {\n            state.intervalId.set(scrollUp(win));\n          } else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) {\n            state.intervalId.set(scrollRight(win));\n          } else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {\n            state.intervalId.set(scrollLeft(win));\n          } else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) {\n            state.intervalId.set(scrollDown(window));\n          } else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {\n            state.intervalId.set(scrollUp(window));\n          } else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) {\n            state.intervalId.set(scrollRight(window));\n          } else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {\n            state.intervalId.set(scrollLeft(window));\n          }\n        }\n      });\n    };\n    const removeElement = elm => {\n      if (elm && elm.parentNode) {\n        elm.parentNode.removeChild(elm);\n      }\n    };\n    const removeElementWithPadding = (dom, elm) => {\n      const parentBlock = dom.getParent(elm.parentNode, dom.isBlock);\n      removeElement(elm);\n      if (parentBlock && parentBlock !== dom.getRoot() && dom.isEmpty(parentBlock)) {\n        fillWithPaddingBr(SugarElement.fromDom(parentBlock));\n      }\n    };\n    const isLeftMouseButtonPressed = e => e.button === 0;\n    const applyRelPos = (state, position) => ({\n      pageX: position.pageX - state.relX,\n      pageY: position.pageY + 5\n    });\n    const start = (state, editor) => e => {\n      if (isLeftMouseButtonPressed(e)) {\n        const ceElm = find$2(editor.dom.getParents(e.target), isContentEditable).getOr(null);\n        if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {\n          const elmPos = editor.dom.getPos(ceElm);\n          const bodyElm = editor.getBody();\n          const docElm = editor.getDoc().documentElement;\n          state.set({\n            element: ceElm,\n            dataTransfer: createDataTransfer(),\n            dragging: false,\n            screenX: e.screenX,\n            screenY: e.screenY,\n            maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,\n            maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,\n            relX: e.pageX - elmPos.x,\n            relY: e.pageY - elmPos.y,\n            width: ceElm.offsetWidth,\n            height: ceElm.offsetHeight,\n            ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),\n            intervalId: repeatable(scrollIntervalValue)\n          });\n        }\n      }\n    };\n    const placeCaretAt = (editor, clientX, clientY) => {\n      editor._selectionOverrides.hideFakeCaret();\n      closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), caretInfo => {\n        const range = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n        if (range) {\n          editor.selection.setRng(range);\n        } else {\n          editor.selection.placeCaretAt(clientX, clientY);\n        }\n      });\n    };\n    const dispatchDragEvent = (editor, type, target, dataTransfer, mouseEvent) => {\n      if (type === 'dragstart') {\n        setHtmlData(dataTransfer, editor.dom.getOuterHTML(target));\n      }\n      const event = makeDragEvent(type, target, dataTransfer, mouseEvent);\n      const args = editor.dispatch(type, event);\n      return args;\n    };\n    const move = (state, editor) => {\n      const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);\n      editor.on('remove', throttledPlaceCaretAt.cancel);\n      const state_ = state;\n      return e => state.on(state => {\n        const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));\n        if (!state.dragging && movement > 10) {\n          const args = dispatchDragEvent(editor, 'dragstart', state.element, state.dataTransfer, e);\n          if (isNonNullable(args.dataTransfer)) {\n            state.dataTransfer = args.dataTransfer;\n          }\n          if (args.isDefaultPrevented()) {\n            return;\n          }\n          state.dragging = true;\n          editor.focus();\n        }\n        if (state.dragging) {\n          const mouseEventOriginatedFromWithinTheEditor = e.currentTarget === editor.getDoc().documentElement;\n          const targetPos = applyRelPos(state, calc(editor, e));\n          appendGhostToBody(state.ghost, editor.getBody());\n          moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY, e.clientY, e.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);\n          throttledPlaceCaretAt.throttle(e.clientX, e.clientY);\n        }\n      });\n    };\n    const getRawTarget = selection => {\n      const sel = selection.getSel();\n      if (isNonNullable(sel)) {\n        const rng = sel.getRangeAt(0);\n        const startContainer = rng.startContainer;\n        return isText$b(startContainer) ? startContainer.parentNode : startContainer;\n      } else {\n        return null;\n      }\n    };\n    const drop = (state, editor) => e => {\n      state.on(state => {\n        var _a;\n        state.intervalId.clear();\n        if (state.dragging) {\n          if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {\n            const dropTarget = (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !== null && _a !== void 0 ? _a : editor.getBody();\n            const args = dispatchDragEvent(editor, 'drop', dropTarget, state.dataTransfer, e);\n            if (!args.isDefaultPrevented()) {\n              editor.undoManager.transact(() => {\n                removeElementWithPadding(editor.dom, state.element);\n                getHtmlData(state.dataTransfer).each(content => editor.insertContent(content));\n                editor._selectionOverrides.hideFakeCaret();\n              });\n            }\n          }\n          dispatchDragEvent(editor, 'dragend', editor.getBody(), state.dataTransfer, e);\n        }\n      });\n      removeDragState(state);\n    };\n    const stopDragging = (state, editor, e) => {\n      state.on(state => {\n        state.intervalId.clear();\n        if (state.dragging) {\n          e.fold(() => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer), mouseEvent => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer, mouseEvent));\n        }\n      });\n      removeDragState(state);\n    };\n    const stop = (state, editor) => e => stopDragging(state, editor, Optional.some(e));\n    const removeDragState = state => {\n      state.on(state => {\n        state.intervalId.clear();\n        removeElement(state.ghost);\n      });\n      state.clear();\n    };\n    const bindFakeDragEvents = editor => {\n      const state = value$2();\n      const pageDom = DOMUtils.DOM;\n      const rootDocument = document;\n      const dragStartHandler = start(state, editor);\n      const dragHandler = move(state, editor);\n      const dropHandler = drop(state, editor);\n      const dragEndHandler = stop(state, editor);\n      editor.on('mousedown', dragStartHandler);\n      editor.on('mousemove', dragHandler);\n      editor.on('mouseup', dropHandler);\n      pageDom.bind(rootDocument, 'mousemove', dragHandler);\n      pageDom.bind(rootDocument, 'mouseup', dragEndHandler);\n      editor.on('remove', () => {\n        pageDom.unbind(rootDocument, 'mousemove', dragHandler);\n        pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);\n      });\n      editor.on('keydown', e => {\n        if (e.keyCode === VK.ESC) {\n          stopDragging(state, editor, Optional.none());\n        }\n      });\n    };\n    const blockUnsupportedFileDrop = editor => {\n      const preventFileDrop = e => {\n        if (!e.isDefaultPrevented()) {\n          const dataTransfer = e.dataTransfer;\n          if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {\n            e.preventDefault();\n            if (e.type === 'drop') {\n              displayError(editor, 'Dropped file type is not supported');\n            }\n          }\n        }\n      };\n      const preventFileDropIfUIElement = e => {\n        if (isUIElement(editor, e.target)) {\n          preventFileDrop(e);\n        }\n      };\n      const setup = () => {\n        const pageDom = DOMUtils.DOM;\n        const dom = editor.dom;\n        const doc = document;\n        const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();\n        const eventNames = [\n          'drop',\n          'dragover'\n        ];\n        each$e(eventNames, name => {\n          pageDom.bind(doc, name, preventFileDropIfUIElement);\n          dom.bind(editorRoot, name, preventFileDrop);\n        });\n        editor.on('remove', () => {\n          each$e(eventNames, name => {\n            pageDom.unbind(doc, name, preventFileDropIfUIElement);\n            dom.unbind(editorRoot, name, preventFileDrop);\n          });\n        });\n      };\n      editor.on('init', () => {\n        Delay.setEditorTimeout(editor, setup, 0);\n      });\n    };\n    const init$2 = editor => {\n      bindFakeDragEvents(editor);\n      if (shouldBlockUnsupportedDrop(editor)) {\n        blockUnsupportedFileDrop(editor);\n      }\n    };\n\n    const setup$4 = editor => {\n      const renderFocusCaret = first$1(() => {\n        if (!editor.removed && editor.getBody().contains(document.activeElement)) {\n          const rng = editor.selection.getRng();\n          if (rng.collapsed) {\n            const caretRange = renderRangeCaret(editor, rng, false);\n            editor.selection.setRng(caretRange);\n          }\n        }\n      }, 0);\n      editor.on('focus', () => {\n        renderFocusCaret.throttle();\n      });\n      editor.on('blur', () => {\n        renderFocusCaret.cancel();\n      });\n    };\n\n    const setup$3 = editor => {\n      editor.on('init', () => {\n        editor.on('focusin', e => {\n          const target = e.target;\n          if (isMedia$2(target)) {\n            const ceRoot = getContentEditableRoot$1(editor.getBody(), target);\n            const node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;\n            if (editor.selection.getNode() !== node) {\n              selectNode(editor, node).each(rng => editor.selection.setRng(rng));\n            }\n          }\n        });\n      });\n    };\n\n    const isContentEditableFalse = isContentEditableFalse$b;\n    const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);\n    const SelectionOverrides = editor => {\n      const selection = editor.selection, dom = editor.dom;\n      const rootNode = editor.getBody();\n      const fakeCaret = FakeCaret(editor, rootNode, dom.isBlock, () => hasFocus(editor));\n      const realSelectionId = 'sel-' + dom.uniqueId();\n      const elementSelectionAttr = 'data-mce-selected';\n      let selectedElement;\n      const isFakeSelectionElement = node => isNonNullable(node) && dom.hasClass(node, 'mce-offscreen-selection');\n      const isFakeSelectionTargetElement = node => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode) && dom.isEditable(node.parentNode);\n      const setRange = range => {\n        if (range) {\n          selection.setRng(range);\n        }\n      };\n      const showCaret = (direction, node, before, scrollIntoView = true) => {\n        const e = editor.dispatch('ShowCaret', {\n          target: node,\n          direction,\n          before\n        });\n        if (e.isDefaultPrevented()) {\n          return null;\n        }\n        if (scrollIntoView) {\n          selection.scrollIntoView(node, direction === -1);\n        }\n        return fakeCaret.show(before, node);\n      };\n      const showBlockCaretContainer = blockCaretContainer => {\n        if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n          showCaretContainerBlock(blockCaretContainer);\n          selection.scrollIntoView(blockCaretContainer);\n        }\n      };\n      const registerEvents = () => {\n        editor.on('click', e => {\n          if (!dom.isEditable(e.target)) {\n            e.preventDefault();\n            editor.focus();\n          }\n        });\n        editor.on('blur NewBlock', removeElementSelection);\n        editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);\n        editor.on('tap', e => {\n          const targetElm = e.target;\n          const contentEditableRoot = getContentEditableRoot(editor, targetElm);\n          if (isContentEditableFalse(contentEditableRoot)) {\n            e.preventDefault();\n            selectNode(editor, contentEditableRoot).each(setElementSelection);\n          } else if (isFakeSelectionTargetElement(targetElm)) {\n            selectNode(editor, targetElm).each(setElementSelection);\n          }\n        }, true);\n        editor.on('mousedown', e => {\n          const targetElm = e.target;\n          if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {\n            return;\n          }\n          if (!isXYInContentArea(editor, e.clientX, e.clientY)) {\n            return;\n          }\n          removeElementSelection();\n          hideFakeCaret();\n          const closestContentEditable = getContentEditableRoot(editor, targetElm);\n          if (isContentEditableFalse(closestContentEditable)) {\n            e.preventDefault();\n            selectNode(editor, closestContentEditable).each(setElementSelection);\n          } else {\n            closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each(caretInfo => {\n              e.preventDefault();\n              const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n              setRange(range);\n              if (isHTMLElement(closestContentEditable)) {\n                closestContentEditable.focus();\n              } else {\n                editor.getBody().focus();\n              }\n            });\n          }\n        });\n        editor.on('keypress', e => {\n          if (VK.modifierPressed(e)) {\n            return;\n          }\n          if (isContentEditableFalse(selection.getNode())) {\n            e.preventDefault();\n          }\n        });\n        editor.on('GetSelectionRange', e => {\n          let rng = e.range;\n          if (selectedElement) {\n            if (!selectedElement.parentNode) {\n              selectedElement = null;\n              return;\n            }\n            rng = rng.cloneRange();\n            rng.selectNode(selectedElement);\n            e.range = rng;\n          }\n        });\n        editor.on('SetSelectionRange', e => {\n          e.range = normalizeVoidElementSelection(e.range);\n          const rng = setElementSelection(e.range, e.forward);\n          if (rng) {\n            e.range = rng;\n          }\n        });\n        const isPasteBin = node => isElement$6(node) && node.id === 'mcepastebin';\n        editor.on('AfterSetSelectionRange', e => {\n          const rng = e.range;\n          const parent = rng.startContainer.parentElement;\n          if (!isRangeInCaretContainer(rng) && !isPasteBin(parent)) {\n            hideFakeCaret();\n          }\n          if (!isFakeSelectionElement(parent)) {\n            removeElementSelection();\n          }\n        });\n        init$2(editor);\n        setup$4(editor);\n        setup$3(editor);\n      };\n      const isWithinCaretContainer = node => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);\n      const isRangeInCaretContainer = rng => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);\n      const normalizeVoidElementSelection = rng => {\n        const voidElements = editor.schema.getVoidElements();\n        const newRng = dom.createRng();\n        const startContainer = rng.startContainer;\n        const startOffset = rng.startOffset;\n        const endContainer = rng.endContainer;\n        const endOffset = rng.endOffset;\n        if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {\n          if (startOffset === 0) {\n            newRng.setStartBefore(startContainer);\n          } else {\n            newRng.setStartAfter(startContainer);\n          }\n        } else {\n          newRng.setStart(startContainer, startOffset);\n        }\n        if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {\n          if (endOffset === 0) {\n            newRng.setEndBefore(endContainer);\n          } else {\n            newRng.setEndAfter(endContainer);\n          }\n        } else {\n          newRng.setEnd(endContainer, endOffset);\n        }\n        return newRng;\n      };\n      const setupOffscreenSelection = (node, targetClone) => {\n        const body = SugarElement.fromDom(editor.getBody());\n        const doc = editor.getDoc();\n        const realSelectionContainer = descendant$1(body, '#' + realSelectionId).getOrThunk(() => {\n          const newContainer = SugarElement.fromHtml('<div data-mce-bogus=\"all\" class=\"mce-offscreen-selection\"></div>', doc);\n          set$3(newContainer, 'id', realSelectionId);\n          append$1(body, newContainer);\n          return newContainer;\n        });\n        const newRange = dom.createRng();\n        empty(realSelectionContainer);\n        append(realSelectionContainer, [\n          SugarElement.fromText(nbsp, doc),\n          SugarElement.fromDom(targetClone),\n          SugarElement.fromText(nbsp, doc)\n        ]);\n        newRange.setStart(realSelectionContainer.dom.firstChild, 1);\n        newRange.setEnd(realSelectionContainer.dom.lastChild, 0);\n        setAll(realSelectionContainer, { top: dom.getPos(node, editor.getBody()).y + 'px' });\n        focus$1(realSelectionContainer);\n        const sel = selection.getSel();\n        if (sel) {\n          sel.removeAllRanges();\n          sel.addRange(newRange);\n        }\n        return newRange;\n      };\n      const selectElement = elm => {\n        const targetClone = elm.cloneNode(true);\n        const e = editor.dispatch('ObjectSelected', {\n          target: elm,\n          targetClone\n        });\n        if (e.isDefaultPrevented()) {\n          return null;\n        }\n        const range = setupOffscreenSelection(elm, e.targetClone);\n        const nodeElm = SugarElement.fromDom(elm);\n        each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${ elementSelectionAttr }]`), elm => {\n          if (!eq(nodeElm, elm)) {\n            remove$9(elm, elementSelectionAttr);\n          }\n        });\n        if (!dom.getAttrib(elm, elementSelectionAttr)) {\n          elm.setAttribute(elementSelectionAttr, '1');\n        }\n        selectedElement = elm;\n        hideFakeCaret();\n        return range;\n      };\n      const setElementSelection = (range, forward) => {\n        if (!range) {\n          return null;\n        }\n        if (range.collapsed) {\n          if (!isRangeInCaretContainer(range)) {\n            const dir = forward ? 1 : -1;\n            const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);\n            const beforeNode = caretPosition.getNode(!forward);\n            if (isNonNullable(beforeNode)) {\n              if (isFakeCaretTarget(beforeNode)) {\n                return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);\n              }\n              if (isCaretContainerInline(beforeNode) && isContentEditableFalse$b(beforeNode.nextSibling)) {\n                const rng = dom.createRng();\n                rng.setStart(beforeNode, 0);\n                rng.setEnd(beforeNode, 0);\n                return rng;\n              }\n            }\n            const afterNode = caretPosition.getNode(forward);\n            if (isNonNullable(afterNode)) {\n              if (isFakeCaretTarget(afterNode)) {\n                return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);\n              }\n              if (isCaretContainerInline(afterNode) && isContentEditableFalse$b(afterNode.previousSibling)) {\n                const rng = dom.createRng();\n                rng.setStart(afterNode, 1);\n                rng.setEnd(afterNode, 1);\n                return rng;\n              }\n            }\n          }\n          return null;\n        }\n        let startContainer = range.startContainer;\n        let startOffset = range.startOffset;\n        const endOffset = range.endOffset;\n        if (isText$b(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {\n          startContainer = startContainer.parentNode;\n          startOffset = dom.nodeIndex(startContainer);\n          startContainer = startContainer.parentNode;\n        }\n        if (!isElement$6(startContainer)) {\n          return null;\n        }\n        if (endOffset === startOffset + 1 && startContainer === range.endContainer) {\n          const node = startContainer.childNodes[startOffset];\n          if (isFakeSelectionTargetElement(node)) {\n            return selectElement(node);\n          }\n        }\n        return null;\n      };\n      const removeElementSelection = () => {\n        if (selectedElement) {\n          selectedElement.removeAttribute(elementSelectionAttr);\n        }\n        descendant$1(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$4);\n        selectedElement = null;\n      };\n      const destroy = () => {\n        fakeCaret.destroy();\n        selectedElement = null;\n      };\n      const hideFakeCaret = () => {\n        fakeCaret.hide();\n      };\n      if (!isRtc(editor)) {\n        registerEvents();\n      }\n      return {\n        showCaret,\n        showBlockCaretContainer,\n        hideFakeCaret,\n        destroy\n      };\n    };\n\n    const getNormalizedTextOffset = (container, offset) => {\n      let normalizedOffset = offset;\n      for (let node = container.previousSibling; isText$b(node); node = node.previousSibling) {\n        normalizedOffset += node.data.length;\n      }\n      return normalizedOffset;\n    };\n    const generatePath = (dom, root, node, offset, normalized) => {\n      if (isText$b(node) && (offset < 0 || offset > node.data.length)) {\n        return [];\n      }\n      const p = normalized && isText$b(node) ? [getNormalizedTextOffset(node, offset)] : [offset];\n      let current = node;\n      while (current !== root && current.parentNode) {\n        p.push(dom.nodeIndex(current, normalized));\n        current = current.parentNode;\n      }\n      return current === root ? p.reverse() : [];\n    };\n    const generatePathRange = (dom, root, startNode, startOffset, endNode, endOffset, normalized = false) => {\n      const start = generatePath(dom, root, startNode, startOffset, normalized);\n      const end = generatePath(dom, root, endNode, endOffset, normalized);\n      return {\n        start,\n        end\n      };\n    };\n    const resolvePath = (root, path) => {\n      const nodePath = path.slice();\n      const offset = nodePath.pop();\n      if (!isNumber(offset)) {\n        return Optional.none();\n      } else {\n        const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind(node => Optional.from(node.childNodes[index])), Optional.some(root));\n        return resolvedNode.bind(node => {\n          if (isText$b(node) && (offset < 0 || offset > node.data.length)) {\n            return Optional.none();\n          } else {\n            return Optional.some({\n              node,\n              offset\n            });\n          }\n        });\n      }\n    };\n    const resolvePathRange = (root, range) => resolvePath(root, range.start).bind(({\n      node: startNode,\n      offset: startOffset\n    }) => resolvePath(root, range.end).map(({\n      node: endNode,\n      offset: endOffset\n    }) => {\n      const rng = document.createRange();\n      rng.setStart(startNode, startOffset);\n      rng.setEnd(endNode, endOffset);\n      return rng;\n    }));\n    const generatePathRangeFromRange = (dom, root, range, normalized = false) => generatePathRange(dom, root, range.startContainer, range.startOffset, range.endContainer, range.endOffset, normalized);\n\n    const cleanEmptyNodes = (dom, node, isRoot) => {\n      if (node && dom.isEmpty(node) && !isRoot(node)) {\n        const parent = node.parentNode;\n        dom.remove(node, isText$b(node.firstChild) && isWhitespaceText(node.firstChild.data));\n        cleanEmptyNodes(dom, parent, isRoot);\n      }\n    };\n    const deleteRng = (dom, rng, isRoot, clean = true) => {\n      const startParent = rng.startContainer.parentNode;\n      const endParent = rng.endContainer.parentNode;\n      rng.deleteContents();\n      if (clean && !isRoot(rng.startContainer)) {\n        if (isText$b(rng.startContainer) && rng.startContainer.data.length === 0) {\n          dom.remove(rng.startContainer);\n        }\n        if (isText$b(rng.endContainer) && rng.endContainer.data.length === 0) {\n          dom.remove(rng.endContainer);\n        }\n        cleanEmptyNodes(dom, startParent, isRoot);\n        if (startParent !== endParent) {\n          cleanEmptyNodes(dom, endParent, isRoot);\n        }\n      }\n    };\n    const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));\n    const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {\n      const dynamicPatterns = patternSet.dynamicPatternsLookup({\n        text: beforeText,\n        block\n      });\n      return {\n        ...patternSet,\n        blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),\n        inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)\n      };\n    };\n    const getBeforeText = (dom, block, node, offset) => {\n      const rng = dom.createRng();\n      rng.setStart(block, 0);\n      rng.setEnd(node, offset);\n      return rng.toString();\n    };\n\n    const newMarker = (dom, id) => dom.create('span', {\n      'data-mce-type': 'bookmark',\n      id\n    });\n    const rangeFromMarker = (dom, marker) => {\n      const rng = dom.createRng();\n      rng.setStartAfter(marker.start);\n      rng.setEndBefore(marker.end);\n      return rng;\n    };\n    const createMarker = (dom, markerPrefix, pathRange) => {\n      const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');\n      const startNode = rng.startContainer;\n      const endNode = rng.endContainer;\n      const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);\n      const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);\n      const startParentNode = textStart.parentNode;\n      const endParentNode = textEnd.parentNode;\n      return {\n        prefix: markerPrefix,\n        end: endParentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),\n        start: startParentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)\n      };\n    };\n    const removeMarker = (dom, marker, isRoot) => {\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);\n    };\n\n    const isReplacementPattern = pattern => pattern.start.length === 0;\n    const matchesPattern = patternContent => (element, offset) => {\n      const text = element.data;\n      const searchText = text.substring(0, offset);\n      const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));\n      const startIndex = searchText.lastIndexOf(patternContent);\n      if (startIndex !== -1) {\n        return startIndex + patternContent.length;\n      } else if (startEndIndex !== -1) {\n        return startEndIndex + 1;\n      } else {\n        return -1;\n      }\n    };\n    const findPatternStartFromSpot = (dom, pattern, block, spot) => {\n      const startPattern = pattern.start;\n      const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);\n      return startSpot.bind(spot => {\n        var _a, _b;\n        const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;\n        const isCompleteMatch = startPatternIndex !== -1 && spot.offset >= startPatternIndex + startPattern.length;\n        if (isCompleteMatch) {\n          const rng = dom.createRng();\n          rng.setStart(spot.container, spot.offset - startPattern.length);\n          rng.setEnd(spot.container, spot.offset);\n          return Optional.some(rng);\n        } else {\n          const offset = spot.offset - startPattern.length;\n          return scanLeft(spot.container, offset, block).map(nextSpot => {\n            const rng = dom.createRng();\n            rng.setStart(nextSpot.container, nextSpot.offset);\n            rng.setEnd(spot.container, spot.offset);\n            return rng;\n          }).filter(rng => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));\n        }\n      });\n    };\n    const findPatternStart = (dom, pattern, node, offset, block, requireGap = false) => {\n      if (pattern.start.length === 0 && !requireGap) {\n        const rng = dom.createRng();\n        rng.setStart(node, offset);\n        rng.setEnd(node, offset);\n        return Optional.some(rng);\n      }\n      return textBefore(node, offset, block).bind(spot => {\n        const start = findPatternStartFromSpot(dom, pattern, block, spot);\n        return start.bind(startRange => {\n          var _a;\n          if (requireGap) {\n            if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {\n              return Optional.none();\n            } else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) {\n              return Optional.none();\n            }\n          }\n          return Optional.some(startRange);\n        });\n      });\n    };\n    const findPattern$3 = (editor, block, details, normalizedMatches) => {\n      const dom = editor.dom;\n      const root = dom.getRoot();\n      const pattern = details.pattern;\n      const endNode = details.position.container;\n      const endOffset = details.position.offset;\n      return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind(spot => {\n        const endPathRng = generatePathRange(dom, root, spot.container, spot.offset, endNode, endOffset, normalizedMatches);\n        if (isReplacementPattern(pattern)) {\n          return Optional.some({\n            matches: [{\n                pattern,\n                startRng: endPathRng,\n                endRng: endPathRng\n              }],\n            position: spot\n          });\n        } else {\n          const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);\n          const results = resultsOpt.getOr({\n            matches: [],\n            position: spot\n          });\n          const pos = results.position;\n          const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());\n          return start.map(startRng => {\n            const startPathRng = generatePathRangeFromRange(dom, root, startRng, normalizedMatches);\n            return {\n              matches: results.matches.concat([{\n                  pattern,\n                  startRng: startPathRng,\n                  endRng: endPathRng\n                }]),\n              position: point(startRng.startContainer, startRng.startOffset)\n            };\n          });\n        }\n      });\n    };\n    const findPatternsRec = (editor, patterns, node, offset, block, normalizedMatches) => {\n      const dom = editor.dom;\n      return textBefore(node, offset, dom.getRoot()).bind(endSpot => {\n        const text = getBeforeText(dom, block, node, offset);\n        for (let i = 0; i < patterns.length; i++) {\n          const pattern = patterns[i];\n          if (!endsWith(text, pattern.end)) {\n            continue;\n          }\n          const patternsWithoutCurrent = patterns.slice();\n          patternsWithoutCurrent.splice(i, 1);\n          const result = findPattern$3(editor, block, {\n            pattern,\n            remainingPatterns: patternsWithoutCurrent,\n            position: endSpot\n          }, normalizedMatches);\n          if (result.isNone() && offset > 0) {\n            return findPatternsRec(editor, patterns, node, offset - 1, block, normalizedMatches);\n          }\n          if (result.isSome()) {\n            return result;\n          }\n        }\n        return Optional.none();\n      });\n    };\n    const applyPattern$2 = (editor, pattern, patternRange) => {\n      editor.selection.setRng(patternRange);\n      if (pattern.type === 'inline-format') {\n        each$e(pattern.format, format => {\n          editor.formatter.apply(format);\n        });\n      } else {\n        editor.execCommand(pattern.cmd, false, pattern.value);\n      }\n    };\n    const applyReplacementPattern = (editor, pattern, marker, isRoot) => {\n      const markerRange = rangeFromMarker(editor.dom, marker);\n      deleteRng(editor.dom, markerRange, isRoot);\n      applyPattern$2(editor, pattern, markerRange);\n    };\n    const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {\n      const dom = editor.dom;\n      const markerEndRange = rangeFromMarker(dom, endMarker);\n      const markerStartRange = rangeFromMarker(dom, startMarker);\n      deleteRng(dom, markerStartRange, isRoot);\n      deleteRng(dom, markerEndRange, isRoot);\n      const patternMarker = {\n        prefix: startMarker.prefix,\n        start: startMarker.end,\n        end: endMarker.start\n      };\n      const patternRange = rangeFromMarker(dom, patternMarker);\n      applyPattern$2(editor, pattern, patternRange);\n    };\n    const addMarkers = (dom, matches) => {\n      const markerPrefix = generate$1('mce_textpattern');\n      const matchesWithEnds = foldr(matches, (acc, match) => {\n        const endMarker = createMarker(dom, markerPrefix + `_end${ acc.length }`, match.endRng);\n        return acc.concat([{\n            ...match,\n            endMarker\n          }]);\n      }, []);\n      return foldr(matchesWithEnds, (acc, match) => {\n        const idx = matchesWithEnds.length - acc.length - 1;\n        const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${ idx }`, match.startRng);\n        return acc.concat([{\n            ...match,\n            startMarker\n          }]);\n      }, []);\n    };\n    const sortPatterns$1 = patterns => sort(patterns, (a, b) => b.end.length - a.end.length);\n    const getBestMatches = (matches, matchesWithSortedPatterns) => {\n      const hasSameMatches = forall(matches, match => exists(matchesWithSortedPatterns, sortedMatch => match.pattern.start === sortedMatch.pattern.start && match.pattern.end === sortedMatch.pattern.end));\n      if (matches.length === matchesWithSortedPatterns.length) {\n        if (hasSameMatches) {\n          return matches;\n        } else {\n          return matchesWithSortedPatterns;\n        }\n      }\n      return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;\n    };\n    const findPatterns$2 = (editor, block, node, offset, patternSet, normalizedMatches) => {\n      const matches = findPatternsRec(editor, patternSet.inlinePatterns, node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\n      const matchesWithSortedPatterns = findPatternsRec(editor, sortPatterns$1(patternSet.inlinePatterns), node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\n      return getBestMatches(matches, matchesWithSortedPatterns);\n    };\n    const applyMatches$2 = (editor, matches) => {\n      if (matches.length === 0) {\n        return;\n      }\n      const dom = editor.dom;\n      const bookmark = editor.selection.getBookmark();\n      const matchesWithMarkers = addMarkers(dom, matches);\n      each$e(matchesWithMarkers, match => {\n        const block = dom.getParent(match.startMarker.start, dom.isBlock);\n        const isRoot = node => node === block;\n        if (isReplacementPattern(match.pattern)) {\n          applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);\n        } else {\n          applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);\n        }\n        removeMarker(dom, match.endMarker, isRoot);\n        removeMarker(dom, match.startMarker, isRoot);\n      });\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    const stripPattern$1 = (dom, block, pattern) => {\n      return textAfter(block, 0, block).map(spot => {\n        const node = spot.container;\n        scanRight(node, pattern.start.length, block).each(end => {\n          const rng = dom.createRng();\n          rng.setStart(node, 0);\n          rng.setEnd(end.container, end.offset);\n          deleteRng(dom, rng, e => e === block);\n        });\n        return node;\n      });\n    };\n    const createApplyPattern = stripPattern => (editor, match) => {\n      const dom = editor.dom;\n      const pattern = match.pattern;\n      const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');\n      const isBlockFormatName = (name, formatter) => {\n        const formatSet = formatter.get(name);\n        return isArray$1(formatSet) && head(formatSet).exists(format => has$2(format, 'block'));\n      };\n      getParentBlock(editor, rng).each(block => {\n        if (pattern.type === 'block-format') {\n          if (isBlockFormatName(pattern.format, editor.formatter)) {\n            editor.undoManager.transact(() => {\n              stripPattern(editor.dom, block, pattern);\n              editor.formatter.apply(pattern.format);\n            });\n          }\n        } else if (pattern.type === 'block-command') {\n          editor.undoManager.transact(() => {\n            stripPattern(editor.dom, block, pattern);\n            editor.execCommand(pattern.cmd, false, pattern.value);\n          });\n        }\n      });\n      return true;\n    };\n    const sortPatterns = patterns => sort(patterns, (a, b) => b.start.length - a.start.length);\n    const findPattern$2 = predicate => (patterns, text) => {\n      const sortedPatterns = sortPatterns(patterns);\n      const nuText = text.replace(nbsp, ' ');\n      return find$2(sortedPatterns, pattern => predicate(pattern, text, nuText));\n    };\n    const createFindPatterns = (findPattern, skipFullMatch) => (editor, block, patternSet, normalizedMatches, text) => {\n      var _a;\n      if (text === void 0) {\n        text = (_a = block.textContent) !== null && _a !== void 0 ? _a : '';\n      }\n      const dom = editor.dom;\n      const forcedRootBlock = getForcedRootBlock(editor);\n      if (!dom.is(block, forcedRootBlock)) {\n        return [];\n      }\n      return findPattern(patternSet.blockPatterns, text).map(pattern => {\n        if (skipFullMatch && Tools.trim(text).length === pattern.start.length) {\n          return [];\n        }\n        return [{\n            pattern,\n            range: generatePathRange(dom, dom.getRoot(), block, 0, block, 0, normalizedMatches)\n          }];\n      }).getOr([]);\n    };\n\n    const startsWithSingleSpace = s => /^\\s[^\\s]/.test(s);\n    const stripPattern = (dom, block, pattern) => {\n      stripPattern$1(dom, block, pattern).each(node => {\n        const text = SugarElement.fromDom(node);\n        const textContent = get$3(text);\n        if (startsWithSingleSpace(textContent)) {\n          set(text, textContent.slice(1));\n        }\n      });\n    };\n    const applyPattern$1 = createApplyPattern(stripPattern);\n    const findPattern$1 = findPattern$2((pattern, text, nuText) => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);\n    const findPatterns$1 = createFindPatterns(findPattern$1, true);\n    const getMatches$1 = (editor, patternSet) => {\n      const rng = editor.selection.getRng();\n      return getParentBlock(editor, rng).map(block => {\n        var _a;\n        const offset = Math.max(0, rng.startOffset);\n        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : '');\n        const inlineMatches = findPatterns$2(editor, block, rng.startContainer, offset, dynamicPatternSet, true);\n        const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);\n        return {\n          inlineMatches,\n          blockMatches\n        };\n      }).filter(({inlineMatches, blockMatches}) => blockMatches.length > 0 || inlineMatches.length > 0);\n    };\n    const applyMatches$1 = (editor, matches) => {\n      if (matches.length === 0) {\n        return;\n      }\n      const bookmark = editor.selection.getBookmark();\n      each$e(matches, match => applyPattern$1(editor, match));\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    const applyPattern = createApplyPattern(stripPattern$1);\n    const findPattern = findPattern$2((pattern, text, nuText) => text === pattern.start || nuText === pattern.start);\n    const findPatterns = createFindPatterns(findPattern, false);\n    const getMatches = (editor, patternSet) => {\n      const rng = editor.selection.getRng();\n      return getParentBlock(editor, rng).map(block => {\n        const offset = Math.max(0, rng.startOffset);\n        const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);\n        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);\n        return findPatterns(editor, block, dynamicPatternSet, false, beforeText);\n      }).filter(matches => matches.length > 0);\n    };\n    const applyMatches = (editor, matches) => {\n      each$e(matches, match => applyPattern(editor, match));\n    };\n\n    const handleEnter = (editor, patternSet) => getMatches$1(editor, patternSet).fold(never, ({inlineMatches, blockMatches}) => {\n      editor.undoManager.add();\n      editor.undoManager.extra(() => {\n        editor.execCommand('mceInsertNewLine');\n      }, () => {\n        insert$5(editor);\n        applyMatches$2(editor, inlineMatches);\n        applyMatches$1(editor, blockMatches);\n        const range = editor.selection.getRng();\n        const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());\n        editor.execCommand('mceInsertNewLine');\n        spot.each(s => {\n          const node = s.container;\n          if (node.data.charAt(s.offset - 1) === zeroWidth) {\n            node.deleteData(s.offset - 1, 1);\n            cleanEmptyNodes(editor.dom, node.parentNode, e => e === editor.dom.getRoot());\n          }\n        });\n      });\n      return true;\n    });\n    const handleInlineKey = (editor, patternSet) => {\n      const rng = editor.selection.getRng();\n      getParentBlock(editor, rng).map(block => {\n        const offset = Math.max(0, rng.startOffset - 1);\n        const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);\n        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);\n        const inlineMatches = findPatterns$2(editor, block, rng.startContainer, offset, dynamicPatternSet, false);\n        if (inlineMatches.length > 0) {\n          editor.undoManager.transact(() => {\n            applyMatches$2(editor, inlineMatches);\n          });\n        }\n      });\n    };\n    const handleBlockPatternOnSpace = (editor, patternSet) => getMatches(editor, patternSet).fold(never, matches => {\n      editor.undoManager.transact(() => {\n        applyMatches(editor, matches);\n      });\n      return true;\n    });\n    const checkKeyEvent = (codes, event, predicate) => {\n      for (let i = 0; i < codes.length; i++) {\n        if (predicate(codes[i], event)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {\n      return code === event.keyCode && !VK.modifierPressed(event);\n    });\n    const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {\n      return chr.charCodeAt(0) === event.charCode;\n    });\n\n    const setup$2 = editor => {\n      const charCodes = [\n        ',',\n        '.',\n        ';',\n        ':',\n        '!',\n        '?'\n      ];\n      const keyCodes = [32];\n      const getPatternSet = () => createPatternSet(getTextPatterns(editor), getTextPatternsLookup(editor));\n      const hasDynamicPatterns = () => hasTextPatternsLookup(editor);\n      editor.on('keydown', e => {\n        if (e.keyCode === 13 && !VK.modifierPressed(e) && editor.selection.isCollapsed()) {\n          const patternSet = filterByTrigger(getPatternSet(), 'enter');\n          const hasPatterns = patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0 || hasDynamicPatterns();\n          if (hasPatterns && handleEnter(editor, patternSet)) {\n            e.preventDefault();\n          }\n        }\n      }, true);\n      editor.on('keydown', e => {\n        if (e.keyCode === 32 && editor.selection.isCollapsed()) {\n          const patternSet = filterByTrigger(getPatternSet(), 'space');\n          const hasPatterns = patternSet.blockPatterns.length > 0 || hasDynamicPatterns();\n          if (hasPatterns && handleBlockPatternOnSpace(editor, patternSet)) {\n            e.preventDefault();\n          }\n        }\n      }, true);\n      const handleInlineTrigger = () => {\n        if (editor.selection.isCollapsed()) {\n          const patternSet = filterByTrigger(getPatternSet(), 'space');\n          const hasPatterns = patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();\n          if (hasPatterns) {\n            handleInlineKey(editor, patternSet);\n          }\n        }\n      };\n      editor.on('keyup', e => {\n        if (checkKeyCode(keyCodes, e)) {\n          handleInlineTrigger();\n        }\n      });\n      editor.on('keypress', e => {\n        if (checkCharCode(charCodes, e)) {\n          Delay.setEditorTimeout(editor, handleInlineTrigger);\n        }\n      });\n    };\n\n    const setup$1 = editor => {\n      setup$2(editor);\n    };\n\n    const Quirks = editor => {\n      const each = Tools.each;\n      const BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, parser = editor.parser;\n      const browser = Env.browser;\n      const isGecko = browser.isFirefox();\n      const isWebKit = browser.isChromium() || browser.isSafari();\n      const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      const setEditorCommandState = (cmd, state) => {\n        try {\n          editor.getDoc().execCommand(cmd, false, String(state));\n        } catch (ex) {\n        }\n      };\n      const isDefaultPrevented = e => {\n        return e.isDefaultPrevented();\n      };\n      const emptyEditorWhenDeleting = () => {\n        const serializeRng = rng => {\n          const body = dom.create('body');\n          const contents = rng.cloneContents();\n          body.appendChild(contents);\n          return selection.serializer.serialize(body, { format: 'html' });\n        };\n        const allContentsSelected = rng => {\n          const selection = serializeRng(rng);\n          const allRng = dom.createRng();\n          allRng.selectNode(editor.getBody());\n          const allSelection = serializeRng(allRng);\n          return selection === allSelection;\n        };\n        editor.on('keydown', e => {\n          const keyCode = e.keyCode;\n          if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE) && editor.selection.isEditable()) {\n            const isCollapsed = editor.selection.isCollapsed();\n            const body = editor.getBody();\n            if (isCollapsed && !isEmptyNode(editor.schema, body)) {\n              return;\n            }\n            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {\n              return;\n            }\n            e.preventDefault();\n            editor.setContent('');\n            if (body.firstChild && dom.isBlock(body.firstChild)) {\n              editor.selection.setCursorLocation(body.firstChild, 0);\n            } else {\n              editor.selection.setCursorLocation(body, 0);\n            }\n            editor.nodeChanged();\n          }\n        });\n      };\n      const selectAll = () => {\n        editor.shortcuts.add('meta+a', null, 'SelectAll');\n      };\n      const documentElementEditingFocus = () => {\n        if (!editor.inline) {\n          dom.bind(editor.getDoc(), 'mousedown mouseup', e => {\n            let rng;\n            if (e.target === editor.getDoc().documentElement) {\n              rng = selection.getRng();\n              editor.getBody().focus();\n              if (e.type === 'mousedown') {\n                if (isCaretContainer$2(rng.startContainer)) {\n                  return;\n                }\n                selection.placeCaretAt(e.clientX, e.clientY);\n              } else {\n                selection.setRng(rng);\n              }\n            }\n          });\n        }\n      };\n      const removeHrOnBackspace = () => {\n        editor.on('keydown', e => {\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n            if (!editor.getBody().getElementsByTagName('hr').length) {\n              return;\n            }\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n              const node = selection.getNode();\n              const previousSibling = node.previousSibling;\n              if (node.nodeName === 'HR') {\n                dom.remove(node);\n                e.preventDefault();\n                return;\n              }\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {\n                dom.remove(previousSibling);\n                e.preventDefault();\n              }\n            }\n          }\n        });\n      };\n      const focusBody = () => {\n        if (!Range.prototype.getClientRects) {\n          editor.on('mousedown', e => {\n            if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {\n              const body = editor.getBody();\n              body.blur();\n              Delay.setEditorTimeout(editor, () => {\n                body.focus();\n              });\n            }\n          });\n        }\n      };\n      const selectControlElements = () => {\n        const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);\n        editor.on('click', e => {\n          const target = e.target;\n          if (/^(IMG|HR)$/.test(target.nodeName) && dom.isEditable(target)) {\n            e.preventDefault();\n            editor.selection.select(target);\n            editor.nodeChanged();\n          }\n          if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom.isEditable(target.parentNode)) {\n            e.preventDefault();\n            selection.select(target);\n          }\n        });\n      };\n      const removeStylesWhenDeletingAcrossBlockElements = () => {\n        const getAttributeApplyFunction = () => {\n          const template = dom.getAttribs(selection.getStart().cloneNode(false));\n          return () => {\n            const target = selection.getStart();\n            if (target !== editor.getBody()) {\n              dom.setAttrib(target, 'style', null);\n              each(template, attr => {\n                target.setAttributeNode(attr.cloneNode(true));\n              });\n            }\n          };\n        };\n        const isSelectionAcrossElements = () => {\n          return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);\n        };\n        editor.on('keypress', e => {\n          let applyAttributes;\n          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {\n            applyAttributes = getAttributeApplyFunction();\n            editor.getDoc().execCommand('delete', false);\n            applyAttributes();\n            e.preventDefault();\n            return false;\n          } else {\n            return true;\n          }\n        });\n        dom.bind(editor.getDoc(), 'cut', e => {\n          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {\n            const applyAttributes = getAttributeApplyFunction();\n            Delay.setEditorTimeout(editor, () => {\n              applyAttributes();\n            });\n          }\n        });\n      };\n      const disableBackspaceIntoATable = () => {\n        editor.on('keydown', e => {\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n              const previousSibling = selection.getNode().previousSibling;\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {\n                e.preventDefault();\n                return false;\n              }\n            }\n          }\n          return true;\n        });\n      };\n      const removeBlockQuoteOnBackSpace = () => {\n        editor.on('keydown', e => {\n          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {\n            return;\n          }\n          let rng = selection.getRng();\n          const container = rng.startContainer;\n          const offset = rng.startOffset;\n          const root = dom.getRoot();\n          let parent = container;\n          if (!rng.collapsed || offset !== 0) {\n            return;\n          }\n          while (parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {\n            parent = parent.parentNode;\n          }\n          if (parent.nodeName === 'BLOCKQUOTE') {\n            editor.formatter.toggle('blockquote', undefined, parent);\n            rng = dom.createRng();\n            rng.setStart(container, 0);\n            rng.setEnd(container, 0);\n            selection.setRng(rng);\n          }\n        });\n      };\n      const setGeckoEditingOptions = () => {\n        const setOpts = () => {\n          setEditorCommandState('StyleWithCSS', false);\n          setEditorCommandState('enableInlineTableEditing', false);\n          if (!getObjectResizing(editor)) {\n            setEditorCommandState('enableObjectResizing', false);\n          }\n        };\n        if (!isReadOnly$1(editor)) {\n          editor.on('BeforeExecCommand mousedown', setOpts);\n        }\n      };\n      const addBrAfterLastLinks = () => {\n        const fixLinks = () => {\n          each(dom.select('a:not([data-mce-block])'), node => {\n            var _a;\n            let parentNode = node.parentNode;\n            const root = dom.getRoot();\n            if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {\n              while (parentNode && !dom.isBlock(parentNode)) {\n                if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root) {\n                  return;\n                }\n                parentNode = parentNode.parentNode;\n              }\n              dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });\n            }\n          });\n        };\n        editor.on('SetContent ExecCommand', e => {\n          if (e.type === 'setcontent' || e.command === 'mceInsertLink') {\n            fixLinks();\n          }\n        });\n      };\n      const setDefaultBlockType = () => {\n        editor.on('init', () => {\n          setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));\n        });\n      };\n      const isAllContentSelected = editor => {\n        const body = editor.getBody();\n        const rng = editor.selection.getRng();\n        return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;\n      };\n      const normalizeSelection = () => {\n        editor.on('keyup focusin mouseup', e => {\n          if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) {\n            selection.normalize();\n          }\n        }, true);\n      };\n      const showBrokenImageIcon = () => {\n        editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');\n      };\n      const restoreFocusOnKeyDown = () => {\n        if (!editor.inline) {\n          editor.on('keydown', () => {\n            if (document.activeElement === document.body) {\n              editor.getWin().focus();\n            }\n          });\n        }\n      };\n      const bodyHeight = () => {\n        if (!editor.inline) {\n          editor.contentStyles.push('body {min-height: 150px}');\n          editor.on('click', e => {\n            let rng;\n            if (e.target.nodeName === 'HTML') {\n              rng = editor.selection.getRng();\n              editor.getBody().focus();\n              editor.selection.setRng(rng);\n              editor.selection.normalize();\n              editor.nodeChanged();\n            }\n          });\n        }\n      };\n      const blockCmdArrowNavigation = () => {\n        if (isMac) {\n          editor.on('keydown', e => {\n            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {\n              e.preventDefault();\n              const selection = editor.selection.getSel();\n              selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');\n            }\n          });\n        }\n      };\n      const tapLinksAndImages = () => {\n        editor.on('click', e => {\n          let elm = e.target;\n          do {\n            if (elm.tagName === 'A') {\n              e.preventDefault();\n              return;\n            }\n          } while (elm = elm.parentNode);\n        });\n        editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');\n      };\n      const blockFormSubmitInsideEditor = () => {\n        editor.on('init', () => {\n          editor.dom.bind(editor.getBody(), 'submit', e => {\n            e.preventDefault();\n          });\n        });\n      };\n      const removeAppleInterchangeBrs = () => {\n        parser.addNodeFilter('br', nodes => {\n          let i = nodes.length;\n          while (i--) {\n            if (nodes[i].attr('class') === 'Apple-interchange-newline') {\n              nodes[i].remove();\n            }\n          }\n        });\n      };\n      const refreshContentEditable = noop;\n      const isHidden = () => {\n        if (!isGecko || editor.removed) {\n          return false;\n        }\n        const sel = editor.selection.getSel();\n        return !sel || !sel.rangeCount || sel.rangeCount === 0;\n      };\n      const setupRtc = () => {\n        if (isWebKit) {\n          documentElementEditingFocus();\n          selectControlElements();\n          blockFormSubmitInsideEditor();\n          selectAll();\n          if (isiOS) {\n            restoreFocusOnKeyDown();\n            bodyHeight();\n            tapLinksAndImages();\n          }\n        }\n        if (isGecko) {\n          focusBody();\n          setGeckoEditingOptions();\n          showBrokenImageIcon();\n          blockCmdArrowNavigation();\n        }\n      };\n      const setup = () => {\n        removeBlockQuoteOnBackSpace();\n        emptyEditorWhenDeleting();\n        if (!Env.windowsPhone) {\n          normalizeSelection();\n        }\n        if (isWebKit) {\n          documentElementEditingFocus();\n          selectControlElements();\n          setDefaultBlockType();\n          blockFormSubmitInsideEditor();\n          disableBackspaceIntoATable();\n          removeAppleInterchangeBrs();\n          if (isiOS) {\n            restoreFocusOnKeyDown();\n            bodyHeight();\n            tapLinksAndImages();\n          } else {\n            selectAll();\n          }\n        }\n        if (isGecko) {\n          removeHrOnBackspace();\n          focusBody();\n          removeStylesWhenDeletingAcrossBlockElements();\n          setGeckoEditingOptions();\n          addBrAfterLastLinks();\n          showBrokenImageIcon();\n          blockCmdArrowNavigation();\n          disableBackspaceIntoATable();\n        }\n      };\n      if (isRtc(editor)) {\n        setupRtc();\n      } else {\n        setup();\n      }\n      return {\n        refreshContentEditable,\n        isHidden\n      };\n    };\n\n    const isGplKey = key => key.toLowerCase() === 'gpl';\n    const isValidGeneratedKey = key => key.length >= 64 && key.length <= 255;\n    const validateLicenseKey = key => isGplKey(key) || isValidGeneratedKey(key) ? 'VALID' : 'INVALID';\n    const validateEditorLicenseKey = editor => {\n      const licenseKey = getLicenseKey(editor);\n      const hasApiKey = isString(getApiKey(editor));\n      if (!hasApiKey && (isUndefined(licenseKey) || validateLicenseKey(licenseKey) === 'INVALID')) {\n        console.warn(`TinyMCE is running in evaluation mode. Provide a valid license key or add license_key: 'gpl' to the init config to agree to the open source license terms. Read more at https://www.tiny.cloud/license-key/`);\n      }\n    };\n\n    const DOM$6 = DOMUtils.DOM;\n    const appendStyle = (editor, text) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const container = getStyleContainer(getRootNode(body));\n      const style = SugarElement.fromTag('style');\n      set$3(style, 'type', 'text/css');\n      append$1(style, SugarElement.fromText(text));\n      append$1(container, style);\n      editor.on('remove', () => {\n        remove$4(style);\n      });\n    };\n    const getRootName = editor => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;\n    const removeUndefined = obj => filter$4(obj, v => isUndefined(v) === false);\n    const mkParserSettings = editor => {\n      const getOption = editor.options.get;\n      const blobCache = editor.editorUpload.blobCache;\n      return removeUndefined({\n        allow_conditional_comments: getOption('allow_conditional_comments'),\n        allow_html_data_urls: getOption('allow_html_data_urls'),\n        allow_svg_data_urls: getOption('allow_svg_data_urls'),\n        allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),\n        allow_script_urls: getOption('allow_script_urls'),\n        allow_unsafe_link_target: getOption('allow_unsafe_link_target'),\n        convert_unsafe_embeds: getOption('convert_unsafe_embeds'),\n        convert_fonts_to_spans: getOption('convert_fonts_to_spans'),\n        fix_list_elements: getOption('fix_list_elements'),\n        font_size_legacy_values: getOption('font_size_legacy_values'),\n        forced_root_block: getOption('forced_root_block'),\n        forced_root_block_attrs: getOption('forced_root_block_attrs'),\n        preserve_cdata: getOption('preserve_cdata'),\n        inline_styles: getOption('inline_styles'),\n        root_name: getRootName(editor),\n        sandbox_iframes: getOption('sandbox_iframes'),\n        sandbox_iframes_exclusions: getSandboxIframesExclusions(editor),\n        sanitize: getOption('xss_sanitization'),\n        validate: true,\n        blob_cache: blobCache,\n        document: editor.getDoc()\n      });\n    };\n    const mkSchemaSettings = editor => {\n      const getOption = editor.options.get;\n      return removeUndefined({\n        custom_elements: getOption('custom_elements'),\n        extended_valid_elements: getOption('extended_valid_elements'),\n        invalid_elements: getOption('invalid_elements'),\n        invalid_styles: getOption('invalid_styles'),\n        schema: getOption('schema'),\n        valid_children: getOption('valid_children'),\n        valid_classes: getOption('valid_classes'),\n        valid_elements: getOption('valid_elements'),\n        valid_styles: getOption('valid_styles'),\n        verify_html: getOption('verify_html'),\n        padd_empty_block_inline_children: getOption('format_empty_lines')\n      });\n    };\n    const mkSerializerSettings = editor => {\n      const getOption = editor.options.get;\n      return {\n        ...mkParserSettings(editor),\n        ...mkSchemaSettings(editor),\n        ...removeUndefined({\n          remove_trailing_brs: getOption('remove_trailing_brs'),\n          pad_empty_with_br: getOption('pad_empty_with_br'),\n          url_converter: getOption('url_converter'),\n          url_converter_scope: getOption('url_converter_scope'),\n          element_format: getOption('element_format'),\n          entities: getOption('entities'),\n          entity_encoding: getOption('entity_encoding'),\n          indent: getOption('indent'),\n          indent_after: getOption('indent_after'),\n          indent_before: getOption('indent_before')\n        })\n      };\n    };\n    const createParser = editor => {\n      const parser = DomParser(mkParserSettings(editor), editor.schema);\n      parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {\n        const dom = editor.dom;\n        const internalName = 'data-mce-' + name;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr(name);\n          if (value && !node.attr(internalName)) {\n            if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {\n              continue;\n            }\n            if (name === 'style') {\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\n              if (!value.length) {\n                value = null;\n              }\n              node.attr(internalName, value);\n              node.attr(name, value);\n            } else if (name === 'tabindex') {\n              node.attr(internalName, value);\n              node.attr(name, null);\n            } else {\n              node.attr(internalName, editor.convertURL(value, name, node.name));\n            }\n          }\n        }\n      });\n      parser.addNodeFilter('script', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const type = node.attr('type') || 'no/type';\n          if (type.indexOf('mce-') !== 0) {\n            node.attr('type', 'mce-' + type);\n          }\n        }\n      });\n      if (shouldPreserveCData(editor)) {\n        parser.addNodeFilter('#cdata', nodes => {\n          var _a;\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            node.type = 8;\n            node.name = '#comment';\n            node.value = '[CDATA[' + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : '') + ']]';\n          }\n        });\n      }\n      parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', nodes => {\n        let i = nodes.length;\n        const nonEmptyElements = editor.schema.getNonEmptyElements();\n        while (i--) {\n          const node = nodes[i];\n          if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {\n            node.append(new AstNode('br', 1));\n          }\n        }\n      });\n      return parser;\n    };\n    const autoFocus = editor => {\n      const autoFocus = getAutoFocus(editor);\n      if (autoFocus) {\n        Delay.setEditorTimeout(editor, () => {\n          let focusEditor;\n          if (autoFocus === true) {\n            focusEditor = editor;\n          } else {\n            focusEditor = editor.editorManager.get(autoFocus);\n          }\n          if (focusEditor && !focusEditor.destroyed) {\n            focusEditor.focus();\n            focusEditor.selection.scrollIntoView();\n          }\n        }, 100);\n      }\n    };\n    const moveSelectionToFirstCaretPosition = editor => {\n      const root = editor.dom.getRoot();\n      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {\n        firstPositionIn(root).each(pos => {\n          const node = pos.getNode();\n          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\n          editor.selection.setRng(caretPos.toRange());\n        });\n      }\n    };\n    const initEditor = editor => {\n      editor.bindPendingEventDelegates();\n      editor.initialized = true;\n      fireInit(editor);\n      editor.focus(true);\n      moveSelectionToFirstCaretPosition(editor);\n      editor.nodeChanged({ initial: true });\n      const initInstanceCallback = getInitInstanceCallback(editor);\n      if (isFunction(initInstanceCallback)) {\n        initInstanceCallback.call(editor, editor);\n      }\n      autoFocus(editor);\n    };\n    const getStyleSheetLoader$1 = editor => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;\n    const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {\n      const {\n        pass: bundledCss,\n        fail: normalCss\n      } = partition$2(css, name => tinymce.Resource.has(toContentSkinResourceName(name)));\n      const bundledPromises = bundledCss.map(url => {\n        const css = tinymce.Resource.get(toContentSkinResourceName(url));\n        if (isString(css)) {\n          return Promise.resolve(getStyleSheetLoader$1(editor).loadRawCss(url, css));\n        }\n        return Promise.resolve();\n      });\n      const promises = [\n        ...bundledPromises,\n        getStyleSheetLoader$1(editor).loadAll(normalCss)\n      ];\n      if (editor.inline) {\n        return promises;\n      } else {\n        return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);\n      }\n    };\n    const loadContentCss = editor => {\n      const styleSheetLoader = getStyleSheetLoader$1(editor);\n      const fontCss = getFontCss(editor);\n      const css = editor.contentCSS;\n      const removeCss = () => {\n        styleSheetLoader.unloadAll(css);\n        if (!editor.inline) {\n          editor.ui.styleSheetLoader.unloadAll(fontCss);\n        }\n      };\n      const loaded = () => {\n        if (editor.removed) {\n          removeCss();\n        } else {\n          editor.on('remove', removeCss);\n        }\n      };\n      if (editor.contentStyles.length > 0) {\n        let contentCssText = '';\n        Tools.each(editor.contentStyles, style => {\n          contentCssText += style + '\\r\\n';\n        });\n        editor.dom.addStyle(contentCssText);\n      }\n      const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);\n      const contentStyle = getContentStyle(editor);\n      if (contentStyle) {\n        appendStyle(editor, contentStyle);\n      }\n      return allStylesheets;\n    };\n    const preInit = editor => {\n      const doc = editor.getDoc(), body = editor.getBody();\n      firePreInit(editor);\n      if (!shouldBrowserSpellcheck(editor)) {\n        doc.body.spellcheck = false;\n        DOM$6.setAttrib(body, 'spellcheck', 'false');\n      }\n      editor.quirks = Quirks(editor);\n      firePostRender(editor);\n      const directionality = getDirectionality(editor);\n      if (directionality !== undefined) {\n        body.dir = directionality;\n      }\n      const protect = getProtect(editor);\n      if (protect) {\n        editor.on('BeforeSetContent', e => {\n          Tools.each(protect, pattern => {\n            e.content = e.content.replace(pattern, str => {\n              return '<!--mce:protected ' + escape(str) + '-->';\n            });\n          });\n        });\n      }\n      editor.on('SetContent', () => {\n        editor.addVisual(editor.getBody());\n      });\n      editor.on('compositionstart compositionend', e => {\n        editor.composing = e.type === 'compositionstart';\n      });\n    };\n    const loadInitialContent = editor => {\n      if (!isRtc(editor)) {\n        editor.load({\n          initial: true,\n          format: 'html'\n        });\n      }\n      editor.startContent = editor.getContent({ format: 'raw' });\n    };\n    const initEditorWithInitialContent = editor => {\n      if (editor.removed !== true) {\n        loadInitialContent(editor);\n        initEditor(editor);\n      }\n    };\n    const startProgress = editor => {\n      let canceled = false;\n      const progressTimeout = setTimeout(() => {\n        if (!canceled) {\n          editor.setProgressState(true);\n        }\n      }, 500);\n      return () => {\n        clearTimeout(progressTimeout);\n        canceled = true;\n        editor.setProgressState(false);\n      };\n    };\n    const contentBodyLoaded = editor => {\n      const targetElm = editor.getElement();\n      let doc = editor.getDoc();\n      if (editor.inline) {\n        DOM$6.addClass(targetElm, 'mce-content-body');\n        editor.contentDocument = doc = document;\n        editor.contentWindow = window;\n        editor.bodyElement = targetElm;\n        editor.contentAreaContainer = targetElm;\n      }\n      const body = editor.getBody();\n      body.disabled = true;\n      editor.readonly = isReadOnly$1(editor);\n      editor._editableRoot = hasEditableRoot$1(editor);\n      if (!editor.readonly && editor.hasEditableRoot()) {\n        if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {\n          body.style.position = 'relative';\n        }\n        body.contentEditable = 'true';\n      }\n      body.disabled = false;\n      editor.editorUpload = EditorUpload(editor);\n      editor.schema = Schema(mkSchemaSettings(editor));\n      editor.dom = DOMUtils(doc, {\n        keep_values: true,\n        url_converter: editor.convertURL,\n        url_converter_scope: editor,\n        update_styles: true,\n        root_element: editor.inline ? editor.getBody() : null,\n        collect: editor.inline,\n        schema: editor.schema,\n        contentCssCors: shouldUseContentCssCors(editor),\n        referrerPolicy: getReferrerPolicy(editor),\n        onSetAttrib: e => {\n          editor.dispatch('SetAttrib', e);\n        }\n      });\n      editor.parser = createParser(editor);\n      editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);\n      editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);\n      editor.annotator = Annotator(editor);\n      editor.formatter = Formatter(editor);\n      editor.undoManager = UndoManager(editor);\n      editor._nodeChangeDispatcher = new NodeChange(editor);\n      editor._selectionOverrides = SelectionOverrides(editor);\n      setup$p(editor);\n      setup$6(editor);\n      setup$n(editor);\n      if (!isRtc(editor)) {\n        setup$5(editor);\n        setup$1(editor);\n      }\n      const caret = setup$b(editor);\n      setup$q(editor, caret);\n      setup$o(editor);\n      setup$r(editor);\n      setup$7(editor);\n      const setupRtcThunk = setup$t(editor);\n      preInit(editor);\n      validateEditorLicenseKey(editor);\n      setupRtcThunk.fold(() => {\n        const cancelProgress = startProgress(editor);\n        loadContentCss(editor).then(() => {\n          initEditorWithInitialContent(editor);\n          cancelProgress();\n        });\n      }, setupRtc => {\n        editor.setProgressState(true);\n        loadContentCss(editor).then(() => {\n          setupRtc().then(_rtcMode => {\n            editor.setProgressState(false);\n            initEditorWithInitialContent(editor);\n            bindEvents(editor);\n          }, err => {\n            editor.notificationManager.open({\n              type: 'error',\n              text: String(err)\n            });\n            initEditorWithInitialContent(editor);\n            bindEvents(editor);\n          });\n        });\n      });\n    };\n\n    const filter = always;\n    const bind = (element, event, handler) => bind$2(element, event, filter, handler);\n\n    const DOM$5 = DOMUtils.DOM;\n    const createIframeElement = (id, title, customAttrs, tabindex) => {\n      const iframe = SugarElement.fromTag('iframe');\n      tabindex.each(t => set$3(iframe, 'tabindex', t));\n      setAll$1(iframe, customAttrs);\n      setAll$1(iframe, {\n        id: id + '_ifr',\n        frameBorder: '0',\n        allowTransparency: 'true',\n        title\n      });\n      add$2(iframe, 'tox-edit-area__iframe');\n      return iframe;\n    };\n    const getIframeHtml = editor => {\n      let iframeHTML = getDocType(editor) + '<html><head>';\n      if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {\n        iframeHTML += '<base href=\"' + editor.documentBaseURI.getURI() + '\" />';\n      }\n      iframeHTML += '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />';\n      const bodyId = getBodyId(editor);\n      const bodyClass = getBodyClass(editor);\n      const translatedAriaText = editor.translate(getIframeAriaText(editor));\n      if (getContentSecurityPolicy(editor)) {\n        iframeHTML += '<meta http-equiv=\"Content-Security-Policy\" content=\"' + getContentSecurityPolicy(editor) + '\" />';\n      }\n      iframeHTML += '</head>' + `<body id=\"${ bodyId }\" class=\"mce-content-body ${ bodyClass }\" data-id=\"${ editor.id }\" aria-label=\"${ translatedAriaText }\">` + '<br>' + '</body></html>';\n      return iframeHTML;\n    };\n    const createIframe = (editor, boxInfo) => {\n      const iframeTitle = Env.browser.isFirefox() ? getIframeAriaText(editor) : 'Rich Text Area';\n      const translatedTitle = editor.translate(iframeTitle);\n      const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);\n      const ifr = createIframeElement(editor.id, translatedTitle, getIframeAttrs(editor), tabindex).dom;\n      ifr.onload = () => {\n        ifr.onload = null;\n        editor.dispatch('load');\n      };\n      editor.contentAreaContainer = boxInfo.iframeContainer;\n      editor.iframeElement = ifr;\n      editor.iframeHTML = getIframeHtml(editor);\n      DOM$5.add(boxInfo.iframeContainer, ifr);\n    };\n    const setupIframeBody = editor => {\n      const iframe = editor.iframeElement;\n      const ready = () => {\n        editor.contentDocument = iframe.contentDocument;\n        contentBodyLoaded(editor);\n      };\n      if (shouldUseDocumentWrite(editor) || Env.browser.isFirefox()) {\n        const doc = editor.getDoc();\n        doc.open();\n        doc.write(editor.iframeHTML);\n        doc.close();\n        ready();\n      } else {\n        const binder = bind(SugarElement.fromDom(iframe), 'load', () => {\n          binder.unbind();\n          ready();\n        });\n        iframe.srcdoc = editor.iframeHTML;\n      }\n    };\n    const init$1 = (editor, boxInfo) => {\n      createIframe(editor, boxInfo);\n      if (boxInfo.editorContainer) {\n        boxInfo.editorContainer.style.display = editor.orgDisplay;\n        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);\n      }\n      editor.getElement().style.display = 'none';\n      DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');\n      editor.getElement().style.visibility = editor.orgVisibility;\n      setupIframeBody(editor);\n    };\n\n    const DOM$4 = DOMUtils.DOM;\n    const initPlugin = (editor, initializedPlugins, plugin) => {\n      const Plugin = PluginManager.get(plugin);\n      const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\\/$/, '');\n      plugin = Tools.trim(plugin);\n      if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {\n        if (editor.plugins[plugin]) {\n          return;\n        }\n        try {\n          const pluginInstance = Plugin(editor, pluginUrl) || {};\n          editor.plugins[plugin] = pluginInstance;\n          if (isFunction(pluginInstance.init)) {\n            pluginInstance.init(editor, pluginUrl);\n            initializedPlugins.push(plugin);\n          }\n        } catch (e) {\n          pluginInitError(editor, plugin, e);\n        }\n      }\n    };\n    const trimLegacyPrefix = name => {\n      return name.replace(/^\\-/, '');\n    };\n    const initPlugins = editor => {\n      const initializedPlugins = [];\n      each$e(getPlugins(editor), name => {\n        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));\n      });\n    };\n    const initIcons = editor => {\n      const iconPackName = Tools.trim(getIconPackName(editor));\n      const currentIcons = editor.ui.registry.getAll().icons;\n      const loadIcons = {\n        ...IconManager.get('default').icons,\n        ...IconManager.get(iconPackName).icons\n      };\n      each$d(loadIcons, (svgData, icon) => {\n        if (!has$2(currentIcons, icon)) {\n          editor.ui.registry.addIcon(icon, svgData);\n        }\n      });\n    };\n    const initTheme = editor => {\n      const theme = getTheme(editor);\n      if (isString(theme)) {\n        const Theme = ThemeManager.get(theme);\n        editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};\n        if (isFunction(editor.theme.init)) {\n          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\\/$/, ''));\n        }\n      } else {\n        editor.theme = {};\n      }\n    };\n    const initModel = editor => {\n      const model = getModel(editor);\n      const Model = ModelManager.get(model);\n      editor.model = Model(editor, ModelManager.urls[model]);\n    };\n    const renderFromLoadedTheme = editor => {\n      const render = editor.theme.renderUI;\n      return render ? render() : renderThemeFalse(editor);\n    };\n    const renderFromThemeFunc = editor => {\n      const elm = editor.getElement();\n      const theme = getTheme(editor);\n      const info = theme(editor, elm);\n      if (info.editorContainer.nodeType) {\n        info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';\n      }\n      if (info.iframeContainer && info.iframeContainer.nodeType) {\n        info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';\n      }\n      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;\n      return info;\n    };\n    const createThemeFalseResult = (element, iframe) => {\n      return {\n        editorContainer: element,\n        iframeContainer: iframe,\n        api: {}\n      };\n    };\n    const renderThemeFalseIframe = targetElement => {\n      const iframeContainer = DOM$4.create('div');\n      DOM$4.insertAfter(iframeContainer, targetElement);\n      return createThemeFalseResult(iframeContainer, iframeContainer);\n    };\n    const renderThemeFalse = editor => {\n      const targetElement = editor.getElement();\n      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);\n    };\n    const renderThemeUi = editor => {\n      const elm = editor.getElement();\n      editor.orgDisplay = elm.style.display;\n      if (isString(getTheme(editor))) {\n        return renderFromLoadedTheme(editor);\n      } else if (isFunction(getTheme(editor))) {\n        return renderFromThemeFunc(editor);\n      } else {\n        return renderThemeFalse(editor);\n      }\n    };\n    const augmentEditorUiApi = (editor, api) => {\n      const uiApiFacade = {\n        show: Optional.from(api.show).getOr(noop),\n        hide: Optional.from(api.hide).getOr(noop),\n        isEnabled: Optional.from(api.isEnabled).getOr(always),\n        setEnabled: state => {\n          if (!editor.mode.isReadOnly()) {\n            Optional.from(api.setEnabled).each(f => f(state));\n          }\n        }\n      };\n      editor.ui = {\n        ...editor.ui,\n        ...uiApiFacade\n      };\n    };\n    const init = async editor => {\n      editor.dispatch('ScriptsLoaded');\n      initIcons(editor);\n      initTheme(editor);\n      initModel(editor);\n      initPlugins(editor);\n      const renderInfo = await renderThemeUi(editor);\n      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));\n      editor.editorContainer = renderInfo.editorContainer;\n      appendContentCssFromSettings(editor);\n      if (editor.inline) {\n        contentBodyLoaded(editor);\n      } else {\n        init$1(editor, {\n          editorContainer: renderInfo.editorContainer,\n          iframeContainer: renderInfo.iframeContainer\n        });\n      }\n    };\n\n    const DOM$3 = DOMUtils.DOM;\n    const hasSkipLoadPrefix = name => name.charAt(0) === '-';\n    const loadLanguage = (scriptLoader, editor) => {\n      const languageCode = getLanguageCode(editor);\n      const languageUrl = getLanguageUrl(editor);\n      if (!I18n.hasCode(languageCode) && languageCode !== 'en') {\n        const url = isNotEmpty(languageUrl) ? languageUrl : `${ editor.editorManager.baseURL }/langs/${ languageCode }.js`;\n        scriptLoader.add(url).catch(() => {\n          languageLoadError(editor, url, languageCode);\n        });\n      }\n    };\n    const loadTheme = (editor, suffix) => {\n      const theme = getTheme(editor);\n      if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {\n        const themeUrl = getThemeUrl(editor);\n        const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${ theme }/theme${ suffix }.js`;\n        ThemeManager.load(theme, url).catch(() => {\n          themeLoadError(editor, url, theme);\n        });\n      }\n    };\n    const loadModel = (editor, suffix) => {\n      const model = getModel(editor);\n      if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {\n        const modelUrl = getModelUrl(editor);\n        const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${ model }/model${ suffix }.js`;\n        ModelManager.load(model, url).catch(() => {\n          modelLoadError(editor, url, model);\n        });\n      }\n    };\n    const getIconsUrlMetaFromUrl = editor => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map(url => ({\n      url,\n      name: Optional.none()\n    }));\n    const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name).filter(name => isNotEmpty(name) && !IconManager.has(name)).map(name => ({\n      url: `${ editor.editorManager.baseURL }/icons/${ name }/icons${ suffix }.js`,\n      name: Optional.some(name)\n    }));\n    const loadIcons = (scriptLoader, editor, suffix) => {\n      const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);\n      const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));\n      each$e(cat([\n        defaultIconsUrl,\n        customIconsUrl\n      ]), urlMeta => {\n        scriptLoader.add(urlMeta.url).catch(() => {\n          iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());\n        });\n      });\n    };\n    const loadPlugins = (editor, suffix) => {\n      const loadPlugin = (name, url) => {\n        PluginManager.load(name, url).catch(() => {\n          pluginLoadError(editor, url, name);\n        });\n      };\n      each$d(getExternalPlugins$1(editor), (url, name) => {\n        loadPlugin(name, url);\n        editor.options.set('plugins', getPlugins(editor).concat(name));\n      });\n      each$e(getPlugins(editor), plugin => {\n        plugin = Tools.trim(plugin);\n        if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {\n          loadPlugin(plugin, `plugins/${ plugin }/plugin${ suffix }.js`);\n        }\n      });\n    };\n    const isThemeLoaded = editor => {\n      const theme = getTheme(editor);\n      return !isString(theme) || isNonNullable(ThemeManager.get(theme));\n    };\n    const isModelLoaded = editor => {\n      const model = getModel(editor);\n      return isNonNullable(ModelManager.get(model));\n    };\n    const loadScripts = (editor, suffix) => {\n      const scriptLoader = ScriptLoader.ScriptLoader;\n      const initEditor = () => {\n        if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {\n          init(editor);\n        }\n      };\n      loadTheme(editor, suffix);\n      loadModel(editor, suffix);\n      loadLanguage(scriptLoader, editor);\n      loadIcons(scriptLoader, editor, suffix);\n      loadPlugins(editor, suffix);\n      scriptLoader.loadQueue().then(initEditor, initEditor);\n    };\n    const getStyleSheetLoader = (element, editor) => instance.forElement(element, {\n      contentCssCors: hasContentCssCors(editor),\n      referrerPolicy: getReferrerPolicy(editor)\n    });\n    const render = editor => {\n      const id = editor.id;\n      I18n.setCode(getLanguageCode(editor));\n      const readyHandler = () => {\n        DOM$3.unbind(window, 'ready', readyHandler);\n        editor.render();\n      };\n      if (!EventUtils.Event.domLoaded) {\n        DOM$3.bind(window, 'ready', readyHandler);\n        return;\n      }\n      if (!editor.getElement()) {\n        return;\n      }\n      const element = SugarElement.fromDom(editor.getElement());\n      const snapshot = clone$4(element);\n      editor.on('remove', () => {\n        eachr(element.dom.attributes, attr => remove$9(element, attr.name));\n        setAll$1(element, snapshot);\n      });\n      editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);\n      if (!isInline$1(editor)) {\n        editor.orgVisibility = editor.getElement().style.visibility;\n        editor.getElement().style.visibility = 'hidden';\n      } else {\n        editor.inline = true;\n      }\n      const form = editor.getElement().form || DOM$3.getParent(id, 'form');\n      if (form) {\n        editor.formElement = form;\n        if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {\n          DOM$3.insertAfter(DOM$3.create('input', {\n            type: 'hidden',\n            name: id\n          }), id);\n          editor.hasHiddenInput = true;\n        }\n        editor.formEventDelegate = e => {\n          editor.dispatch(e.type, e);\n        };\n        DOM$3.bind(form, 'submit reset', editor.formEventDelegate);\n        editor.on('reset', () => {\n          editor.resetContent();\n        });\n        if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {\n          form._mceOldSubmit = form.submit;\n          form.submit = () => {\n            editor.editorManager.triggerSave();\n            editor.setDirty(false);\n            return form._mceOldSubmit(form);\n          };\n        }\n      }\n      editor.windowManager = WindowManager(editor);\n      editor.notificationManager = NotificationManager(editor);\n      if (isEncodingXml(editor)) {\n        editor.on('GetContent', e => {\n          if (e.save) {\n            e.content = DOM$3.encode(e.content);\n          }\n        });\n      }\n      if (shouldAddFormSubmitTrigger(editor)) {\n        editor.on('submit', () => {\n          if (editor.initialized) {\n            editor.save();\n          }\n        });\n      }\n      if (shouldAddUnloadTrigger(editor)) {\n        editor._beforeUnload = () => {\n          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {\n            editor.save({\n              format: 'raw',\n              no_events: true,\n              set_dirty: false\n            });\n          }\n        };\n        editor.editorManager.on('BeforeUnload', editor._beforeUnload);\n      }\n      editor.editorManager.add(editor);\n      loadScripts(editor, editor.suffix);\n    };\n\n    const setEditableRoot = (editor, state) => {\n      if (editor._editableRoot !== state) {\n        editor._editableRoot = state;\n        if (!editor.readonly) {\n          editor.getBody().contentEditable = String(editor.hasEditableRoot());\n          editor.nodeChanged();\n        }\n        fireEditableRootStateChange(editor, state);\n      }\n    };\n    const hasEditableRoot = editor => editor._editableRoot;\n\n    const sectionResult = (sections, settings) => ({\n      sections: constant(sections),\n      options: constant(settings)\n    });\n    const deviceDetection = detect$1().deviceType;\n    const isPhone = deviceDetection.isPhone();\n    const isTablet = deviceDetection.isTablet();\n    const normalizePlugins = plugins => {\n      if (isNullable(plugins)) {\n        return [];\n      } else {\n        const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);\n        const trimmedPlugins = map$3(pluginNames, trim$4);\n        return filter$5(trimmedPlugins, isNotEmpty);\n      }\n    };\n    const extractSections = (keys, options) => {\n      const result = bifilter(options, (value, key) => {\n        return contains$2(keys, key);\n      });\n      return sectionResult(result.t, result.f);\n    };\n    const getSection = (sectionResult, name, defaults = {}) => {\n      const sections = sectionResult.sections();\n      const sectionOptions = get$a(sections, name).getOr({});\n      return Tools.extend({}, defaults, sectionOptions);\n    };\n    const hasSection = (sectionResult, name) => {\n      return has$2(sectionResult.sections(), name);\n    };\n    const getSectionConfig = (sectionResult, name) => {\n      return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};\n    };\n    const getMobileOverrideOptions = (mobileOptions, isPhone) => {\n      const defaultMobileOptions = {\n        table_grid: false,\n        object_resizing: false,\n        resize: false,\n        toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'),\n        toolbar_sticky: false\n      };\n      const defaultPhoneOptions = { menubar: false };\n      return {\n        ...defaultMobileOptions,\n        ...isPhone ? defaultPhoneOptions : {}\n      };\n    };\n    const getExternalPlugins = (overrideOptions, options) => {\n      var _a;\n      const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};\n      if (overrideOptions && overrideOptions.external_plugins) {\n        return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);\n      } else {\n        return userDefinedExternalPlugins;\n      }\n    };\n    const combinePlugins = (forcedPlugins, plugins) => [\n      ...normalizePlugins(forcedPlugins),\n      ...normalizePlugins(plugins)\n    ];\n    const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {\n      if (isMobileDevice && hasSection(sectionResult, 'mobile')) {\n        return mobilePlugins;\n      } else {\n        return desktopPlugins;\n      }\n    };\n    const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {\n      const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);\n      const desktopPlugins = normalizePlugins(options.plugins);\n      const mobileConfig = getSectionConfig(sectionResult, 'mobile');\n      const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;\n      const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);\n      const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);\n      return Tools.extend(options, {\n        forced_plugins: forcedPlugins,\n        plugins: combinedPlugins\n      });\n    };\n    const isOnMobile = (isMobileDevice, sectionResult) => {\n      return isMobileDevice && hasSection(sectionResult, 'mobile');\n    };\n    const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {\n      var _a;\n      const deviceOverrideOptions = isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone) } : {};\n      const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));\n      const extendedOptions = Tools.extend(defaultOptions, defaultOverrideOptions, sectionResult.options(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, { external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options()) });\n      return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);\n    };\n    const normalizeOptions = (defaultOverrideOptions, options) => {\n      const copiedOptions = merge(options);\n      return combineOptions(isPhone || isTablet, isPhone, copiedOptions, defaultOverrideOptions, copiedOptions);\n    };\n\n    const addVisual = (editor, elm) => addVisual$1(editor, elm);\n\n    const registerExecCommands$2 = editor => {\n      const toggleFormat = (name, value) => {\n        editor.formatter.toggle(name, value);\n        editor.nodeChanged();\n      };\n      const toggleAlign = align => () => {\n        each$e('left,center,right,justify'.split(','), name => {\n          if (align !== name) {\n            editor.formatter.remove('align' + name);\n          }\n        });\n        if (align !== 'none') {\n          toggleFormat('align' + align);\n        }\n      };\n      editor.editorCommands.addCommands({\n        JustifyLeft: toggleAlign('left'),\n        JustifyCenter: toggleAlign('center'),\n        JustifyRight: toggleAlign('right'),\n        JustifyFull: toggleAlign('justify'),\n        JustifyNone: toggleAlign('none')\n      });\n    };\n    const registerQueryStateCommands = editor => {\n      const alignStates = name => () => {\n        const selection = editor.selection;\n        const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();\n        return exists(nodes, node => isNonNullable(editor.formatter.matchNode(node, name)));\n      };\n      editor.editorCommands.addCommands({\n        JustifyLeft: alignStates('alignleft'),\n        JustifyCenter: alignStates('aligncenter'),\n        JustifyRight: alignStates('alignright'),\n        JustifyFull: alignStates('alignjustify')\n      }, 'state');\n    };\n    const registerCommands$a = editor => {\n      registerExecCommands$2(editor);\n      registerQueryStateCommands(editor);\n    };\n\n    const registerCommands$9 = editor => {\n      editor.editorCommands.addCommands({\n        'Cut,Copy,Paste': command => {\n          const doc = editor.getDoc();\n          let failed;\n          try {\n            doc.execCommand(command);\n          } catch (ex) {\n            failed = true;\n          }\n          if (command === 'paste' && !doc.queryCommandEnabled(command)) {\n            failed = true;\n          }\n          if (failed || !doc.queryCommandSupported(command)) {\n            let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');\n            if (Env.os.isMacOS() || Env.os.isiOS()) {\n              msg = msg.replace(/Ctrl\\+/g, '\\u2318+');\n            }\n            editor.notificationManager.open({\n              text: msg,\n              type: 'error'\n            });\n          }\n        }\n      });\n    };\n\n    const trimOrPadLeftRight = (dom, rng, html, schema) => {\n      const root = SugarElement.fromDom(dom.getRoot());\n      if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng), schema)) {\n        html = html.replace(/^ /, '&nbsp;');\n      } else {\n        html = html.replace(/^&nbsp;/, ' ');\n      }\n      if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng), schema)) {\n        html = html.replace(/(&nbsp;| )(<br( \\/)>)?$/, '&nbsp;');\n      } else {\n        html = html.replace(/&nbsp;(<br( \\/)?>)?$/, ' ');\n      }\n      return html;\n    };\n\n    const processValue$1 = value => {\n      if (typeof value !== 'string') {\n        const details = Tools.extend({\n          paste: value.paste,\n          data: { paste: value.paste }\n        }, value);\n        return {\n          content: value.content,\n          details\n        };\n      }\n      return {\n        content: value,\n        details: {}\n      };\n    };\n    const trimOrPad = (editor, value) => {\n      const selection = editor.selection;\n      const dom = editor.dom;\n      if (/^ | $/.test(value)) {\n        return trimOrPadLeftRight(dom, selection.getRng(), value, editor.schema);\n      } else {\n        return value;\n      }\n    };\n    const insertAtCaret = (editor, value) => {\n      if (editor.selection.isEditable()) {\n        const {content, details} = processValue$1(value);\n        preProcessSetContent(editor, {\n          ...details,\n          content: trimOrPad(editor, content),\n          format: 'html',\n          set: false,\n          selection: true\n        }).each(args => {\n          const insertedContent = insertContent$1(editor, args.content, details);\n          postProcessSetContent(editor, insertedContent, args);\n          editor.addVisual();\n        });\n      }\n    };\n\n    const registerCommands$8 = editor => {\n      editor.editorCommands.addCommands({\n        mceCleanup: () => {\n          const bm = editor.selection.getBookmark();\n          editor.setContent(editor.getContent());\n          editor.selection.moveToBookmark(bm);\n        },\n        insertImage: (_command, _ui, value) => {\n          insertAtCaret(editor, editor.dom.createHTML('img', { src: value }));\n        },\n        insertHorizontalRule: () => {\n          editor.execCommand('mceInsertContent', false, '<hr>');\n        },\n        insertText: (_command, _ui, value) => {\n          insertAtCaret(editor, editor.dom.encode(value));\n        },\n        insertHTML: (_command, _ui, value) => {\n          insertAtCaret(editor, value);\n        },\n        mceInsertContent: (_command, _ui, value) => {\n          insertAtCaret(editor, value);\n        },\n        mceSetContent: (_command, _ui, value) => {\n          editor.setContent(value);\n        },\n        mceReplaceContent: (_command, _ui, value) => {\n          editor.execCommand('mceInsertContent', false, value.replace(/\\{\\$selection\\}/g, editor.selection.getContent({ format: 'text' })));\n        },\n        mceNewDocument: () => {\n          editor.setContent(getNewDocumentContent(editor));\n        }\n      });\n    };\n\n    const legacyPropNames = {\n      'font-size': 'size',\n      'font-family': 'face'\n    };\n    const isFont = isTag('font');\n    const getSpecifiedFontProp = (propName, rootElm, elm) => {\n      const getProperty = elm => getRaw(elm, propName).orThunk(() => {\n        if (isFont(elm)) {\n          return get$a(legacyPropNames, propName).bind(legacyPropName => getOpt(elm, legacyPropName));\n        } else {\n          return Optional.none();\n        }\n      });\n      const isRoot = elm => eq(SugarElement.fromDom(rootElm), elm);\n      return closest$1(SugarElement.fromDom(elm), elm => getProperty(elm), isRoot);\n    };\n    const normalizeFontFamily = fontFamily => fontFamily.replace(/[\\'\\\"\\\\]/g, '').replace(/,\\s+/g, ',');\n    const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));\n    const getFontProp = propName => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind(element => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr('');\n    const getFontSize = getFontProp('font-size');\n    const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));\n\n    const findFirstCaretElement = editor => firstPositionIn(editor.getBody()).bind(caret => {\n      const container = caret.container();\n      return Optional.from(isText$b(container) ? container.parentNode : container);\n    });\n    const getCaretElement = editor => Optional.from(editor.selection.getRng()).bind(rng => {\n      const root = editor.getBody();\n      const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;\n      return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));\n    });\n    const bindRange = (editor, binder) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder);\n    const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));\n\n    const fromFontSizeNumber = (editor, value) => {\n      if (/^[0-9.]+$/.test(value)) {\n        const fontSizeNumber = parseInt(value, 10);\n        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {\n          const fontSizes = getFontStyleValues(editor);\n          const fontClasses = getFontSizeClasses(editor);\n          if (fontClasses.length > 0) {\n            return fontClasses[fontSizeNumber - 1] || value;\n          } else {\n            return fontSizes[fontSizeNumber - 1] || value;\n          }\n        } else {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    };\n    const normalizeFontNames = font => {\n      const fonts = font.split(/\\s*,\\s*/);\n      return map$3(fonts, font => {\n        if (font.indexOf(' ') !== -1 && !(startsWith(font, '\"') || startsWith(font, `'`))) {\n          return `'${ font }'`;\n        } else {\n          return font;\n        }\n      }).join(',');\n    };\n    const fontNameAction = (editor, value) => {\n      const font = fromFontSizeNumber(editor, value);\n      editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });\n      editor.nodeChanged();\n    };\n    const fontNameQuery = editor => mapRange(editor, elm => getFontFamily(editor.getBody(), elm.dom)).getOr('');\n    const fontSizeAction = (editor, value) => {\n      editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });\n      editor.nodeChanged();\n    };\n    const fontSizeQuery = editor => mapRange(editor, elm => getFontSize(editor.getBody(), elm.dom)).getOr('');\n\n    const lineHeightQuery = editor => mapRange(editor, elm => {\n      const root = SugarElement.fromDom(editor.getBody());\n      const specifiedStyle = closest$1(elm, elm => getRaw(elm, 'line-height'), curry(eq, root));\n      const computedStyle = () => {\n        const lineHeight = parseFloat(get$7(elm, 'line-height'));\n        const fontSize = parseFloat(get$7(elm, 'font-size'));\n        return String(lineHeight / fontSize);\n      };\n      return specifiedStyle.getOrThunk(computedStyle);\n    }).getOr('');\n    const lineHeightAction = (editor, lineHeight) => {\n      editor.formatter.toggle('lineheight', { value: String(lineHeight) });\n      editor.nodeChanged();\n    };\n\n    const registerExecCommands$1 = editor => {\n      const toggleFormat = (name, value) => {\n        editor.formatter.toggle(name, value);\n        editor.nodeChanged();\n      };\n      editor.editorCommands.addCommands({\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => {\n          toggleFormat(command);\n        },\n        'ForeColor,HiliteColor': (command, _ui, value) => {\n          toggleFormat(command, { value });\n        },\n        'BackColor': (_command, _ui, value) => {\n          toggleFormat('hilitecolor', { value });\n        },\n        'FontName': (_command, _ui, value) => {\n          fontNameAction(editor, value);\n        },\n        'FontSize': (_command, _ui, value) => {\n          fontSizeAction(editor, value);\n        },\n        'LineHeight': (_command, _ui, value) => {\n          lineHeightAction(editor, value);\n        },\n        'Lang': (command, _ui, lang) => {\n          var _a;\n          toggleFormat(command, {\n            value: lang.code,\n            customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null\n          });\n        },\n        'RemoveFormat': command => {\n          editor.formatter.remove(command);\n        },\n        'mceBlockQuote': () => {\n          toggleFormat('blockquote');\n        },\n        'FormatBlock': (_command, _ui, value) => {\n          toggleFormat(isString(value) ? value : 'p');\n        },\n        'mceToggleFormat': (_command, _ui, value) => {\n          toggleFormat(value);\n        }\n      });\n    };\n    const registerQueryValueCommands = editor => {\n      const isFormatMatch = name => editor.formatter.match(name);\n      editor.editorCommands.addCommands({\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => isFormatMatch(command),\n        'mceBlockQuote': () => isFormatMatch('blockquote')\n      }, 'state');\n      editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));\n      editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));\n      editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));\n    };\n    const registerCommands$7 = editor => {\n      registerExecCommands$1(editor);\n      registerQueryValueCommands(editor);\n    };\n\n    const registerCommands$6 = editor => {\n      editor.editorCommands.addCommands({\n        mceAddUndoLevel: () => {\n          editor.undoManager.add();\n        },\n        mceEndUndoLevel: () => {\n          editor.undoManager.add();\n        },\n        Undo: () => {\n          editor.undoManager.undo();\n        },\n        Redo: () => {\n          editor.undoManager.redo();\n        }\n      });\n    };\n\n    const registerCommands$5 = editor => {\n      editor.editorCommands.addCommands({\n        Indent: () => {\n          indent(editor);\n        },\n        Outdent: () => {\n          outdent(editor);\n        }\n      });\n      editor.editorCommands.addCommands({ Outdent: () => canOutdent(editor) }, 'state');\n    };\n\n    const registerCommands$4 = editor => {\n      const applyLinkToSelection = (_command, _ui, value) => {\n        const linkDetails = isString(value) ? { href: value } : value;\n        const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');\n        if (isObject(linkDetails) && isString(linkDetails.href)) {\n          linkDetails.href = linkDetails.href.replace(/ /g, '%20');\n          if (!anchor || !linkDetails.href) {\n            editor.formatter.remove('link');\n          }\n          if (linkDetails.href) {\n            editor.formatter.apply('link', linkDetails, anchor);\n          }\n        }\n      };\n      editor.editorCommands.addCommands({\n        unlink: () => {\n          if (editor.selection.isEditable()) {\n            if (editor.selection.isCollapsed()) {\n              const elm = editor.dom.getParent(editor.selection.getStart(), 'a');\n              if (elm) {\n                editor.dom.remove(elm, true);\n              }\n              return;\n            }\n            editor.formatter.remove('link');\n          }\n        },\n        mceInsertLink: applyLinkToSelection,\n        createLink: applyLinkToSelection\n      });\n    };\n\n    const getTopParentBlock = (editor, node, root, container) => {\n      const dom = editor.dom;\n      const selector = node => dom.isBlock(node) && node.parentElement === root;\n      const topParentBlock = selector(node) ? node : dom.getParent(container, selector, root);\n      return Optional.from(topParentBlock).map(SugarElement.fromDom);\n    };\n    const insert = (editor, before) => {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      const node = before ? editor.selection.getStart() : editor.selection.getEnd();\n      const container = before ? rng.startContainer : rng.endContainer;\n      const root = getEditableRoot(dom, container);\n      if (!root || !root.isContentEditable) {\n        return;\n      }\n      const insertFn = before ? before$3 : after$4;\n      const newBlockName = getForcedRootBlock(editor);\n      getTopParentBlock(editor, node, root, container).each(parentBlock => {\n        const newBlock = createNewBlock(editor, container, parentBlock.dom, root, false, newBlockName);\n        insertFn(parentBlock, SugarElement.fromDom(newBlock));\n        editor.selection.setCursorLocation(newBlock, 0);\n        editor.dispatch('NewBlock', { newBlock });\n        fireInputEvent(editor, 'insertParagraph');\n      });\n    };\n    const insertBefore = editor => insert(editor, true);\n    const insertAfter = editor => insert(editor, false);\n\n    const registerCommands$3 = editor => {\n      editor.editorCommands.addCommands({\n        InsertNewBlockBefore: () => {\n          insertBefore(editor);\n        },\n        InsertNewBlockAfter: () => {\n          insertAfter(editor);\n        }\n      });\n    };\n\n    const registerCommands$2 = editor => {\n      editor.editorCommands.addCommands({\n        insertParagraph: () => {\n          insertBreak(blockbreak, editor);\n        },\n        mceInsertNewLine: (_command, _ui, value) => {\n          insert$1(editor, value);\n        },\n        InsertLineBreak: (_command, _ui, _value) => {\n          insertBreak(linebreak, editor);\n        }\n      });\n    };\n\n    const registerCommands$1 = editor => {\n      editor.editorCommands.addCommands({\n        mceSelectNodeDepth: (_command, _ui, value) => {\n          let counter = 0;\n          editor.dom.getParent(editor.selection.getNode(), node => {\n            if (isElement$6(node) && counter++ === value) {\n              editor.selection.select(node);\n              return false;\n            } else {\n              return true;\n            }\n          }, editor.getBody());\n        },\n        mceSelectNode: (_command, _ui, value) => {\n          editor.selection.select(value);\n        },\n        selectAll: () => {\n          const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);\n          if (editingHost) {\n            const rng = editor.dom.createRng();\n            rng.selectNodeContents(editingHost);\n            editor.selection.setRng(rng);\n          }\n        }\n      });\n    };\n\n    const registerExecCommands = editor => {\n      editor.editorCommands.addCommands({\n        mceRemoveNode: (_command, _ui, value) => {\n          const node = value !== null && value !== void 0 ? value : editor.selection.getNode();\n          if (node !== editor.getBody()) {\n            const bm = editor.selection.getBookmark();\n            editor.dom.remove(node, true);\n            editor.selection.moveToBookmark(bm);\n          }\n        },\n        mcePrint: () => {\n          editor.getWin().print();\n        },\n        mceFocus: (_command, _ui, value) => {\n          focus(editor, value === true);\n        },\n        mceToggleVisualAid: () => {\n          editor.hasVisual = !editor.hasVisual;\n          editor.addVisual();\n        }\n      });\n    };\n    const registerCommands = editor => {\n      registerCommands$a(editor);\n      registerCommands$9(editor);\n      registerCommands$6(editor);\n      registerCommands$1(editor);\n      registerCommands$8(editor);\n      registerCommands$4(editor);\n      registerCommands$5(editor);\n      registerCommands$3(editor);\n      registerCommands$2(editor);\n      registerCommands$7(editor);\n      registerExecCommands(editor);\n    };\n\n    const selectionSafeCommands = ['toggleview'];\n    const isSelectionSafeCommand = command => contains$2(selectionSafeCommands, command.toLowerCase());\n    class EditorCommands {\n      constructor(editor) {\n        this.commands = {\n          state: {},\n          exec: {},\n          value: {}\n        };\n        this.editor = editor;\n      }\n      execCommand(command, ui = false, value, args) {\n        const editor = this.editor;\n        const lowerCaseCommand = command.toLowerCase();\n        const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;\n        if (editor.removed) {\n          return false;\n        }\n        if (lowerCaseCommand !== 'mcefocus') {\n          if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {\n            editor.focus();\n          } else {\n            restore(editor);\n          }\n        }\n        const eventArgs = editor.dispatch('BeforeExecCommand', {\n          command,\n          ui,\n          value\n        });\n        if (eventArgs.isDefaultPrevented()) {\n          return false;\n        }\n        const func = this.commands.exec[lowerCaseCommand];\n        if (isFunction(func)) {\n          func(lowerCaseCommand, ui, value);\n          editor.dispatch('ExecCommand', {\n            command,\n            ui,\n            value\n          });\n          return true;\n        }\n        return false;\n      }\n      queryCommandState(command) {\n        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\n          return false;\n        }\n        const lowerCaseCommand = command.toLowerCase();\n        const func = this.commands.state[lowerCaseCommand];\n        if (isFunction(func)) {\n          return func(lowerCaseCommand);\n        }\n        return false;\n      }\n      queryCommandValue(command) {\n        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\n          return '';\n        }\n        const lowerCaseCommand = command.toLowerCase();\n        const func = this.commands.value[lowerCaseCommand];\n        if (isFunction(func)) {\n          return func(lowerCaseCommand);\n        }\n        return '';\n      }\n      addCommands(commandList, type = 'exec') {\n        const commands = this.commands;\n        each$d(commandList, (callback, command) => {\n          each$e(command.toLowerCase().split(','), command => {\n            commands[type][command] = callback;\n          });\n        });\n      }\n      addCommand(command, callback, scope) {\n        const lowerCaseCommand = command.toLowerCase();\n        this.commands.exec[lowerCaseCommand] = (_command, ui, value) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value);\n      }\n      queryCommandSupported(command) {\n        const lowerCaseCommand = command.toLowerCase();\n        if (this.commands.exec[lowerCaseCommand]) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n      addQueryStateHandler(command, callback, scope) {\n        this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n      }\n      addQueryValueHandler(command, callback, scope) {\n        this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n      }\n    }\n\n    const internalContentEditableAttr = 'data-mce-contenteditable';\n    const toggleClass = (elm, cls, state) => {\n      if (has(elm, cls) && !state) {\n        remove$6(elm, cls);\n      } else if (state) {\n        add$2(elm, cls);\n      }\n    };\n    const setEditorCommandState = (editor, cmd, state) => {\n      try {\n        editor.getDoc().execCommand(cmd, false, String(state));\n      } catch (ex) {\n      }\n    };\n    const setContentEditable = (elm, state) => {\n      elm.dom.contentEditable = state ? 'true' : 'false';\n    };\n    const switchOffContentEditableTrue = elm => {\n      each$e(descendants(elm, '*[contenteditable=\"true\"]'), elm => {\n        set$3(elm, internalContentEditableAttr, 'true');\n        setContentEditable(elm, false);\n      });\n    };\n    const switchOnContentEditableTrue = elm => {\n      each$e(descendants(elm, `*[${ internalContentEditableAttr }=\"true\"]`), elm => {\n        remove$9(elm, internalContentEditableAttr);\n        setContentEditable(elm, true);\n      });\n    };\n    const removeFakeSelection = editor => {\n      Optional.from(editor.selection.getNode()).each(elm => {\n        elm.removeAttribute('data-mce-selected');\n      });\n    };\n    const restoreFakeSelection = editor => {\n      editor.selection.setRng(editor.selection.getRng());\n    };\n    const toggleReadOnly = (editor, state) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      toggleClass(body, 'mce-content-readonly', state);\n      if (state) {\n        editor.selection.controlSelection.hideResizeRect();\n        editor._selectionOverrides.hideFakeCaret();\n        removeFakeSelection(editor);\n        editor.readonly = true;\n        setContentEditable(body, false);\n        switchOffContentEditableTrue(body);\n      } else {\n        editor.readonly = false;\n        if (editor.hasEditableRoot()) {\n          setContentEditable(body, true);\n        }\n        switchOnContentEditableTrue(body);\n        setEditorCommandState(editor, 'StyleWithCSS', false);\n        setEditorCommandState(editor, 'enableInlineTableEditing', false);\n        setEditorCommandState(editor, 'enableObjectResizing', false);\n        if (hasEditorOrUiFocus(editor)) {\n          editor.focus();\n        }\n        restoreFakeSelection(editor);\n        editor.nodeChanged();\n      }\n    };\n    const isReadOnly = editor => editor.readonly;\n    const registerFilters = editor => {\n      editor.parser.addAttributeFilter('contenteditable', nodes => {\n        if (isReadOnly(editor)) {\n          each$e(nodes, node => {\n            node.attr(internalContentEditableAttr, node.attr('contenteditable'));\n            node.attr('contenteditable', 'false');\n          });\n        }\n      });\n      editor.serializer.addAttributeFilter(internalContentEditableAttr, nodes => {\n        if (isReadOnly(editor)) {\n          each$e(nodes, node => {\n            node.attr('contenteditable', node.attr(internalContentEditableAttr));\n          });\n        }\n      });\n      editor.serializer.addTempAttr(internalContentEditableAttr);\n    };\n    const registerReadOnlyContentFilters = editor => {\n      if (editor.serializer) {\n        registerFilters(editor);\n      } else {\n        editor.on('PreInit', () => {\n          registerFilters(editor);\n        });\n      }\n    };\n    const isClickEvent = e => e.type === 'click';\n    const allowedEvents = ['copy'];\n    const isReadOnlyAllowedEvent = e => contains$2(allowedEvents, e.type);\n    const getAnchorHrefOpt = (editor, elm) => {\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n      return closest$3(elm, 'a', isRoot).bind(a => getOpt(a, 'href'));\n    };\n    const processReadonlyEvents = (editor, e) => {\n      if (isClickEvent(e) && !VK.metaKeyPressed(e)) {\n        const elm = SugarElement.fromDom(e.target);\n        getAnchorHrefOpt(editor, elm).each(href => {\n          e.preventDefault();\n          if (/^#/.test(href)) {\n            const targetEl = editor.dom.select(`${ href },[name=\"${ removeLeading(href, '#') }\"]`);\n            if (targetEl.length) {\n              editor.selection.scrollIntoView(targetEl[0], true);\n            }\n          } else {\n            window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');\n          }\n        });\n      } else if (isReadOnlyAllowedEvent(e)) {\n        editor.dispatch(e.type, e);\n      }\n    };\n    const registerReadOnlySelectionBlockers = editor => {\n      editor.on('ShowCaret', e => {\n        if (isReadOnly(editor)) {\n          e.preventDefault();\n        }\n      });\n      editor.on('ObjectSelected', e => {\n        if (isReadOnly(editor)) {\n          e.preventDefault();\n        }\n      });\n    };\n\n    const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');\n    class EventDispatcher {\n      static isNative(name) {\n        return !!nativeEvents[name.toLowerCase()];\n      }\n      constructor(settings) {\n        this.bindings = {};\n        this.settings = settings || {};\n        this.scope = this.settings.scope || this;\n        this.toggleEvent = this.settings.toggleEvent || never;\n      }\n      fire(name, args) {\n        return this.dispatch(name, args);\n      }\n      dispatch(name, args) {\n        const lcName = name.toLowerCase();\n        const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);\n        if (this.settings.beforeFire) {\n          this.settings.beforeFire(event);\n        }\n        const handlers = this.bindings[lcName];\n        if (handlers) {\n          for (let i = 0, l = handlers.length; i < l; i++) {\n            const callback = handlers[i];\n            if (callback.removed) {\n              continue;\n            }\n            if (callback.once) {\n              this.off(lcName, callback.func);\n            }\n            if (event.isImmediatePropagationStopped()) {\n              return event;\n            }\n            if (callback.func.call(this.scope, event) === false) {\n              event.preventDefault();\n              return event;\n            }\n          }\n        }\n        return event;\n      }\n      on(name, callback, prepend, extra) {\n        if (callback === false) {\n          callback = never;\n        }\n        if (callback) {\n          const wrappedCallback = {\n            func: callback,\n            removed: false\n          };\n          if (extra) {\n            Tools.extend(wrappedCallback, extra);\n          }\n          const names = name.toLowerCase().split(' ');\n          let i = names.length;\n          while (i--) {\n            const currentName = names[i];\n            let handlers = this.bindings[currentName];\n            if (!handlers) {\n              handlers = [];\n              this.toggleEvent(currentName, true);\n            }\n            if (prepend) {\n              handlers = [\n                wrappedCallback,\n                ...handlers\n              ];\n            } else {\n              handlers = [\n                ...handlers,\n                wrappedCallback\n              ];\n            }\n            this.bindings[currentName] = handlers;\n          }\n        }\n        return this;\n      }\n      off(name, callback) {\n        if (name) {\n          const names = name.toLowerCase().split(' ');\n          let i = names.length;\n          while (i--) {\n            const currentName = names[i];\n            let handlers = this.bindings[currentName];\n            if (!currentName) {\n              each$d(this.bindings, (_value, bindingName) => {\n                this.toggleEvent(bindingName, false);\n                delete this.bindings[bindingName];\n              });\n              return this;\n            }\n            if (handlers) {\n              if (!callback) {\n                handlers.length = 0;\n              } else {\n                const filteredHandlers = partition$2(handlers, handler => handler.func === callback);\n                handlers = filteredHandlers.fail;\n                this.bindings[currentName] = handlers;\n                each$e(filteredHandlers.pass, handler => {\n                  handler.removed = true;\n                });\n              }\n              if (!handlers.length) {\n                this.toggleEvent(name, false);\n                delete this.bindings[currentName];\n              }\n            }\n          }\n        } else {\n          each$d(this.bindings, (_value, name) => {\n            this.toggleEvent(name, false);\n          });\n          this.bindings = {};\n        }\n        return this;\n      }\n      once(name, callback, prepend) {\n        return this.on(name, callback, prepend, { once: true });\n      }\n      has(name) {\n        name = name.toLowerCase();\n        const binding = this.bindings[name];\n        return !(!binding || binding.length === 0);\n      }\n    }\n\n    const getEventDispatcher = obj => {\n      if (!obj._eventDispatcher) {\n        obj._eventDispatcher = new EventDispatcher({\n          scope: obj,\n          toggleEvent: (name, state) => {\n            if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {\n              obj.toggleNativeEvent(name, state);\n            }\n          }\n        });\n      }\n      return obj._eventDispatcher;\n    };\n    const Observable = {\n      fire(name, args, bubble) {\n        return this.dispatch(name, args, bubble);\n      },\n      dispatch(name, args, bubble) {\n        const self = this;\n        if (self.removed && name !== 'remove' && name !== 'detach') {\n          return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);\n        }\n        const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);\n        if (bubble !== false && self.parent) {\n          let parent = self.parent();\n          while (parent && !dispatcherArgs.isPropagationStopped()) {\n            parent.dispatch(name, dispatcherArgs, false);\n            parent = parent.parent ? parent.parent() : undefined;\n          }\n        }\n        return dispatcherArgs;\n      },\n      on(name, callback, prepend) {\n        return getEventDispatcher(this).on(name, callback, prepend);\n      },\n      off(name, callback) {\n        return getEventDispatcher(this).off(name, callback);\n      },\n      once(name, callback) {\n        return getEventDispatcher(this).once(name, callback);\n      },\n      hasEventListeners(name) {\n        return getEventDispatcher(this).has(name);\n      }\n    };\n\n    const DOM$2 = DOMUtils.DOM;\n    let customEventRootDelegates;\n    const getEventTarget = (editor, eventName) => {\n      if (eventName === 'selectionchange') {\n        return editor.getDoc();\n      }\n      if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) {\n        return editor.getDoc().documentElement;\n      }\n      const eventRoot = getEventRoot(editor);\n      if (eventRoot) {\n        if (!editor.eventRoot) {\n          editor.eventRoot = DOM$2.select(eventRoot)[0];\n        }\n        return editor.eventRoot;\n      }\n      return editor.getBody();\n    };\n    const isListening = editor => !editor.hidden && !isReadOnly(editor);\n    const fireEvent = (editor, eventName, e) => {\n      if (isListening(editor)) {\n        editor.dispatch(eventName, e);\n      } else if (isReadOnly(editor)) {\n        processReadonlyEvents(editor, e);\n      }\n    };\n    const bindEventDelegate = (editor, eventName) => {\n      if (!editor.delegates) {\n        editor.delegates = {};\n      }\n      if (editor.delegates[eventName] || editor.removed) {\n        return;\n      }\n      const eventRootElm = getEventTarget(editor, eventName);\n      if (getEventRoot(editor)) {\n        if (!customEventRootDelegates) {\n          customEventRootDelegates = {};\n          editor.editorManager.on('removeEditor', () => {\n            if (!editor.editorManager.activeEditor) {\n              if (customEventRootDelegates) {\n                each$d(customEventRootDelegates, (_value, name) => {\n                  editor.dom.unbind(getEventTarget(editor, name));\n                });\n                customEventRootDelegates = null;\n              }\n            }\n          });\n        }\n        if (customEventRootDelegates[eventName]) {\n          return;\n        }\n        const delegate = e => {\n          const target = e.target;\n          const editors = editor.editorManager.get();\n          let i = editors.length;\n          while (i--) {\n            const body = editors[i].getBody();\n            if (body === target || DOM$2.isChildOf(target, body)) {\n              fireEvent(editors[i], eventName, e);\n            }\n          }\n        };\n        customEventRootDelegates[eventName] = delegate;\n        DOM$2.bind(eventRootElm, eventName, delegate);\n      } else {\n        const delegate = e => {\n          fireEvent(editor, eventName, e);\n        };\n        DOM$2.bind(eventRootElm, eventName, delegate);\n        editor.delegates[eventName] = delegate;\n      }\n    };\n    const EditorObservable = {\n      ...Observable,\n      bindPendingEventDelegates() {\n        const self = this;\n        Tools.each(self._pendingNativeEvents, name => {\n          bindEventDelegate(self, name);\n        });\n      },\n      toggleNativeEvent(name, state) {\n        const self = this;\n        if (name === 'focus' || name === 'blur') {\n          return;\n        }\n        if (self.removed) {\n          return;\n        }\n        if (state) {\n          if (self.initialized) {\n            bindEventDelegate(self, name);\n          } else {\n            if (!self._pendingNativeEvents) {\n              self._pendingNativeEvents = [name];\n            } else {\n              self._pendingNativeEvents.push(name);\n            }\n          }\n        } else if (self.initialized && self.delegates) {\n          self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);\n          delete self.delegates[name];\n        }\n      },\n      unbindAllNativeEvents() {\n        const self = this;\n        const body = self.getBody();\n        const dom = self.dom;\n        if (self.delegates) {\n          each$d(self.delegates, (value, name) => {\n            self.dom.unbind(getEventTarget(self, name), name, value);\n          });\n          delete self.delegates;\n        }\n        if (!self.inline && body && dom) {\n          body.onload = null;\n          dom.unbind(self.getWin());\n          dom.unbind(self.getDoc());\n        }\n        if (dom) {\n          dom.unbind(body);\n          dom.unbind(self.getContainer());\n        }\n      }\n    };\n\n    const stringListProcessor = value => {\n      if (isString(value)) {\n        return {\n          value: value.split(/[ ,]/),\n          valid: true\n        };\n      } else if (isArrayOf(value, isString)) {\n        return {\n          value,\n          valid: true\n        };\n      } else {\n        return {\n          valid: false,\n          message: `The value must be a string[] or a comma/space separated string.`\n        };\n      }\n    };\n    const getBuiltInProcessor = type => {\n      const validator = (() => {\n        switch (type) {\n        case 'array':\n          return isArray$1;\n        case 'boolean':\n          return isBoolean;\n        case 'function':\n          return isFunction;\n        case 'number':\n          return isNumber;\n        case 'object':\n          return isObject;\n        case 'string':\n          return isString;\n        case 'string[]':\n          return stringListProcessor;\n        case 'object[]':\n          return val => isArrayOf(val, isObject);\n        case 'regexp':\n          return val => is$4(val, RegExp);\n        default:\n          return always;\n        }\n      })();\n      return value => processValue(value, validator, `The value must be a ${ type }.`);\n    };\n    const isBuiltInSpec = spec => isString(spec.processor);\n    const getErrorMessage = (message, result) => {\n      const additionalText = isEmpty$3(result.message) ? '' : `. ${ result.message }`;\n      return message + additionalText;\n    };\n    const isValidResult = result => result.valid;\n    const processValue = (value, processor, message = '') => {\n      const result = processor(value);\n      if (isBoolean(result)) {\n        return result ? {\n          value: value,\n          valid: true\n        } : {\n          valid: false,\n          message\n        };\n      } else {\n        return result;\n      }\n    };\n    const processDefaultValue = (name, defaultValue, processor) => {\n      if (!isUndefined(defaultValue)) {\n        const result = processValue(defaultValue, processor);\n        if (isValidResult(result)) {\n          return result.value;\n        } else {\n          console.error(getErrorMessage(`Invalid default value passed for the \"${ name }\" option`, result));\n        }\n      }\n      return undefined;\n    };\n    const create$5 = (editor, initialOptions, rawInitialOptions = initialOptions) => {\n      const registry = {};\n      const values = {};\n      const setValue = (name, value, processor) => {\n        const result = processValue(value, processor);\n        if (isValidResult(result)) {\n          values[name] = result.value;\n          return true;\n        } else {\n          console.warn(getErrorMessage(`Invalid value passed for the ${ name } option`, result));\n          return false;\n        }\n      };\n      const register = (name, spec) => {\n        const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;\n        const defaultValue = processDefaultValue(name, spec.default, processor);\n        registry[name] = {\n          ...spec,\n          default: defaultValue,\n          processor\n        };\n        const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));\n        initValue.each(value => setValue(name, value, processor));\n      };\n      const isRegistered = name => has$2(registry, name);\n      const get = name => get$a(values, name).orThunk(() => get$a(registry, name).map(spec => spec.default)).getOrUndefined();\n      const set = (name, value) => {\n        if (!isRegistered(name)) {\n          console.warn(`\"${ name }\" is not a registered option. Ensure the option has been registered before setting a value.`);\n          return false;\n        } else {\n          const spec = registry[name];\n          if (spec.immutable) {\n            console.error(`\"${ name }\" is an immutable option and cannot be updated`);\n            return false;\n          } else {\n            return setValue(name, value, spec.processor);\n          }\n        }\n      };\n      const unset = name => {\n        const registered = isRegistered(name);\n        if (registered) {\n          delete values[name];\n        }\n        return registered;\n      };\n      const isSet = name => has$2(values, name);\n      const debug = () => {\n        try {\n          console.log(JSON.parse(JSON.stringify(rawInitialOptions, (_key, value) => {\n            if (isBoolean(value) || isNumber(value) || isString(value) || isNull(value) || isArray$1(value) || isPlainObject(value)) {\n              return value;\n            }\n            return Object.prototype.toString.call(value);\n          })));\n        } catch (error) {\n          console.error(error);\n        }\n      };\n      return {\n        register,\n        isRegistered,\n        get,\n        set,\n        unset,\n        isSet,\n        debug\n      };\n    };\n\n    const defaultModes = [\n      'design',\n      'readonly'\n    ];\n    const switchToMode = (editor, activeMode, availableModes, mode) => {\n      const oldMode = availableModes[activeMode.get()];\n      const newMode = availableModes[mode];\n      try {\n        newMode.activate();\n      } catch (e) {\n        console.error(`problem while activating editor mode ${ mode }:`, e);\n        return;\n      }\n      oldMode.deactivate();\n      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {\n        toggleReadOnly(editor, newMode.editorReadOnly);\n      }\n      activeMode.set(mode);\n      fireSwitchMode(editor, mode);\n    };\n    const setMode = (editor, availableModes, activeMode, mode) => {\n      if (mode === activeMode.get()) {\n        return;\n      } else if (!has$2(availableModes, mode)) {\n        throw new Error(`Editor mode '${ mode }' is invalid`);\n      }\n      if (editor.initialized) {\n        switchToMode(editor, activeMode, availableModes, mode);\n      } else {\n        editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));\n      }\n    };\n    const registerMode = (availableModes, mode, api) => {\n      if (contains$2(defaultModes, mode)) {\n        throw new Error(`Cannot override default mode ${ mode }`);\n      }\n      return {\n        ...availableModes,\n        [mode]: {\n          ...api,\n          deactivate: () => {\n            try {\n              api.deactivate();\n            } catch (e) {\n              console.error(`problem while deactivating editor mode ${ mode }:`, e);\n            }\n          }\n        }\n      };\n    };\n\n    const create$4 = editor => {\n      const activeMode = Cell('design');\n      const availableModes = Cell({\n        design: {\n          activate: noop,\n          deactivate: noop,\n          editorReadOnly: false\n        },\n        readonly: {\n          activate: noop,\n          deactivate: noop,\n          editorReadOnly: true\n        }\n      });\n      registerReadOnlyContentFilters(editor);\n      registerReadOnlySelectionBlockers(editor);\n      return {\n        isReadOnly: () => isReadOnly(editor),\n        set: mode => setMode(editor, availableModes.get(), activeMode, mode),\n        get: () => activeMode.get(),\n        register: (mode, api) => {\n          availableModes.set(registerMode(availableModes.get(), mode, api));\n        }\n      };\n    };\n\n    const each$2 = Tools.each, explode = Tools.explode;\n    const keyCodeLookup = {\n      f1: 112,\n      f2: 113,\n      f3: 114,\n      f4: 115,\n      f5: 116,\n      f6: 117,\n      f7: 118,\n      f8: 119,\n      f9: 120,\n      f10: 121,\n      f11: 122,\n      f12: 123\n    };\n    const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');\n    const isModifier = key => key in modifierNames;\n    const parseShortcut = pattern => {\n      const shortcut = {};\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      each$2(explode(pattern.toLowerCase(), '+'), value => {\n        if (isModifier(value)) {\n          shortcut[value] = true;\n        } else {\n          if (/^[0-9]{2,}$/.test(value)) {\n            shortcut.keyCode = parseInt(value, 10);\n          } else {\n            shortcut.charCode = value.charCodeAt(0);\n            shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);\n          }\n        }\n      });\n      const id = [shortcut.keyCode];\n      let key;\n      for (key in modifierNames) {\n        if (shortcut[key]) {\n          id.push(key);\n        } else {\n          shortcut[key] = false;\n        }\n      }\n      shortcut.id = id.join(',');\n      if (shortcut.access) {\n        shortcut.alt = true;\n        if (isMac) {\n          shortcut.ctrl = true;\n        } else {\n          shortcut.shift = true;\n        }\n      }\n      if (shortcut.meta) {\n        if (isMac) {\n          shortcut.meta = true;\n        } else {\n          shortcut.ctrl = true;\n          shortcut.meta = false;\n        }\n      }\n      return shortcut;\n    };\n    class Shortcuts {\n      constructor(editor) {\n        this.shortcuts = {};\n        this.pendingPatterns = [];\n        this.editor = editor;\n        const self = this;\n        editor.on('keyup keypress keydown', e => {\n          if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {\n            each$2(self.shortcuts, shortcut => {\n              if (self.matchShortcut(e, shortcut)) {\n                self.pendingPatterns = shortcut.subpatterns.slice(0);\n                if (e.type === 'keydown') {\n                  self.executeShortcutAction(shortcut);\n                }\n              }\n            });\n            if (self.matchShortcut(e, self.pendingPatterns[0])) {\n              if (self.pendingPatterns.length === 1) {\n                if (e.type === 'keydown') {\n                  self.executeShortcutAction(self.pendingPatterns[0]);\n                }\n              }\n              self.pendingPatterns.shift();\n            }\n          }\n        });\n      }\n      add(pattern, desc, cmdFunc, scope) {\n        const self = this;\n        const func = self.normalizeCommandFunc(cmdFunc);\n        each$2(explode(Tools.trim(pattern)), pattern => {\n          const shortcut = self.createShortcut(pattern, desc, func, scope);\n          self.shortcuts[shortcut.id] = shortcut;\n        });\n        return true;\n      }\n      remove(pattern) {\n        const shortcut = this.createShortcut(pattern);\n        if (this.shortcuts[shortcut.id]) {\n          delete this.shortcuts[shortcut.id];\n          return true;\n        }\n        return false;\n      }\n      normalizeCommandFunc(cmdFunc) {\n        const self = this;\n        const cmd = cmdFunc;\n        if (typeof cmd === 'string') {\n          return () => {\n            self.editor.execCommand(cmd, false, null);\n          };\n        } else if (Tools.isArray(cmd)) {\n          return () => {\n            self.editor.execCommand(cmd[0], cmd[1], cmd[2]);\n          };\n        } else {\n          return cmd;\n        }\n      }\n      createShortcut(pattern, desc, cmdFunc, scope) {\n        const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);\n        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {\n          func: cmdFunc,\n          scope: scope || this.editor\n        });\n        return Tools.extend(shortcuts[0], {\n          desc: this.editor.translate(desc),\n          subpatterns: shortcuts.slice(1)\n        });\n      }\n      hasModifier(e) {\n        return e.altKey || e.ctrlKey || e.metaKey;\n      }\n      isFunctionKey(e) {\n        return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;\n      }\n      matchShortcut(e, shortcut) {\n        if (!shortcut) {\n          return false;\n        }\n        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {\n          return false;\n        }\n        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {\n          return false;\n        }\n        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {\n          e.preventDefault();\n          return true;\n        }\n        return false;\n      }\n      executeShortcutAction(shortcut) {\n        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;\n      }\n    }\n\n    const create$3 = () => {\n      const buttons = {};\n      const menuItems = {};\n      const popups = {};\n      const icons = {};\n      const contextMenus = {};\n      const contextToolbars = {};\n      const sidebars = {};\n      const views = {};\n      const add = (collection, type) => (name, spec) => {\n        collection[name.toLowerCase()] = {\n          ...spec,\n          type\n        };\n      };\n      const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;\n      return {\n        addButton: add(buttons, 'button'),\n        addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),\n        addToggleButton: add(buttons, 'togglebutton'),\n        addMenuButton: add(buttons, 'menubutton'),\n        addSplitButton: add(buttons, 'splitbutton'),\n        addMenuItem: add(menuItems, 'menuitem'),\n        addNestedMenuItem: add(menuItems, 'nestedmenuitem'),\n        addToggleMenuItem: add(menuItems, 'togglemenuitem'),\n        addAutocompleter: add(popups, 'autocompleter'),\n        addContextMenu: add(contextMenus, 'contextmenu'),\n        addContextToolbar: add(contextToolbars, 'contexttoolbar'),\n        addContextForm: add(contextToolbars, 'contextform'),\n        addSidebar: add(sidebars, 'sidebar'),\n        addView: add(views, 'views'),\n        addIcon,\n        getAll: () => ({\n          buttons,\n          menuItems,\n          icons,\n          popups,\n          contextMenus,\n          contextToolbars,\n          sidebars,\n          views\n        })\n      };\n    };\n\n    const registry = () => {\n      const bridge = create$3();\n      return {\n        addAutocompleter: bridge.addAutocompleter,\n        addButton: bridge.addButton,\n        addContextForm: bridge.addContextForm,\n        addContextMenu: bridge.addContextMenu,\n        addContextToolbar: bridge.addContextToolbar,\n        addIcon: bridge.addIcon,\n        addMenuButton: bridge.addMenuButton,\n        addMenuItem: bridge.addMenuItem,\n        addNestedMenuItem: bridge.addNestedMenuItem,\n        addSidebar: bridge.addSidebar,\n        addSplitButton: bridge.addSplitButton,\n        addToggleButton: bridge.addToggleButton,\n        addGroupToolbarButton: bridge.addGroupToolbarButton,\n        addToggleMenuItem: bridge.addToggleMenuItem,\n        addView: bridge.addView,\n        getAll: bridge.getAll\n      };\n    };\n\n    const DOM$1 = DOMUtils.DOM;\n    const extend = Tools.extend, each$1 = Tools.each;\n    class Editor {\n      constructor(id, options, editorManager) {\n        this.plugins = {};\n        this.contentCSS = [];\n        this.contentStyles = [];\n        this.loadedCSS = {};\n        this.isNotDirty = false;\n        this.composing = false;\n        this.destroyed = false;\n        this.hasHiddenInput = false;\n        this.iframeElement = null;\n        this.initialized = false;\n        this.readonly = false;\n        this.removed = false;\n        this.startContent = '';\n        this._pendingNativeEvents = [];\n        this._skinLoaded = false;\n        this._editableRoot = true;\n        this.editorManager = editorManager;\n        this.documentBaseUrl = editorManager.documentBaseURL;\n        extend(this, EditorObservable);\n        const self = this;\n        this.id = id;\n        this.hidden = false;\n        const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);\n        this.options = create$5(self, normalizedOptions, options);\n        register$7(self);\n        const getOption = this.options.get;\n        if (getOption('deprecation_warnings')) {\n          logWarnings(options, normalizedOptions);\n        }\n        const suffix = getOption('suffix');\n        if (suffix) {\n          editorManager.suffix = suffix;\n        }\n        this.suffix = editorManager.suffix;\n        const baseUrl = getOption('base_url');\n        if (baseUrl) {\n          editorManager._setBaseUrl(baseUrl);\n        }\n        this.baseUri = editorManager.baseURI;\n        const referrerPolicy = getReferrerPolicy(self);\n        if (referrerPolicy) {\n          ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);\n          DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);\n        }\n        const contentCssCors = hasContentCssCors(self);\n        if (isNonNullable(contentCssCors)) {\n          DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);\n        }\n        AddOnManager.languageLoad = getOption('language_load');\n        AddOnManager.baseURL = editorManager.baseURL;\n        this.setDirty(false);\n        this.documentBaseURI = new URI(getDocumentBaseUrl(self), { base_uri: this.baseUri });\n        this.baseURI = this.baseUri;\n        this.inline = isInline$1(self);\n        this.hasVisual = isVisualAidsEnabled(self);\n        this.shortcuts = new Shortcuts(this);\n        this.editorCommands = new EditorCommands(this);\n        registerCommands(this);\n        const cacheSuffix = getOption('cache_suffix');\n        if (cacheSuffix) {\n          Env.cacheSuffix = cacheSuffix.replace(/^[\\?\\&]+/, '');\n        }\n        this.ui = {\n          registry: registry(),\n          styleSheetLoader: undefined,\n          show: noop,\n          hide: noop,\n          setEnabled: noop,\n          isEnabled: always\n        };\n        this.mode = create$4(self);\n        editorManager.dispatch('SetupEditor', { editor: this });\n        const setupCallback = getSetupCallback(self);\n        if (isFunction(setupCallback)) {\n          setupCallback.call(self, self);\n        }\n      }\n      render() {\n        render(this);\n      }\n      focus(skipFocus) {\n        this.execCommand('mceFocus', false, skipFocus);\n      }\n      hasFocus() {\n        return hasFocus(this);\n      }\n      translate(text) {\n        return I18n.translate(text);\n      }\n      getParam(name, defaultVal, type) {\n        const options = this.options;\n        if (!options.isRegistered(name)) {\n          if (isNonNullable(type)) {\n            options.register(name, {\n              processor: type,\n              default: defaultVal\n            });\n          } else {\n            options.register(name, {\n              processor: always,\n              default: defaultVal\n            });\n          }\n        }\n        return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);\n      }\n      hasPlugin(name, loaded) {\n        const hasPlugin = contains$2(getPlugins(this), name);\n        if (hasPlugin) {\n          return loaded ? PluginManager.get(name) !== undefined : true;\n        } else {\n          return false;\n        }\n      }\n      nodeChanged(args) {\n        this._nodeChangeDispatcher.nodeChanged(args);\n      }\n      addCommand(name, callback, scope) {\n        this.editorCommands.addCommand(name, callback, scope);\n      }\n      addQueryStateHandler(name, callback, scope) {\n        this.editorCommands.addQueryStateHandler(name, callback, scope);\n      }\n      addQueryValueHandler(name, callback, scope) {\n        this.editorCommands.addQueryValueHandler(name, callback, scope);\n      }\n      addShortcut(pattern, desc, cmdFunc, scope) {\n        this.shortcuts.add(pattern, desc, cmdFunc, scope);\n      }\n      execCommand(cmd, ui, value, args) {\n        return this.editorCommands.execCommand(cmd, ui, value, args);\n      }\n      queryCommandState(cmd) {\n        return this.editorCommands.queryCommandState(cmd);\n      }\n      queryCommandValue(cmd) {\n        return this.editorCommands.queryCommandValue(cmd);\n      }\n      queryCommandSupported(cmd) {\n        return this.editorCommands.queryCommandSupported(cmd);\n      }\n      show() {\n        const self = this;\n        if (self.hidden) {\n          self.hidden = false;\n          if (self.inline) {\n            self.getBody().contentEditable = 'true';\n          } else {\n            DOM$1.show(self.getContainer());\n            DOM$1.hide(self.id);\n          }\n          self.load();\n          self.dispatch('show');\n        }\n      }\n      hide() {\n        const self = this;\n        if (!self.hidden) {\n          self.save();\n          if (self.inline) {\n            self.getBody().contentEditable = 'false';\n            if (self === self.editorManager.focusedEditor) {\n              self.editorManager.focusedEditor = null;\n            }\n          } else {\n            DOM$1.hide(self.getContainer());\n            DOM$1.setStyle(self.id, 'display', self.orgDisplay);\n          }\n          self.hidden = true;\n          self.dispatch('hide');\n        }\n      }\n      isHidden() {\n        return this.hidden;\n      }\n      setProgressState(state, time) {\n        this.dispatch('ProgressState', {\n          state,\n          time\n        });\n      }\n      load(args = {}) {\n        const self = this;\n        const elm = self.getElement();\n        if (self.removed) {\n          return '';\n        }\n        if (elm) {\n          const loadArgs = {\n            ...args,\n            load: true\n          };\n          const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;\n          const html = self.setContent(value, loadArgs);\n          if (!loadArgs.no_events) {\n            self.dispatch('LoadContent', {\n              ...loadArgs,\n              element: elm\n            });\n          }\n          return html;\n        } else {\n          return '';\n        }\n      }\n      save(args = {}) {\n        const self = this;\n        let elm = self.getElement();\n        if (!elm || !self.initialized || self.removed) {\n          return '';\n        }\n        const getArgs = {\n          ...args,\n          save: true,\n          element: elm\n        };\n        let html = self.getContent(getArgs);\n        const saveArgs = {\n          ...getArgs,\n          content: html\n        };\n        if (!saveArgs.no_events) {\n          self.dispatch('SaveContent', saveArgs);\n        }\n        if (saveArgs.format === 'raw') {\n          self.dispatch('RawSaveContent', saveArgs);\n        }\n        html = saveArgs.content;\n        if (!isTextareaOrInput(elm)) {\n          if (args.is_removing || !self.inline) {\n            elm.innerHTML = html;\n          }\n          const form = DOM$1.getParent(self.id, 'form');\n          if (form) {\n            each$1(form.elements, elm => {\n              if (elm.name === self.id) {\n                elm.value = html;\n                return false;\n              } else {\n                return true;\n              }\n            });\n          }\n        } else {\n          elm.value = html;\n        }\n        saveArgs.element = getArgs.element = elm = null;\n        if (saveArgs.set_dirty !== false) {\n          self.setDirty(false);\n        }\n        return html;\n      }\n      setContent(content, args) {\n        return setContent(this, content, args);\n      }\n      getContent(args) {\n        return getContent(this, args);\n      }\n      insertContent(content, args) {\n        if (args) {\n          content = extend({ content }, args);\n        }\n        this.execCommand('mceInsertContent', false, content);\n      }\n      resetContent(initialContent) {\n        if (initialContent === undefined) {\n          setContent(this, this.startContent, { format: 'raw' });\n        } else {\n          setContent(this, initialContent);\n        }\n        this.undoManager.reset();\n        this.setDirty(false);\n        this.nodeChanged();\n      }\n      isDirty() {\n        return !this.isNotDirty;\n      }\n      setDirty(state) {\n        const oldState = !this.isNotDirty;\n        this.isNotDirty = !state;\n        if (state && state !== oldState) {\n          this.dispatch('dirty');\n        }\n      }\n      getContainer() {\n        const self = this;\n        if (!self.container) {\n          self.container = self.editorContainer || DOM$1.get(self.id + '_parent');\n        }\n        return self.container;\n      }\n      getContentAreaContainer() {\n        return this.contentAreaContainer;\n      }\n      getElement() {\n        if (!this.targetElm) {\n          this.targetElm = DOM$1.get(this.id);\n        }\n        return this.targetElm;\n      }\n      getWin() {\n        const self = this;\n        if (!self.contentWindow) {\n          const elm = self.iframeElement;\n          if (elm) {\n            self.contentWindow = elm.contentWindow;\n          }\n        }\n        return self.contentWindow;\n      }\n      getDoc() {\n        const self = this;\n        if (!self.contentDocument) {\n          const win = self.getWin();\n          if (win) {\n            self.contentDocument = win.document;\n          }\n        }\n        return self.contentDocument;\n      }\n      getBody() {\n        var _a, _b;\n        const doc = this.getDoc();\n        return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;\n      }\n      convertURL(url, name, elm) {\n        const self = this, getOption = self.options.get;\n        const urlConverterCallback = getUrlConverterCallback(self);\n        if (isFunction(urlConverterCallback)) {\n          return urlConverterCallback.call(self, url, elm, true, name);\n        }\n        if (!getOption('convert_urls') || elm === 'link' || isObject(elm) && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {\n          return url;\n        }\n        const urlObject = new URI(url);\n        if (urlObject.protocol !== 'http' && urlObject.protocol !== 'https' && urlObject.protocol !== '') {\n          return url;\n        }\n        if (getOption('relative_urls')) {\n          return self.documentBaseURI.toRelative(url);\n        }\n        url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));\n        return url;\n      }\n      addVisual(elm) {\n        addVisual(this, elm);\n      }\n      setEditableRoot(state) {\n        setEditableRoot(this, state);\n      }\n      hasEditableRoot() {\n        return hasEditableRoot(this);\n      }\n      remove() {\n        remove$1(this);\n      }\n      destroy(automatic) {\n        destroy(this, automatic);\n      }\n      uploadImages() {\n        return this.editorUpload.uploadImages();\n      }\n      _scanForImages() {\n        return this.editorUpload.scanForImages();\n      }\n    }\n\n    const DOM = DOMUtils.DOM;\n    const each = Tools.each;\n    let boundGlobalEvents = false;\n    let beforeUnloadDelegate;\n    let editors = [];\n    const globalEventDelegate = e => {\n      const type = e.type;\n      each(EditorManager.get(), editor => {\n        switch (type) {\n        case 'scroll':\n          editor.dispatch('ScrollWindow', e);\n          break;\n        case 'resize':\n          editor.dispatch('ResizeWindow', e);\n          break;\n        }\n      });\n    };\n    const toggleGlobalEvents = state => {\n      if (state !== boundGlobalEvents) {\n        const DOM = DOMUtils.DOM;\n        if (state) {\n          DOM.bind(window, 'resize', globalEventDelegate);\n          DOM.bind(window, 'scroll', globalEventDelegate);\n        } else {\n          DOM.unbind(window, 'resize', globalEventDelegate);\n          DOM.unbind(window, 'scroll', globalEventDelegate);\n        }\n        boundGlobalEvents = state;\n      }\n    };\n    const removeEditorFromList = targetEditor => {\n      const oldEditors = editors;\n      editors = filter$5(editors, editor => {\n        return targetEditor !== editor;\n      });\n      if (EditorManager.activeEditor === targetEditor) {\n        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;\n      }\n      if (EditorManager.focusedEditor === targetEditor) {\n        EditorManager.focusedEditor = null;\n      }\n      return oldEditors.length !== editors.length;\n    };\n    const purgeDestroyedEditor = editor => {\n      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {\n        removeEditorFromList(editor);\n        editor.unbindAllNativeEvents();\n        editor.destroy(true);\n        editor.removed = true;\n      }\n    };\n    const isQuirksMode = document.compatMode !== 'CSS1Compat';\n    const EditorManager = {\n      ...Observable,\n      baseURI: null,\n      baseURL: null,\n      defaultOptions: {},\n      documentBaseURL: null,\n      suffix: null,\n      majorVersion: '7',\n      minorVersion: '2.1',\n      releaseDate: '2024-07-03',\n      i18n: I18n,\n      activeEditor: null,\n      focusedEditor: null,\n      setup() {\n        const self = this;\n        let baseURL = '';\n        let suffix = '';\n        let documentBaseURL = URI.getDocumentBaseUrl(document.location);\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(documentBaseURL)) {\n          documentBaseURL = documentBaseURL.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n          if (!/[\\/\\\\]$/.test(documentBaseURL)) {\n            documentBaseURL += '/';\n          }\n        }\n        const preInit = window.tinymce || window.tinyMCEPreInit;\n        if (preInit) {\n          baseURL = preInit.base || preInit.baseURL;\n          suffix = preInit.suffix;\n        } else {\n          const scripts = document.getElementsByTagName('script');\n          for (let i = 0; i < scripts.length; i++) {\n            const src = scripts[i].src || '';\n            if (src === '') {\n              continue;\n            }\n            const srcScript = src.substring(src.lastIndexOf('/'));\n            if (/tinymce(\\.full|\\.jquery|)(\\.min|\\.dev|)\\.js/.test(src)) {\n              if (srcScript.indexOf('.min') !== -1) {\n                suffix = '.min';\n              }\n              baseURL = src.substring(0, src.lastIndexOf('/'));\n              break;\n            }\n          }\n          if (!baseURL && document.currentScript) {\n            const src = document.currentScript.src;\n            if (src.indexOf('.min') !== -1) {\n              suffix = '.min';\n            }\n            baseURL = src.substring(0, src.lastIndexOf('/'));\n          }\n        }\n        self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);\n        self.documentBaseURL = documentBaseURL;\n        self.baseURI = new URI(self.baseURL);\n        self.suffix = suffix;\n        setup$w(self);\n      },\n      overrideDefaults(defaultOptions) {\n        const baseUrl = defaultOptions.base_url;\n        if (baseUrl) {\n          this._setBaseUrl(baseUrl);\n        }\n        const suffix = defaultOptions.suffix;\n        if (suffix) {\n          this.suffix = suffix;\n        }\n        this.defaultOptions = defaultOptions;\n        const pluginBaseUrls = defaultOptions.plugin_base_urls;\n        if (pluginBaseUrls !== undefined) {\n          each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {\n            AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;\n          });\n        }\n      },\n      init(options) {\n        const self = this;\n        let result;\n        const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');\n        const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;\n        const createId = elm => {\n          let id = elm.id;\n          if (!id) {\n            id = get$a(elm, 'name').filter(name => !DOM.get(name)).getOrThunk(DOM.uniqueId);\n            elm.setAttribute('id', id);\n          }\n          return id;\n        };\n        const execCallback = name => {\n          const callback = options[name];\n          if (!callback) {\n            return;\n          }\n          return callback.apply(self, []);\n        };\n        const findTargets = options => {\n          if (Env.browser.isIE() || Env.browser.isEdge()) {\n            initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tiny.cloud/docs/tinymce/7/support/#supportedwebbrowsers');\n            return [];\n          } else if (isQuirksMode) {\n            initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');\n            return [];\n          } else if (isString(options.selector)) {\n            return DOM.select(options.selector);\n          } else if (isNonNullable(options.target)) {\n            return [options.target];\n          } else {\n            return [];\n          }\n        };\n        let provideResults = editors => {\n          result = editors;\n        };\n        const initEditors = () => {\n          let initCount = 0;\n          const editors = [];\n          let targets;\n          const createEditor = (id, options, targetElm) => {\n            const editor = new Editor(id, options, self);\n            editors.push(editor);\n            editor.on('init', () => {\n              if (++initCount === targets.length) {\n                provideResults(editors);\n              }\n            });\n            editor.targetElm = editor.targetElm || targetElm;\n            editor.render();\n          };\n          DOM.unbind(window, 'ready', initEditors);\n          execCallback('onpageload');\n          targets = unique$1(findTargets(options));\n          Tools.each(targets, elm => {\n            purgeDestroyedEditor(self.get(elm.id));\n          });\n          targets = Tools.grep(targets, elm => {\n            return !self.get(elm.id);\n          });\n          if (targets.length === 0) {\n            provideResults([]);\n          } else {\n            each(targets, elm => {\n              if (isInvalidInlineTarget(options, elm)) {\n                initError('Could not initialize inline editor on invalid inline target element', elm);\n              } else {\n                createEditor(createId(elm), options, elm);\n              }\n            });\n          }\n        };\n        DOM.bind(window, 'ready', initEditors);\n        return new Promise(resolve => {\n          if (result) {\n            resolve(result);\n          } else {\n            provideResults = editors => {\n              resolve(editors);\n            };\n          }\n        });\n      },\n      get(id) {\n        if (arguments.length === 0) {\n          return editors.slice(0);\n        } else if (isString(id)) {\n          return find$2(editors, editor => {\n            return editor.id === id;\n          }).getOr(null);\n        } else if (isNumber(id)) {\n          return editors[id] ? editors[id] : null;\n        } else {\n          return null;\n        }\n      },\n      add(editor) {\n        const self = this;\n        const existingEditor = self.get(editor.id);\n        if (existingEditor === editor) {\n          return editor;\n        }\n        if (existingEditor === null) {\n          editors.push(editor);\n        }\n        toggleGlobalEvents(true);\n        self.activeEditor = editor;\n        self.dispatch('AddEditor', { editor });\n        if (!beforeUnloadDelegate) {\n          beforeUnloadDelegate = e => {\n            const event = self.dispatch('BeforeUnload');\n            if (event.returnValue) {\n              e.preventDefault();\n              e.returnValue = event.returnValue;\n              return event.returnValue;\n            }\n          };\n          window.addEventListener('beforeunload', beforeUnloadDelegate);\n        }\n        return editor;\n      },\n      createEditor(id, options) {\n        return this.add(new Editor(id, options, this));\n      },\n      remove(selector) {\n        const self = this;\n        let editor;\n        if (!selector) {\n          for (let i = editors.length - 1; i >= 0; i--) {\n            self.remove(editors[i]);\n          }\n          return;\n        }\n        if (isString(selector)) {\n          each(DOM.select(selector), elm => {\n            editor = self.get(elm.id);\n            if (editor) {\n              self.remove(editor);\n            }\n          });\n          return;\n        }\n        editor = selector;\n        if (isNull(self.get(editor.id))) {\n          return null;\n        }\n        if (removeEditorFromList(editor)) {\n          self.dispatch('RemoveEditor', { editor });\n        }\n        if (editors.length === 0) {\n          window.removeEventListener('beforeunload', beforeUnloadDelegate);\n        }\n        editor.remove();\n        toggleGlobalEvents(editors.length > 0);\n        return editor;\n      },\n      execCommand(cmd, ui, value) {\n        var _a;\n        const self = this;\n        const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;\n        switch (cmd) {\n        case 'mceAddEditor': {\n            if (!self.get(editorId)) {\n              const editorOptions = value.options;\n              new Editor(editorId, editorOptions, self).render();\n            }\n            return true;\n          }\n        case 'mceRemoveEditor': {\n            const editor = self.get(editorId);\n            if (editor) {\n              editor.remove();\n            }\n            return true;\n          }\n        case 'mceToggleEditor': {\n            const editor = self.get(editorId);\n            if (!editor) {\n              self.execCommand('mceAddEditor', false, value);\n              return true;\n            }\n            if (editor.isHidden()) {\n              editor.show();\n            } else {\n              editor.hide();\n            }\n            return true;\n          }\n        }\n        if (self.activeEditor) {\n          return self.activeEditor.execCommand(cmd, ui, value);\n        }\n        return false;\n      },\n      triggerSave: () => {\n        each(editors, editor => {\n          editor.save();\n        });\n      },\n      addI18n: (code, items) => {\n        I18n.add(code, items);\n      },\n      translate: text => {\n        return I18n.translate(text);\n      },\n      setActive(editor) {\n        const activeEditor = this.activeEditor;\n        if (this.activeEditor !== editor) {\n          if (activeEditor) {\n            activeEditor.dispatch('deactivate', { relatedTarget: editor });\n          }\n          editor.dispatch('activate', { relatedTarget: activeEditor });\n        }\n        this.activeEditor = editor;\n      },\n      _setBaseUrl(baseUrl) {\n        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\\/+$/, ''));\n        this.baseURI = new URI(this.baseURL);\n      }\n    };\n    EditorManager.setup();\n\n    const setup = () => {\n      const dataValue = value$2();\n      const FakeClipboardItem = items => ({\n        items,\n        types: keys(items),\n        getType: type => get$a(items, type).getOrUndefined()\n      });\n      const write = data => {\n        dataValue.set(data);\n      };\n      const read = () => dataValue.get().getOrUndefined();\n      const clear = dataValue.clear;\n      return {\n        FakeClipboardItem,\n        write,\n        read,\n        clear\n      };\n    };\n    const FakeClipboard = setup();\n\n    const min = Math.min, max = Math.max, round = Math.round;\n    const relativePosition = (rect, targetRect, rel) => {\n      let x = targetRect.x;\n      let y = targetRect.y;\n      const w = rect.w;\n      const h = rect.h;\n      const targetW = targetRect.w;\n      const targetH = targetRect.h;\n      const relChars = (rel || '').split('');\n      if (relChars[0] === 'b') {\n        y += targetH;\n      }\n      if (relChars[1] === 'r') {\n        x += targetW;\n      }\n      if (relChars[0] === 'c') {\n        y += round(targetH / 2);\n      }\n      if (relChars[1] === 'c') {\n        x += round(targetW / 2);\n      }\n      if (relChars[3] === 'b') {\n        y -= h;\n      }\n      if (relChars[4] === 'r') {\n        x -= w;\n      }\n      if (relChars[3] === 'c') {\n        y -= round(h / 2);\n      }\n      if (relChars[4] === 'c') {\n        x -= round(w / 2);\n      }\n      return create$2(x, y, w, h);\n    };\n    const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {\n      for (let i = 0; i < rels.length; i++) {\n        const pos = relativePosition(rect, targetRect, rels[i]);\n        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {\n          return rels[i];\n        }\n      }\n      return null;\n    };\n    const inflate = (rect, w, h) => {\n      return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);\n    };\n    const intersect = (rect, cropRect) => {\n      const x1 = max(rect.x, cropRect.x);\n      const y1 = max(rect.y, cropRect.y);\n      const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);\n      const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);\n      if (x2 - x1 < 0 || y2 - y1 < 0) {\n        return null;\n      }\n      return create$2(x1, y1, x2 - x1, y2 - y1);\n    };\n    const clamp = (rect, clampRect, fixedSize) => {\n      let x1 = rect.x;\n      let y1 = rect.y;\n      let x2 = rect.x + rect.w;\n      let y2 = rect.y + rect.h;\n      const cx2 = clampRect.x + clampRect.w;\n      const cy2 = clampRect.y + clampRect.h;\n      const underflowX1 = max(0, clampRect.x - x1);\n      const underflowY1 = max(0, clampRect.y - y1);\n      const overflowX2 = max(0, x2 - cx2);\n      const overflowY2 = max(0, y2 - cy2);\n      x1 += underflowX1;\n      y1 += underflowY1;\n      if (fixedSize) {\n        x2 += underflowX1;\n        y2 += underflowY1;\n        x1 -= overflowX2;\n        y1 -= overflowY2;\n      }\n      x2 -= overflowX2;\n      y2 -= overflowY2;\n      return create$2(x1, y1, x2 - x1, y2 - y1);\n    };\n    const create$2 = (x, y, w, h) => {\n      return {\n        x,\n        y,\n        w,\n        h\n      };\n    };\n    const fromClientRect = clientRect => {\n      return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);\n    };\n    const Rect = {\n      inflate,\n      relativePosition,\n      findBestRelativePosition,\n      intersect,\n      clamp,\n      create: create$2,\n      fromClientRect\n    };\n\n    const awaiter = (resolveCb, rejectCb, timeout = 1000) => {\n      let done = false;\n      let timer = null;\n      const complete = completer => (...args) => {\n        if (!done) {\n          done = true;\n          if (timer !== null) {\n            clearTimeout(timer);\n            timer = null;\n          }\n          completer.apply(null, args);\n        }\n      };\n      const resolve = complete(resolveCb);\n      const reject = complete(rejectCb);\n      const start = (...args) => {\n        if (!done && timer === null) {\n          timer = setTimeout(() => reject.apply(null, args), timeout);\n        }\n      };\n      return {\n        start,\n        resolve,\n        reject\n      };\n    };\n    const create$1 = () => {\n      const tasks = {};\n      const resultFns = {};\n      const resources = {};\n      const load = (id, url) => {\n        const loadErrMsg = `Script at URL \"${ url }\" failed to load`;\n        const runErrMsg = `Script at URL \"${ url }\" did not call \\`tinymce.Resource.add('${ id }', data)\\` within 1 second`;\n        if (tasks[id] !== undefined) {\n          return tasks[id];\n        } else {\n          const task = new Promise((resolve, reject) => {\n            const waiter = awaiter(resolve, reject);\n            resultFns[id] = waiter.resolve;\n            ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));\n          });\n          tasks[id] = task;\n          return task;\n        }\n      };\n      const add = (id, data) => {\n        if (resultFns[id] !== undefined) {\n          resultFns[id](data);\n          delete resultFns[id];\n        }\n        tasks[id] = Promise.resolve(data);\n        resources[id] = data;\n      };\n      const has = id => {\n        return id in resources;\n      };\n      const unload = id => {\n        delete tasks[id];\n        delete resources[id];\n      };\n      const get = id => resources[id];\n      return {\n        load,\n        add,\n        has,\n        get,\n        unload\n      };\n    };\n    const Resource = create$1();\n\n    const create = () => (() => {\n      let data = {};\n      let keys = [];\n      const storage = {\n        getItem: key => {\n          const item = data[key];\n          return item ? item : null;\n        },\n        setItem: (key, value) => {\n          keys.push(key);\n          data[key] = String(value);\n        },\n        key: index => {\n          return keys[index];\n        },\n        removeItem: key => {\n          keys = keys.filter(k => k === key);\n          delete data[key];\n        },\n        clear: () => {\n          keys = [];\n          data = {};\n        },\n        length: 0\n      };\n      Object.defineProperty(storage, 'length', {\n        get: () => keys.length,\n        configurable: false,\n        enumerable: false\n      });\n      return storage;\n    })();\n\n    let localStorage;\n    try {\n      const test = '__storage_test__';\n      localStorage = window.localStorage;\n      localStorage.setItem(test, test);\n      localStorage.removeItem(test);\n    } catch (e) {\n      localStorage = create();\n    }\n    var LocalStorage = localStorage;\n\n    const publicApi = {\n      geom: { Rect },\n      util: {\n        Delay,\n        Tools,\n        VK,\n        URI,\n        EventDispatcher,\n        Observable,\n        I18n,\n        LocalStorage,\n        ImageUploader\n      },\n      dom: {\n        EventUtils,\n        TreeWalker: DomTreeWalker,\n        TextSeeker,\n        DOMUtils,\n        ScriptLoader,\n        RangeUtils,\n        Serializer: DomSerializer,\n        StyleSheetLoader,\n        ControlSelection,\n        BookmarkManager,\n        Selection: EditorSelection,\n        Event: EventUtils.Event\n      },\n      html: {\n        Styles,\n        Entities,\n        Node: AstNode,\n        Schema,\n        DomParser,\n        Writer,\n        Serializer: HtmlSerializer\n      },\n      Env,\n      AddOnManager,\n      Annotator,\n      Formatter,\n      UndoManager,\n      EditorCommands,\n      WindowManager,\n      NotificationManager,\n      EditorObservable,\n      Shortcuts,\n      Editor,\n      FocusManager,\n      EditorManager,\n      DOM: DOMUtils.DOM,\n      ScriptLoader: ScriptLoader.ScriptLoader,\n      PluginManager,\n      ThemeManager,\n      ModelManager,\n      IconManager,\n      Resource,\n      FakeClipboard,\n      trim: Tools.trim,\n      isArray: Tools.isArray,\n      is: Tools.is,\n      toArray: Tools.toArray,\n      makeMap: Tools.makeMap,\n      each: Tools.each,\n      map: Tools.map,\n      grep: Tools.grep,\n      inArray: Tools.inArray,\n      extend: Tools.extend,\n      walk: Tools.walk,\n      resolve: Tools.resolve,\n      explode: Tools.explode,\n      _addCacheSuffix: Tools._addCacheSuffix\n    };\n    const tinymce$1 = Tools.extend(EditorManager, publicApi);\n\n    const exportToModuleLoaders = tinymce => {\n      if (true) {\n        try {\n          module.exports = tinymce;\n        } catch (_) {\n        }\n      }\n    };\n    const exportToWindowGlobal = tinymce => {\n      window.tinymce = tinymce;\n      window.tinyMCE = tinymce;\n    };\n    exportToWindowGlobal(tinymce$1);\n    exportToModuleLoaders(tinymce$1);\n\n})();\n\n\n//# sourceURL=webpack://keenthemes/./node_modules/tinymce/tinymce.js?");

/***/ }),

/***/ "./webpack/plugins/custom/tinymce/tinymce.js":
/*!***************************************************!*\
  !*** ./webpack/plugins/custom/tinymce/tinymce.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// TinyMCE: The rich text editor built to scale, designed to innovate, and developed in open source: https://www.tiny.cloud/\n\n__webpack_require__(/*! tinymce/tinymce.js */ \"./node_modules/tinymce/tinymce.js\");\n__webpack_require__(/*! tinymce/icons/default/icons.js */ \"./node_modules/tinymce/icons/default/icons.js\");\n__webpack_require__(/*! tinymce/themes/silver/theme.js */ \"./node_modules/tinymce/themes/silver/theme.js\");\n\n\n//# sourceURL=webpack://keenthemes/./webpack/plugins/custom/tinymce/tinymce.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./webpack/plugins/custom/tinymce/tinymce.js");
/******/ 	
/******/ })()
;