/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@shopify/draggable/build/umd/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@shopify/draggable/build/umd/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  0;\n})(this, (function (exports) { 'use strict';\n\n  class AbstractEvent {\n\n    constructor(data) {\n\n      this._canceled = false;\n      this.data = data;\n    }\n\n    get type() {\n      return this.constructor.type;\n    }\n\n    get cancelable() {\n      return this.constructor.cancelable;\n    }\n\n    cancel() {\n      this._canceled = true;\n    }\n\n    canceled() {\n      return this._canceled;\n    }\n\n    clone(data) {\n      return new this.constructor({\n        ...this.data,\n        ...data\n      });\n    }\n  }\n\n  AbstractEvent.type = 'event';\n\n  AbstractEvent.cancelable = false;\n\n  class AbstractPlugin {\n\n    constructor(draggable) {\n      this.draggable = draggable;\n    }\n\n    attach() {\n      throw new Error('Not Implemented');\n    }\n\n    detach() {\n      throw new Error('Not Implemented');\n    }\n  }\n\n  const defaultDelay = {\n    mouse: 0,\n    drag: 0,\n    touch: 100\n  };\n\n  class Sensor {\n\n    constructor(containers = [], options = {}) {\n\n      this.containers = [...containers];\n\n      this.options = {\n        ...options\n      };\n\n      this.dragging = false;\n\n      this.currentContainer = null;\n\n      this.originalSource = null;\n\n      this.startEvent = null;\n\n      this.delay = calcDelay(options.delay);\n    }\n\n    attach() {\n      return this;\n    }\n\n    detach() {\n      return this;\n    }\n\n    addContainer(...containers) {\n      this.containers = [...this.containers, ...containers];\n    }\n\n    removeContainer(...containers) {\n      this.containers = this.containers.filter(container => !containers.includes(container));\n    }\n\n    trigger(element, sensorEvent) {\n      const event = document.createEvent('Event');\n      event.detail = sensorEvent;\n      event.initEvent(sensorEvent.type, true, true);\n      element.dispatchEvent(event);\n      this.lastEvent = sensorEvent;\n      return sensorEvent;\n    }\n  }\n\n  function calcDelay(optionsDelay) {\n    const delay = {};\n    if (optionsDelay === undefined) {\n      return {\n        ...defaultDelay\n      };\n    }\n    if (typeof optionsDelay === 'number') {\n      for (const key in defaultDelay) {\n        if (Object.prototype.hasOwnProperty.call(defaultDelay, key)) {\n          delay[key] = optionsDelay;\n        }\n      }\n      return delay;\n    }\n    for (const key in defaultDelay) {\n      if (Object.prototype.hasOwnProperty.call(defaultDelay, key)) {\n        if (optionsDelay[key] === undefined) {\n          delay[key] = defaultDelay[key];\n        } else {\n          delay[key] = optionsDelay[key];\n        }\n      }\n    }\n    return delay;\n  }\n\n  function closest(node, value) {\n    if (node == null) {\n      return null;\n    }\n    function conditionFn(currentNode) {\n      if (currentNode == null || value == null) {\n        return false;\n      } else if (isSelector(value)) {\n        return Element.prototype.matches.call(currentNode, value);\n      } else if (isNodeList(value)) {\n        return [...value].includes(currentNode);\n      } else if (isElement(value)) {\n        return value === currentNode;\n      } else if (isFunction(value)) {\n        return value(currentNode);\n      } else {\n        return false;\n      }\n    }\n    let current = node;\n    do {\n      current = current.correspondingUseElement || current.correspondingElement || current;\n      if (conditionFn(current)) {\n        return current;\n      }\n      current = current?.parentNode || null;\n    } while (current != null && current !== document.body && current !== document);\n    return null;\n  }\n  function isSelector(value) {\n    return Boolean(typeof value === 'string');\n  }\n  function isNodeList(value) {\n    return Boolean(value instanceof NodeList || value instanceof Array);\n  }\n  function isElement(value) {\n    return Boolean(value instanceof Node);\n  }\n  function isFunction(value) {\n    return Boolean(typeof value === 'function');\n  }\n\n  function AutoBind(originalMethod, {\n    name,\n    addInitializer\n  }) {\n    addInitializer(function () {\n\n      this[name] = originalMethod.bind(this);\n\n    });\n  }\n\n  function requestNextAnimationFrame(callback) {\n    return requestAnimationFrame(() => {\n      requestAnimationFrame(callback);\n    });\n  }\n\n  function distance(x1, y1, x2, y2) {\n    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n  }\n\n  function touchCoords(event) {\n    const {\n      touches,\n      changedTouches\n    } = event;\n    return touches && touches[0] || changedTouches && changedTouches[0];\n  }\n\n  class SensorEvent extends AbstractEvent {\n\n    get originalEvent() {\n      return this.data.originalEvent;\n    }\n\n    get clientX() {\n      return this.data.clientX;\n    }\n\n    get clientY() {\n      return this.data.clientY;\n    }\n\n    get target() {\n      return this.data.target;\n    }\n\n    get container() {\n      return this.data.container;\n    }\n\n    get originalSource() {\n      return this.data.originalSource;\n    }\n\n    get pressure() {\n      return this.data.pressure;\n    }\n  }\n\n  class DragStartSensorEvent extends SensorEvent {}\n\n  DragStartSensorEvent.type = 'drag:start';\n  class DragMoveSensorEvent extends SensorEvent {}\n\n  DragMoveSensorEvent.type = 'drag:move';\n  class DragStopSensorEvent extends SensorEvent {}\n\n  DragStopSensorEvent.type = 'drag:stop';\n  class DragPressureSensorEvent extends SensorEvent {}\n  DragPressureSensorEvent.type = 'drag:pressure';\n\n  const onContextMenuWhileDragging = Symbol('onContextMenuWhileDragging');\n  const onMouseDown$2 = Symbol('onMouseDown');\n  const onMouseMove$1 = Symbol('onMouseMove');\n  const onMouseUp$2 = Symbol('onMouseUp');\n  const startDrag$1 = Symbol('startDrag');\n  const onDistanceChange$1 = Symbol('onDistanceChange');\n\n  class MouseSensor extends Sensor {\n\n    constructor(containers = [], options = {}) {\n      super(containers, options);\n\n      this.mouseDownTimeout = null;\n\n      this.pageX = null;\n\n      this.pageY = null;\n      this[onContextMenuWhileDragging] = this[onContextMenuWhileDragging].bind(this);\n      this[onMouseDown$2] = this[onMouseDown$2].bind(this);\n      this[onMouseMove$1] = this[onMouseMove$1].bind(this);\n      this[onMouseUp$2] = this[onMouseUp$2].bind(this);\n      this[startDrag$1] = this[startDrag$1].bind(this);\n      this[onDistanceChange$1] = this[onDistanceChange$1].bind(this);\n    }\n\n    attach() {\n      document.addEventListener('mousedown', this[onMouseDown$2], true);\n    }\n\n    detach() {\n      document.removeEventListener('mousedown', this[onMouseDown$2], true);\n    }\n\n    [onMouseDown$2](event) {\n      if (event.button !== 0 || event.ctrlKey || event.metaKey) {\n        return;\n      }\n      const container = closest(event.target, this.containers);\n      if (!container) {\n        return;\n      }\n      if (this.options.handle && event.target && !closest(event.target, this.options.handle)) {\n        return;\n      }\n      const originalSource = closest(event.target, this.options.draggable);\n      if (!originalSource) {\n        return;\n      }\n      const {\n        delay\n      } = this;\n      const {\n        pageX,\n        pageY\n      } = event;\n      Object.assign(this, {\n        pageX,\n        pageY\n      });\n      this.onMouseDownAt = Date.now();\n      this.startEvent = event;\n      this.currentContainer = container;\n      this.originalSource = originalSource;\n      document.addEventListener('mouseup', this[onMouseUp$2]);\n      document.addEventListener('dragstart', preventNativeDragStart);\n      document.addEventListener('mousemove', this[onDistanceChange$1]);\n      this.mouseDownTimeout = window.setTimeout(() => {\n        this[onDistanceChange$1]({\n          pageX: this.pageX,\n          pageY: this.pageY\n        });\n      }, delay.mouse);\n    }\n\n    [startDrag$1]() {\n      const startEvent = this.startEvent;\n      const container = this.currentContainer;\n      const originalSource = this.originalSource;\n      const dragStartEvent = new DragStartSensorEvent({\n        clientX: startEvent.clientX,\n        clientY: startEvent.clientY,\n        target: startEvent.target,\n        container,\n        originalSource,\n        originalEvent: startEvent\n      });\n      this.trigger(this.currentContainer, dragStartEvent);\n      this.dragging = !dragStartEvent.canceled();\n      if (this.dragging) {\n        document.addEventListener('contextmenu', this[onContextMenuWhileDragging], true);\n        document.addEventListener('mousemove', this[onMouseMove$1]);\n      }\n    }\n\n    [onDistanceChange$1](event) {\n      const {\n        pageX,\n        pageY\n      } = event;\n      const {\n        distance: distance$1\n      } = this.options;\n      const {\n        startEvent,\n        delay\n      } = this;\n      Object.assign(this, {\n        pageX,\n        pageY\n      });\n      if (!this.currentContainer) {\n        return;\n      }\n      const timeElapsed = Date.now() - this.onMouseDownAt;\n      const distanceTravelled = distance(startEvent.pageX, startEvent.pageY, pageX, pageY) || 0;\n      clearTimeout(this.mouseDownTimeout);\n      if (timeElapsed < delay.mouse) {\n\n        document.removeEventListener('mousemove', this[onDistanceChange$1]);\n      } else if (distanceTravelled >= distance$1) {\n        document.removeEventListener('mousemove', this[onDistanceChange$1]);\n        this[startDrag$1]();\n      }\n    }\n\n    [onMouseMove$1](event) {\n      if (!this.dragging) {\n        return;\n      }\n      const target = document.elementFromPoint(event.clientX, event.clientY);\n      const dragMoveEvent = new DragMoveSensorEvent({\n        clientX: event.clientX,\n        clientY: event.clientY,\n        target,\n        container: this.currentContainer,\n        originalEvent: event\n      });\n      this.trigger(this.currentContainer, dragMoveEvent);\n    }\n\n    [onMouseUp$2](event) {\n      clearTimeout(this.mouseDownTimeout);\n      if (event.button !== 0) {\n        return;\n      }\n      document.removeEventListener('mouseup', this[onMouseUp$2]);\n      document.removeEventListener('dragstart', preventNativeDragStart);\n      document.removeEventListener('mousemove', this[onDistanceChange$1]);\n      if (!this.dragging) {\n        return;\n      }\n      const target = document.elementFromPoint(event.clientX, event.clientY);\n      const dragStopEvent = new DragStopSensorEvent({\n        clientX: event.clientX,\n        clientY: event.clientY,\n        target,\n        container: this.currentContainer,\n        originalEvent: event\n      });\n      this.trigger(this.currentContainer, dragStopEvent);\n      document.removeEventListener('contextmenu', this[onContextMenuWhileDragging], true);\n      document.removeEventListener('mousemove', this[onMouseMove$1]);\n      this.currentContainer = null;\n      this.dragging = false;\n      this.startEvent = null;\n    }\n\n    [onContextMenuWhileDragging](event) {\n      event.preventDefault();\n    }\n  }\n  function preventNativeDragStart(event) {\n    event.preventDefault();\n  }\n\n  const onTouchStart = Symbol('onTouchStart');\n  const onTouchEnd = Symbol('onTouchEnd');\n  const onTouchMove = Symbol('onTouchMove');\n  const startDrag = Symbol('startDrag');\n  const onDistanceChange = Symbol('onDistanceChange');\n\n  let preventScrolling = false;\n\n  window.addEventListener('touchmove', event => {\n    if (!preventScrolling) {\n      return;\n    }\n\n    event.preventDefault();\n  }, {\n    passive: false\n  });\n\n  class TouchSensor extends Sensor {\n\n    constructor(containers = [], options = {}) {\n      super(containers, options);\n\n      this.currentScrollableParent = null;\n\n      this.tapTimeout = null;\n\n      this.touchMoved = false;\n\n      this.pageX = null;\n\n      this.pageY = null;\n      this[onTouchStart] = this[onTouchStart].bind(this);\n      this[onTouchEnd] = this[onTouchEnd].bind(this);\n      this[onTouchMove] = this[onTouchMove].bind(this);\n      this[startDrag] = this[startDrag].bind(this);\n      this[onDistanceChange] = this[onDistanceChange].bind(this);\n    }\n\n    attach() {\n      document.addEventListener('touchstart', this[onTouchStart]);\n    }\n\n    detach() {\n      document.removeEventListener('touchstart', this[onTouchStart]);\n    }\n\n    [onTouchStart](event) {\n      const container = closest(event.target, this.containers);\n      if (!container) {\n        return;\n      }\n      if (this.options.handle && event.target && !closest(event.target, this.options.handle)) {\n        return;\n      }\n      const originalSource = closest(event.target, this.options.draggable);\n      if (!originalSource) {\n        return;\n      }\n      const {\n        distance = 0\n      } = this.options;\n      const {\n        delay\n      } = this;\n      const {\n        pageX,\n        pageY\n      } = touchCoords(event);\n      Object.assign(this, {\n        pageX,\n        pageY\n      });\n      this.onTouchStartAt = Date.now();\n      this.startEvent = event;\n      this.currentContainer = container;\n      this.originalSource = originalSource;\n      document.addEventListener('touchend', this[onTouchEnd]);\n      document.addEventListener('touchcancel', this[onTouchEnd]);\n      document.addEventListener('touchmove', this[onDistanceChange]);\n      container.addEventListener('contextmenu', onContextMenu);\n      if (distance) {\n        preventScrolling = true;\n      }\n      this.tapTimeout = window.setTimeout(() => {\n        this[onDistanceChange]({\n          touches: [{\n            pageX: this.pageX,\n            pageY: this.pageY\n          }]\n        });\n      }, delay.touch);\n    }\n\n    [startDrag]() {\n      const startEvent = this.startEvent;\n      const container = this.currentContainer;\n      const touch = touchCoords(startEvent);\n      const originalSource = this.originalSource;\n      const dragStartEvent = new DragStartSensorEvent({\n        clientX: touch.pageX,\n        clientY: touch.pageY,\n        target: startEvent.target,\n        container,\n        originalSource,\n        originalEvent: startEvent\n      });\n      this.trigger(this.currentContainer, dragStartEvent);\n      this.dragging = !dragStartEvent.canceled();\n      if (this.dragging) {\n        document.addEventListener('touchmove', this[onTouchMove]);\n      }\n      preventScrolling = this.dragging;\n    }\n\n    [onDistanceChange](event) {\n      const {\n        distance: distance$1\n      } = this.options;\n      const {\n        startEvent,\n        delay\n      } = this;\n      const start = touchCoords(startEvent);\n      const current = touchCoords(event);\n      const timeElapsed = Date.now() - this.onTouchStartAt;\n      const distanceTravelled = distance(start.pageX, start.pageY, current.pageX, current.pageY);\n      Object.assign(this, current);\n      clearTimeout(this.tapTimeout);\n      if (timeElapsed < delay.touch) {\n\n        document.removeEventListener('touchmove', this[onDistanceChange]);\n      } else if (distanceTravelled >= distance$1) {\n        document.removeEventListener('touchmove', this[onDistanceChange]);\n        this[startDrag]();\n      }\n    }\n\n    [onTouchMove](event) {\n      if (!this.dragging) {\n        return;\n      }\n      const {\n        pageX,\n        pageY\n      } = touchCoords(event);\n      const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);\n      const dragMoveEvent = new DragMoveSensorEvent({\n        clientX: pageX,\n        clientY: pageY,\n        target,\n        container: this.currentContainer,\n        originalEvent: event\n      });\n      this.trigger(this.currentContainer, dragMoveEvent);\n    }\n\n    [onTouchEnd](event) {\n      clearTimeout(this.tapTimeout);\n      preventScrolling = false;\n      document.removeEventListener('touchend', this[onTouchEnd]);\n      document.removeEventListener('touchcancel', this[onTouchEnd]);\n      document.removeEventListener('touchmove', this[onDistanceChange]);\n      if (this.currentContainer) {\n        this.currentContainer.removeEventListener('contextmenu', onContextMenu);\n      }\n      if (!this.dragging) {\n        return;\n      }\n      document.removeEventListener('touchmove', this[onTouchMove]);\n      const {\n        pageX,\n        pageY\n      } = touchCoords(event);\n      const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);\n      event.preventDefault();\n      const dragStopEvent = new DragStopSensorEvent({\n        clientX: pageX,\n        clientY: pageY,\n        target,\n        container: this.currentContainer,\n        originalEvent: event\n      });\n      this.trigger(this.currentContainer, dragStopEvent);\n      this.currentContainer = null;\n      this.dragging = false;\n      this.startEvent = null;\n    }\n  }\n  function onContextMenu(event) {\n    event.preventDefault();\n    event.stopPropagation();\n  }\n\n  const onMouseDown$1 = Symbol('onMouseDown');\n  const onMouseUp$1 = Symbol('onMouseUp');\n  const onDragStart$7 = Symbol('onDragStart');\n  const onDragOver$3 = Symbol('onDragOver');\n  const onDragEnd = Symbol('onDragEnd');\n  const onDrop = Symbol('onDrop');\n  const reset = Symbol('reset');\n\n  class DragSensor extends Sensor {\n\n    constructor(containers = [], options = {}) {\n      super(containers, options);\n\n      this.mouseDownTimeout = null;\n\n      this.draggableElement = null;\n\n      this.nativeDraggableElement = null;\n      this[onMouseDown$1] = this[onMouseDown$1].bind(this);\n      this[onMouseUp$1] = this[onMouseUp$1].bind(this);\n      this[onDragStart$7] = this[onDragStart$7].bind(this);\n      this[onDragOver$3] = this[onDragOver$3].bind(this);\n      this[onDragEnd] = this[onDragEnd].bind(this);\n      this[onDrop] = this[onDrop].bind(this);\n    }\n\n    attach() {\n      document.addEventListener('mousedown', this[onMouseDown$1], true);\n    }\n\n    detach() {\n      document.removeEventListener('mousedown', this[onMouseDown$1], true);\n    }\n\n    [onDragStart$7](event) {\n\n      event.dataTransfer.setData('text', '');\n      event.dataTransfer.effectAllowed = this.options.type;\n      const target = document.elementFromPoint(event.clientX, event.clientY);\n      const originalSource = this.draggableElement;\n      if (!originalSource) {\n        return;\n      }\n      const dragStartEvent = new DragStartSensorEvent({\n        clientX: event.clientX,\n        clientY: event.clientY,\n        target,\n        originalSource,\n        container: this.currentContainer,\n        originalEvent: event\n      });\n\n      setTimeout(() => {\n        this.trigger(this.currentContainer, dragStartEvent);\n        if (dragStartEvent.canceled()) {\n          this.dragging = false;\n        } else {\n          this.dragging = true;\n        }\n      }, 0);\n    }\n\n    [onDragOver$3](event) {\n      if (!this.dragging) {\n        return;\n      }\n      const target = document.elementFromPoint(event.clientX, event.clientY);\n      const container = this.currentContainer;\n      const dragMoveEvent = new DragMoveSensorEvent({\n        clientX: event.clientX,\n        clientY: event.clientY,\n        target,\n        container,\n        originalEvent: event\n      });\n      this.trigger(container, dragMoveEvent);\n      if (!dragMoveEvent.canceled()) {\n        event.preventDefault();\n        event.dataTransfer.dropEffect = this.options.type;\n      }\n    }\n\n    [onDragEnd](event) {\n      if (!this.dragging) {\n        return;\n      }\n      document.removeEventListener('mouseup', this[onMouseUp$1], true);\n      const target = document.elementFromPoint(event.clientX, event.clientY);\n      const container = this.currentContainer;\n      const dragStopEvent = new DragStopSensorEvent({\n        clientX: event.clientX,\n        clientY: event.clientY,\n        target,\n        container,\n        originalEvent: event\n      });\n      this.trigger(container, dragStopEvent);\n      this.dragging = false;\n      this.startEvent = null;\n      this[reset]();\n    }\n\n    [onDrop](event) {\n      event.preventDefault();\n    }\n\n    [onMouseDown$1](event) {\n\n      if (event.target && (event.target.form || event.target.contenteditable)) {\n        return;\n      }\n      const target = event.target;\n      this.currentContainer = closest(target, this.containers);\n      if (!this.currentContainer) {\n        return;\n      }\n      if (this.options.handle && target && !closest(target, this.options.handle)) {\n        return;\n      }\n      const originalSource = closest(target, this.options.draggable);\n      if (!originalSource) {\n        return;\n      }\n      const nativeDraggableElement = closest(event.target, element => element.draggable);\n      if (nativeDraggableElement) {\n        nativeDraggableElement.draggable = false;\n        this.nativeDraggableElement = nativeDraggableElement;\n      }\n      document.addEventListener('mouseup', this[onMouseUp$1], true);\n      document.addEventListener('dragstart', this[onDragStart$7], false);\n      document.addEventListener('dragover', this[onDragOver$3], false);\n      document.addEventListener('dragend', this[onDragEnd], false);\n      document.addEventListener('drop', this[onDrop], false);\n      this.startEvent = event;\n      this.mouseDownTimeout = setTimeout(() => {\n        originalSource.draggable = true;\n        this.draggableElement = originalSource;\n      }, this.delay.drag);\n    }\n\n    [onMouseUp$1]() {\n      this[reset]();\n    }\n\n    [reset]() {\n      clearTimeout(this.mouseDownTimeout);\n      document.removeEventListener('mouseup', this[onMouseUp$1], true);\n      document.removeEventListener('dragstart', this[onDragStart$7], false);\n      document.removeEventListener('dragover', this[onDragOver$3], false);\n      document.removeEventListener('dragend', this[onDragEnd], false);\n      document.removeEventListener('drop', this[onDrop], false);\n      if (this.nativeDraggableElement) {\n        this.nativeDraggableElement.draggable = true;\n        this.nativeDraggableElement = null;\n      }\n      if (this.draggableElement) {\n        this.draggableElement.draggable = false;\n        this.draggableElement = null;\n      }\n    }\n  }\n\n  const onMouseForceWillBegin = Symbol('onMouseForceWillBegin');\n  const onMouseForceDown = Symbol('onMouseForceDown');\n  const onMouseDown = Symbol('onMouseDown');\n  const onMouseForceChange = Symbol('onMouseForceChange');\n  const onMouseMove = Symbol('onMouseMove');\n  const onMouseUp = Symbol('onMouseUp');\n  const onMouseForceGlobalChange = Symbol('onMouseForceGlobalChange');\n\n  class ForceTouchSensor extends Sensor {\n\n    constructor(containers = [], options = {}) {\n      super(containers, options);\n\n      this.mightDrag = false;\n      this[onMouseForceWillBegin] = this[onMouseForceWillBegin].bind(this);\n      this[onMouseForceDown] = this[onMouseForceDown].bind(this);\n      this[onMouseDown] = this[onMouseDown].bind(this);\n      this[onMouseForceChange] = this[onMouseForceChange].bind(this);\n      this[onMouseMove] = this[onMouseMove].bind(this);\n      this[onMouseUp] = this[onMouseUp].bind(this);\n    }\n\n    attach() {\n      for (const container of this.containers) {\n        container.addEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\n        container.addEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\n        container.addEventListener('mousedown', this[onMouseDown], true);\n        container.addEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\n      }\n      document.addEventListener('mousemove', this[onMouseMove]);\n      document.addEventListener('mouseup', this[onMouseUp]);\n    }\n\n    detach() {\n      for (const container of this.containers) {\n        container.removeEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\n        container.removeEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\n        container.removeEventListener('mousedown', this[onMouseDown], true);\n        container.removeEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\n      }\n      document.removeEventListener('mousemove', this[onMouseMove]);\n      document.removeEventListener('mouseup', this[onMouseUp]);\n    }\n\n    [onMouseForceWillBegin](event) {\n      event.preventDefault();\n      this.mightDrag = true;\n    }\n\n    [onMouseForceDown](event) {\n      if (this.dragging) {\n        return;\n      }\n      const target = document.elementFromPoint(event.clientX, event.clientY);\n      const container = event.currentTarget;\n      if (this.options.handle && target && !closest(target, this.options.handle)) {\n        return;\n      }\n      const originalSource = closest(target, this.options.draggable);\n      if (!originalSource) {\n        return;\n      }\n      const dragStartEvent = new DragStartSensorEvent({\n        clientX: event.clientX,\n        clientY: event.clientY,\n        target,\n        container,\n        originalSource,\n        originalEvent: event\n      });\n      this.trigger(container, dragStartEvent);\n      this.currentContainer = container;\n      this.dragging = !dragStartEvent.canceled();\n      this.mightDrag = false;\n    }\n\n    [onMouseUp](event) {\n      if (!this.dragging) {\n        return;\n      }\n      const dragStopEvent = new DragStopSensorEvent({\n        clientX: event.clientX,\n        clientY: event.clientY,\n        target: null,\n        container: this.currentContainer,\n        originalEvent: event\n      });\n      this.trigger(this.currentContainer, dragStopEvent);\n      this.currentContainer = null;\n      this.dragging = false;\n      this.mightDrag = false;\n    }\n\n    [onMouseDown](event) {\n      if (!this.mightDrag) {\n        return;\n      }\n\n      event.stopPropagation();\n      event.stopImmediatePropagation();\n      event.preventDefault();\n    }\n\n    [onMouseMove](event) {\n      if (!this.dragging) {\n        return;\n      }\n      const target = document.elementFromPoint(event.clientX, event.clientY);\n      const dragMoveEvent = new DragMoveSensorEvent({\n        clientX: event.clientX,\n        clientY: event.clientY,\n        target,\n        container: this.currentContainer,\n        originalEvent: event\n      });\n      this.trigger(this.currentContainer, dragMoveEvent);\n    }\n\n    [onMouseForceChange](event) {\n      if (this.dragging) {\n        return;\n      }\n      const target = event.target;\n      const container = event.currentTarget;\n      const dragPressureEvent = new DragPressureSensorEvent({\n        pressure: event.webkitForce,\n        clientX: event.clientX,\n        clientY: event.clientY,\n        target,\n        container,\n        originalEvent: event\n      });\n      this.trigger(container, dragPressureEvent);\n    }\n\n    [onMouseForceGlobalChange](event) {\n      if (!this.dragging) {\n        return;\n      }\n      const target = event.target;\n      const dragPressureEvent = new DragPressureSensorEvent({\n        pressure: event.webkitForce,\n        clientX: event.clientX,\n        clientY: event.clientY,\n        target,\n        container: this.currentContainer,\n        originalEvent: event\n      });\n      this.trigger(this.currentContainer, dragPressureEvent);\n    }\n  }\n\n  var index$2 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    DragMoveSensorEvent: DragMoveSensorEvent,\n    DragPressureSensorEvent: DragPressureSensorEvent,\n    DragSensor: DragSensor,\n    DragStartSensorEvent: DragStartSensorEvent,\n    DragStopSensorEvent: DragStopSensorEvent,\n    ForceTouchSensor: ForceTouchSensor,\n    MouseSensor: MouseSensor,\n    Sensor: Sensor,\n    SensorEvent: SensorEvent,\n    TouchSensor: TouchSensor\n  });\n\n  class CollidableEvent extends AbstractEvent {\n\n    constructor(data) {\n      super(data);\n      this.data = data;\n    }\n\n    get dragEvent() {\n      return this.data.dragEvent;\n    }\n  }\n  CollidableEvent.type = 'collidable';\n\n  class CollidableInEvent extends CollidableEvent {\n\n    get collidingElement() {\n      return this.data.collidingElement;\n    }\n  }\n  CollidableInEvent.type = 'collidable:in';\n\n  class CollidableOutEvent extends CollidableEvent {\n\n    get collidingElement() {\n      return this.data.collidingElement;\n    }\n  }\n  CollidableOutEvent.type = 'collidable:out';\n\n  const onDragMove$4 = Symbol('onDragMove');\n  const onDragStop$7 = Symbol('onDragStop');\n  const onRequestAnimationFrame = Symbol('onRequestAnimationFrame');\n\n  class Collidable extends AbstractPlugin {\n\n    constructor(draggable) {\n      super(draggable);\n\n      this.currentlyCollidingElement = null;\n\n      this.lastCollidingElement = null;\n\n      this.currentAnimationFrame = null;\n      this[onDragMove$4] = this[onDragMove$4].bind(this);\n      this[onDragStop$7] = this[onDragStop$7].bind(this);\n      this[onRequestAnimationFrame] = this[onRequestAnimationFrame].bind(this);\n    }\n\n    attach() {\n      this.draggable.on('drag:move', this[onDragMove$4]).on('drag:stop', this[onDragStop$7]);\n    }\n\n    detach() {\n      this.draggable.off('drag:move', this[onDragMove$4]).off('drag:stop', this[onDragStop$7]);\n    }\n\n    getCollidables() {\n      const collidables = this.draggable.options.collidables;\n      if (typeof collidables === 'string') {\n        return Array.prototype.slice.call(document.querySelectorAll(collidables));\n      } else if (collidables instanceof NodeList || collidables instanceof Array) {\n        return Array.prototype.slice.call(collidables);\n      } else if (collidables instanceof HTMLElement) {\n        return [collidables];\n      } else if (typeof collidables === 'function') {\n        return collidables();\n      } else {\n        return [];\n      }\n    }\n\n    [onDragMove$4](event) {\n      const target = event.sensorEvent.target;\n      this.currentAnimationFrame = requestAnimationFrame(this[onRequestAnimationFrame](target));\n      if (this.currentlyCollidingElement) {\n        event.cancel();\n      }\n      const collidableInEvent = new CollidableInEvent({\n        dragEvent: event,\n        collidingElement: this.currentlyCollidingElement\n      });\n      const collidableOutEvent = new CollidableOutEvent({\n        dragEvent: event,\n        collidingElement: this.lastCollidingElement\n      });\n      const enteringCollidable = Boolean(this.currentlyCollidingElement && this.lastCollidingElement !== this.currentlyCollidingElement);\n      const leavingCollidable = Boolean(!this.currentlyCollidingElement && this.lastCollidingElement);\n      if (enteringCollidable) {\n        if (this.lastCollidingElement) {\n          this.draggable.trigger(collidableOutEvent);\n        }\n        this.draggable.trigger(collidableInEvent);\n      } else if (leavingCollidable) {\n        this.draggable.trigger(collidableOutEvent);\n      }\n      this.lastCollidingElement = this.currentlyCollidingElement;\n    }\n\n    [onDragStop$7](event) {\n      const lastCollidingElement = this.currentlyCollidingElement || this.lastCollidingElement;\n      const collidableOutEvent = new CollidableOutEvent({\n        dragEvent: event,\n        collidingElement: lastCollidingElement\n      });\n      if (lastCollidingElement) {\n        this.draggable.trigger(collidableOutEvent);\n      }\n      this.lastCollidingElement = null;\n      this.currentlyCollidingElement = null;\n    }\n\n    [onRequestAnimationFrame](target) {\n      return () => {\n        const collidables = this.getCollidables();\n        this.currentlyCollidingElement = closest(target, element => collidables.includes(element));\n      };\n    }\n  }\n\n  function createAddInitializerMethod(e, t) {\n    return function (r) {\n      assertNotFinished(t, \"addInitializer\"), assertCallable(r, \"An initializer\"), e.push(r);\n    };\n  }\n  function assertInstanceIfPrivate(e, t) {\n    if (!e(t)) throw new TypeError(\"Attempted to access private element on non-instance\");\n  }\n  function memberDec(e, t, r, a, n, i, s, o, c, l, u) {\n    var f;\n    switch (i) {\n      case 1:\n        f = \"accessor\";\n        break;\n      case 2:\n        f = \"method\";\n        break;\n      case 3:\n        f = \"getter\";\n        break;\n      case 4:\n        f = \"setter\";\n        break;\n      default:\n        f = \"field\";\n    }\n    var d,\n      p,\n      h = {\n        kind: f,\n        name: o ? \"#\" + r : r,\n        static: s,\n        private: o,\n        metadata: u\n      },\n      v = {\n        v: !1\n      };\n    if (0 !== i && (h.addInitializer = createAddInitializerMethod(n, v)), o || 0 !== i && 2 !== i) {\n      if (2 === i) d = function (e) {\n        return assertInstanceIfPrivate(l, e), a.value;\n      };else {\n        var y = 0 === i || 1 === i;\n        (y || 3 === i) && (d = o ? function (e) {\n          return assertInstanceIfPrivate(l, e), a.get.call(e);\n        } : function (e) {\n          return a.get.call(e);\n        }), (y || 4 === i) && (p = o ? function (e, t) {\n          assertInstanceIfPrivate(l, e), a.set.call(e, t);\n        } : function (e, t) {\n          a.set.call(e, t);\n        });\n      }\n    } else d = function (e) {\n      return e[r];\n    }, 0 === i && (p = function (e, t) {\n      e[r] = t;\n    });\n    var m = o ? l.bind() : function (e) {\n      return r in e;\n    };\n    h.access = d && p ? {\n      get: d,\n      set: p,\n      has: m\n    } : d ? {\n      get: d,\n      has: m\n    } : {\n      set: p,\n      has: m\n    };\n    try {\n      return e.call(t, c, h);\n    } finally {\n      v.v = !0;\n    }\n  }\n  function assertNotFinished(e, t) {\n    if (e.v) throw new Error(\"attempted to call \" + t + \" after decoration was finished\");\n  }\n  function assertCallable(e, t) {\n    if (\"function\" != typeof e) throw new TypeError(t + \" must be a function\");\n  }\n  function assertValidReturnValue(e, t) {\n    var r = typeof t;\n    if (1 === e) {\n      if (\"object\" !== r || null === t) throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");\n      void 0 !== t.get && assertCallable(t.get, \"accessor.get\"), void 0 !== t.set && assertCallable(t.set, \"accessor.set\"), void 0 !== t.init && assertCallable(t.init, \"accessor.init\");\n    } else if (\"function\" !== r) {\n      var a;\n      throw a = 0 === e ? \"field\" : 5 === e ? \"class\" : \"method\", new TypeError(a + \" decorators must return a function or void 0\");\n    }\n  }\n  function curryThis1(e) {\n    return function () {\n      return e(this);\n    };\n  }\n  function curryThis2(e) {\n    return function (t) {\n      e(this, t);\n    };\n  }\n  function applyMemberDec(e, t, r, a, n, i, s, o, c, l, u) {\n    var f,\n      d,\n      p,\n      h,\n      v,\n      y,\n      m = r[0];\n    a || Array.isArray(m) || (m = [m]), o ? f = 0 === i || 1 === i ? {\n      get: curryThis1(r[3]),\n      set: curryThis2(r[4])\n    } : 3 === i ? {\n      get: r[3]\n    } : 4 === i ? {\n      set: r[3]\n    } : {\n      value: r[3]\n    } : 0 !== i && (f = Object.getOwnPropertyDescriptor(t, n)), 1 === i ? p = {\n      get: f.get,\n      set: f.set\n    } : 2 === i ? p = f.value : 3 === i ? p = f.get : 4 === i && (p = f.set);\n    for (var g = a ? 2 : 1, b = m.length - 1; b >= 0; b -= g) {\n      var I;\n      if (void 0 !== (h = memberDec(m[b], a ? m[b - 1] : void 0, n, f, c, i, s, o, p, l, u))) assertValidReturnValue(i, h), 0 === i ? I = h : 1 === i ? (I = h.init, v = h.get || p.get, y = h.set || p.set, p = {\n        get: v,\n        set: y\n      }) : p = h, void 0 !== I && (void 0 === d ? d = I : \"function\" == typeof d ? d = [d, I] : d.push(I));\n    }\n    if (0 === i || 1 === i) {\n      if (void 0 === d) d = function (e, t) {\n        return t;\n      };else if (\"function\" != typeof d) {\n        var w = d;\n        d = function (e, t) {\n          for (var r = t, a = w.length - 1; a >= 0; a--) r = w[a].call(e, r);\n          return r;\n        };\n      } else {\n        var M = d;\n        d = function (e, t) {\n          return M.call(e, t);\n        };\n      }\n      e.push(d);\n    }\n    0 !== i && (1 === i ? (f.get = p.get, f.set = p.set) : 2 === i ? f.value = p : 3 === i ? f.get = p : 4 === i && (f.set = p), o ? 1 === i ? (e.push(function (e, t) {\n      return p.get.call(e, t);\n    }), e.push(function (e, t) {\n      return p.set.call(e, t);\n    })) : 2 === i ? e.push(p) : e.push(function (e, t) {\n      return p.call(e, t);\n    }) : Object.defineProperty(t, n, f));\n  }\n  function applyMemberDecs(e, t, r, a) {\n    for (var n, i, s, o = [], c = new Map(), l = new Map(), u = 0; u < t.length; u++) {\n      var f = t[u];\n      if (Array.isArray(f)) {\n        var d,\n          p,\n          h = f[1],\n          v = f[2],\n          y = f.length > 3,\n          m = 16 & h,\n          g = !!(8 & h),\n          b = r;\n        if (h &= 7, g ? (d = e, 0 !== h && (p = i = i || []), y && !s && (s = function (t) {\n          return _checkInRHS(t) === e;\n        }), b = s) : (d = e.prototype, 0 !== h && (p = n = n || [])), 0 !== h && !y) {\n          var I = g ? l : c,\n            w = I.get(v) || 0;\n          if (!0 === w || 3 === w && 4 !== h || 4 === w && 3 !== h) throw new Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \" + v);\n          I.set(v, !(!w && h > 2) || h);\n        }\n        applyMemberDec(o, d, f, m, v, h, g, y, p, b, a);\n      }\n    }\n    return pushInitializers(o, n), pushInitializers(o, i), o;\n  }\n  function pushInitializers(e, t) {\n    t && e.push(function (e) {\n      for (var r = 0; r < t.length; r++) t[r].call(e);\n      return e;\n    });\n  }\n  function applyClassDecs(e, t, r, a) {\n    if (t.length) {\n      for (var n = [], i = e, s = e.name, o = r ? 2 : 1, c = t.length - 1; c >= 0; c -= o) {\n        var l = {\n          v: !1\n        };\n        try {\n          var u = t[c].call(r ? t[c - 1] : void 0, i, {\n            kind: \"class\",\n            name: s,\n            addInitializer: createAddInitializerMethod(n, l),\n            metadata: a\n          });\n        } finally {\n          l.v = !0;\n        }\n        void 0 !== u && (assertValidReturnValue(5, u), i = u);\n      }\n      return [defineMetadata(i, a), function () {\n        for (var e = 0; e < n.length; e++) n[e].call(i);\n      }];\n    }\n  }\n  function defineMetadata(e, t) {\n    return Object.defineProperty(e, Symbol.metadata || Symbol.for(\"Symbol.metadata\"), {\n      configurable: !0,\n      enumerable: !0,\n      value: t\n    });\n  }\n  function _applyDecs2305(e, t, r, a, n, i) {\n    if (arguments.length >= 6) var s = i[Symbol.metadata || Symbol.for(\"Symbol.metadata\")];\n    var o = Object.create(void 0 === s ? null : s),\n      c = applyMemberDecs(e, t, n, o);\n    return r.length || defineMetadata(e, o), {\n      e: c,\n      get c() {\n        return applyClassDecs(e, r, a, o);\n      }\n    };\n  }\n  function _checkInRHS(e) {\n    if (Object(e) !== e) throw TypeError(\"right-hand side of 'in' should be an object, got \" + (null !== e ? typeof e : \"null\"));\n    return e;\n  }\n\n  class DragEvent extends AbstractEvent {\n\n    constructor(data) {\n      super(data);\n      this.data = data;\n    }\n\n    get source() {\n      return this.data.source;\n    }\n\n    get originalSource() {\n      return this.data.originalSource;\n    }\n\n    get mirror() {\n      return this.data.mirror;\n    }\n\n    get sourceContainer() {\n      return this.data.sourceContainer;\n    }\n\n    get sensorEvent() {\n      return this.data.sensorEvent;\n    }\n\n    get originalEvent() {\n      if (this.sensorEvent) {\n        return this.sensorEvent.originalEvent;\n      }\n      return null;\n    }\n  }\n\n  DragEvent.type = 'drag';\n  class DragStartEvent extends DragEvent {}\n\n  DragStartEvent.type = 'drag:start';\n  DragStartEvent.cancelable = true;\n  class DragMoveEvent extends DragEvent {}\n\n  DragMoveEvent.type = 'drag:move';\n\n  class DragOverEvent extends DragEvent {\n\n    get overContainer() {\n      return this.data.overContainer;\n    }\n\n    get over() {\n      return this.data.over;\n    }\n  }\n  DragOverEvent.type = 'drag:over';\n  DragOverEvent.cancelable = true;\n  function isDragOverEvent(event) {\n    return event.type === DragOverEvent.type;\n  }\n\n  class DragOutEvent extends DragEvent {\n\n    get overContainer() {\n      return this.data.overContainer;\n    }\n\n    get over() {\n      return this.data.over;\n    }\n  }\n\n  DragOutEvent.type = 'drag:out';\n\n  class DragOverContainerEvent extends DragEvent {\n\n    get overContainer() {\n      return this.data.overContainer;\n    }\n  }\n\n  DragOverContainerEvent.type = 'drag:over:container';\n\n  class DragOutContainerEvent extends DragEvent {\n\n    get overContainer() {\n      return this.data.overContainer;\n    }\n  }\n\n  DragOutContainerEvent.type = 'drag:out:container';\n\n  class DragPressureEvent extends DragEvent {\n\n    get pressure() {\n      return this.data.pressure;\n    }\n  }\n\n  DragPressureEvent.type = 'drag:pressure';\n  class DragStopEvent extends DragEvent {}\n\n  DragStopEvent.type = 'drag:stop';\n  DragStopEvent.cancelable = true;\n  class DragStoppedEvent extends DragEvent {}\n  DragStoppedEvent.type = 'drag:stopped';\n\n  var _initProto$1, _class$1;\n\n  const defaultOptions$8 = {};\n\n  class ResizeMirror extends AbstractPlugin {\n\n    constructor(draggable) {\n      _initProto$1(super(draggable));\n\n      this.lastWidth = 0;\n\n      this.lastHeight = 0;\n\n      this.mirror = null;\n    }\n\n    attach() {\n      this.draggable.on('mirror:created', this.onMirrorCreated).on('drag:over', this.onDragOver).on('drag:over:container', this.onDragOver);\n    }\n\n    detach() {\n      this.draggable.off('mirror:created', this.onMirrorCreated).off('mirror:destroy', this.onMirrorDestroy).off('drag:over', this.onDragOver).off('drag:over:container', this.onDragOver);\n    }\n\n    getOptions() {\n      return this.draggable.options.resizeMirror || {};\n    }\n\n    onMirrorCreated({\n      mirror\n    }) {\n      this.mirror = mirror;\n    }\n\n    onMirrorDestroy() {\n      this.mirror = null;\n    }\n\n    onDragOver(dragEvent) {\n      this.resize(dragEvent);\n    }\n\n    resize(dragEvent) {\n      requestAnimationFrame(() => {\n        let over = null;\n        const {\n          overContainer\n        } = dragEvent;\n        if (this.mirror == null || this.mirror.parentNode == null) {\n          return;\n        }\n        if (this.mirror.parentNode !== overContainer) {\n          overContainer.appendChild(this.mirror);\n        }\n        if (isDragOverEvent(dragEvent)) {\n          over = dragEvent.over;\n        }\n        const overElement = over || this.draggable.getDraggableElementsForContainer(overContainer)[0];\n        if (!overElement) {\n          return;\n        }\n        requestNextAnimationFrame(() => {\n          const overRect = overElement.getBoundingClientRect();\n          if (this.mirror == null || this.lastHeight === overRect.height && this.lastWidth === overRect.width) {\n            return;\n          }\n          this.mirror.style.width = `${overRect.width}px`;\n          this.mirror.style.height = `${overRect.height}px`;\n          this.lastWidth = overRect.width;\n          this.lastHeight = overRect.height;\n        });\n      });\n    }\n  }\n  _class$1 = ResizeMirror;\n  [_initProto$1] = _applyDecs2305(_class$1, [[AutoBind, 2, \"onMirrorCreated\"], [AutoBind, 2, \"onMirrorDestroy\"], [AutoBind, 2, \"onDragOver\"]], [], 0, void 0, AbstractPlugin).e;\n\n  class SnapEvent extends AbstractEvent {\n\n    get dragEvent() {\n      return this.data.dragEvent;\n    }\n\n    get snappable() {\n      return this.data.snappable;\n    }\n  }\n\n  SnapEvent.type = 'snap';\n  class SnapInEvent extends SnapEvent {}\n\n  SnapInEvent.type = 'snap:in';\n  SnapInEvent.cancelable = true;\n  class SnapOutEvent extends SnapEvent {}\n  SnapOutEvent.type = 'snap:out';\n  SnapOutEvent.cancelable = true;\n\n  const onDragStart$6 = Symbol('onDragStart');\n  const onDragStop$6 = Symbol('onDragStop');\n  const onDragOver$2 = Symbol('onDragOver');\n  const onDragOut = Symbol('onDragOut');\n  const onMirrorCreated$1 = Symbol('onMirrorCreated');\n  const onMirrorDestroy = Symbol('onMirrorDestroy');\n\n  class Snappable extends AbstractPlugin {\n\n    constructor(draggable) {\n      super(draggable);\n\n      this.firstSource = null;\n\n      this.mirror = null;\n      this[onDragStart$6] = this[onDragStart$6].bind(this);\n      this[onDragStop$6] = this[onDragStop$6].bind(this);\n      this[onDragOver$2] = this[onDragOver$2].bind(this);\n      this[onDragOut] = this[onDragOut].bind(this);\n      this[onMirrorCreated$1] = this[onMirrorCreated$1].bind(this);\n      this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);\n    }\n\n    attach() {\n      this.draggable.on('drag:start', this[onDragStart$6]).on('drag:stop', this[onDragStop$6]).on('drag:over', this[onDragOver$2]).on('drag:out', this[onDragOut]).on('droppable:over', this[onDragOver$2]).on('droppable:out', this[onDragOut]).on('mirror:created', this[onMirrorCreated$1]).on('mirror:destroy', this[onMirrorDestroy]);\n    }\n\n    detach() {\n      this.draggable.off('drag:start', this[onDragStart$6]).off('drag:stop', this[onDragStop$6]).off('drag:over', this[onDragOver$2]).off('drag:out', this[onDragOut]).off('droppable:over', this[onDragOver$2]).off('droppable:out', this[onDragOut]).off('mirror:created', this[onMirrorCreated$1]).off('mirror:destroy', this[onMirrorDestroy]);\n    }\n\n    [onDragStart$6](event) {\n      if (event.canceled()) {\n        return;\n      }\n      this.firstSource = event.source;\n    }\n\n    [onDragStop$6]() {\n      this.firstSource = null;\n    }\n\n    [onDragOver$2](event) {\n      if (event.canceled()) {\n        return;\n      }\n      const source = event.source || event.dragEvent.source;\n      if (source === this.firstSource) {\n        this.firstSource = null;\n        return;\n      }\n      const snapInEvent = new SnapInEvent({\n        dragEvent: event,\n        snappable: event.over || event.droppable\n      });\n      this.draggable.trigger(snapInEvent);\n      if (snapInEvent.canceled()) {\n        return;\n      }\n      if (this.mirror) {\n        this.mirror.style.display = 'none';\n      }\n      source.classList.remove(...this.draggable.getClassNamesFor('source:dragging'));\n      source.classList.add(...this.draggable.getClassNamesFor('source:placed'));\n\n      setTimeout(() => {\n        source.classList.remove(...this.draggable.getClassNamesFor('source:placed'));\n      }, this.draggable.options.placedTimeout);\n    }\n\n    [onDragOut](event) {\n      if (event.canceled()) {\n        return;\n      }\n      const source = event.source || event.dragEvent.source;\n      const snapOutEvent = new SnapOutEvent({\n        dragEvent: event,\n        snappable: event.over || event.droppable\n      });\n      this.draggable.trigger(snapOutEvent);\n      if (snapOutEvent.canceled()) {\n        return;\n      }\n      if (this.mirror) {\n        this.mirror.style.display = '';\n      }\n      source.classList.add(...this.draggable.getClassNamesFor('source:dragging'));\n    }\n\n    [onMirrorCreated$1]({\n      mirror\n    }) {\n      this.mirror = mirror;\n    }\n\n    [onMirrorDestroy]() {\n      this.mirror = null;\n    }\n  }\n\n  var _initProto, _class;\n\n  const defaultOptions$7 = {\n    duration: 150,\n    easingFunction: 'ease-in-out',\n    horizontal: false\n  };\n\n  class SwapAnimation extends AbstractPlugin {\n\n    constructor(draggable) {\n      _initProto(super(draggable));\n\n      this.options = {\n        ...defaultOptions$7,\n        ...this.getOptions()\n      };\n\n      this.lastAnimationFrame = null;\n    }\n\n    attach() {\n      this.draggable.on('sortable:sorted', this.onSortableSorted);\n    }\n\n    detach() {\n      this.draggable.off('sortable:sorted', this.onSortableSorted);\n    }\n\n    getOptions() {\n      return this.draggable.options.swapAnimation || {};\n    }\n\n    onSortableSorted({\n      oldIndex,\n      newIndex,\n      dragEvent\n    }) {\n      const {\n        source,\n        over\n      } = dragEvent;\n      if (this.lastAnimationFrame) {\n        cancelAnimationFrame(this.lastAnimationFrame);\n      }\n\n      this.lastAnimationFrame = requestAnimationFrame(() => {\n        if (oldIndex >= newIndex) {\n          animate$1(source, over, this.options);\n        } else {\n          animate$1(over, source, this.options);\n        }\n      });\n    }\n  }\n\n  _class = SwapAnimation;\n  [_initProto] = _applyDecs2305(_class, [[AutoBind, 2, \"onSortableSorted\"]], [], 0, void 0, AbstractPlugin).e;\n  function animate$1(from, to, {\n    duration,\n    easingFunction,\n    horizontal\n  }) {\n    for (const element of [from, to]) {\n      element.style.pointerEvents = 'none';\n    }\n    if (horizontal) {\n      const width = from.offsetWidth;\n      from.style.transform = `translate3d(${width}px, 0, 0)`;\n      to.style.transform = `translate3d(-${width}px, 0, 0)`;\n    } else {\n      const height = from.offsetHeight;\n      from.style.transform = `translate3d(0, ${height}px, 0)`;\n      to.style.transform = `translate3d(0, -${height}px, 0)`;\n    }\n    requestAnimationFrame(() => {\n      for (const element of [from, to]) {\n        element.addEventListener('transitionend', resetElementOnTransitionEnd$1);\n        element.style.transition = `transform ${duration}ms ${easingFunction}`;\n        element.style.transform = '';\n      }\n    });\n  }\n\n  function resetElementOnTransitionEnd$1(event) {\n    if (event.target == null || !isHTMLElement(event.target)) {\n      return;\n    }\n    event.target.style.transition = '';\n    event.target.style.pointerEvents = '';\n    event.target.removeEventListener('transitionend', resetElementOnTransitionEnd$1);\n  }\n  function isHTMLElement(eventTarget) {\n    return Boolean('style' in eventTarget);\n  }\n\n  const onSortableSorted = Symbol('onSortableSorted');\n  const onSortableSort = Symbol('onSortableSort');\n\n  const defaultOptions$6 = {\n    duration: 150,\n    easingFunction: 'ease-in-out'\n  };\n\n  class SortAnimation extends AbstractPlugin {\n\n    constructor(draggable) {\n      super(draggable);\n\n      this.options = {\n        ...defaultOptions$6,\n        ...this.getOptions()\n      };\n\n      this.lastAnimationFrame = null;\n      this.lastElements = [];\n      this[onSortableSorted] = this[onSortableSorted].bind(this);\n      this[onSortableSort] = this[onSortableSort].bind(this);\n    }\n\n    attach() {\n      this.draggable.on('sortable:sort', this[onSortableSort]);\n      this.draggable.on('sortable:sorted', this[onSortableSorted]);\n    }\n\n    detach() {\n      this.draggable.off('sortable:sort', this[onSortableSort]);\n      this.draggable.off('sortable:sorted', this[onSortableSorted]);\n    }\n\n    getOptions() {\n      return this.draggable.options.sortAnimation || {};\n    }\n\n    [onSortableSort]({\n      dragEvent\n    }) {\n      const {\n        sourceContainer\n      } = dragEvent;\n      const elements = this.draggable.getDraggableElementsForContainer(sourceContainer);\n      this.lastElements = Array.from(elements).map(el => {\n        return {\n          domEl: el,\n          offsetTop: el.offsetTop,\n          offsetLeft: el.offsetLeft\n        };\n      });\n    }\n\n    [onSortableSorted]({\n      oldIndex,\n      newIndex\n    }) {\n      if (oldIndex === newIndex) {\n        return;\n      }\n      const effectedElements = [];\n      let start;\n      let end;\n      let num;\n      if (oldIndex > newIndex) {\n        start = newIndex;\n        end = oldIndex - 1;\n        num = 1;\n      } else {\n        start = oldIndex + 1;\n        end = newIndex;\n        num = -1;\n      }\n      for (let i = start; i <= end; i++) {\n        const from = this.lastElements[i];\n        const to = this.lastElements[i + num];\n        effectedElements.push({\n          from,\n          to\n        });\n      }\n      cancelAnimationFrame(this.lastAnimationFrame);\n\n      this.lastAnimationFrame = requestAnimationFrame(() => {\n        effectedElements.forEach(element => animate(element, this.options));\n      });\n    }\n  }\n\n  function animate({\n    from,\n    to\n  }, {\n    duration,\n    easingFunction\n  }) {\n    const domEl = from.domEl;\n    const x = from.offsetLeft - to.offsetLeft;\n    const y = from.offsetTop - to.offsetTop;\n    domEl.style.pointerEvents = 'none';\n    domEl.style.transform = `translate3d(${x}px, ${y}px, 0)`;\n    requestAnimationFrame(() => {\n      domEl.addEventListener('transitionend', resetElementOnTransitionEnd);\n      domEl.style.transition = `transform ${duration}ms ${easingFunction}`;\n      domEl.style.transform = '';\n    });\n  }\n\n  function resetElementOnTransitionEnd(event) {\n    event.target.style.transition = '';\n    event.target.style.pointerEvents = '';\n    event.target.removeEventListener('transitionend', resetElementOnTransitionEnd);\n  }\n\n  var index$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Collidable: Collidable,\n    ResizeMirror: ResizeMirror,\n    Snappable: Snappable,\n    SortAnimation: SortAnimation,\n    SwapAnimation: SwapAnimation,\n    defaultResizeMirrorOptions: defaultOptions$8,\n    defaultSortAnimationOptions: defaultOptions$6,\n    defaultSwapAnimationOptions: defaultOptions$7\n  });\n\n  const onInitialize$1 = Symbol('onInitialize');\n  const onDestroy$1 = Symbol('onDestroy');\n  const announceEvent = Symbol('announceEvent');\n  const announceMessage = Symbol('announceMessage');\n  const ARIA_RELEVANT = 'aria-relevant';\n  const ARIA_ATOMIC = 'aria-atomic';\n  const ARIA_LIVE = 'aria-live';\n  const ROLE = 'role';\n\n  const defaultOptions$5 = {\n    expire: 7000\n  };\n\n  class Announcement extends AbstractPlugin {\n\n    constructor(draggable) {\n      super(draggable);\n\n      this.options = {\n        ...defaultOptions$5,\n        ...this.getOptions()\n      };\n\n      this.originalTriggerMethod = this.draggable.trigger;\n      this[onInitialize$1] = this[onInitialize$1].bind(this);\n      this[onDestroy$1] = this[onDestroy$1].bind(this);\n    }\n\n    attach() {\n      this.draggable.on('draggable:initialize', this[onInitialize$1]);\n    }\n\n    detach() {\n      this.draggable.off('draggable:destroy', this[onDestroy$1]);\n    }\n\n    getOptions() {\n      return this.draggable.options.announcements || {};\n    }\n\n    [announceEvent](event) {\n      const message = this.options[event.type];\n      if (message && typeof message === 'string') {\n        this[announceMessage](message);\n      }\n      if (message && typeof message === 'function') {\n        this[announceMessage](message(event));\n      }\n    }\n\n    [announceMessage](message) {\n      announce(message, {\n        expire: this.options.expire\n      });\n    }\n\n    [onInitialize$1]() {\n\n      this.draggable.trigger = event => {\n        try {\n          this[announceEvent](event);\n        } finally {\n\n          this.originalTriggerMethod.call(this.draggable, event);\n        }\n      };\n    }\n\n    [onDestroy$1]() {\n      this.draggable.trigger = this.originalTriggerMethod;\n    }\n  }\n\n  const liveRegion = createRegion();\n\n  function announce(message, {\n    expire\n  }) {\n    const element = document.createElement('div');\n    element.textContent = message;\n    liveRegion.appendChild(element);\n    return setTimeout(() => {\n      liveRegion.removeChild(element);\n    }, expire);\n  }\n\n  function createRegion() {\n    const element = document.createElement('div');\n    element.setAttribute('id', 'draggable-live-region');\n    element.setAttribute(ARIA_RELEVANT, 'additions');\n    element.setAttribute(ARIA_ATOMIC, 'true');\n    element.setAttribute(ARIA_LIVE, 'assertive');\n    element.setAttribute(ROLE, 'log');\n    element.style.position = 'fixed';\n    element.style.width = '1px';\n    element.style.height = '1px';\n    element.style.top = '-1px';\n    element.style.overflow = 'hidden';\n    return element;\n  }\n\n  document.addEventListener('DOMContentLoaded', () => {\n    document.body.appendChild(liveRegion);\n  });\n\n  const onInitialize = Symbol('onInitialize');\n  const onDestroy = Symbol('onDestroy');\n\n  const defaultOptions$4 = {};\n\n  class Focusable extends AbstractPlugin {\n\n    constructor(draggable) {\n      super(draggable);\n\n      this.options = {\n        ...defaultOptions$4,\n        ...this.getOptions()\n      };\n      this[onInitialize] = this[onInitialize].bind(this);\n      this[onDestroy] = this[onDestroy].bind(this);\n    }\n\n    attach() {\n      this.draggable.on('draggable:initialize', this[onInitialize]).on('draggable:destroy', this[onDestroy]);\n    }\n\n    detach() {\n      this.draggable.off('draggable:initialize', this[onInitialize]).off('draggable:destroy', this[onDestroy]);\n\n      this[onDestroy]();\n    }\n\n    getOptions() {\n      return this.draggable.options.focusable || {};\n    }\n\n    getElements() {\n      return [...this.draggable.containers, ...this.draggable.getDraggableElements()];\n    }\n\n    [onInitialize]() {\n\n      requestAnimationFrame(() => {\n        this.getElements().forEach(element => decorateElement(element));\n      });\n    }\n\n    [onDestroy]() {\n\n      requestAnimationFrame(() => {\n        this.getElements().forEach(element => stripElement(element));\n      });\n    }\n  }\n\n  const elementsWithMissingTabIndex = [];\n\n  function decorateElement(element) {\n    const hasMissingTabIndex = Boolean(!element.getAttribute('tabindex') && element.tabIndex === -1);\n    if (hasMissingTabIndex) {\n      elementsWithMissingTabIndex.push(element);\n      element.tabIndex = 0;\n    }\n  }\n\n  function stripElement(element) {\n    const tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);\n    if (tabIndexElementPosition !== -1) {\n      element.tabIndex = -1;\n      elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);\n    }\n  }\n\n  class MirrorEvent extends AbstractEvent {\n\n    constructor(data) {\n      super(data);\n      this.data = data;\n    }\n\n    get source() {\n      return this.data.source;\n    }\n\n    get originalSource() {\n      return this.data.originalSource;\n    }\n\n    get sourceContainer() {\n      return this.data.sourceContainer;\n    }\n\n    get sensorEvent() {\n      return this.data.sensorEvent;\n    }\n\n    get dragEvent() {\n      return this.data.dragEvent;\n    }\n\n    get originalEvent() {\n      if (this.sensorEvent) {\n        return this.sensorEvent.originalEvent;\n      }\n      return null;\n    }\n  }\n\n  class MirrorCreateEvent extends MirrorEvent {}\n  MirrorCreateEvent.type = 'mirror:create';\n\n  class MirrorCreatedEvent extends MirrorEvent {\n\n    get mirror() {\n      return this.data.mirror;\n    }\n  }\n  MirrorCreatedEvent.type = 'mirror:created';\n\n  class MirrorAttachedEvent extends MirrorEvent {\n\n    get mirror() {\n      return this.data.mirror;\n    }\n  }\n  MirrorAttachedEvent.type = 'mirror:attached';\n\n  class MirrorMoveEvent extends MirrorEvent {\n\n    get mirror() {\n      return this.data.mirror;\n    }\n\n    get passedThreshX() {\n      return this.data.passedThreshX;\n    }\n\n    get passedThreshY() {\n      return this.data.passedThreshY;\n    }\n  }\n  MirrorMoveEvent.type = 'mirror:move';\n  MirrorMoveEvent.cancelable = true;\n\n  class MirrorMovedEvent extends MirrorEvent {\n\n    get mirror() {\n      return this.data.mirror;\n    }\n\n    get passedThreshX() {\n      return this.data.passedThreshX;\n    }\n\n    get passedThreshY() {\n      return this.data.passedThreshY;\n    }\n  }\n  MirrorMovedEvent.type = 'mirror:moved';\n\n  class MirrorDestroyEvent extends MirrorEvent {\n\n    get mirror() {\n      return this.data.mirror;\n    }\n  }\n  MirrorDestroyEvent.type = 'mirror:destroy';\n  MirrorDestroyEvent.cancelable = true;\n\n  const onDragStart$5 = Symbol('onDragStart');\n  const onDragMove$3 = Symbol('onDragMove');\n  const onDragStop$5 = Symbol('onDragStop');\n  const onMirrorCreated = Symbol('onMirrorCreated');\n  const onMirrorMove = Symbol('onMirrorMove');\n  const onScroll = Symbol('onScroll');\n  const getAppendableContainer = Symbol('getAppendableContainer');\n\n  const defaultOptions$3 = {\n    constrainDimensions: false,\n    xAxis: true,\n    yAxis: true,\n    cursorOffsetX: null,\n    cursorOffsetY: null,\n    thresholdX: null,\n    thresholdY: null\n  };\n\n  class Mirror extends AbstractPlugin {\n\n    constructor(draggable) {\n      super(draggable);\n\n      this.options = {\n        ...defaultOptions$3,\n        ...this.getOptions()\n      };\n\n      this.scrollOffset = {\n        x: 0,\n        y: 0\n      };\n\n      this.initialScrollOffset = {\n        x: window.scrollX,\n        y: window.scrollY\n      };\n      this[onDragStart$5] = this[onDragStart$5].bind(this);\n      this[onDragMove$3] = this[onDragMove$3].bind(this);\n      this[onDragStop$5] = this[onDragStop$5].bind(this);\n      this[onMirrorCreated] = this[onMirrorCreated].bind(this);\n      this[onMirrorMove] = this[onMirrorMove].bind(this);\n      this[onScroll] = this[onScroll].bind(this);\n    }\n\n    attach() {\n      this.draggable.on('drag:start', this[onDragStart$5]).on('drag:move', this[onDragMove$3]).on('drag:stop', this[onDragStop$5]).on('mirror:created', this[onMirrorCreated]).on('mirror:move', this[onMirrorMove]);\n    }\n\n    detach() {\n      this.draggable.off('drag:start', this[onDragStart$5]).off('drag:move', this[onDragMove$3]).off('drag:stop', this[onDragStop$5]).off('mirror:created', this[onMirrorCreated]).off('mirror:move', this[onMirrorMove]);\n    }\n\n    getOptions() {\n      return this.draggable.options.mirror || {};\n    }\n    [onDragStart$5](dragEvent) {\n      if (dragEvent.canceled()) {\n        return;\n      }\n      if ('ontouchstart' in window) {\n        document.addEventListener('scroll', this[onScroll], true);\n      }\n      this.initialScrollOffset = {\n        x: window.scrollX,\n        y: window.scrollY\n      };\n      const {\n        source,\n        originalSource,\n        sourceContainer,\n        sensorEvent\n      } = dragEvent;\n\n      this.lastMirrorMovedClient = {\n        x: sensorEvent.clientX,\n        y: sensorEvent.clientY\n      };\n      const mirrorCreateEvent = new MirrorCreateEvent({\n        source,\n        originalSource,\n        sourceContainer,\n        sensorEvent,\n        dragEvent\n      });\n      this.draggable.trigger(mirrorCreateEvent);\n      if (isNativeDragEvent(sensorEvent) || mirrorCreateEvent.canceled()) {\n        return;\n      }\n      const appendableContainer = this[getAppendableContainer](source) || sourceContainer;\n      this.mirror = source.cloneNode(true);\n      const mirrorCreatedEvent = new MirrorCreatedEvent({\n        source,\n        originalSource,\n        sourceContainer,\n        sensorEvent,\n        dragEvent,\n        mirror: this.mirror\n      });\n      const mirrorAttachedEvent = new MirrorAttachedEvent({\n        source,\n        originalSource,\n        sourceContainer,\n        sensorEvent,\n        dragEvent,\n        mirror: this.mirror\n      });\n      this.draggable.trigger(mirrorCreatedEvent);\n      appendableContainer.appendChild(this.mirror);\n      this.draggable.trigger(mirrorAttachedEvent);\n    }\n    [onDragMove$3](dragEvent) {\n      if (!this.mirror || dragEvent.canceled()) {\n        return;\n      }\n      const {\n        source,\n        originalSource,\n        sourceContainer,\n        sensorEvent\n      } = dragEvent;\n      let passedThreshX = true;\n      let passedThreshY = true;\n      if (this.options.thresholdX || this.options.thresholdY) {\n        const {\n          x: lastX,\n          y: lastY\n        } = this.lastMirrorMovedClient;\n        if (Math.abs(lastX - sensorEvent.clientX) < this.options.thresholdX) {\n          passedThreshX = false;\n        } else {\n          this.lastMirrorMovedClient.x = sensorEvent.clientX;\n        }\n        if (Math.abs(lastY - sensorEvent.clientY) < this.options.thresholdY) {\n          passedThreshY = false;\n        } else {\n          this.lastMirrorMovedClient.y = sensorEvent.clientY;\n        }\n        if (!passedThreshX && !passedThreshY) {\n          return;\n        }\n      }\n      const mirrorMoveEvent = new MirrorMoveEvent({\n        source,\n        originalSource,\n        sourceContainer,\n        sensorEvent,\n        dragEvent,\n        mirror: this.mirror,\n        passedThreshX,\n        passedThreshY\n      });\n      this.draggable.trigger(mirrorMoveEvent);\n    }\n    [onDragStop$5](dragEvent) {\n      if ('ontouchstart' in window) {\n        document.removeEventListener('scroll', this[onScroll], true);\n      }\n      this.initialScrollOffset = {\n        x: 0,\n        y: 0\n      };\n      this.scrollOffset = {\n        x: 0,\n        y: 0\n      };\n      if (!this.mirror) {\n        return;\n      }\n      const {\n        source,\n        sourceContainer,\n        sensorEvent\n      } = dragEvent;\n      const mirrorDestroyEvent = new MirrorDestroyEvent({\n        source,\n        mirror: this.mirror,\n        sourceContainer,\n        sensorEvent,\n        dragEvent\n      });\n      this.draggable.trigger(mirrorDestroyEvent);\n      if (!mirrorDestroyEvent.canceled()) {\n        this.mirror.remove();\n      }\n    }\n    [onScroll]() {\n      this.scrollOffset = {\n        x: window.scrollX - this.initialScrollOffset.x,\n        y: window.scrollY - this.initialScrollOffset.y\n      };\n    }\n\n    [onMirrorCreated]({\n      mirror,\n      source,\n      sensorEvent\n    }) {\n      const mirrorClasses = this.draggable.getClassNamesFor('mirror');\n      const setState = ({\n        mirrorOffset,\n        initialX,\n        initialY,\n        ...args\n      }) => {\n        this.mirrorOffset = mirrorOffset;\n        this.initialX = initialX;\n        this.initialY = initialY;\n        this.lastMovedX = initialX;\n        this.lastMovedY = initialY;\n        return {\n          mirrorOffset,\n          initialX,\n          initialY,\n          ...args\n        };\n      };\n      mirror.style.display = 'none';\n      const initialState = {\n        mirror,\n        source,\n        sensorEvent,\n        mirrorClasses,\n        scrollOffset: this.scrollOffset,\n        options: this.options,\n        passedThreshX: true,\n        passedThreshY: true\n      };\n      return Promise.resolve(initialState)\n\n      .then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({\n        initial: true\n      })).then(removeMirrorID).then(setState);\n    }\n\n    [onMirrorMove](mirrorEvent) {\n      if (mirrorEvent.canceled()) {\n        return null;\n      }\n      const setState = ({\n        lastMovedX,\n        lastMovedY,\n        ...args\n      }) => {\n        this.lastMovedX = lastMovedX;\n        this.lastMovedY = lastMovedY;\n        return {\n          lastMovedX,\n          lastMovedY,\n          ...args\n        };\n      };\n      const triggerMoved = args => {\n        const mirrorMovedEvent = new MirrorMovedEvent({\n          source: mirrorEvent.source,\n          originalSource: mirrorEvent.originalSource,\n          sourceContainer: mirrorEvent.sourceContainer,\n          sensorEvent: mirrorEvent.sensorEvent,\n          dragEvent: mirrorEvent.dragEvent,\n          mirror: this.mirror,\n          passedThreshX: mirrorEvent.passedThreshX,\n          passedThreshY: mirrorEvent.passedThreshY\n        });\n        this.draggable.trigger(mirrorMovedEvent);\n        return args;\n      };\n      const initialState = {\n        mirror: mirrorEvent.mirror,\n        sensorEvent: mirrorEvent.sensorEvent,\n        mirrorOffset: this.mirrorOffset,\n        options: this.options,\n        initialX: this.initialX,\n        initialY: this.initialY,\n        scrollOffset: this.scrollOffset,\n        passedThreshX: mirrorEvent.passedThreshX,\n        passedThreshY: mirrorEvent.passedThreshY,\n        lastMovedX: this.lastMovedX,\n        lastMovedY: this.lastMovedY\n      };\n      return Promise.resolve(initialState).then(positionMirror({\n        raf: true\n      })).then(setState).then(triggerMoved);\n    }\n\n    [getAppendableContainer](source) {\n      const appendTo = this.options.appendTo;\n      if (typeof appendTo === 'string') {\n        return document.querySelector(appendTo);\n      } else if (appendTo instanceof HTMLElement) {\n        return appendTo;\n      } else if (typeof appendTo === 'function') {\n        return appendTo(source);\n      } else {\n        return source.parentNode;\n      }\n    }\n  }\n\n  function computeMirrorDimensions({\n    source,\n    ...args\n  }) {\n    return withPromise(resolve => {\n      const sourceRect = source.getBoundingClientRect();\n      resolve({\n        source,\n        sourceRect,\n        ...args\n      });\n    });\n  }\n\n  function calculateMirrorOffset({\n    sensorEvent,\n    sourceRect,\n    options,\n    ...args\n  }) {\n    return withPromise(resolve => {\n      const top = options.cursorOffsetY === null ? sensorEvent.clientY - sourceRect.top : options.cursorOffsetY;\n      const left = options.cursorOffsetX === null ? sensorEvent.clientX - sourceRect.left : options.cursorOffsetX;\n      const mirrorOffset = {\n        top,\n        left\n      };\n      resolve({\n        sensorEvent,\n        sourceRect,\n        mirrorOffset,\n        options,\n        ...args\n      });\n    });\n  }\n\n  function resetMirror({\n    mirror,\n    source,\n    options,\n    ...args\n  }) {\n    return withPromise(resolve => {\n      let offsetHeight;\n      let offsetWidth;\n      if (options.constrainDimensions) {\n        const computedSourceStyles = getComputedStyle(source);\n        offsetHeight = computedSourceStyles.getPropertyValue('height');\n        offsetWidth = computedSourceStyles.getPropertyValue('width');\n      }\n      mirror.style.display = null;\n      mirror.style.position = 'fixed';\n      mirror.style.pointerEvents = 'none';\n      mirror.style.top = 0;\n      mirror.style.left = 0;\n      mirror.style.margin = 0;\n      if (options.constrainDimensions) {\n        mirror.style.height = offsetHeight;\n        mirror.style.width = offsetWidth;\n      }\n      resolve({\n        mirror,\n        source,\n        options,\n        ...args\n      });\n    });\n  }\n\n  function addMirrorClasses({\n    mirror,\n    mirrorClasses,\n    ...args\n  }) {\n    return withPromise(resolve => {\n      mirror.classList.add(...mirrorClasses);\n      resolve({\n        mirror,\n        mirrorClasses,\n        ...args\n      });\n    });\n  }\n\n  function removeMirrorID({\n    mirror,\n    ...args\n  }) {\n    return withPromise(resolve => {\n      mirror.removeAttribute('id');\n      delete mirror.id;\n      resolve({\n        mirror,\n        ...args\n      });\n    });\n  }\n\n  function positionMirror({\n    withFrame = false,\n    initial = false\n  } = {}) {\n    return ({\n      mirror,\n      sensorEvent,\n      mirrorOffset,\n      initialY,\n      initialX,\n      scrollOffset,\n      options,\n      passedThreshX,\n      passedThreshY,\n      lastMovedX,\n      lastMovedY,\n      ...args\n    }) => {\n      return withPromise(resolve => {\n        const result = {\n          mirror,\n          sensorEvent,\n          mirrorOffset,\n          options,\n          ...args\n        };\n        if (mirrorOffset) {\n          const x = passedThreshX ? Math.round((sensorEvent.clientX - mirrorOffset.left - scrollOffset.x) / (options.thresholdX || 1)) * (options.thresholdX || 1) : Math.round(lastMovedX);\n          const y = passedThreshY ? Math.round((sensorEvent.clientY - mirrorOffset.top - scrollOffset.y) / (options.thresholdY || 1)) * (options.thresholdY || 1) : Math.round(lastMovedY);\n          if (options.xAxis && options.yAxis || initial) {\n            mirror.style.transform = `translate3d(${x}px, ${y}px, 0)`;\n          } else if (options.xAxis && !options.yAxis) {\n            mirror.style.transform = `translate3d(${x}px, ${initialY}px, 0)`;\n          } else if (options.yAxis && !options.xAxis) {\n            mirror.style.transform = `translate3d(${initialX}px, ${y}px, 0)`;\n          }\n          if (initial) {\n            result.initialX = x;\n            result.initialY = y;\n          }\n          result.lastMovedX = x;\n          result.lastMovedY = y;\n        }\n        resolve(result);\n      }, {\n        frame: withFrame\n      });\n    };\n  }\n\n  function withPromise(callback, {\n    raf = false\n  } = {}) {\n    return new Promise((resolve, reject) => {\n      if (raf) {\n        requestAnimationFrame(() => {\n          callback(resolve, reject);\n        });\n      } else {\n        callback(resolve, reject);\n      }\n    });\n  }\n\n  function isNativeDragEvent(sensorEvent) {\n    return /^drag/.test(sensorEvent.originalEvent.type);\n  }\n\n  const onDragStart$4 = Symbol('onDragStart');\n  const onDragMove$2 = Symbol('onDragMove');\n  const onDragStop$4 = Symbol('onDragStop');\n  const scroll = Symbol('scroll');\n\n  const defaultOptions$2 = {\n    speed: 6,\n    sensitivity: 50,\n    scrollableElements: []\n  };\n\n  class Scrollable extends AbstractPlugin {\n\n    constructor(draggable) {\n      super(draggable);\n\n      this.options = {\n        ...defaultOptions$2,\n        ...this.getOptions()\n      };\n\n      this.currentMousePosition = null;\n\n      this.scrollAnimationFrame = null;\n\n      this.scrollableElement = null;\n\n      this.findScrollableElementFrame = null;\n      this[onDragStart$4] = this[onDragStart$4].bind(this);\n      this[onDragMove$2] = this[onDragMove$2].bind(this);\n      this[onDragStop$4] = this[onDragStop$4].bind(this);\n      this[scroll] = this[scroll].bind(this);\n    }\n\n    attach() {\n      this.draggable.on('drag:start', this[onDragStart$4]).on('drag:move', this[onDragMove$2]).on('drag:stop', this[onDragStop$4]);\n    }\n\n    detach() {\n      this.draggable.off('drag:start', this[onDragStart$4]).off('drag:move', this[onDragMove$2]).off('drag:stop', this[onDragStop$4]);\n    }\n\n    getOptions() {\n      return this.draggable.options.scrollable || {};\n    }\n\n    getScrollableElement(target) {\n      if (this.hasDefinedScrollableElements()) {\n        return closest(target, this.options.scrollableElements) || document.documentElement;\n      } else {\n        return closestScrollableElement(target);\n      }\n    }\n\n    hasDefinedScrollableElements() {\n      return Boolean(this.options.scrollableElements.length !== 0);\n    }\n\n    [onDragStart$4](dragEvent) {\n      this.findScrollableElementFrame = requestAnimationFrame(() => {\n        this.scrollableElement = this.getScrollableElement(dragEvent.source);\n      });\n    }\n\n    [onDragMove$2](dragEvent) {\n      this.findScrollableElementFrame = requestAnimationFrame(() => {\n        this.scrollableElement = this.getScrollableElement(dragEvent.sensorEvent.target);\n      });\n      if (!this.scrollableElement) {\n        return;\n      }\n      const sensorEvent = dragEvent.sensorEvent;\n      const scrollOffset = {\n        x: 0,\n        y: 0\n      };\n      if ('ontouchstart' in window) {\n        scrollOffset.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n        scrollOffset.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;\n      }\n      this.currentMousePosition = {\n        clientX: sensorEvent.clientX - scrollOffset.x,\n        clientY: sensorEvent.clientY - scrollOffset.y\n      };\n      this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\n    }\n\n    [onDragStop$4]() {\n      cancelAnimationFrame(this.scrollAnimationFrame);\n      cancelAnimationFrame(this.findScrollableElementFrame);\n      this.scrollableElement = null;\n      this.scrollAnimationFrame = null;\n      this.findScrollableElementFrame = null;\n      this.currentMousePosition = null;\n    }\n\n    [scroll]() {\n      if (!this.scrollableElement || !this.currentMousePosition) {\n        return;\n      }\n      cancelAnimationFrame(this.scrollAnimationFrame);\n      const {\n        speed,\n        sensitivity\n      } = this.options;\n      const rect = this.scrollableElement.getBoundingClientRect();\n      const bottomCutOff = rect.bottom > window.innerHeight;\n      const topCutOff = rect.top < 0;\n      const cutOff = topCutOff || bottomCutOff;\n      const documentScrollingElement = getDocumentScrollingElement();\n      const scrollableElement = this.scrollableElement;\n      const clientX = this.currentMousePosition.clientX;\n      const clientY = this.currentMousePosition.clientY;\n      if (scrollableElement !== document.body && scrollableElement !== document.documentElement && !cutOff) {\n        const {\n          offsetHeight,\n          offsetWidth\n        } = scrollableElement;\n        if (rect.top + offsetHeight - clientY < sensitivity) {\n          scrollableElement.scrollTop += speed;\n        } else if (clientY - rect.top < sensitivity) {\n          scrollableElement.scrollTop -= speed;\n        }\n        if (rect.left + offsetWidth - clientX < sensitivity) {\n          scrollableElement.scrollLeft += speed;\n        } else if (clientX - rect.left < sensitivity) {\n          scrollableElement.scrollLeft -= speed;\n        }\n      } else {\n        const {\n          innerHeight,\n          innerWidth\n        } = window;\n        if (clientY < sensitivity) {\n          documentScrollingElement.scrollTop -= speed;\n        } else if (innerHeight - clientY < sensitivity) {\n          documentScrollingElement.scrollTop += speed;\n        }\n        if (clientX < sensitivity) {\n          documentScrollingElement.scrollLeft -= speed;\n        } else if (innerWidth - clientX < sensitivity) {\n          documentScrollingElement.scrollLeft += speed;\n        }\n      }\n      this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\n    }\n  }\n\n  function hasOverflow(element) {\n    const overflowRegex = /(auto|scroll)/;\n    const computedStyles = getComputedStyle(element, null);\n    const overflow = computedStyles.getPropertyValue('overflow') + computedStyles.getPropertyValue('overflow-y') + computedStyles.getPropertyValue('overflow-x');\n    return overflowRegex.test(overflow);\n  }\n\n  function isStaticallyPositioned(element) {\n    const position = getComputedStyle(element).getPropertyValue('position');\n    return position === 'static';\n  }\n\n  function closestScrollableElement(element) {\n    if (!element) {\n      return getDocumentScrollingElement();\n    }\n    const position = getComputedStyle(element).getPropertyValue('position');\n    const excludeStaticParents = position === 'absolute';\n    const scrollableElement = closest(element, parent => {\n      if (excludeStaticParents && isStaticallyPositioned(parent)) {\n        return false;\n      }\n      return hasOverflow(parent);\n    });\n    if (position === 'fixed' || !scrollableElement) {\n      return getDocumentScrollingElement();\n    } else {\n      return scrollableElement;\n    }\n  }\n\n  function getDocumentScrollingElement() {\n    return document.scrollingElement || document.documentElement;\n  }\n\n  class Emitter {\n    constructor() {\n      this.callbacks = {};\n    }\n\n    on(type, ...callbacks) {\n      if (!this.callbacks[type]) {\n        this.callbacks[type] = [];\n      }\n      this.callbacks[type].push(...callbacks);\n      return this;\n    }\n\n    off(type, callback) {\n      if (!this.callbacks[type]) {\n        return null;\n      }\n      const copy = this.callbacks[type].slice(0);\n      for (let i = 0; i < copy.length; i++) {\n        if (callback === copy[i]) {\n          this.callbacks[type].splice(i, 1);\n        }\n      }\n      return this;\n    }\n\n    trigger(event) {\n      if (!this.callbacks[event.type]) {\n        return null;\n      }\n      const callbacks = [...this.callbacks[event.type]];\n      const caughtErrors = [];\n      for (let i = callbacks.length - 1; i >= 0; i--) {\n        const callback = callbacks[i];\n        try {\n          callback(event);\n        } catch (error) {\n          caughtErrors.push(error);\n        }\n      }\n      if (caughtErrors.length) {\n\n        console.error(`Draggable caught errors while triggering '${event.type}'`, caughtErrors);\n\n      }\n\n      return this;\n    }\n  }\n\n  class DraggableEvent extends AbstractEvent {\n\n    get draggable() {\n      return this.data.draggable;\n    }\n  }\n\n  DraggableEvent.type = 'draggable';\n  class DraggableInitializedEvent extends DraggableEvent {}\n\n  DraggableInitializedEvent.type = 'draggable:initialize';\n  class DraggableDestroyEvent extends DraggableEvent {}\n  DraggableDestroyEvent.type = 'draggable:destroy';\n\n  const onDragStart$3 = Symbol('onDragStart');\n  const onDragMove$1 = Symbol('onDragMove');\n  const onDragStop$3 = Symbol('onDragStop');\n  const onDragPressure = Symbol('onDragPressure');\n  const dragStop = Symbol('dragStop');\n\n  const defaultAnnouncements$3 = {\n    'drag:start': event => `Picked up ${event.source.textContent.trim() || event.source.id || 'draggable element'}`,\n    'drag:stop': event => `Released ${event.source.textContent.trim() || event.source.id || 'draggable element'}`\n  };\n  const defaultClasses$1 = {\n    'container:dragging': 'draggable-container--is-dragging',\n    'source:dragging': 'draggable-source--is-dragging',\n    'source:placed': 'draggable-source--placed',\n    'container:placed': 'draggable-container--placed',\n    'body:dragging': 'draggable--is-dragging',\n    'draggable:over': 'draggable--over',\n    'container:over': 'draggable-container--over',\n    'source:original': 'draggable--original',\n    mirror: 'draggable-mirror'\n  };\n  const defaultOptions$1 = {\n    draggable: '.draggable-source',\n    handle: null,\n    delay: {},\n    distance: 0,\n    placedTimeout: 800,\n    plugins: [],\n    sensors: [],\n    exclude: {\n      plugins: [],\n      sensors: []\n    }\n  };\n\n  class Draggable {\n\n    constructor(containers = [document.body], options = {}) {\n\n      if (containers instanceof NodeList || containers instanceof Array) {\n        this.containers = [...containers];\n      } else if (containers instanceof HTMLElement) {\n        this.containers = [containers];\n      } else {\n        throw new Error('Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`');\n      }\n      this.options = {\n        ...defaultOptions$1,\n        ...options,\n        classes: {\n          ...defaultClasses$1,\n          ...(options.classes || {})\n        },\n        announcements: {\n          ...defaultAnnouncements$3,\n          ...(options.announcements || {})\n        },\n        exclude: {\n          plugins: options.exclude && options.exclude.plugins || [],\n          sensors: options.exclude && options.exclude.sensors || []\n        }\n      };\n\n      this.emitter = new Emitter();\n\n      this.dragging = false;\n\n      this.plugins = [];\n\n      this.sensors = [];\n      this[onDragStart$3] = this[onDragStart$3].bind(this);\n      this[onDragMove$1] = this[onDragMove$1].bind(this);\n      this[onDragStop$3] = this[onDragStop$3].bind(this);\n      this[onDragPressure] = this[onDragPressure].bind(this);\n      this[dragStop] = this[dragStop].bind(this);\n      document.addEventListener('drag:start', this[onDragStart$3], true);\n      document.addEventListener('drag:move', this[onDragMove$1], true);\n      document.addEventListener('drag:stop', this[onDragStop$3], true);\n      document.addEventListener('drag:pressure', this[onDragPressure], true);\n      const defaultPlugins = Object.values(Draggable.Plugins).filter(Plugin => !this.options.exclude.plugins.includes(Plugin));\n      const defaultSensors = Object.values(Draggable.Sensors).filter(sensor => !this.options.exclude.sensors.includes(sensor));\n      this.addPlugin(...[...defaultPlugins, ...this.options.plugins]);\n      this.addSensor(...[...defaultSensors, ...this.options.sensors]);\n      const draggableInitializedEvent = new DraggableInitializedEvent({\n        draggable: this\n      });\n      this.on('mirror:created', ({\n        mirror\n      }) => this.mirror = mirror);\n      this.on('mirror:destroy', () => this.mirror = null);\n      this.trigger(draggableInitializedEvent);\n    }\n\n    destroy() {\n      document.removeEventListener('drag:start', this[onDragStart$3], true);\n      document.removeEventListener('drag:move', this[onDragMove$1], true);\n      document.removeEventListener('drag:stop', this[onDragStop$3], true);\n      document.removeEventListener('drag:pressure', this[onDragPressure], true);\n      const draggableDestroyEvent = new DraggableDestroyEvent({\n        draggable: this\n      });\n      this.trigger(draggableDestroyEvent);\n      this.removePlugin(...this.plugins.map(plugin => plugin.constructor));\n      this.removeSensor(...this.sensors.map(sensor => sensor.constructor));\n    }\n\n    addPlugin(...plugins) {\n      const activePlugins = plugins.map(Plugin => new Plugin(this));\n      activePlugins.forEach(plugin => plugin.attach());\n      this.plugins = [...this.plugins, ...activePlugins];\n      return this;\n    }\n\n    removePlugin(...plugins) {\n      const removedPlugins = this.plugins.filter(plugin => plugins.includes(plugin.constructor));\n      removedPlugins.forEach(plugin => plugin.detach());\n      this.plugins = this.plugins.filter(plugin => !plugins.includes(plugin.constructor));\n      return this;\n    }\n\n    addSensor(...sensors) {\n      const activeSensors = sensors.map(Sensor => new Sensor(this.containers, this.options));\n      activeSensors.forEach(sensor => sensor.attach());\n      this.sensors = [...this.sensors, ...activeSensors];\n      return this;\n    }\n\n    removeSensor(...sensors) {\n      const removedSensors = this.sensors.filter(sensor => sensors.includes(sensor.constructor));\n      removedSensors.forEach(sensor => sensor.detach());\n      this.sensors = this.sensors.filter(sensor => !sensors.includes(sensor.constructor));\n      return this;\n    }\n\n    addContainer(...containers) {\n      this.containers = [...this.containers, ...containers];\n      this.sensors.forEach(sensor => sensor.addContainer(...containers));\n      return this;\n    }\n\n    removeContainer(...containers) {\n      this.containers = this.containers.filter(container => !containers.includes(container));\n      this.sensors.forEach(sensor => sensor.removeContainer(...containers));\n      return this;\n    }\n\n    on(type, ...callbacks) {\n      this.emitter.on(type, ...callbacks);\n      return this;\n    }\n\n    off(type, callback) {\n      this.emitter.off(type, callback);\n      return this;\n    }\n\n    trigger(event) {\n      this.emitter.trigger(event);\n      return this;\n    }\n\n    getClassNameFor(name) {\n      return this.getClassNamesFor(name)[0];\n    }\n\n    getClassNamesFor(name) {\n      const classNames = this.options.classes[name];\n      if (classNames instanceof Array) {\n        return classNames;\n      } else if (typeof classNames === 'string' || classNames instanceof String) {\n        return [classNames];\n      } else {\n        return [];\n      }\n    }\n\n    isDragging() {\n      return Boolean(this.dragging);\n    }\n\n    getDraggableElements() {\n      return this.containers.reduce((current, container) => {\n        return [...current, ...this.getDraggableElementsForContainer(container)];\n      }, []);\n    }\n\n    getDraggableElementsForContainer(container) {\n      const allDraggableElements = container.querySelectorAll(this.options.draggable);\n      return [...allDraggableElements].filter(childElement => {\n        return childElement !== this.originalSource && childElement !== this.mirror;\n      });\n    }\n\n    cancel() {\n      this[dragStop]();\n    }\n\n    [onDragStart$3](event) {\n      const sensorEvent = getSensorEvent(event);\n      const {\n        target,\n        container,\n        originalSource\n      } = sensorEvent;\n      if (!this.containers.includes(container)) {\n        return;\n      }\n      if (this.options.handle && target && !closest(target, this.options.handle)) {\n        sensorEvent.cancel();\n        return;\n      }\n      this.originalSource = originalSource;\n      this.sourceContainer = container;\n      if (this.lastPlacedSource && this.lastPlacedContainer) {\n        clearTimeout(this.placedTimeoutID);\n        this.lastPlacedSource.classList.remove(...this.getClassNamesFor('source:placed'));\n        this.lastPlacedContainer.classList.remove(...this.getClassNamesFor('container:placed'));\n      }\n      this.source = this.originalSource.cloneNode(true);\n      this.originalSource.parentNode.insertBefore(this.source, this.originalSource);\n      this.originalSource.style.display = 'none';\n      const dragStartEvent = new DragStartEvent({\n        source: this.source,\n        originalSource: this.originalSource,\n        sourceContainer: container,\n        sensorEvent\n      });\n      this.trigger(dragStartEvent);\n      this.dragging = !dragStartEvent.canceled();\n      if (dragStartEvent.canceled()) {\n        this.source.remove();\n        this.originalSource.style.display = null;\n        return;\n      }\n      this.originalSource.classList.add(...this.getClassNamesFor('source:original'));\n      this.source.classList.add(...this.getClassNamesFor('source:dragging'));\n      this.sourceContainer.classList.add(...this.getClassNamesFor('container:dragging'));\n      document.body.classList.add(...this.getClassNamesFor('body:dragging'));\n      applyUserSelect(document.body, 'none');\n      requestAnimationFrame(() => {\n        const oldSensorEvent = getSensorEvent(event);\n        const newSensorEvent = oldSensorEvent.clone({\n          target: this.source\n        });\n        this[onDragMove$1]({\n          ...event,\n          detail: newSensorEvent\n        });\n      });\n    }\n\n    [onDragMove$1](event) {\n      if (!this.dragging) {\n        return;\n      }\n      const sensorEvent = getSensorEvent(event);\n      const {\n        container\n      } = sensorEvent;\n      let target = sensorEvent.target;\n      const dragMoveEvent = new DragMoveEvent({\n        source: this.source,\n        originalSource: this.originalSource,\n        sourceContainer: container,\n        sensorEvent\n      });\n      this.trigger(dragMoveEvent);\n      if (dragMoveEvent.canceled()) {\n        sensorEvent.cancel();\n      }\n      target = closest(target, this.options.draggable);\n      const withinCorrectContainer = closest(sensorEvent.target, this.containers);\n      const overContainer = sensorEvent.overContainer || withinCorrectContainer;\n      const isLeavingContainer = this.currentOverContainer && overContainer !== this.currentOverContainer;\n      const isLeavingDraggable = this.currentOver && target !== this.currentOver;\n      const isOverContainer = overContainer && this.currentOverContainer !== overContainer;\n      const isOverDraggable = withinCorrectContainer && target && this.currentOver !== target;\n      if (isLeavingDraggable) {\n        const dragOutEvent = new DragOutEvent({\n          source: this.source,\n          originalSource: this.originalSource,\n          sourceContainer: container,\n          sensorEvent,\n          over: this.currentOver,\n          overContainer: this.currentOverContainer\n        });\n        this.currentOver.classList.remove(...this.getClassNamesFor('draggable:over'));\n        this.currentOver = null;\n        this.trigger(dragOutEvent);\n      }\n      if (isLeavingContainer) {\n        const dragOutContainerEvent = new DragOutContainerEvent({\n          source: this.source,\n          originalSource: this.originalSource,\n          sourceContainer: container,\n          sensorEvent,\n          overContainer: this.currentOverContainer\n        });\n        this.currentOverContainer.classList.remove(...this.getClassNamesFor('container:over'));\n        this.currentOverContainer = null;\n        this.trigger(dragOutContainerEvent);\n      }\n      if (isOverContainer) {\n        overContainer.classList.add(...this.getClassNamesFor('container:over'));\n        const dragOverContainerEvent = new DragOverContainerEvent({\n          source: this.source,\n          originalSource: this.originalSource,\n          sourceContainer: container,\n          sensorEvent,\n          overContainer\n        });\n        this.currentOverContainer = overContainer;\n        this.trigger(dragOverContainerEvent);\n      }\n      if (isOverDraggable) {\n        target.classList.add(...this.getClassNamesFor('draggable:over'));\n        const dragOverEvent = new DragOverEvent({\n          source: this.source,\n          originalSource: this.originalSource,\n          sourceContainer: container,\n          sensorEvent,\n          overContainer,\n          over: target\n        });\n        this.currentOver = target;\n        this.trigger(dragOverEvent);\n      }\n    }\n\n    [dragStop](event) {\n      if (!this.dragging) {\n        return;\n      }\n      this.dragging = false;\n      const dragStopEvent = new DragStopEvent({\n        source: this.source,\n        originalSource: this.originalSource,\n        sensorEvent: event ? event.sensorEvent : null,\n        sourceContainer: this.sourceContainer\n      });\n      this.trigger(dragStopEvent);\n      if (!dragStopEvent.canceled()) this.source.parentNode.insertBefore(this.originalSource, this.source);\n      this.source.remove();\n      this.originalSource.style.display = '';\n      this.source.classList.remove(...this.getClassNamesFor('source:dragging'));\n      this.originalSource.classList.remove(...this.getClassNamesFor('source:original'));\n      this.originalSource.classList.add(...this.getClassNamesFor('source:placed'));\n      this.sourceContainer.classList.add(...this.getClassNamesFor('container:placed'));\n      this.sourceContainer.classList.remove(...this.getClassNamesFor('container:dragging'));\n      document.body.classList.remove(...this.getClassNamesFor('body:dragging'));\n      applyUserSelect(document.body, '');\n      if (this.currentOver) {\n        this.currentOver.classList.remove(...this.getClassNamesFor('draggable:over'));\n      }\n      if (this.currentOverContainer) {\n        this.currentOverContainer.classList.remove(...this.getClassNamesFor('container:over'));\n      }\n      this.lastPlacedSource = this.originalSource;\n      this.lastPlacedContainer = this.sourceContainer;\n      this.placedTimeoutID = setTimeout(() => {\n        if (this.lastPlacedSource) {\n          this.lastPlacedSource.classList.remove(...this.getClassNamesFor('source:placed'));\n        }\n        if (this.lastPlacedContainer) {\n          this.lastPlacedContainer.classList.remove(...this.getClassNamesFor('container:placed'));\n        }\n        this.lastPlacedSource = null;\n        this.lastPlacedContainer = null;\n      }, this.options.placedTimeout);\n      const dragStoppedEvent = new DragStoppedEvent({\n        source: this.source,\n        originalSource: this.originalSource,\n        sensorEvent: event ? event.sensorEvent : null,\n        sourceContainer: this.sourceContainer\n      });\n      this.trigger(dragStoppedEvent);\n      this.source = null;\n      this.originalSource = null;\n      this.currentOverContainer = null;\n      this.currentOver = null;\n      this.sourceContainer = null;\n    }\n\n    [onDragStop$3](event) {\n      this[dragStop](event);\n    }\n\n    [onDragPressure](event) {\n      if (!this.dragging) {\n        return;\n      }\n      const sensorEvent = getSensorEvent(event);\n      const source = this.source || closest(sensorEvent.originalEvent.target, this.options.draggable);\n      const dragPressureEvent = new DragPressureEvent({\n        sensorEvent,\n        source,\n        pressure: sensorEvent.pressure\n      });\n      this.trigger(dragPressureEvent);\n    }\n  }\n\n  Draggable.Plugins = {\n    Announcement,\n    Focusable,\n    Mirror,\n    Scrollable\n  };\n\n  Draggable.Sensors = {\n    MouseSensor,\n    TouchSensor\n  };\n  function getSensorEvent(event) {\n    return event.detail;\n  }\n  function applyUserSelect(element, value) {\n    element.style.webkitUserSelect = value;\n    element.style.mozUserSelect = value;\n    element.style.msUserSelect = value;\n    element.style.oUserSelect = value;\n    element.style.userSelect = value;\n  }\n\n  class DroppableEvent extends AbstractEvent {\n\n    constructor(data) {\n      super(data);\n      this.data = data;\n    }\n\n    get dragEvent() {\n      return this.data.dragEvent;\n    }\n  }\n  DroppableEvent.type = 'droppable';\n\n  class DroppableStartEvent extends DroppableEvent {\n\n    get dropzone() {\n      return this.data.dropzone;\n    }\n  }\n  DroppableStartEvent.type = 'droppable:start';\n  DroppableStartEvent.cancelable = true;\n\n  class DroppableDroppedEvent extends DroppableEvent {\n\n    get dropzone() {\n      return this.data.dropzone;\n    }\n  }\n  DroppableDroppedEvent.type = 'droppable:dropped';\n  DroppableDroppedEvent.cancelable = true;\n\n  class DroppableReturnedEvent extends DroppableEvent {\n\n    get dropzone() {\n      return this.data.dropzone;\n    }\n  }\n  DroppableReturnedEvent.type = 'droppable:returned';\n  DroppableReturnedEvent.cancelable = true;\n\n  class DroppableStopEvent extends DroppableEvent {\n\n    get dropzone() {\n      return this.data.dropzone;\n    }\n  }\n  DroppableStopEvent.type = 'droppable:stop';\n  DroppableStopEvent.cancelable = true;\n\n  const onDragStart$2 = Symbol('onDragStart');\n  const onDragMove = Symbol('onDragMove');\n  const onDragStop$2 = Symbol('onDragStop');\n  const dropInDropzone = Symbol('dropInDropZone');\n  const returnToOriginalDropzone = Symbol('returnToOriginalDropzone');\n  const closestDropzone = Symbol('closestDropzone');\n  const getDropzones = Symbol('getDropzones');\n\n  function onDroppableDroppedDefaultAnnouncement({\n    dragEvent,\n    dropzone\n  }) {\n    const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'draggable element';\n    const dropzoneText = dropzone.textContent.trim() || dropzone.id || 'droppable element';\n    return `Dropped ${sourceText} into ${dropzoneText}`;\n  }\n\n  function onDroppableReturnedDefaultAnnouncement({\n    dragEvent,\n    dropzone\n  }) {\n    const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'draggable element';\n    const dropzoneText = dropzone.textContent.trim() || dropzone.id || 'droppable element';\n    return `Returned ${sourceText} from ${dropzoneText}`;\n  }\n\n  const defaultAnnouncements$2 = {\n    'droppable:dropped': onDroppableDroppedDefaultAnnouncement,\n    'droppable:returned': onDroppableReturnedDefaultAnnouncement\n  };\n  const defaultClasses = {\n    'droppable:active': 'draggable-dropzone--active',\n    'droppable:occupied': 'draggable-dropzone--occupied'\n  };\n  const defaultOptions = {\n    dropzone: '.draggable-droppable'\n  };\n\n  class Droppable extends Draggable {\n\n    constructor(containers = [], options = {}) {\n      super(containers, {\n        ...defaultOptions,\n        ...options,\n        classes: {\n          ...defaultClasses,\n          ...(options.classes || {})\n        },\n        announcements: {\n          ...defaultAnnouncements$2,\n          ...(options.announcements || {})\n        }\n      });\n\n      this.dropzones = null;\n\n      this.lastDropzone = null;\n\n      this.initialDropzone = null;\n      this[onDragStart$2] = this[onDragStart$2].bind(this);\n      this[onDragMove] = this[onDragMove].bind(this);\n      this[onDragStop$2] = this[onDragStop$2].bind(this);\n      this.on('drag:start', this[onDragStart$2]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop$2]);\n    }\n\n    destroy() {\n      super.destroy();\n      this.off('drag:start', this[onDragStart$2]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop$2]);\n    }\n\n    [onDragStart$2](event) {\n      if (event.canceled()) {\n        return;\n      }\n      this.dropzones = [...this[getDropzones]()];\n      const dropzone = closest(event.sensorEvent.target, this.options.dropzone);\n      if (!dropzone) {\n        event.cancel();\n        return;\n      }\n      const droppableStartEvent = new DroppableStartEvent({\n        dragEvent: event,\n        dropzone\n      });\n      this.trigger(droppableStartEvent);\n      if (droppableStartEvent.canceled()) {\n        event.cancel();\n        return;\n      }\n      this.initialDropzone = dropzone;\n      for (const dropzoneElement of this.dropzones) {\n        if (dropzoneElement.classList.contains(this.getClassNameFor('droppable:occupied'))) {\n          continue;\n        }\n        dropzoneElement.classList.add(...this.getClassNamesFor('droppable:active'));\n      }\n    }\n\n    [onDragMove](event) {\n      if (event.canceled()) {\n        return;\n      }\n      const dropzone = this[closestDropzone](event.sensorEvent.target);\n      const overEmptyDropzone = dropzone && !dropzone.classList.contains(this.getClassNameFor('droppable:occupied'));\n      if (overEmptyDropzone && this[dropInDropzone](event, dropzone)) {\n        this.lastDropzone = dropzone;\n      } else if ((!dropzone || dropzone === this.initialDropzone) && this.lastDropzone) {\n        this[returnToOriginalDropzone](event);\n        this.lastDropzone = null;\n      }\n    }\n\n    [onDragStop$2](event) {\n      const droppableStopEvent = new DroppableStopEvent({\n        dragEvent: event,\n        dropzone: this.lastDropzone || this.initialDropzone\n      });\n      this.trigger(droppableStopEvent);\n      const occupiedClasses = this.getClassNamesFor('droppable:occupied');\n      for (const dropzone of this.dropzones) {\n        dropzone.classList.remove(...this.getClassNamesFor('droppable:active'));\n      }\n      if (this.lastDropzone && this.lastDropzone !== this.initialDropzone) {\n        this.initialDropzone.classList.remove(...occupiedClasses);\n      }\n      this.dropzones = null;\n      this.lastDropzone = null;\n      this.initialDropzone = null;\n    }\n\n    [dropInDropzone](event, dropzone) {\n      const droppableDroppedEvent = new DroppableDroppedEvent({\n        dragEvent: event,\n        dropzone\n      });\n      this.trigger(droppableDroppedEvent);\n      if (droppableDroppedEvent.canceled()) {\n        return false;\n      }\n      const occupiedClasses = this.getClassNamesFor('droppable:occupied');\n      if (this.lastDropzone) {\n        this.lastDropzone.classList.remove(...occupiedClasses);\n      }\n      dropzone.appendChild(event.source);\n      dropzone.classList.add(...occupiedClasses);\n      return true;\n    }\n\n    [returnToOriginalDropzone](event) {\n      const droppableReturnedEvent = new DroppableReturnedEvent({\n        dragEvent: event,\n        dropzone: this.lastDropzone\n      });\n      this.trigger(droppableReturnedEvent);\n      if (droppableReturnedEvent.canceled()) {\n        return;\n      }\n      this.initialDropzone.appendChild(event.source);\n      this.lastDropzone.classList.remove(...this.getClassNamesFor('droppable:occupied'));\n    }\n\n    [closestDropzone](target) {\n      if (!this.dropzones) {\n        return null;\n      }\n      return closest(target, this.dropzones);\n    }\n\n    [getDropzones]() {\n      const dropzone = this.options.dropzone;\n      if (typeof dropzone === 'string') {\n        return document.querySelectorAll(dropzone);\n      } else if (dropzone instanceof NodeList || dropzone instanceof Array) {\n        return dropzone;\n      } else if (typeof dropzone === 'function') {\n        return dropzone();\n      } else {\n        return [];\n      }\n    }\n  }\n\n  class SwappableEvent extends AbstractEvent {\n\n    constructor(data) {\n      super(data);\n      this.data = data;\n    }\n\n    get dragEvent() {\n      return this.data.dragEvent;\n    }\n  }\n\n  SwappableEvent.type = 'swappable';\n  class SwappableStartEvent extends SwappableEvent {}\n  SwappableStartEvent.type = 'swappable:start';\n  SwappableStartEvent.cancelable = true;\n\n  class SwappableSwapEvent extends SwappableEvent {\n\n    get over() {\n      return this.data.over;\n    }\n\n    get overContainer() {\n      return this.data.overContainer;\n    }\n  }\n  SwappableSwapEvent.type = 'swappable:swap';\n  SwappableSwapEvent.cancelable = true;\n\n  class SwappableSwappedEvent extends SwappableEvent {\n\n    get swappedElement() {\n      return this.data.swappedElement;\n    }\n  }\n\n  SwappableSwappedEvent.type = 'swappable:swapped';\n  class SwappableStopEvent extends SwappableEvent {}\n  SwappableStopEvent.type = 'swappable:stop';\n\n  const onDragStart$1 = Symbol('onDragStart');\n  const onDragOver$1 = Symbol('onDragOver');\n  const onDragStop$1 = Symbol('onDragStop');\n\n  function onSwappableSwappedDefaultAnnouncement({\n    dragEvent,\n    swappedElement\n  }) {\n    const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'swappable element';\n    const overText = swappedElement.textContent.trim() || swappedElement.id || 'swappable element';\n    return `Swapped ${sourceText} with ${overText}`;\n  }\n\n  const defaultAnnouncements$1 = {\n    'swappabled:swapped': onSwappableSwappedDefaultAnnouncement\n  };\n\n  class Swappable extends Draggable {\n\n    constructor(containers = [], options = {}) {\n      super(containers, {\n        ...options,\n        announcements: {\n          ...defaultAnnouncements$1,\n          ...(options.announcements || {})\n        }\n      });\n\n      this.lastOver = null;\n      this[onDragStart$1] = this[onDragStart$1].bind(this);\n      this[onDragOver$1] = this[onDragOver$1].bind(this);\n      this[onDragStop$1] = this[onDragStop$1].bind(this);\n      this.on('drag:start', this[onDragStart$1]).on('drag:over', this[onDragOver$1]).on('drag:stop', this[onDragStop$1]);\n    }\n\n    destroy() {\n      super.destroy();\n      this.off('drag:start', this._onDragStart).off('drag:over', this._onDragOver).off('drag:stop', this._onDragStop);\n    }\n\n    [onDragStart$1](event) {\n      const swappableStartEvent = new SwappableStartEvent({\n        dragEvent: event\n      });\n      this.trigger(swappableStartEvent);\n      if (swappableStartEvent.canceled()) {\n        event.cancel();\n      }\n    }\n\n    [onDragOver$1](event) {\n      if (event.over === event.originalSource || event.over === event.source || event.canceled()) {\n        return;\n      }\n      const swappableSwapEvent = new SwappableSwapEvent({\n        dragEvent: event,\n        over: event.over,\n        overContainer: event.overContainer\n      });\n      this.trigger(swappableSwapEvent);\n      if (swappableSwapEvent.canceled()) {\n        return;\n      }\n\n      if (this.lastOver && this.lastOver !== event.over) {\n        swap(this.lastOver, event.source);\n      }\n      if (this.lastOver === event.over) {\n        this.lastOver = null;\n      } else {\n        this.lastOver = event.over;\n      }\n      swap(event.source, event.over);\n      const swappableSwappedEvent = new SwappableSwappedEvent({\n        dragEvent: event,\n        swappedElement: event.over\n      });\n      this.trigger(swappableSwappedEvent);\n    }\n\n    [onDragStop$1](event) {\n      const swappableStopEvent = new SwappableStopEvent({\n        dragEvent: event\n      });\n      this.trigger(swappableStopEvent);\n      this.lastOver = null;\n    }\n  }\n  function withTempElement(callback) {\n    const tmpElement = document.createElement('div');\n    callback(tmpElement);\n    tmpElement.remove();\n  }\n  function swap(source, over) {\n    const overParent = over.parentNode;\n    const sourceParent = source.parentNode;\n    withTempElement(tmpElement => {\n      sourceParent.insertBefore(tmpElement, source);\n      overParent.insertBefore(source, over);\n      sourceParent.insertBefore(over, tmpElement);\n    });\n  }\n\n  class SortableEvent extends AbstractEvent {\n\n    constructor(data) {\n      super(data);\n      this.data = data;\n    }\n\n    get dragEvent() {\n      return this.data.dragEvent;\n    }\n  }\n  SortableEvent.type = 'sortable';\n\n  class SortableStartEvent extends SortableEvent {\n\n    get startIndex() {\n      return this.data.startIndex;\n    }\n\n    get startContainer() {\n      return this.data.startContainer;\n    }\n  }\n  SortableStartEvent.type = 'sortable:start';\n  SortableStartEvent.cancelable = true;\n\n  class SortableSortEvent extends SortableEvent {\n\n    get currentIndex() {\n      return this.data.currentIndex;\n    }\n\n    get over() {\n      return this.data.over;\n    }\n\n    get overContainer() {\n      return this.data.dragEvent.overContainer;\n    }\n  }\n  SortableSortEvent.type = 'sortable:sort';\n  SortableSortEvent.cancelable = true;\n\n  class SortableSortedEvent extends SortableEvent {\n\n    get oldIndex() {\n      return this.data.oldIndex;\n    }\n\n    get newIndex() {\n      return this.data.newIndex;\n    }\n\n    get oldContainer() {\n      return this.data.oldContainer;\n    }\n\n    get newContainer() {\n      return this.data.newContainer;\n    }\n  }\n  SortableSortedEvent.type = 'sortable:sorted';\n\n  class SortableStopEvent extends SortableEvent {\n\n    get oldIndex() {\n      return this.data.oldIndex;\n    }\n\n    get newIndex() {\n      return this.data.newIndex;\n    }\n\n    get oldContainer() {\n      return this.data.oldContainer;\n    }\n\n    get newContainer() {\n      return this.data.newContainer;\n    }\n  }\n  SortableStopEvent.type = 'sortable:stop';\n\n  const onDragStart = Symbol('onDragStart');\n  const onDragOverContainer = Symbol('onDragOverContainer');\n  const onDragOver = Symbol('onDragOver');\n  const onDragStop = Symbol('onDragStop');\n\n  function onSortableSortedDefaultAnnouncement({\n    dragEvent\n  }) {\n    const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'sortable element';\n    if (dragEvent.over) {\n      const overText = dragEvent.over.textContent.trim() || dragEvent.over.id || 'sortable element';\n      const isFollowing = dragEvent.source.compareDocumentPosition(dragEvent.over) & Node.DOCUMENT_POSITION_FOLLOWING;\n      if (isFollowing) {\n        return `Placed ${sourceText} after ${overText}`;\n      } else {\n        return `Placed ${sourceText} before ${overText}`;\n      }\n    } else {\n\n      return `Placed ${sourceText} into a different container`;\n    }\n  }\n\n  const defaultAnnouncements = {\n    'sortable:sorted': onSortableSortedDefaultAnnouncement\n  };\n\n  class Sortable extends Draggable {\n\n    constructor(containers = [], options = {}) {\n      super(containers, {\n        ...options,\n        announcements: {\n          ...defaultAnnouncements,\n          ...(options.announcements || {})\n        }\n      });\n\n      this.startIndex = null;\n\n      this.startContainer = null;\n      this[onDragStart] = this[onDragStart].bind(this);\n      this[onDragOverContainer] = this[onDragOverContainer].bind(this);\n      this[onDragOver] = this[onDragOver].bind(this);\n      this[onDragStop] = this[onDragStop].bind(this);\n      this.on('drag:start', this[onDragStart]).on('drag:over:container', this[onDragOverContainer]).on('drag:over', this[onDragOver]).on('drag:stop', this[onDragStop]);\n    }\n\n    destroy() {\n      super.destroy();\n      this.off('drag:start', this[onDragStart]).off('drag:over:container', this[onDragOverContainer]).off('drag:over', this[onDragOver]).off('drag:stop', this[onDragStop]);\n    }\n\n    index(element) {\n      return this.getSortableElementsForContainer(element.parentNode).indexOf(element);\n    }\n\n    getSortableElementsForContainer(container) {\n      const allSortableElements = container.querySelectorAll(this.options.draggable);\n      return [...allSortableElements].filter(childElement => {\n        return childElement !== this.originalSource && childElement !== this.mirror && childElement.parentNode === container;\n      });\n    }\n\n    [onDragStart](event) {\n      this.startContainer = event.source.parentNode;\n      this.startIndex = this.index(event.source);\n      const sortableStartEvent = new SortableStartEvent({\n        dragEvent: event,\n        startIndex: this.startIndex,\n        startContainer: this.startContainer\n      });\n      this.trigger(sortableStartEvent);\n      if (sortableStartEvent.canceled()) {\n        event.cancel();\n      }\n    }\n\n    [onDragOverContainer](event) {\n      if (event.canceled()) {\n        return;\n      }\n      const {\n        source,\n        over,\n        overContainer\n      } = event;\n      const oldIndex = this.index(source);\n      const sortableSortEvent = new SortableSortEvent({\n        dragEvent: event,\n        currentIndex: oldIndex,\n        source,\n        over\n      });\n      this.trigger(sortableSortEvent);\n      if (sortableSortEvent.canceled()) {\n        return;\n      }\n      const children = this.getSortableElementsForContainer(overContainer);\n      const moves = move({\n        source,\n        over,\n        overContainer,\n        children\n      });\n      if (!moves) {\n        return;\n      }\n      const {\n        oldContainer,\n        newContainer\n      } = moves;\n      const newIndex = this.index(event.source);\n      const sortableSortedEvent = new SortableSortedEvent({\n        dragEvent: event,\n        oldIndex,\n        newIndex,\n        oldContainer,\n        newContainer\n      });\n      this.trigger(sortableSortedEvent);\n    }\n\n    [onDragOver](event) {\n      if (event.over === event.originalSource || event.over === event.source) {\n        return;\n      }\n      const {\n        source,\n        over,\n        overContainer\n      } = event;\n      const oldIndex = this.index(source);\n      const sortableSortEvent = new SortableSortEvent({\n        dragEvent: event,\n        currentIndex: oldIndex,\n        source,\n        over\n      });\n      this.trigger(sortableSortEvent);\n      if (sortableSortEvent.canceled()) {\n        return;\n      }\n      const children = this.getDraggableElementsForContainer(overContainer);\n      const moves = move({\n        source,\n        over,\n        overContainer,\n        children\n      });\n      if (!moves) {\n        return;\n      }\n      const {\n        oldContainer,\n        newContainer\n      } = moves;\n      const newIndex = this.index(source);\n      const sortableSortedEvent = new SortableSortedEvent({\n        dragEvent: event,\n        oldIndex,\n        newIndex,\n        oldContainer,\n        newContainer\n      });\n      this.trigger(sortableSortedEvent);\n    }\n\n    [onDragStop](event) {\n      const sortableStopEvent = new SortableStopEvent({\n        dragEvent: event,\n        oldIndex: this.startIndex,\n        newIndex: this.index(event.source),\n        oldContainer: this.startContainer,\n        newContainer: event.source.parentNode\n      });\n      this.trigger(sortableStopEvent);\n      this.startIndex = null;\n      this.startContainer = null;\n    }\n  }\n  function index(element) {\n    return Array.prototype.indexOf.call(element.parentNode.children, element);\n  }\n  function move({\n    source,\n    over,\n    overContainer,\n    children\n  }) {\n    const emptyOverContainer = !children.length;\n    const differentContainer = source.parentNode !== overContainer;\n    const sameContainer = over && source.parentNode === over.parentNode;\n    if (emptyOverContainer) {\n      return moveInsideEmptyContainer(source, overContainer);\n    } else if (sameContainer) {\n      return moveWithinContainer(source, over);\n    } else if (differentContainer) {\n      return moveOutsideContainer(source, over, overContainer);\n    } else {\n      return null;\n    }\n  }\n  function moveInsideEmptyContainer(source, overContainer) {\n    const oldContainer = source.parentNode;\n    overContainer.appendChild(source);\n    return {\n      oldContainer,\n      newContainer: overContainer\n    };\n  }\n  function moveWithinContainer(source, over) {\n    const oldIndex = index(source);\n    const newIndex = index(over);\n    if (oldIndex < newIndex) {\n      source.parentNode.insertBefore(source, over.nextElementSibling);\n    } else {\n      source.parentNode.insertBefore(source, over);\n    }\n    return {\n      oldContainer: source.parentNode,\n      newContainer: source.parentNode\n    };\n  }\n  function moveOutsideContainer(source, over, overContainer) {\n    const oldContainer = source.parentNode;\n    if (over) {\n      over.parentNode.insertBefore(source, over);\n    } else {\n\n      overContainer.appendChild(source);\n    }\n    return {\n      oldContainer,\n      newContainer: source.parentNode\n    };\n  }\n\n  exports.BaseEvent = AbstractEvent;\n  exports.BasePlugin = AbstractPlugin;\n  exports.Draggable = Draggable;\n  exports.Droppable = Droppable;\n  exports.Plugins = index$1;\n  exports.Sensors = index$2;\n  exports.Sortable = Sortable;\n  exports.Swappable = Swappable;\n\n}));\n\n\n//# sourceURL=webpack://keenthemes/./node_modules/@shopify/draggable/build/umd/index.js?");

/***/ }),

/***/ "./webpack/plugins/custom/draggable/draggable.js":
/*!*******************************************************!*\
  !*** ./webpack/plugins/custom/draggable/draggable.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _shopify_draggable_build_umd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shopify/draggable/build/umd */ \"./node_modules/@shopify/draggable/build/umd/index.js\");\n/* harmony import */ var _shopify_draggable_build_umd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shopify_draggable_build_umd__WEBPACK_IMPORTED_MODULE_0__);\n// Draggable - a lightweight, responsive, modern drag & drop library: https://shopify.github.io/draggable/\n\n\nwindow.Draggable = (_shopify_draggable_build_umd__WEBPACK_IMPORTED_MODULE_0___default());\n\n//# sourceURL=webpack://keenthemes/./webpack/plugins/custom/draggable/draggable.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./webpack/plugins/custom/draggable/draggable.js");
/******/ 	
/******/ })()
;